// datastruct.b - SSA data structures (v3_17)
//
// 제네릭 없이 SSA를 구성하기 위한 전용 자료구조 집합.
// - BlockList: BasicBlock 포인터 배열 (동적 확장)
// - Instruction: 침습적 연결 리스트 노드
// - SSAContext: 전체 SSA 그래프 컨텍스트

// ============================================
// Constants
// ============================================


const SSA_OP_NOP = 0;
const SSA_OP_ENTRY = 1;
const SSA_OP_PHI = 2;

// Basic arithmetic
const SSA_OP_CONST = 10;
const SSA_OP_FCONST = 89;
const SSA_OP_ADD = 11;
const SSA_OP_SUB = 12;
const SSA_OP_MUL = 13;
const SSA_OP_DIV = 14;

// Float arithmetic
const SSA_OP_FADD = 90;
const SSA_OP_FSUB = 91;
const SSA_OP_FMUL = 92;
const SSA_OP_FDIV = 93;
const SSA_OP_FNEG = 94;

// Float comparison ops
const SSA_OP_FEQ = 95;
const SSA_OP_FNE = 96;
const SSA_OP_FLT = 97;
const SSA_OP_FGT = 98;
const SSA_OP_FLE = 99;
const SSA_OP_FGE = 100;

// Unsigned integer ops
const SSA_OP_UDIV = 101;
const SSA_OP_UMOD = 102;
const SSA_OP_ULT = 103;
const SSA_OP_UGT = 104;
const SSA_OP_ULE = 105;
const SSA_OP_UGE = 106;
const SSA_OP_I2F = 107;
const SSA_OP_U2F = 108;
const SSA_OP_F2I = 109;
const SSA_OP_F2U = 110;

// Comparison ops
const SSA_OP_EQ = 15;
const SSA_OP_NE = 16;
const SSA_OP_LT = 17;
const SSA_OP_GT = 18;
const SSA_OP_LE = 19;
const SSA_OP_GE = 20;

// Bitwise/shift/mod ops
const SSA_OP_MOD = 33;
const SSA_OP_AND = 34;
const SSA_OP_OR = 35;
const SSA_OP_XOR = 36;
const SSA_OP_SHL = 37;
const SSA_OP_SHR = 38;
const SSA_OP_SAR = 39;

// Memory ops (mem2reg 이전 단계)
const SSA_OP_LOAD = 25;
const SSA_OP_STORE = 26;
const SSA_OP_PARAM = 27;
const SSA_OP_CALL = 28;
const SSA_OP_CALL_PTR = 29;

// Control flow
const SSA_OP_JMP = 30;
const SSA_OP_BR = 31;
const SSA_OP_RET = 32;
const SSA_OP_RET_SLICE_HEAP = 71;

// SSA destruction helper
const SSA_OP_COPY = 40;

// Address helpers
const SSA_OP_LEA_STR = 50;
const SSA_OP_LEA_LOCAL = 51;
const SSA_OP_LEA_GLOBAL = 52;
const SSA_OP_LEA_FUNC = 53;

// Memory ops (explicit address)
const SSA_OP_LOAD8 = 60;
const SSA_OP_LOAD16 = 61;
const SSA_OP_LOAD32 = 62;
const SSA_OP_LOAD64 = 63;
const SSA_OP_STORE8 = 64;
const SSA_OP_STORE16 = 65;
const SSA_OP_STORE32 = 66;
const SSA_OP_STORE64 = 67;
const SSA_OP_STORE_SLICE = 68;
const SSA_OP_ASM = 69;
const SSA_OP_CALL_SLICE_STORE = 70;

const SSA_OPR_VALUE_MASK = 9223372036854775807;

// ============================================
// SSA Core Types
// ============================================

packed struct InstMeta {
    public op: u16;
}

struct SSAInstruction {
    public prev: *tagged(InstMeta) u8;
    public next: *SSAInstruction;
    public id: u64;
    public dest: u64; // virtual register id
    public src1: u64; // tagged operand (const/reg) or phi args head
    public src2: u64; // tagged operand (const/reg)
}

impl SSAInstruction {
    public constructor() {
        self.prev = 0;
        self.next = 0;
        self.id = 0;
        self.dest = 0;
        self.src1 = 0;
        self.src2 = 0;
    }
}

struct SSAPhiArg {
    public val: u64;        // incoming value (virtual register id)
    public block_id: u64;   // predecessor block id
    public next: *SSAPhiArg;
}

impl SSAPhiArg {
    public constructor() {
        self.val = 0;
        self.block_id = 0;
        self.next = 0;
    }
}

struct SSACallInfo {
    public name_ptr: u64;
    public name_len: u64;
    public args_vec: *Vec<u64>;
    public nargs: u64;
    public ret_type: u64;
    public ret_ptr_depth: u64;
    public ret_struct_size: u64;
}

impl SSACallInfo {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.args_vec = 0;
        self.nargs = 0;
        self.ret_type = 0;
        self.ret_ptr_depth = 0;
        self.ret_struct_size = 0;
    }
}

struct SSACallPtrInfo {
    public callee_reg: u64;
    public args_vec: *Vec<u64>;
    public nargs: u64;
    public ret_type: u64;
    public ret_ptr_depth: u64;
    public ret_struct_size: u64;
}

impl SSACallPtrInfo {
    public constructor() {
        self.callee_reg = 0;
        self.args_vec = 0;
        self.nargs = 0;
        self.ret_type = 0;
        self.ret_ptr_depth = 0;
        self.ret_struct_size = 0;
    }
}

struct SSACallSliceStoreInfo {
    public is_ptr: u64;          // 0: direct call, 1: call_ptr
    public name_ptr: u64;        // direct call target
    public name_len: u64;
    public callee_reg: u64;      // call_ptr target register
    public args_vec: *Vec<u64>;
    public nargs: u64;
    public ret_type: u64;
    public ret_ptr_depth: u64;
}

impl SSACallSliceStoreInfo {
    public constructor() {
        self.is_ptr = 0;
        self.name_ptr = 0;
        self.name_len = 0;
        self.callee_reg = 0;
        self.args_vec = 0;
        self.nargs = 0;
        self.ret_type = 0;
        self.ret_ptr_depth = 0;
    }
}

struct SSABlock {
    public id: u64;
    public phi_head: *SSAInstruction;
    public inst_head: *SSAInstruction;
    public inst_tail: *SSAInstruction;
    public preds: []*SSABlock;
    public preds_cap: u64;
    public succs: []*SSABlock;
    public succs_cap: u64;
    public df: []*SSABlock;
    public df_cap: u64;
    public dom_parent: *SSABlock;
}

impl SSABlock {
    public constructor() {
        self.id = 0;
        self.phi_head = 0;
        self.inst_head = 0;
        self.inst_tail = 0;
        self.preds = slice(0, 0);
        self.preds_cap = 0;
        self.succs = slice(0, 0);
        self.succs_cap = 0;
        self.df = slice(0, 0);
        self.df_cap = 0;
        self.dom_parent = 0;
    }
}

struct SSAFunction {
    public id: u64;
    public name_ptr: u64;
    public name_len: u64;
    public blocks: []*SSABlock;
    public blocks_cap: u64;
    public entry: *SSABlock;
    public reg_map_data: u64; // *u64 (virtual reg -> phys reg)
    public reg_map_len: u64;
    public next_local_block_id: u64;
    public regalloc_failed: u64;
    public regalloc_done: u64;
}

impl SSAFunction {
    public constructor() {
        self.id = 0;
        self.name_ptr = 0;
        self.name_len = 0;
        self.blocks = slice(0, 0);
        self.blocks_cap = 0;
        self.entry = 0;
        self.reg_map_data = 0;
        self.reg_map_len = 0;
        self.next_local_block_id = 0;
        self.regalloc_failed = 0;
        self.regalloc_done = 0;
    }
}

struct SSAContext {
    public funcs: []*SSAFunction;
    public funcs_cap: u64;
    public next_block_id: u64;
    public next_inst_id: u64;
}

impl SSAContext {
    public constructor() {
        self.funcs = slice(0, 0);
        self.funcs_cap = 0;
        self.next_block_id = 0;
        self.next_inst_id = 0;
    }
}
