// ssa.b - SSA entry points (outside ssa/)
// SSA 진입 지점을 외부로 분리한 모듈

import std.io;
import std.util;
import std.vec;
import std.hashmap;
import ast;
import ssa.datastruct;
import ssa.core;
import compiler;
import ssa.builder;
import ssa.codegen;
import emitter.emitter;

// ============================================
// SSA Builder Entry
// ============================================

var g_ssa_builder_failed_funcs: *HashMap<u64, u64> = 0;

func ssa_builder_clear_failed_funcs() -> u64 {
    g_ssa_builder_failed_funcs = new HashMap<u64, u64>(64);
    return 0;
}

func ssa_builder_mark_failed(name_ptr: u64, name_len: u64) -> u64 {
    if (g_ssa_builder_failed_funcs == 0) {
        g_ssa_builder_failed_funcs = new HashMap<u64, u64>(64);
    }
    g_ssa_builder_failed_funcs.put(name_ptr, name_len, 1);
    return 0;
}

func ssa_builder_is_build_ok(name_ptr: u64, name_len: u64) -> u64 {
    if (g_ssa_builder_failed_funcs == 0) { return true; }
    return g_ssa_builder_failed_funcs.get(name_ptr, name_len) == 0;
}

func ssa_builder_build_func(ctx: *BuilderCtx, fn: *AstFunc) -> u64 {
    push_trace("ssa_builder_build_func", "ssa.b", __LINE__);
    defer pop_trace();
    if (fn == 0) { return 0; }
    set_current_module_for_func(fn.name_ptr, fn.name_len);
    compiler_set_current_access_struct_from_func(fn.name_ptr, fn.name_len);
    if (SSA_BUILDER_DEBUG != 0) {
        emit("[DEBUG] ssa_builder_build_func: ");
        emit_len(fn.name_ptr, fn.name_len);
        emit("\n");
    }
    var ssa_fn_ptr: *SSAFunction = ssa_new_function(ctx.ssa_ctx, fn.name_ptr, fn.name_len);
    ctx.cur_func = ssa_fn_ptr;
    ctx.cur_block = ctx.cur_func.entry;
    emitter_set_ret_type(fn.ret_type);
    emitter_set_ret_ptr_depth(fn.ret_ptr_depth);
    emitter_set_ret_struct_name(fn.ret_struct_name_ptr, fn.ret_struct_name_len);
    builder_reset_func(ctx);
    builder_scan_addr_taken_stmt(ctx, fn.body);
    builder_add_params(ctx, fn);
    build_block(ctx, fn.body);
    if (ctx.build_failed != 0) {
        ssa_builder_mark_failed(fn.name_ptr, fn.name_len);
        compiler_clear_current_access_struct();
        return 0;
    }
    if (builder_block_is_terminated(ctx.cur_block) == 0) {
        var ret_ptr: *SSAInstruction = ssa_new_inst(ctx.ssa_ctx, SSA_OP_RET, 0, 0, 0);
        ssa_inst_append(ctx.cur_block, ret_ptr);
    }
    compiler_clear_current_access_struct();
    return 0;
}

func ssa_builder_build_program(prog: *AstProgram) -> *SSAContext {
    push_trace("ssa_builder_build_program", "ssa.b", __LINE__);
    defer pop_trace();

    var funcs: *Vec<*AstFunc> = prog.funcs_vec;
    var count: u64 = funcs.len();

    var ssa_ctx_ptr: *SSAContext = ssa_context_new();
    ssa_ret_slice_heap_clear();
    ssa_builder_clear_failed_funcs();
    compiler_clear_current_access_struct();
    var bctx: *BuilderCtx = builder_ctx_new(ssa_ctx_ptr);

    for (var i: u64 = 0; i < count; i++) {
        var fn: *AstFunc = funcs.get(i);
        if (fn.body == 0) {
            ssa_new_function(bctx.ssa_ctx, fn.name_ptr, fn.name_len);
        } else if (ssa_codegen_is_supported_func(fn, prog.globals_vec) == 0) {
            ssa_new_function(bctx.ssa_ctx, fn.name_ptr, fn.name_len);
        } else {
            ssa_builder_build_func(bctx, fn);
        }
    }
    compiler_clear_current_access_struct();
    return ssa_ctx_ptr;
}
