// hashmap.b - Hash map implementation for v3.8

import std.io;
import std.str;

func hm_memzero(dst: u64, len: u64) -> u64 {
    if (len == 0) { return 0; }
    var words: u64 = len / 8;
    var rem: u64 = len % 8;
    var d64: *u64 = (*u64)dst;
    for (var i: u64 = 0; i < words; i++) {
        d64[i] = 0;
    }
    if (rem != 0) {
        var base: u64 = words * 8;
        var d8: *u8 = (*u8)(dst + base);
        for (var j: u64 = 0; j < rem; j++) {
            d8[j] = 0;
        }
    }
    return 0;
}

func hm_memcpy(dst: u64, src: u64, size: u64) -> u64 {
    if (size == 0) { return 0; }
    if (size == 8) {
        var d1: *u64 = (*u64)dst;
        var s1: *u64 = (*u64)src;
        d1[0] = s1[0];
        return 0;
    }
    if (size == 16) {
        var d2: *u64 = (*u64)dst;
        var s2: *u64 = (*u64)src;
        d2[0] = s2[0];
        d2[1] = s2[1];
        return 0;
    }
    if (size == 24) {
        var d3: *u64 = (*u64)dst;
        var s3: *u64 = (*u64)src;
        d3[0] = s3[0];
        d3[1] = s3[1];
        d3[2] = s3[2];
        return 0;
    }
    if (size == 32) {
        var d4: *u64 = (*u64)dst;
        var s4: *u64 = (*u64)src;
        d4[0] = s4[0];
        d4[1] = s4[1];
        d4[2] = s4[2];
        d4[3] = s4[3];
        return 0;
    }

    var words: u64 = size / 8;
    var rem: u64 = size % 8;
    var d64g: *u64 = (*u64)dst;
    var s64g: *u64 = (*u64)src;
    for (var i2: u64 = 0; i2 < words; i2++) {
        d64g[i2] = s64g[i2];
    }
    if (rem != 0) {
        var base2: u64 = words * 8;
        var d8g: *u8 = (*u8)(dst + base2);
        var s8g: *u8 = (*u8)(src + base2);
        for (var j2: u64 = 0; j2 < rem; j2++) {
            d8g[j2] = s8g[j2];
        }
    }
    return 0;
}

// HashMap<K, V> structure: [entries_ptr, capacity, count]
// Entry: [key_ptr, key_len, hash, used, value]

struct HashMap<K, V> {
    entries_ptr: u64;
    capacity: u64;
    count: u64;
}

struct HashEntry<V> {
    public key_ptr: u64;
    public key_len: u64;
    public hash: u64;
    public used: u64;
    public value: V;
}

impl HashMap {
    public constructor(capacity: u64) {
        var cap: u64 = 16;
        for (; cap < capacity; cap = cap * 2) {
        }
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var bytes: u64 = cap * entry_bytes;
        var entries: u64 = heap_alloc(bytes);
        hm_memzero(entries, bytes);

        self.entries_ptr = entries;
        self.capacity = cap;
        self.count = 0;
    }

    public func entry_size<K, V>() -> u64 {
        var base_size: u64 = 4 * sizeof(u64);
        return base_size + sizeof(V);
    }

    public func ensure_capacity<K, V>(self: *HashMap<K, V>, min_cap: u64) -> u64 {
        // NOTE: Constructor body may be skipped in some bootstrapping paths.
        // This guard ensures capacity is never zero before hashing/modulo.
        // It keeps behavior explicit and prevents divide-by-zero traps.
        if (self.capacity != 0) { return 0; }

        var cap: u64 = 16;
        for (; cap < min_cap; cap = cap * 2) {
        }
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var bytes: u64 = cap * entry_bytes;
        var entries: u64 = heap_alloc(bytes);
        hm_memzero(entries, bytes);

        self.entries_ptr = entries;
        self.capacity = cap;
        self.count = 0;
        return 0;
    }

    public func hash(key_ptr: u64, key_len: u64) -> u64 {
        // 64-bit FNV-1a with u64 chunks to reduce per-byte hashing overhead.
        var hash: u64 = 1469598103934665603;
        var prime: u64 = 1099511628211;
        var words: u64 = key_len / 8;
        var rem: u64 = key_len % 8;

        var key_u64: *u64 = (*u64)key_ptr;
        for (var i: u64 = 0; i < words; i++) {
            hash = hash ^ key_u64[i];
            hash = hash * prime;
        }

        if (rem != 0) {
            var base: u64 = words * 8;
            var key_u8: *u8 = (*u8)(key_ptr + base);
            for (var j: u64 = 0; j < rem; j++) {
                hash = hash ^ key_u8[j];
                hash = hash * prime;
            }
        }

        if (hash == 0) { hash = 1; }
        return hash;
    }

    public func entry_ptr<K, V>(entries: u64, idx: u64) -> *HashEntry<V> {
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        return (*HashEntry<V>)(entries + idx * entry_bytes);
    }

    public func put_internal<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        if (self.capacity == 0) {
            self.ensure_capacity(16);
        }
        var entries: u64 = self.entries_ptr;
        var cap: u64 = self.capacity;
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var mask: u64 = cap - 1;
        var idx: u64 = hash & mask;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = (*HashEntry<V>)(entries + idx * entry_bytes);
            var used: u64 = entry.used;

            if (used == 0) {
                entry.key_ptr = key_ptr;
                entry.key_len = key_len;
                entry.hash = hash;
                entry.used = 1;
                var dst: u64 = (u64)&entry.value;
                var src: u64 = (u64)&value;
                var elem_size: u64 = sizeof(V);
                hm_memcpy(dst, src, elem_size);
                self.count = self.count + 1;
                return 0;
            }

            idx = (idx + 1) & mask;
        }
        return 0;
    }

    public func grow<K, V>(self: *HashMap<K, V>) -> u64 {
        var old_entries: u64 = self.entries_ptr;
        var old_cap: u64 = self.capacity;

        if (old_cap == 0) {
            self.ensure_capacity(16);
            return 0;
        }

        var new_cap: u64 = old_cap * 2;
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var new_bytes: u64 = new_cap * entry_bytes;
        var new_entries: u64 = heap_alloc(new_bytes);
        hm_memzero(new_entries, new_bytes);

        self.entries_ptr = new_entries;
        self.capacity = new_cap;
        self.count = 0;

        for (var i: u64 = 0; i < old_cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(old_entries, i);
            var used: u64 = entry.used;
            if (used != 0) {
                var kp: u64 = entry.key_ptr;
                var kl: u64 = entry.key_len;
                var val: V;
                var srcv: u64 = (u64)&entry.value;
                var dstv: u64 = (u64)&val;
                var elem_size: u64 = sizeof(V);
                hm_memcpy(dstv, srcv, elem_size);
                self.put_internal(kp, kl, val);
            }
        }
        return 0;
    }

    public func put<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        if (self.capacity == 0) {
            self.ensure_capacity(16);
        }
        var entries: u64 = self.entries_ptr;
        var cap: u64 = self.capacity;
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var count: u64 = self.count;

        if (count * 10 >= cap * 7) {
            self.grow();
            entries = self.entries_ptr;
            cap = self.capacity;
            entry_bytes = HashMap.entry_size<K, V>();
        }

        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var mask: u64 = cap - 1;
        var idx: u64 = hash & mask;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = (*HashEntry<V>)(entries + idx * entry_bytes);
            var used: u64 = entry.used;

            if (used == 0) {
                entry.key_ptr = key_ptr;
                entry.key_len = key_len;
                entry.hash = hash;
                entry.used = 1;
                var dst2: u64 = (u64)&entry.value;
                var src2: u64 = (u64)&value;
                var elem_size2: u64 = sizeof(V);
                hm_memcpy(dst2, src2, elem_size2);
                self.count = self.count + 1;
                return 0;
            }

            var kp: u64 = entry.key_ptr;
            var kl: u64 = entry.key_len;
            if (entry.hash == hash && str_eq(kp, kl, key_ptr, key_len)) {
                var dst3: u64 = (u64)&entry.value;
                var src3: u64 = (u64)&value;
                var elem_size3: u64 = sizeof(V);
                hm_memcpy(dst3, src3, elem_size3);
                return 0;
            }

            idx = (idx + 1) & mask;
        }
        return 0;
    }

    public func get<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> V {
        var entries: u64 = self.entries_ptr;
        var cap: u64 = self.capacity;
        if (cap == 0) { return 0; }
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var mask: u64 = cap - 1;
        var idx: u64 = hash & mask;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = (*HashEntry<V>)(entries + idx * entry_bytes);
            var used: u64 = entry.used;

            if (used == 0) {
                return 0;
            }

            var kp: u64 = entry.key_ptr;
            var kl: u64 = entry.key_len;
            if (entry.hash == hash && str_eq(kp, kl, key_ptr, key_len)) {
                var out: V;
                var src4: u64 = (u64)&entry.value;
                var dst4: u64 = (u64)&out;
                var elem_size4: u64 = sizeof(V);
                hm_memcpy(dst4, src4, elem_size4);
                return out;
            }

            idx = (idx + 1) & mask;
        }
        return 0;
    }

    public func has<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> u64 {
        var entries: u64 = self.entries_ptr;
        var cap: u64 = self.capacity;
        if (cap == 0) { return false; }
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var mask: u64 = cap - 1;
        var idx: u64 = hash & mask;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = (*HashEntry<V>)(entries + idx * entry_bytes);
            var used: u64 = entry.used;

            if (used == 0) {
                return false;
            }

            var kp: u64 = entry.key_ptr;
            var kl: u64 = entry.key_len;
            if (entry.hash == hash && str_eq(kp, kl, key_ptr, key_len)) {
                return true;
            }

            idx = (idx + 1) & mask;
        }
        return false;
    }

    public func clear<K, V>(self: *HashMap<K, V>) -> u64 {
        if (self.capacity == 0 || self.entries_ptr == 0) {
            self.ensure_capacity(16);
            self.count = 0;
            return 0;
        }
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        hm_memzero(self.entries_ptr, self.capacity * entry_bytes);
        self.count = 0;
        return 0;
    }
}
