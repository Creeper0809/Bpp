// module_utils.b - Module/path/symbol utility helpers extracted from compiler.bpp

import std.io;
import std.str;
import std.vec;
import types;
import ast;

func module_util_build_joined_name(lhs_ptr: u64, lhs_len: u64, rhs_ptr: u64, rhs_len: u64) -> *NameInfo {
    var full_len: u64 = lhs_len + 1 + rhs_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    str_copy(full_ptr, lhs_ptr, lhs_len);
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    full_u8[lhs_len] = 95;
    str_copy(full_ptr + lhs_len + 1, rhs_ptr, rhs_len);
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func module_util_build_joined_name_with_suffix(lhs_ptr: u64, lhs_len: u64, rhs_ptr: u64, rhs_len: u64, suffix_ptr: u64, suffix_len: u64) -> *NameInfo {
    var full_len: u64 = lhs_len + 1 + rhs_len + suffix_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    str_copy(full_ptr, lhs_ptr, lhs_len);
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    full_u8[lhs_len] = 95;
    str_copy(full_ptr + lhs_len + 1, rhs_ptr, rhs_len);
    str_copy(full_ptr + lhs_len + 1 + rhs_len, suffix_ptr, suffix_len);
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func module_util_find_line_starting_with(content: u64, content_len: u64, prefix: u64, prefix_len: u64) -> u64 {
    var content_u8: []u8 = slice(content, content_len);
    for (var i: u64 = 0; i < content_len; ) {
        var line_start: u64 = i;
        var line_end: u64 = i;
        for (; line_end < content_len; line_end++) {
            if (content_u8[line_end] == 10) { break; }
        }

        var line_len: u64 = line_end - line_start;
        if (line_len >= prefix_len) {
            if (str_eq(content + line_start, prefix_len, prefix, prefix_len)) {
                var value_start: u64 = line_start + prefix_len;
                var value_len: u64 = line_len - prefix_len;
                var value: u64 = heap_alloc((value_len + 1) * sizeof(u8));
                var value_u8: []u8 = slice(value, value_len + 1);
                for (var j: u64 = 0; j < value_len; j++) {
                    value_u8[j] = content_u8[value_start + j];
                }
                value_u8[value_len] = 0;
                return value;
            }
        }
        i = line_end + 1;
    }
    return 0;
}

func module_util_str_has_prefix(s: u64, s_len: u64, prefix: u64, prefix_len: u64) -> u64 {
    if (s_len < prefix_len) { return false; }
    var s_u8: []u8 = slice(s, s_len);
    var prefix_u8: []u8 = slice(prefix, prefix_len);
    for (var i: u64 = 0; i < prefix_len; i++) {
        if (s_u8[i] != prefix_u8[i]) { return false; }
    }
    return true;
}

func module_util_module_id_from_path(path: u64, path_len: u64, lib_dir: u64, lib_dir_len: u64, base_dir: u64, base_dir_len: u64) -> *NameInfo {
    var start: u64 = 0;
    var path_u8: []u8 = slice(path, path_len);
    if (lib_dir != 0 && module_util_str_has_prefix(path, path_len, lib_dir, lib_dir_len)) {
        if (path_len > lib_dir_len && path_u8[lib_dir_len] == 47) {
            start = lib_dir_len + 1;
        }
    }
    if (start == 0 && base_dir != 0 && module_util_str_has_prefix(path, path_len, base_dir, base_dir_len)) {
        if (path_len > base_dir_len && path_u8[base_dir_len] == 47) {
            start = base_dir_len + 1;
        }
    }

    var end: u64 = path_len;
    if (end >= 4) {
        if (path_u8[end - 4] == 46 && path_u8[end - 3] == 98 && path_u8[end - 2] == 112 && path_u8[end - 1] == 112) {
            end = end - 4;
        }
    }
    if (end == path_len && end >= 2) {
        if (path_u8[end - 2] == 46 && path_u8[end - 1] == 98) {
            end = end - 2;
        }
    }

    var id_len: u64 = 0;
    if (end > start) { id_len = end - start; }
    var id_ptr: u64 = heap_alloc((id_len + 1) * sizeof(u8));
    var id_u8: []u8 = slice(id_ptr, id_len + 1);
    for (var i: u64 = 0; i < id_len; i++) {
        id_u8[i] = path_u8[start + i];
    }
    id_u8[id_len] = 0;
    return new NameInfo{id_ptr, id_len};
}

func module_util_module_id_from_import(path: u64, path_len: u64) -> *NameInfo {
    var id_ptr: u64 = heap_alloc((path_len + 1) * sizeof(u8));
    str_copy(id_ptr, path, path_len);
    var id_u8: []u8 = slice(id_ptr, path_len + 1);
    id_u8[path_len] = 0;
    return new NameInfo{id_ptr, path_len};
}

func module_util_module_prefix_from_id(id_ptr: u64, id_len: u64) -> *NameInfo {
    var extra: u64 = 0;
    if (id_len > 0) {
        var id_u8: []u8 = slice(id_ptr, id_len);
        var c0: u64 = id_u8[0];
        if (c0 >= 48 && c0 <= 57) { extra = 1; }
    }

    var pref_ptr: u64 = heap_alloc((id_len + extra + 1) * sizeof(u8));
    var pref_u8: []u8 = slice(pref_ptr, id_len + extra + 1);
    if (extra == 1) {
        pref_u8[0] = 95;
    }
    var id_u8b: []u8 = slice(id_ptr, id_len);
    for (var i: u64 = 0; i < id_len; i++) {
        var c: u64 = id_u8b[i];
        if (c == 47 || c == 46) { c = 95; }
        pref_u8[extra + i] = c;
    }
    pref_u8[id_len + extra] = 0;
    return new NameInfo{pref_ptr, id_len + extra};
}

func module_util_mangle_name(prefix_ptr: u64, prefix_len: u64, name_ptr: u64, name_len: u64) -> *NameInfo {
    if (prefix_len == 0) {
        return new NameInfo{name_ptr, name_len};
    }
    var sep_len: u64 = 2;
    var total: u64 = prefix_len + sep_len + name_len;
    var buf: u64 = heap_alloc((total + 1) * sizeof(u8));
    var buf_u8: []u8 = slice(buf, total + 1);
    var prefix_u8: []u8 = slice(prefix_ptr, prefix_len);
    var name_u8: []u8 = slice(name_ptr, name_len);
    for (var i: u64 = 0; i < prefix_len; i++) {
        buf_u8[i] = prefix_u8[i];
    }
    buf_u8[prefix_len] = 95;
    buf_u8[prefix_len + 1] = 95;
    for (var j: u64 = 0; j < name_len; j++) {
        buf_u8[prefix_len + sep_len + j] = name_u8[j];
    }
    buf_u8[total] = 0;
    return new NameInfo{buf, total};
}

func module_util_clone_cstr(src_ptr: u64, src_len: u64) -> u64 {
    if (src_ptr == 0) { return 0; }
    var dst_ptr: u64 = heap_alloc((src_len + 1) * sizeof(u8));
    str_copy(dst_ptr, src_ptr, src_len);
    var dst_u8: []u8 = slice(dst_ptr, src_len + 1);
    dst_u8[src_len] = 0;
    return dst_ptr;
}

func module_util_clone_name_info(src_ptr: u64, src_len: u64) -> *NameInfo {
    var copied_ptr: u64 = module_util_clone_cstr(src_ptr, src_len);
    return new NameInfo{copied_ptr, src_len};
}

struct ModulePreludeInfo {
    public found: u64;
    public ptr: u64;
    public len: u64;
}

func module_util_prelude_module_info(index: u64) -> ModulePreludeInfo {
    var info: ModulePreludeInfo;
    info.found = 1;
    switch (index) {
        case 0:
            info.ptr = (u64)"std/io";
            info.len = 6;
            return info;
        case 1:
            info.ptr = (u64)"std/mem";
            info.len = 7;
            return info;
        case 2:
            info.ptr = (u64)"std/str";
            info.len = 7;
            return info;
        case 3:
            info.ptr = (u64)"std/char";
            info.len = 8;
            return info;
        case 4:
            info.ptr = (u64)"std/util";
            info.len = 8;
            return info;
        case 5:
            info.ptr = (u64)"std/vec";
            info.len = 7;
            return info;
        case 6:
            info.ptr = (u64)"std/hashmap";
            info.len = 11;
            return info;
        default:
            info.found = 0;
            info.ptr = 0;
            info.len = 0;
            return info;
    }
}

func module_util_file_exists(path: u64) -> u64 {
    var fd_i: i64 = (i64)sys_open(path, 0, 0);
    if (fd_i < 0) { return false; }
    sys_close((u64)fd_i);
    return true;
}

func module_util_is_std_alias(module_path: u64, module_len: u64) -> u64 {
    if (str_eq(module_path, module_len, "io", 2)) { return true; }
    if (str_eq(module_path, module_len, "util", 4)) { return true; }
    if (str_eq(module_path, module_len, "vec", 3)) { return true; }
    if (str_eq(module_path, module_len, "hashmap", 7)) { return true; }
    return false;
}

func module_util_std_alias_to_module_path(module_path: u64, module_len: u64) -> u64 {
    if (str_eq(module_path, module_len, "io", 2)) { return "std/io"; }
    if (str_eq(module_path, module_len, "util", 4)) { return "std/util"; }
    if (str_eq(module_path, module_len, "vec", 3)) { return "std/vec"; }
    if (str_eq(module_path, module_len, "hashmap", 7)) { return "std/hashmap"; }
    return 0;
}

func module_util_is_std_path(module_path: u64, module_len: u64) -> u64 {
    if (module_len < 4) { return false; }
    var module_u8: []u8 = slice(module_path, module_len);
    if (module_u8[0] != 115) { return false; }      // s
    if (module_u8[1] != 116) { return false; }      // t
    if (module_u8[2] != 100) { return false; }      // d
    if (module_u8[3] != 47) { return false; }       // /
    return true;
}

func module_util_name_concat2(a_ptr: u64, a_len: u64, b_ptr: u64, b_len: u64) -> *NameInfo {
    var total_len: u64 = a_len + b_len;
    var total_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    str_copy(total_ptr, a_ptr, a_len);
    str_copy(total_ptr + a_len, b_ptr, b_len);
    var out_u8: []u8 = slice(total_ptr, total_len + 1);
    out_u8[total_len] = 0;
    return new NameInfo{total_ptr, total_len};
}

func module_util_name_concat4(a_ptr: u64, a_len: u64, b_ptr: u64, b_len: u64, c_ptr: u64, c_len: u64, d_ptr: u64, d_len: u64) -> *NameInfo {
    var total_len: u64 = a_len + b_len + c_len + d_len;
    var total_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var offset: u64 = 0;
    str_copy(total_ptr + offset, a_ptr, a_len); offset = offset + a_len;
    str_copy(total_ptr + offset, b_ptr, b_len); offset = offset + b_len;
    str_copy(total_ptr + offset, c_ptr, c_len); offset = offset + c_len;
    str_copy(total_ptr + offset, d_ptr, d_len);
    var out_u8: []u8 = slice(total_ptr, total_len + 1);
    out_u8[total_len] = 0;
    return new NameInfo{total_ptr, total_len};
}

func module_util_name_concat6(a_ptr: u64, a_len: u64, b_ptr: u64, b_len: u64, c_ptr: u64, c_len: u64, d_ptr: u64, d_len: u64, e_ptr: u64, e_len: u64, f_ptr: u64, f_len: u64) -> *NameInfo {
    var total_len: u64 = a_len + b_len + c_len + d_len + e_len + f_len;
    var total_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var offset: u64 = 0;
    str_copy(total_ptr + offset, a_ptr, a_len); offset = offset + a_len;
    str_copy(total_ptr + offset, b_ptr, b_len); offset = offset + b_len;
    str_copy(total_ptr + offset, c_ptr, c_len); offset = offset + c_len;
    str_copy(total_ptr + offset, d_ptr, d_len); offset = offset + d_len;
    str_copy(total_ptr + offset, e_ptr, e_len); offset = offset + e_len;
    str_copy(total_ptr + offset, f_ptr, f_len);
    var out_u8: []u8 = slice(total_ptr, total_len + 1);
    out_u8[total_len] = 0;
    return new NameInfo{total_ptr, total_len};
}

func module_util_clone_param(src: *Param) -> *Param {
    var p: *Param = new Param();
    p.copy_from_param(src);
    return p;
}

func module_util_is_self_type(type_kind: u64, struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    if (type_kind != TYPE_STRUCT) { return false; }
    if (struct_name_ptr == 0 || struct_name_len == 0) { return false; }
    if (str_eq(struct_name_ptr, struct_name_len, "Self", 4) != 0) { return true; }
    return false;
}

func module_util_trait_method_error(prefix: u64, method_ptr: u64, method_len: u64) -> u64 {
    emit_stderr(prefix);
    emit_stderr_len(method_ptr, method_len);
    emit_stderr("\n");
    panic("Syntax error");
    return 0;
}

func module_util_nameinfo_vec_contains(names: *Vec<*NameInfo>, name_ptr: u64, name_len: u64) -> u64 {
    if (names == 0) { return 0; }
    var n: u64 = names.len();
    for (var i: u64 = 0; i < n; i++) {
        var item: *NameInfo = names.get(i);
        if (str_eq(item.ptr, item.len, name_ptr, name_len)) { return 1; }
    }
    return 0;
}

func module_util_nameinfo_vec_push_unique(names: *Vec<*NameInfo>, item: *NameInfo) -> u64 {
    if (names == 0 || item == 0) { return 0; }
    if (module_util_nameinfo_vec_contains(names, item.ptr, item.len) != 0) { return 0; }
    names.push(item);
    return 0;
}
