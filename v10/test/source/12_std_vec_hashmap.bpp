// Covers: stdlib vec/hashmap/str (stress)
// Expect exit code: 0

import std.vec;
import std.hashmap;
import std.str;

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var vec_handle: u64 = (u64)new Vec<i64>(4);
    var map_handle: u64 = (u64)new HashMap<u64, i64>(8);
    var vec_sum: i64 = 0;

    // Execution
    ((*Vec<i64>)vec_handle).push(10);
    ((*Vec<i64>)vec_handle).push(20);
    ((*Vec<i64>)vec_handle).push(12);
    if (((*Vec<i64>)vec_handle).len() != 3) { return 1; }
    if (((*Vec<i64>)vec_handle).get(1) != 20) { return 2; }

    // Stress: 대량 push + 합산
    for (var i: i64 = 0; i < 256; i = i + 1) {
        ((*Vec<i64>)vec_handle).push(i * 3);
    }
    if (((*Vec<i64>)vec_handle).len() != 259) { return 3; }
    for (var j: i64 = 0; j < 256; j = j + 1) {
        vec_sum = vec_sum + ((*Vec<i64>)vec_handle).get((u64)(j + 3));
    }
    if (vec_sum != 97920) { return 4; }

    ((*HashMap<u64, i64>)map_handle).put("key", str_len("key"), 42);
    if (!((*HashMap<u64, i64>)map_handle).has("key", 3)) { return 5; }
    if (((*HashMap<u64, i64>)map_handle).get("key", 3) != 42) { return 6; }

    // Stress: 동일 키 반복 업데이트
    for (var k: i64 = 0; k < 100; k = k + 1) {
        ((*HashMap<u64, i64>)map_handle).put("key", 3, 1000 + k);
    }
    if (((*HashMap<u64, i64>)map_handle).get("key", 3) != 1099) { return 7; }

    // Complex: conditional vec push + reverse aggregation
    var base_len: i64 = (i64)((*Vec<i64>)vec_handle).len();
    for (var m: i64 = 0; m < 32; m = m + 1) {
        var v: i64 = m * 5;
        if ((m & 3) == 0) {
            ((*Vec<i64>)vec_handle).push(v);
        } else {
            ((*Vec<i64>)vec_handle).push(v + 1);
        }
    }
    var mix_total: i64 = 0;
    for (var n: i64 = 0; n < 32; n = n + 1) {
        var val: i64 = ((*Vec<i64>)vec_handle).get((u64)(base_len + 31 - n));
        if ((val & 1) == 0) {
            mix_total = mix_total + val;
        } else {
            mix_total = mix_total - val;
        }
    }
    if (mix_total != 1208) { return 8; }

    var inserted_sum: i64 = 0;
    var expected_inserted_sum: i64 = 0;
    var inserted_weighted: i64 = 0;
    var expected_inserted_weighted: i64 = 0;
    for (var r: i64 = 0; r < 32; r = r + 1) {
        var got: i64 = ((*Vec<i64>)vec_handle).get((u64)(base_len + r));
        inserted_sum = inserted_sum + got;
        inserted_weighted = inserted_weighted + got * (r + 1);

        var expect_v: i64 = r * 5;
        if ((r & 3) != 0) { expect_v = expect_v + 1; }
        expected_inserted_sum = expected_inserted_sum + expect_v;
        expected_inserted_weighted = expected_inserted_weighted + expect_v * (r + 1);
    }
    if (inserted_sum != expected_inserted_sum) { return 10; }
    if (inserted_weighted != expected_inserted_weighted) { return 11; }

    // Complex: multiple key updates
    ((*HashMap<u64, i64>)map_handle).put("a", 1, 1);
    ((*HashMap<u64, i64>)map_handle).put("b", 1, 2);
    for (var t: i64 = 0; t < 6; t = t + 1) {
        if ((t & 1) == 0) {
            ((*HashMap<u64, i64>)map_handle).put("a", 1, 10 + t);
        } else {
            ((*HashMap<u64, i64>)map_handle).put("b", 1, 20 + t);
        }
    }
    var map_sum: i64 = ((*HashMap<u64, i64>)map_handle).get("a", 1) + ((*HashMap<u64, i64>)map_handle).get("b", 1);
    if (map_sum != 39) { return 9; }

    for (var u: i64 = 0; u < 10; u = u + 1) {
        if ((u % 3) == 0) {
            ((*HashMap<u64, i64>)map_handle).put("a", 1, 100 + u);
        } else if ((u % 3) == 1) {
            ((*HashMap<u64, i64>)map_handle).put("b", 1, 200 + u);
        } else {
            ((*HashMap<u64, i64>)map_handle).put("c", 1, 300 + u);
        }
    }
    if (!((*HashMap<u64, i64>)map_handle).has("c", 1)) { return 12; }
    var map_triple: i64 = ((*HashMap<u64, i64>)map_handle).get("a", 1)
                        + ((*HashMap<u64, i64>)map_handle).get("b", 1)
                        + ((*HashMap<u64, i64>)map_handle).get("c", 1);
    if (map_triple != 624) { return 13; }

    // Assertion
    return 0;
}
