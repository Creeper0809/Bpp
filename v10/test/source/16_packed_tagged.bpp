// Covers: packed struct, tagged metadata pointer (stress)
// Expect exit code: 0

packed struct PackedMeta {
    public a: u8;
    public b: u64;
    public c: u8;
}

packed struct TagMeta {
    public op: u16;
    public flags: u8;
}

func sum_packed(p: PackedMeta) -> u64 {
    return (u64)p.a + p.b + (u64)p.c;
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var pm: PackedMeta;
    pm.a = 1;
    pm.b = 100;
    pm.c = 2;

    var arr: [4]PackedMeta;
    var buf: [8]u8;
    var sum_arr: u64 = 0;
    var tag_sum: u64 = 0;

    // Execution
    var size_packed: u64 = sizeof(PackedMeta);
    if (size_packed != 10) { return 1; }
    if (sum_packed(pm) != 103) { return 2; }

    for (var i: i64 = 0; i < 4; i = i + 1) {
        arr[i].a = (u8)i;
        arr[i].b = (u64)((i + 1) * 10);
        arr[i].c = (u8)(5 - i);
    }
    for (var j: i64 = 0; j < 4; j = j + 1) {
        sum_arr = sum_arr + sum_packed(arr[j]);
    }
    if (sum_arr != 120) { return 3; }

    var base: *u8 = &buf[0];
    var p: *tagged(TagMeta) u8 = (*tagged(TagMeta) u8)base;
    p.op = 7;
    p.flags = 3;
    if (p.op != 7) { return 4; }
    if (p.flags != 3) { return 5; }

    // Stress: tagged metadata mutation loop
    for (var k: i64 = 0; k < 16; k = k + 1) {
        p.op = (u16)(k * 3 + 1);
        p.flags = (u8)(k & 7);
        if ((p.op & 1) == 1) {
            tag_sum = tag_sum + (u64)p.op + (u64)p.flags;
        } else {
            tag_sum = tag_sum + (u64)p.op - (u64)p.flags;
        }
    }
    if (tag_sum != 368) { return 6; }

    // Complex: packed mutation + tagged pointer switching
    var packed_acc: u64 = 0;
    for (var m: i64 = 0; m < 6; m = m + 1) {
        var idx: i64 = m & 3;
        if ((m % 2) == 0) {
            arr[idx].a = (u8)(arr[idx].a + 1);
            arr[idx].b = arr[idx].b + (u64)(m * 2);
        } else {
            arr[idx].c = (u8)(arr[idx].c + 2);
            arr[idx].b = arr[idx].b - 1;
        }
        var s: u64 = sum_packed(arr[idx]);
        if ((arr[idx].a & 1) == 0) {
            packed_acc = packed_acc + s;
        } else {
            packed_acc = packed_acc + (s - 1);
        }
    }
    if (packed_acc != 175) { return 7; }

    var base_addr: u64 = (u64)base;
    var p1: *tagged(TagMeta) u8 = (*tagged(TagMeta) u8)(base_addr + 3);
    p1.op = 0;
    p1.flags = 0;

    var tag_mix: u64 = 0;
    for (var t: i64 = 0; t < 10; t = t + 1) {
        if ((t & 1) == 0) {
            p.op = (u16)(t + 10);
            p.flags = (u8)(t & 3);
        } else {
            p1.op = (u16)(t + 20);
            p1.flags = (u8)((t * 2) & 7);
        }
        if ((t % 3) == 0) {
            tag_mix = tag_mix + (u64)p.op + (u64)p1.op;
        } else {
            tag_mix = tag_mix + (u64)p.flags + (u64)p1.flags;
        }
    }
    if (tag_mix != 161) { return 8; }

    // Assertion
    return 0;
}
