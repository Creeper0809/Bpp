// Covers: module import + generics + static generic method via module (old 17,18,19,20,63)
// Mode: ssa|nossa
// Opt: O0|O1
// Expect exit code: 0

import modules.mod_b;
import modules.mod_cyc_b;
import make_pair_sum as alias_sum from modules.mod_alias_src;
import modules.mod_chain_c;
import modules.mod_static_generic_method;
import modules.mod_a;

func main() -> u64 {
    if (make_and_read() != 42) { return 1; }
    if (cyc_value() != 7) { return 2; }
    if (alias_sum() != 3) { return 3; }
    if (chain_call() != 5) { return 4; }

    var a: i64 = StaticGenericBox.pick<i64>(7);
    var b: u64 = StaticGenericBox.pick<u64>(5);
    if (a != 7) { return 5; }
    if (b != 5) { return 6; }

    // Corner: generic module type imported directly should be instantiable.
    var bx: Box<u64>;
    bx.value = 9;
    if (bx.value != 9) { return 7; }

    // Corner: repeated cross-module calls and mixed aggregation.
    var acc: u64 = 0;
    for (var i: u64 = 0; i < 4; i = i + 1) {
        if ((i & 1) == 0) {
            acc = acc + make_and_read();
        } else {
            acc = acc + chain_call() + cyc_value();
        }
    }
    if (acc != 108) { return 8; }

    var mix: u64 = StaticGenericBox.pick<u64>((u64)a + b + bx.value);
    if (mix != 21) { return 9; }

    return 0;
}
