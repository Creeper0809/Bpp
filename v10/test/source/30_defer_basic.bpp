// Covers: defer block order + break/continue/return paths
// Expect exit code: 0

func test_block_order() -> i64 {
    // Setup
    var x: i64 = 0;

    // Execution
    if (1) {
        defer x = x + 1;
        defer x = x + 2;
        x = x + 3;
    }

    // Assertion
    return x;
}

func test_continue_path() -> i64 {
    // Setup
    var sum: i64 = 0;

    // Execution
    for (var i: i64 = 0; i < 4; i = i + 1) {
        defer sum = sum + 10;
        if (i == 1) {
            continue;
        }
        sum = sum + 1;
    }

    // Assertion
    return sum;
}

func test_break_path() -> i64 {
    // Setup
    var sum: i64 = 0;

    // Execution
    for (var i: i64 = 0; i < 4; i = i + 1) {
        defer sum = sum + 10;
        if (i == 2) {
            break;
        }
        sum = sum + 1;
    }

    // Assertion
    return sum;
}

func test_return_path() -> i64 {
    // Setup
    var sum: i64 = 0;

    // Execution
    if (1) {
        defer sum = sum + 5;
        return sum;
    }

    // Assertion
    return sum;
}

func add_to(sum: *i64, v: i64) -> i64 {
    // Setup

    // Execution
    *sum = *sum + v;

    // Assertion
    return 0;
}

func test_defer_call() -> i64 {
    // Setup
    var sum: i64 = 1;

    // Execution
    if (1) {
        defer add_to(&sum, 7);
        sum = sum + 2;
    }

    // Assertion
    return sum;
}

func test_nested_scope_lifo() -> i64 {
    var x: i64 = 0;

    if (1) {
        defer x = x * 10 + 1;
        if (1) {
            defer x = x * 10 + 2;
            x = x * 10 + 3;
        }
        x = x * 10 + 4;
    }

    return x;
}

func test_break_defer_lifo() -> i64 {
    var x: i64 = 0;

    for (var i: i64 = 0; i < 3; i = i + 1) {
        if (i == 0) {
            defer x = x * 10 + 1;
            x = x + 5;
        }

        if (i == 1) {
            defer x = x * 10 + 2;
            break;
        }
    }

    return x;
}

func test_branch_nested_defer() -> i64 {
    var s: i64 = 0;

    if (1) {
        defer s = s + 100;
        if (1) {
            defer s = s * 2;
            s = 7;
        }
        s = s + 1;
    }

    return s;
}

func main(argc: i64, argv: *u64) -> i64 {
    // Import

    // Setup
    var v0: i64 = test_block_order();
    var v1: i64 = test_continue_path();
    var v2: i64 = test_break_path();
    var v3: i64 = test_return_path();
    var v4: i64 = test_defer_call();
    var v5: i64 = test_nested_scope_lifo();
    var v6: i64 = test_break_defer_lifo();
    var v7: i64 = test_branch_nested_defer();

    // Assertion
    if (v0 != 6) { return 1; }
    if (v1 != 43) { return 2; }
    if (v2 != 32) { return 3; }
    if (v3 != 5) { return 4; }
    if (v4 != 10) { return 5; }
    if (v5 != 3241) { return 6; }
    if (v6 != 512) { return 7; }
    if (v7 != 115) { return 8; }
    return 0;
}
