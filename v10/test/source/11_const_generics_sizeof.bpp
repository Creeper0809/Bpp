// Covers: const generics, sizeof, array size (stress)
// Expect exit code: 0

func size_of_buf<const N: u64>() -> u64 {
    return sizeof([N]u64);
}

func size_mul_three() -> u64 {
    return size_of_buf<3>() * 3;
}

func sum_indices_5() -> u64 {
    var s: u64 = 0;
    for (var i: u64 = 0; i < 5; i++) {
        s = s + i;
    }
    return s;
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var size_bytes: u64 = size_of_buf<4>();
    var size_one: u64 = size_of_buf<1>();
    var size_eight: u64 = size_of_buf<8>();
    var size_large: u64 = size_of_buf<128>();
    var size_sixteen: u64 = size_of_buf<16>();

    // Execution
    if (size_bytes != 32) { return 1; }
    if (size_one != 8) { return 2; }
    if (size_eight != 64) { return 3; }
    if (size_large != 1024) { return 4; }
    if (size_sixteen != 128) { return 5; }
    if (size_sixteen != size_eight * 2) { return 6; }

    var scaled: u64 = size_mul_three();
    if (scaled != 72) { return 7; }

    var idx_sum: u64 = sum_indices_5();
    if (idx_sum != 10) { return 8; }

    // Complex: size aggregation with conditional logic
    var sizes: [4]u64;
    sizes[0] = size_of_buf<2>();
    sizes[1] = size_of_buf<3>();
    sizes[2] = size_of_buf<5>();
    sizes[3] = size_of_buf<7>();

    var complex_size: i64 = 0;
    for (var i: i64 = 0; i < 4; i = i + 1) {
        if ((i & 1) == 0) {
            complex_size = complex_size + (i64)sizes[i];
        } else {
            complex_size = complex_size - (i64)sizes[i];
        }
    }
    if (complex_size != -24) { return 9; }

    var scale: i64 = 0;
    for (var j: i64 = 0; j < 4; j = j + 1) {
        var v: i64 = (i64)sizes[j];
        if (v > 20) {
            scale = scale + v;
        } else {
            scale = scale - v;
        }
    }
    if (scale != 104) { return 10; }

    var doubled_9: u64 = size_of_buf<9>() + size_of_buf<9>();
    if (doubled_9 != 144) { return 11; }

    var ratio_64_8: u64 = size_of_buf<64>() / size_of_buf<8>();
    if (ratio_64_8 != 8) { return 12; }

    var mix_sizes: u64 = size_of_buf<3>() + size_of_buf<6>() + size_of_buf<12>();
    if (mix_sizes != 168) { return 13; }

    // Assertion
    return 0;
}
