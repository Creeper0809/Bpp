// Covers: struct members, nested struct, struct pointers, loops (stress)
// Expect exit code: 0

struct Inner {
    public a: i64;
    public b: i64;
}

struct Outer {
    public inner: Inner;
    public c: i64;
}

struct Point {
    public x: i64;
    public y: i64;
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var outer: Outer;
    outer.inner.a = 10;
    outer.inner.b = 15;
    outer.c = 17;

    var p: Point;
    var p_ptr: *Point = &p;
    var sum_points: i64 = 0;
    var copy_sum: i64 = 0;

    // Execution
    if (outer.inner.a + outer.inner.b + outer.c != 42) { return 1; }

    p_ptr.x = 20;
    p_ptr.y = 22;
    if (p_ptr.x + p_ptr.y != 42) { return 2; }

    // Edge: struct copy/assignment by value
    var p_copy: Point = p;
    if (p_copy.x + p_copy.y != 42) { return 3; }
    p_copy.x = 7;
    if (p.x != 20) { return 4; }
    copy_sum = p_copy.x + p_copy.y;
    if (copy_sum != 29) { return 5; }

    var total: i64 = 0;
    for (var i: i64 = 0; i < 6; i = i + 1) {
        total = total + i;
    }
    if (total != 15) { return 6; }

    // Stress: struct array accumulation
    var points: [10]Point;
    for (var j: i64 = 0; j < 10; j = j + 1) {
        points[j].x = j;
        points[j].y = 10 - j;
    }
    for (var k: i64 = 0; k < 10; k = k + 1) {
        sum_points = sum_points + points[k].x + points[k].y;
    }
    if (sum_points != 100) { return 7; }

    // Complex: nested struct array updates + pointer access
    var outers: [4]Outer;
    for (var t: i64 = 0; t < 4; t = t + 1) {
        outers[t].inner.a = t;
        outers[t].inner.b = t * 2;
        outers[t].c = t * 3;
    }
    var o_ptr: *Outer = &outers[2];
    o_ptr.inner.b = o_ptr.inner.b + 5;
    o_ptr.c = o_ptr.c - 1;

    var outer_sum: i64 = 0;
    for (var u: i64 = 0; u < 4; u = u + 1) {
        if ((outers[u].inner.a & 1) == 0) {
            outer_sum = outer_sum + outers[u].inner.a + outers[u].inner.b;
        } else {
            outer_sum = outer_sum + outers[u].c;
        }
    }
    if (outer_sum != 23) { return 8; }

    // Corner: nested struct copy must be by-value, not alias.
    var outer_copy: Outer = outer;
    outer_copy.inner.a = 99;
    outer_copy.c = 1;
    if (outer.inner.a != 10) { return 9; }
    if (outer.c != 17) { return 10; }

    var outer_arr: [2]Outer;
    outer_arr[0] = outer;
    outer_arr[1] = outer_copy;
    outer_arr[1].inner.b = 77;
    if (outer_arr[0].inner.b != 15) { return 11; }

    var outer_arr_ptr: *Outer = &outer_arr[1];
    outer_arr_ptr.inner.a = outer_arr_ptr.inner.a - 9;
    if (outer_arr[1].inner.a != 90) { return 12; }

    var copy_diag: i64 = outer_arr[0].inner.a + outer_arr[1].inner.a + outer_arr[1].inner.b + outer_copy.c;
    if (copy_diag != 178) { return 13; }

    // Assertion
    return 0;
}
