// Covers: generics explicit/infer, generic structs, multiple params, pointer generics (stress)
// Expect exit code: 0

struct Pair<T, U> {
    public a: T;
    public b: U;
}

struct Box<T> {
    public value: T;
    public weight: i64;
}

func id<T>(x: T) -> T { return x; }

func add_pair<T, U>(a: T, b: U) -> i64 {
    return a + b;
}

func pass_ptr<T>(p: *T) -> *T { return p; }

func pass_pp<T>(p: **T) -> **T { return p; }

func choose<T>(a: T, b: T, flag: i64) -> T {
    if (flag != 0) { return a; }
    return b;
}

func sum_pair(p: Pair<i64, i64>) -> i64 {
    return p.a + p.b;
}

func make_pair_i64(a: i64, b: i64) -> Pair<i64, i64> {
    var p: Pair<i64, i64>;
    p.a = a;
    p.b = b;
    return p;
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var a: i64 = 10;
    var b: i64 = 32;
    var sum_ids: i64 = 0;

    // Execution
    var v0: i64 = id<i64>(42);
    if (v0 != 42) { return 1; }

    var v1: i64 = id(7);
    if (v1 != 7) { return 2; }

    var sum: i64 = add_pair<i64, i64>(a, b);
    if (sum != 42) { return 3; }

    var ptr: *i64 = &a;
    var out_ptr: *i64 = pass_ptr<i64>(ptr);
    if (*out_ptr != 10) { return 4; }

    var ptr2: **i64 = &ptr;
    var out_ptr2: **i64 = pass_pp<i64>(ptr2);
    if (**out_ptr2 != 10) { return 5; }
    
    // Stress: 반복 제네릭 호출
    for (var i: i64 = 0; i < 100; i = i + 1) {
        sum_ids = sum_ids + id<i64>(i);
    }
    if (sum_ids != 4950) { return 6; }

    // Generic struct instantiation + copy
    var p0: Pair<i64, i64> = make_pair_i64(10, 32);
    if (sum_pair(p0) != 42) { return 7; }

    var p1: Pair<i64, i64> = id(p0);
    p1.a = 7;
    if (p0.a != 10) { return 8; }
    if (p1.a + p1.b != 39) { return 9; }

    var box: Box<i64>;
    box.value = 5;
    box.weight = 37;
    var box_ptr: *Box<i64> = &box;
    box_ptr.value = box_ptr.value + 1;
    if (box.value + box.weight != 43) { return 10; }

    var pairs: [6]Pair<i64, i64>;
    var sum_pairs: i64 = 0;
    for (var k: i64 = 0; k < 6; k = k + 1) {
        pairs[k].a = k;
        pairs[k].b = 10 - k;
    }
    for (var m: i64 = 0; m < 6; m = m + 1) {
        sum_pairs = sum_pairs + pairs[m].a + pairs[m].b;
    }
    if (sum_pairs != 60) { return 11; }

    // Complex: mixed generics + conditional arithmetic
    var mix_sum: i64 = 0;
    for (var j: i64 = 0; j < 20; j = j + 1) {
        var pick: i64 = choose<i64>(j, j * 2, j & 1);
        var base: i64 = id(pick);
        if ((j % 3) == 0) {
            mix_sum = mix_sum + add_pair<i64, i64>(base, 1);
        } else {
            mix_sum = mix_sum + add_pair<i64, i64>(base, -1);
        }
    }
    if (mix_sum != 274) { return 13; }

    // Complex: generic structs + conditional selection
    var mix_struct_sum: i64 = 0;
    for (var j: i64 = 0; j < 10; j = j + 1) {
        var pj: Pair<i64, i64>;
        pj.a = j;
        pj.b = j * 2;
        var pick: i64 = choose<i64>(pj.a, pj.b, j & 1);
        if ((j % 3) == 0) {
            mix_struct_sum = mix_struct_sum + pick + box.value;
        } else {
            mix_struct_sum = mix_struct_sum + pick - 1;
        }
    }
    if (mix_struct_sum != 83) { return 12; }

    // Corner: generic pointer passthrough for generic struct payload.
    var box2: Box<i64>;
    box2.value = 100;
    box2.weight = 1;
    var box2_ptr: *Box<i64> = pass_ptr<Box<i64>>(&box2);
    box2_ptr.value = box2_ptr.value - 58;
    if (box2.value != 42) { return 14; }

    var p_alias: *i64 = &box2.value;
    var pp_alias: **i64 = pass_pp<i64>(&p_alias);
    **pp_alias = **pp_alias + 1;
    if (box2.value != 43) { return 15; }

    // Corner: generic choose over struct-derived values in compact matrix.
    var pair_matrix: [3]Pair<i64, i64>;
    for (var t: i64 = 0; t < 3; t = t + 1) {
        pair_matrix[t].a = t + 1;
        pair_matrix[t].b = (t + 1) * 10;
    }
    var diag: i64 = 0;
    for (var t2: i64 = 0; t2 < 3; t2 = t2 + 1) {
        diag = diag + choose<i64>(pair_matrix[t2].a, pair_matrix[t2].b, t2 & 1);
    }
    if (diag != 42) { return 16; }

    // Assertion
    return 0;
}
