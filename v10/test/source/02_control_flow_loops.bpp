// Covers: if/else, for/while, break/continue (stress)
// Expect exit code: 0

func main(argc: i64, argv: *u64) -> i64 {
    // Import

    // Setup
    var sum_for: i64 = 0;
    var sum_while: i64 = 0;
    var branch: i64 = 0;
    var nested_sum: i64 = 0;

    // Execution
    for (var i: i64 = 0; i < 6; i = i + 1) {
        if (i == 2) { continue; }
        if (i == 5) { break; }
        sum_for = sum_for + i;
    }
    if (sum_for != 8) { return 1; }

    var idx: i64 = 0;
    while (idx < 5) {
        sum_while = sum_while + idx;
        idx = idx + 1;
    }
    if (sum_while != 10) { return 2; }

    if (sum_for + sum_while == 17) {
        branch = 1;
    } else {
        branch = 2;
    }
    if (branch != 2) { return 3; }

    // Stress: nested loops with predictable sum
    for (var i: i64 = 0; i < 50; i = i + 1) {
        for (var j: i64 = 0; j < 10; j = j + 1) {
            nested_sum = nested_sum + i;
        }
    }
    if (nested_sum != 12250) { return 4; }

    // Edge: while loop with early break path
    var guard: i64 = 0;
    var guard_sum: i64 = 0;
    while (guard < 100) {
        if (guard == 3) { break; }
        guard_sum = guard_sum + guard;
        guard = guard + 1;
    }
    if (guard_sum != 3) { return 5; }

    // Complex: mixed loop control with conditional breaks/continues
    var complex_sum: i64 = 0;
    var toggle: i64 = 0;
    for (var i: i64 = 0; i < 10; i = i + 1) {
        var j: i64 = 0;
        while (j < 6) {
            if (((i + j) % 4) == 0) { j = j + 1; continue; }
            if ((i == 7) && (j == 3)) { break; }
            if ((j & 1) == 1) {
                complex_sum = complex_sum + i - j;
            } else {
                complex_sum = complex_sum + i + j;
            }
            if (i == j) { toggle = toggle ^ 1; }
            j = j + 1;
        }
        if (i == 7) { break; }
    }
    if (complex_sum != 93) { return 6; }
    if (toggle != 1) { return 7; }

    // Single-statement bodies (no braces)
    var single_stmt_acc: i64 = 0;
    if (1) single_stmt_acc = single_stmt_acc + 1;
    else single_stmt_acc = single_stmt_acc + 100;

    var single_stmt_i: i64 = 0;
    while (single_stmt_i < 3) single_stmt_i = single_stmt_i + 1;

    for (var single_stmt_j: i64 = 0; single_stmt_j < 3; single_stmt_j = single_stmt_j + 1)
        single_stmt_acc = single_stmt_acc + single_stmt_j;

    if (single_stmt_i != 3) { return 8; }
    if (single_stmt_acc != 4) { return 9; }

    // Assertion
    return 0;
}
