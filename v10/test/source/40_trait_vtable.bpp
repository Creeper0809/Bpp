// Covers: trait/vtable dispatch, trait inheritance, abstract methods, default trait methods,
//         virtual dispatch in inheritance chain, safe virtual call, private shadowing + virtual dispatch
// Expect exit code: 0

trait CalcA {
    func add(self: *Self, v: i64) -> i64;
    func mul(self: *Self, v: i64) -> i64;
}

struct CalcAImplA {
    public base: i64;
}

struct CalcAImplB {
    public base: i64;
}

impl CalcA for CalcAImplA {
    public func add(self: *CalcAImplA, v: i64) -> i64 {
        return self.base + v;
    }

    public func mul(self: *CalcAImplA, v: i64) -> i64 {
        return self.base * v;
    }
}

impl CalcA for CalcAImplB {
    public func add(self: *CalcAImplB, v: i64) -> i64 {
        return self.base + v + 10;
    }

    public func mul(self: *CalcAImplB, v: i64) -> i64 {
        return self.base * v + 5;
    }
}

trait CalcB {
    func add(self: *Self, v: i64) -> i64;
}

struct CalcBBase {
    public base: i64;
}

struct CalcBChild: CalcBBase, CalcB {
    public extra: i64;
}

impl CalcB for CalcBChild {
    public func add(self: *CalcBChild, v: i64) -> i64 {
        return self.base + self.extra + v;
    }
}

struct AbParent {
    public value: i64;
}

struct AbChild : AbParent {
    public extra: i64;
}

impl AbParent {
    public abst func calc(self: *AbParent) -> i64;
}

impl AbChild {
    @[override]
    public func calc(self: *AbChild) -> i64 {
        return self.value + self.extra;
    }
}

trait CounterOps {
    func value(self: *Self) -> i64;

    func twice(self: *Self) -> i64 {
        return self.value() * 2;
    }

    func mix(self: *Self, a: i64, b: i64) -> i64 {
        return self.twice() + a - b;
    }
}

struct BaseCounter {
    public n: i64;
}

struct FancyCounter {
    public n: i64;
}

impl CounterOps for BaseCounter {
    public func value(self: *BaseCounter) -> i64 {
        return self.n;
    }
}

impl CounterOps for FancyCounter {
    public func value(self: *FancyCounter) -> i64 {
        return self.n + 1;
    }

    public func twice(self: *FancyCounter) -> i64 {
        return self.value() * 3;
    }
}

struct VDParent {
    public v: i64;
}

struct VDChild : VDParent {
    public x: i64;
}

struct VDGrand : VDChild {
    public y: i64;
}

impl VDParent {
    public abst func calc(self: *VDParent) -> i64;

    public func calc_plus(self: *VDParent, k: i64) -> i64 {
        return self.calc() + k;
    }
}

impl VDChild {
    @[override]
    public func calc(self: *VDChild) -> i64 {
        return self.v + self.x;
    }
}

impl VDGrand {
    @[override]
    public func calc(self: *VDGrand) -> i64 {
        return self.v + self.x + self.y;
    }
}

struct Shape {
    public bias: i64;
}

struct Rect : Shape {
    public w: i64;
    public h: i64;
}

impl Shape {
    public abst func area(self: *Shape) -> i64;
}

impl Rect {
    @[override]
    public func area(self: *Rect) -> i64 {
        return self.w * self.h + self.bias;
    }
}

struct PSParent {
    public v: i64;
}

struct PSChild : PSParent {
    public x: i64;
}

impl PSParent {
    private func local(self: *PSParent) -> i64 {
        return 100;
    }

    public abst func calc(self: *PSParent) -> i64;

    public func call_local(self: *PSParent) -> i64 {
        return self.local();
    }

    public func call_calc(self: *PSParent) -> i64 {
        return self.calc();
    }
}

impl PSChild {
    private func local(self: *PSChild) -> i64 {
        return 200;
    }

    @[override]
    public func calc(self: *PSChild) -> i64 {
        return self.local() + self.v + self.x;
    }

    public func child_local(self: *PSChild) -> i64 {
        return self.local();
    }
}

func case_trait_vtable() -> u64 {
    var a: CalcAImplA;
    a.base = 3;
    var b: CalcAImplB;
    b.base = 4;

    var ta: *CalcA = (*CalcA)&a;
    var tb: *CalcA = (*CalcA)&b;

    if (ta.add(2) != 5) { return 1; }
    if (ta.mul(2) != 6) { return 2; }
    if (tb.add(2) != 16) { return 3; }
    if (tb.mul(2) != 13) { return 4; }
    return 0;
}

func case_trait_inheritance() -> u64 {
    var c: CalcBChild;
    c.base = 3;
    c.extra = 4;
    var tc: *CalcB = (*CalcB)&c;
    if (tc.add(5) != 12) { return 1; }
    return 0;
}

func case_abstract_override() -> u64 {
    var c: AbChild;
    c.value = 10;
    c.extra = 5;
    if (c.calc() != 15) { return 1; }
    return 0;
}

func case_trait_defaults() -> u64 {
    var b: BaseCounter;
    b.n = 7;
    var f: FancyCounter;
    f.n = 4;
    var tb: *CounterOps = (*CounterOps)&b;
    var tf: *CounterOps = (*CounterOps)&f;

    if (tb.value() != 7) { return 1; }
    if (tb.twice() != 14) { return 2; }
    if (tb.mix(10, 3) != 21) { return 3; }
    if (tf.value() != 5) { return 4; }
    if (tf.twice() != 15) { return 5; }
    if (tf.mix(2, 1) != 16) { return 6; }
    return 0;
}

func case_virtual_inherit_chain() -> u64 {
    var c: VDChild;
    c.v = 2;
    c.x = 5;

    var g: VDGrand;
    g.v = 3;
    g.x = 7;
    g.y = 11;

    var p1: *VDParent = (*VDParent)&c;
    var p2: *VDParent = (*VDParent)&g;

    if (p1.calc() != 7) { return 1; }
    if (p2.calc() != 21) { return 2; }
    if (p1.calc_plus(10) != 17) { return 3; }
    if (p2.calc_plus(10) != 31) { return 4; }
    return 0;
}

func case_virtual_safe_call() -> u64 {
    var r: Rect;
    r.bias = 1;
    r.w = 3;
    r.h = 4;

    var sp: *Shape = (*Shape)&r;
    if (sp.area() != 13) { return 1; }
    if (sp.?area() != 13) { return 2; }

    var null_sp: *Shape = 0;
    if (null_sp.?area() != 0) { return 3; }
    return 0;
}

func case_private_shadow_virtual() -> u64 {
    var c: PSChild;
    c.v = 1;
    c.x = 2;
    if (c.child_local() != 200) { return 1; }
    if (c.calc() != 203) { return 2; }

    var p: *PSParent = (*PSParent)&c;
    if (p.call_local() != 100) { return 3; }
    if (p.call_calc() != 203) { return 4; }
    return 0;
}

func main() -> u64 {
    var r: u64 = case_trait_vtable();
    if (r != 0) { return 100 + r; }

    r = case_trait_inheritance();
    if (r != 0) { return 200 + r; }

    r = case_abstract_override();
    if (r != 0) { return 300 + r; }

    r = case_trait_defaults();
    if (r != 0) { return 400 + r; }

    r = case_virtual_inherit_chain();
    if (r != 0) { return 500 + r; }

    r = case_virtual_safe_call();
    if (r != 0) { return 600 + r; }

    r = case_private_shadow_virtual();
    if (r != 0) { return 700 + r; }

    return 0;
}
