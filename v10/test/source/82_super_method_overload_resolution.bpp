// Covers: super.method(...) overload resolution should use argument types, not only arity
// Expect exit code: 0

struct ParentSuperOverload {
    public v: i64;
}

impl ParentSuperOverload {
    public func foo(self: *ParentSuperOverload, x: i64) -> i64 {
        return x + 10;
    }

    public func foo(self: *ParentSuperOverload, x: f64) -> i64 {
        return 77;
    }
}

struct ChildSuperOverload : ParentSuperOverload {
    public c: i64;
}

impl ChildSuperOverload {
    public func call_i(self: *ChildSuperOverload) -> i64 {
        return super.foo((i64)5);
    }

    public func call_f(self: *ChildSuperOverload) -> i64 {
        return super.foo(1.5);
    }
}

func main() -> i64 {
    var x: ChildSuperOverload;
    if (x.call_i() != 15) { return 1; }
    if (x.call_f() != 77) { return 2; }
    return 0;
}
