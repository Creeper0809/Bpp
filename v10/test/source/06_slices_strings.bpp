// Covers: slices, indexing, assignment, string literal, slice return (stress)
// Expect exit code: 0

func make_slice() -> []u8 {
    return slice("XYZ", 3);
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var slice_data: []u8 = slice("ABCD", 4);
    var slice_alias: []u8 = slice_data;
    var sum: i64 = 0;
    var ret_slice: []u8 = make_slice();

    // Execution
    if (slice_data[0] != 65) { return 1; }
    if (slice_data[1] != 66) { return 2; }
    if (slice_data[2] != 67) { return 3; }
    if (slice_data[3] != 68) { return 4; }

    if (slice_alias[2] != 67) { return 5; }
    if (ret_slice[0] != 88) { return 6; }
    if (ret_slice[1] != 89) { return 7; }
    if (ret_slice[2] != 90) { return 8; }

    // Stress: 반복 인덱싱 합산
    for (var i: i64 = 0; i < 4; i = i + 1) {
        sum = sum + slice_data[i];
    }
    if (sum != 266) { return 9; }

    // Complex: mixed indexing + conditional aggregation
    var complex_sum: i64 = 0;
    for (var i: i64 = 0; i < 4; i = i + 1) {
        var v: i64 = slice_data[i];
        if ((i & 1) == 0) {
            complex_sum = complex_sum + v;
        } else {
            complex_sum = complex_sum - v;
        }
        if (i < 3) {
            complex_sum = complex_sum + ret_slice[i];
        }
    }
    if (complex_sum != 265) { return 10; }

    var alias_sum: i64 = 0;
    for (var j: i64 = 0; j < 3; j = j + 1) {
        if (slice_alias[j] > 66) {
            alias_sum = alias_sum + 1;
        } else {
            alias_sum = alias_sum + 2;
        }
    }
    if (alias_sum != 5) { return 11; }

    // Corner: writable slices over stack array must preserve alias semantics.
    var arr: [6]u8;
    for (var t: i64 = 0; t < 6; t = t + 1) {
        arr[t] = (u8)(t + 1);
    }
    var s0: []u8 = slice(&arr[0], 6);
    var s1: []u8 = slice(&arr[1], 4);
    s1[0] = 20;
    s1[3] = 40;
    if (arr[1] != 20) { return 12; }
    if (s0[4] != 40) { return 13; }

    var rolling: i64 = 0;
    for (var k: i64 = 0; k < 6; k = k + 1) {
        if ((k & 1) == 0) {
            rolling = rolling + s0[k];
        } else {
            rolling = rolling - s0[k];
        }
    }
    if (rolling != 14) { return 14; }

    var s2: []u8 = slice(&s1[1], 2);
    s2[0] = 50;
    if (arr[2] != 50) { return 15; }

    var total_arr: i64 = 0;
    for (var m: i64 = 0; m < 6; m = m + 1) {
        total_arr = total_arr + s0[m];
    }
    if (total_arr != 121) { return 16; }

    // Assertion
    return 0;
}
