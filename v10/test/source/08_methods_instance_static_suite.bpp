// Covers: instance methods + static methods unified regression (old 08, 15)
// Expect exit code: 0

struct Counter {
    public value: i64;
}

impl Counter {
    public func init(self: *Counter, v: i64) {
        self.value = v;
    }

    public func add_value(self: *Counter, n: i64) {
        self.value = self.value + n;
    }

    public func add_if_even(self: *Counter, n: i64) {
        if ((n & 1) == 0) {
            self.value = self.value + n;
        } else {
            self.value = self.value - n;
        }
    }

    public func inc(self: *Counter, delta: i64) {
        self.value = self.value + delta;
    }

    public func get(self: *Counter) -> i64 {
        return self.value;
    }

    public static func make(v: i64) -> Counter {
        var c: Counter;
        c.value = v;
        return c;
    }

    public static func sum(a: i64, b: i64) -> i64 {
        return a + b;
    }

    public static func mix(a: i64, b: i64) -> i64 {
        if ((a & 1) == 0) { return a + b; }
        return a - b;
    }
}

func main(argc, argv) -> i64 {
    // Old 08 path
    var c0: Counter;
    c0.init(3);
    c0.add_value(4);
    if (c0.get() != 7) { return 1; }
    c0.add_value(5);
    if (c0.get() != 12) { return 2; }

    for (var i: i64 = 0; i < 1000; i = i + 1) {
        c0.add_value(1);
    }
    if (c0.get() != 1012) { return 3; }

    var complex_sum: i64 = 0;
    for (var k: i64 = 0; k < 10; k = k + 1) {
        c0.add_if_even(k);
        if ((k % 3) == 0) { c0.add_value(2); }
        complex_sum = complex_sum + c0.get() - k;
    }
    if (c0.get() != 1015) { return 4; }
    if (complex_sum != 10114) { return 5; }

    // Old 15 path
    var c1: Counter = Counter.make(10);
    var expected: i64 = Counter.sum(10, 5);
    c1.inc(5);
    if (c1.get() != expected) { return 101; }

    for (var j: i64 = 0; j < 1000; j = j + 1) {
        var step: i64 = Counter.sum(1, 0);
        c1.inc(step);
    }
    if (c1.get() != expected + 1000) { return 102; }

    var acc: i64 = 0;
    for (var t: i64 = 0; t < 12; t = t + 1) {
        var step2: i64 = Counter.mix(t, 3);
        if ((t % 4) == 0) {
            c1.inc(step2);
        } else {
            c1.inc(step2 + 1);
        }
        acc = acc + c1.get();
    }
    if (c1.get() != 1090) { return 103; }
    if (acc != 12538) { return 104; }

    return 0;
}
