// Covers: pointers, addr/deref, double pointer, arrays, pointer arithmetic, globals (stress)
// Expect exit code: 0

var global_counter: i64;

func main(argc: i64, argv: *u64) -> i64 {
    // Import

    // Setup
    var values: [4]i64;
    values[0] = 10;
    values[1] = 20;
    values[2] = 30;
    values[3] = 40;

    var big_values: [64]i64;
    for (var i: i64 = 0; i < 64; i = i + 1) {
        big_values[i] = i * 2;
    }

    // Execution
    var ptr_second: *i64 = &values[1];
    if (*ptr_second != 20) { return 1; }

    var ptr_to_ptr: **i64 = &ptr_second;
    if (**ptr_to_ptr != 20) { return 2; }

    var base_addr: u64 = &values;
    var ptr_third: *i64 = (*i64)(base_addr + 16);
    if (*ptr_third != 30) { return 3; }

    var global_ptr: *i64 = &global_counter;
    *global_ptr = 9;
    if (global_counter != 9) { return 4; }

    // Stress: pointer arithmetic over larger array
    var base_big: u64 = &big_values;
    var sum_big: i64 = 0;
    for (var k: i64 = 0; k < 64; k = k + 1) {
        var elem_ptr: *i64 = (*i64)(base_big + k * 8);
        sum_big = sum_big + *elem_ptr;
    }
    if (sum_big != 4032) { return 5; }

    // Stress: global updates through pointer
    for (var m: i64 = 0; m < 100; m = m + 1) {
        *global_ptr = m;
    }
    if (global_counter != 99) { return 6; }

    // Complex: pointer updates with conditional accumulation
    var local_sum: i64 = 0;
    var base_mut: u64 = &big_values;
    for (var i: i64 = 0; i < 8; i = i + 1) {
        var row_sum: i64 = 0;
        for (var j: i64 = 0; j < 8; j = j + 1) {
            var idx: i64 = i * 8 + j;
            var elem_ptr2: *i64 = (*i64)(base_mut + idx * 8);
            if ((idx & 3) == 0) {
                *elem_ptr2 = *elem_ptr2 + 1;
            } else {
                *elem_ptr2 = *elem_ptr2 - 1;
            }
            row_sum = row_sum + *elem_ptr2;
        }
        if ((row_sum & 1) == 0) {
            local_sum = local_sum + row_sum;
        } else {
            local_sum = local_sum - row_sum;
        }
    }
    if (local_sum != 4000) { return 7; }

    // Corner: pointer-to-pointer mutation should target original array cell.
    var head_ptr: *i64 = &big_values[0];
    var head_pp: **i64 = &head_ptr;
    **head_pp = **head_pp + 41;
    if (big_values[0] != 42) { return 8; }

    // Corner: strided pointer walk over every 4th element (post-mutation view).
    var stride_sum: i64 = 0;
    for (var q: i64 = 0; q < 16; q = q + 1) {
        var stride_ptr: *i64 = (*i64)(base_mut + q * 32);
        stride_sum = stride_sum + *stride_ptr;
    }
    if (stride_sum != 1017) { return 9; }

    // Corner: tail pointer mutation and full checksum after multiple alias writes.
    var tail_ptr: *i64 = (*i64)(base_mut + 63 * 8);
    *tail_ptr = *tail_ptr - 5;
    if (big_values[63] != 120) { return 10; }

    var final_sum: i64 = 0;
    for (var z: i64 = 0; z < 64; z = z + 1) {
        final_sum = final_sum + big_values[z];
    }
    if (final_sum != 4036) { return 11; }

    // Assertion
    return 0;
}
