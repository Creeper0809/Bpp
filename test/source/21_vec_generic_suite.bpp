// Covers: Vec<T> generic value/pointer/stress scenarios (old 21,22,32)
// Mode: ssa|nossa
// Opt: O0|O1
// Expect exit code: 0

import std.vec;

struct Point {
    public x: u64;
    public y: u64;
}

struct S24 {
    public a: u64;
    public b: u64;
    public c: u64;
}

struct S40 {
    public a: u64;
    public b: u64;
    public c: u64;
    public d: u64;
    public e: u64;
}

struct Foo {
    public v: u64;
}

func make_foo(val: u64) -> *Foo {
    return new Foo{val};
}

func check_s24(v: *Vec<S24>) -> u64 {
    if (sizeof(S24) != 24) { return 10; }
    if (v.len() != 4) { return 11; }

    var g0: S24 = v.get(0);
    if (g0.a != 100) { return 12; }
    if (g0.b != 101) { return 13; }
    if (g0.c != 102) { return 14; }

    var g2: S24 = v.get(2);
    if (g2.a != 900) { return 15; }
    if (g2.b != 901) { return 16; }
    if (g2.c != 902) { return 17; }

    var g3: S24 = v.get(3);
    if (g3.a != 400) { return 18; }
    if (g3.b != 401) { return 19; }
    if (g3.c != 402) { return 20; }

    return 0;
}

func check_s40(v: *Vec<S40>) -> u64 {
    if (sizeof(S40) != 40) { return 30; }
    if (v.len() != 3) { return 31; }

    var g2: S40 = v.get(2);
    if (g2.a != 2020) { return 32; }
    if (g2.b != 2021) { return 33; }
    if (g2.c != 2022) { return 34; }
    if (g2.d != 2023) { return 35; }
    if (g2.e != 2024) { return 36; }

    return 0;
}

func main() -> u64 {
    if (sizeof(Point) != 16) { return 1; }
    var vp: *Vec<Point> = (*Vec<Point>)new Vec<Point>(4);

    var p0: Point;
    p0.x = 11;
    p0.y = 22;

    var p1: Point;
    p1.x = 33;
    p1.y = 44;

    vp.push(p0);
    vp.push(p1);

    if (vp.len() != 2) { return 2; }
    var gp0: Point = vp.get(0);
    var gp1: Point = vp.get(1);
    if (gp0.x != 11 || gp0.y != 22) { return 3; }
    if (gp1.x != 33 || gp1.y != 44) { return 4; }

    var v24: *Vec<S24> = (*Vec<S24>)new Vec<S24>(1);
    for (var i: u64 = 0; i < 5; i = i + 1) {
        var s: S24;
        s.a = 100 + i * 100;
        s.b = 101 + i * 100;
        s.c = 102 + i * 100;
        v24.push(s);
    }
    if (v24.len() != 5) { return 101; }

    var s2: S24;
    s2.a = 900;
    s2.b = 901;
    s2.c = 902;
    v24.set(2, s2);
    v24.pop();

    var r24: u64 = check_s24(v24);
    if (r24 != 0) { return 120 + r24; }

    var v40: *Vec<S40> = (*Vec<S40>)new Vec<S40>(2);
    for (var j: u64 = 0; j < 3; j = j + 1) {
        var t: S40;
        t.a = 2000 + j * 10;
        t.b = 2001 + j * 10;
        t.c = 2002 + j * 10;
        t.d = 2003 + j * 10;
        t.e = 2004 + j * 10;
        v40.push(t);
    }

    var r40: u64 = check_s40(v40);
    if (r40 != 0) { return 120 + r40; }

    var vf: *Vec<*Foo> = new Vec<*Foo>(4);
    var f0: *Foo = make_foo(10);
    var f1: *Foo = make_foo(20);

    vf.push(f0);
    vf.push(f1);
    if (vf.len() != 2) { return 201; }

    var g0: *Foo = vf.get(0);
    var g1: *Foo = vf.get(1);
    if (g0.v != 10) { return 202; }
    if (g1.v != 20) { return 203; }

    return 0;
}
