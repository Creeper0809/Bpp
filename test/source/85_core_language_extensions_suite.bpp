// Covers: core language extensions success suite

//=== CASE 108_bool_and_signed_int_primitives
func main() -> u64 {
    var b_true: bool = true;
    var b_false: bool = false;
    var x8: i8 = (i8)120;
    var x16: i16 = (i16)30000;
    var x32: i32 = (i32)2000000000;

    if (b_true == 0) { return 1; }
    if (b_false != 0) { return 2; }
    if ((i64)x8 != 120) { return 3; }
    if ((i64)x16 != 30000) { return 4; }
    if ((i64)x32 != 2000000000) { return 5; }

    return 0;
}
//=== END

//=== CASE 145_lambda_explicit_capture_modes_success
func lambda_ref_from_param(x: u64) -> u64 {
    var by_ref: u64 = func [&x] () -> u64 { x + 1 };
    x = x + 40;
    return by_ref();
}

func main() -> u64 {
    var v_ref: u64 = lambda_ref_from_param(1);
    if (v_ref != 42) { return 1; }

    var y: u64 = 7;
    var by_val: u64 = func [y] () -> u64 { y + 1 };
    y = 100;
    if (by_val() != 8) { return 2; }
    if (y != 100) { return 3; }
    return 0;
}
//=== END

//=== CASE 146_enum_payload_and_variant_match_success
enum MaybeU64 {
    None,
    Some(value: u64),
}

func unwrap_or_zero(v: MaybeU64) -> u64 {
    match (v) {
        case MaybeU64.None:
            return 0;
        case MaybeU64.Some(x):
            return x;
    }
}

func main() -> u64 {
    var a: MaybeU64 = MaybeU64.None();
    var b: MaybeU64 = MaybeU64.Some(42);
    if (unwrap_or_zero(a) != 0) { return 1; }
    if (unwrap_or_zero(b) != 42) { return 2; }
    return 0;
}
//=== END

//=== CASE 147_generic_where_bound_infer_success
trait Incrementable {
    func inc(self: *Self, x: u64) -> u64;
}

struct IncBox {
    public bias: u64;
}

impl Incrementable for IncBox {
    public func inc(self: *IncBox, x: u64) -> u64 {
        return x + self.bias;
    }
}

func apply_inc<T>(obj: *T, x: u64) -> u64 where T: Incrementable {
    return obj.inc(x);
}

func main() -> u64 {
    if (apply_inc<IncBox>(new IncBox { 2 }, 40) != 42) { return 1; }
    return 0;
}
//=== END

//=== CASE 143_function_type_variance_success
func driver_variance(cb: func (i64) -> i64) -> u64 {
    return (u64)cb((i64)41);
}

func main() -> u64 {
    var c: func (u64) -> u64 = func (x: u64) -> u64 { x + 1 };
    var direct: u64 = driver_variance(c);
    if (direct != 42) { return 1; }

    var d: func (func (i64) -> i64) -> u64 = driver_variance;
    var out: u64 = d(c);
    if (out != 42) { return 2; }
    return 0;
}
//=== END

//=== CASE 124_annotation_on_function_and_variable_decls
@[config]
var G_ANNOTATED: u64 = 40;

struct AnnBox {
}

impl AnnBox {
    @[trace]
    public static func add(a: u64, b: u64) -> u64 {
        return a + b;
    }
}

@[feature]
func sum_with_annotation(a: u64, b: u64) -> u64 {
    @[hot]
    var local_sum: u64 = a + b;
    return local_sum;
}

func main() -> u64 {
    var out: u64 = sum_with_annotation(G_ANNOTATED, 2);
    if (out != 42) { return 1; }
    if (AnnBox.add(1, 1) != 2) { return 2; }
    return 0;
}
//=== END

//=== CASE 109_default_named_and_variadic_direct_call
func add3(a: u64, b: u64 = 7, c: u64 = 11) -> u64 {
    return a + b + c;
}

func variadic_head_sum(head: u64, ...rest: u64) -> u64 {
    return head + rest;
}

func main() -> u64 {
    var a: u64 = add3(1);
    var b: u64 = add3(1, c: 100, b: 10);
    var c: u64 = add3(a: 5, c: 1);

    if (a != 19) { return 10; }
    if (b != 111) { return 11; }
    if (c != 13) { return 12; }

    var v0: u64 = variadic_head_sum(9);
    var v1: u64 = variadic_head_sum(9, 4);
    var v2: u64 = variadic_head_sum(9, 4, 88, 99);

    if (v0 != 9) { return 20; }
    if (v1 != 13) { return 21; }
    if (v2 != 13) { return 22; }

    return 0;
}
//=== END

//=== CASE 110_lambda_non_capture_success
func main() -> u64 {
    var f: u64 = func (x: u64) -> u64 { x + 2 };
    var g: u64 = func (x: u64, y: u64) -> u64 { x * y };

    var a: u64 = f(40);
    var b: u64 = g(6, 7);

    if (a != 42) { return 1; }
    if (b != 42) { return 2; }
    return 0;
}
//=== END

//=== CASE 135_lambda_capture_success
func make_adder(base: u64) -> u64 {
    var add: u64 = func (x: u64) -> u64 { x + base };
    return add;
}

func main() -> u64 {
    var add5: u64 = make_adder(5);
    if (add5(37) != 42) { return 1; }
    return 0;
}
//=== END

//=== CASE 111_match_alias_with_wildcard
func classify(v: u64) -> u64 {
    match (v) {
        case 1:
            return 10;
        case 2:
            return 20;
        case _:
            return 99;
    }
}

func main() -> u64 {
    if (classify(1) != 10) { return 1; }
    if (classify(2) != 20) { return 2; }
    if (classify(777) != 99) { return 3; }
    return 0;
}
//=== END

//=== CASE 112_try_catch_finally_throw_success
func main() -> u64 {
    var x: u64 = 0;
    try {
        x = x + 1;
        throw 123;
        x = x + 100;
    } catch {
        x = x + 10;
    } finally {
        x = x + 1000;
    }

    if (x != 1011) { return 1; }
    return 0;
}
//=== END

//=== CASE 113_constructor_default_and_named_args
struct PointEx {
    public x: u64;
    public y: u64;
}

impl PointEx {
    public constructor(x: u64, y: u64 = 5) {
        self.x = x;
        self.y = y;
    }
}

func main() -> u64 {
    var p0: PointEx = PointEx(2);
    var p1: PointEx = PointEx(y: 9, x: 3);

    if (p0.x != 2 || p0.y != 5) { return 1; }
    if (p1.x != 3 || p1.y != 9) { return 2; }
    return 0;
}
//=== END

//=== CASE 114_static_method_default_and_named_args
struct CalcEx {
}

impl CalcEx {
    public static func add(a: u64, b: u64 = 40) -> u64 {
        return a + b;
    }
}

func main() -> u64 {
    var v0: u64 = CalcEx.add(2);
    var v1: u64 = CalcEx.add(b: 39, a: 3);
    if (v0 != 42) { return 1; }
    if (v1 != 42) { return 2; }
    return 0;
}
//=== END

//=== CASE 127_function_decorator_runtime_behavior
func add_one(next: u64, x: u64) -> u64 {
    return next(x) + 1;
}

@[add_one]
func decorated_double(x: u64) -> u64 {
    return x * 2;
}

func main() -> u64 {
    if (decorated_double(20) != 41) { return 1; }
    if (decorated_double(0) != 1) { return 2; }
    return 0;
}
//=== END

//=== CASE 128_entry_annotation_changes_program_entry
func main() -> u64 {
    return 77;
}

@[entry]
func runtime_entry() -> u64 {
    return 0;
}
//=== END

//=== CASE 132_match_multi_value_case_success
func classify_many(v: u64) -> u64 {
    match (v) {
        case 1, 2, 3:
            return 10;
        case 4, 5:
            return 20;
        case _:
            return 99;
    }
}

func main() -> u64 {
    if (classify_many(1) != 10) { return 1; }
    if (classify_many(3) != 10) { return 2; }
    if (classify_many(5) != 20) { return 3; }
    if (classify_many(9) != 99) { return 4; }
    return 0;
}
//=== END

//=== CASE 138_match_expression_with_capture_success
func main() -> u64 {
    var base: u64 = 40;
    var x: u64 = 2;
    var y: u64 = match (x) {
        case 1:
            base + 1;
        case 2, 3:
            base + x;
        case _:
            0;
    };

    if (y != 42) { return 1; }
    return 0;
}
//=== END

//=== CASE 139_function_type_signature_success
struct FuncBox {
    public cb: func (u64) -> u64;
}

func plus_one(v: u64) -> u64 {
    return v + 1;
}

func apply_once(cb: func (u64) -> u64, x: u64) -> u64 {
    return cb(x);
}

func apply_many(cb: func (u64, ...u64) -> u64) -> u64 {
    return cb(10, 20, 30);
}

func sum_head(head: u64, ...rest: u64) -> u64 {
    return head + rest;
}

func main() -> u64 {
    var f: func (u64) -> u64 = plus_one;
    if (f(41) != 42) { return 1; }

    var box: FuncBox = FuncBox { f };
    if (box.cb(41) != 42) { return 2; }

    if (apply_once(f, 41) != 42) { return 3; }

    var vf: func (u64, ...u64) -> u64 = sum_head;
    if (apply_many(vf) != 30) { return 4; }
    return 0;
}
//=== END

//=== CASE 140_try_catch_typed_value_success
func main() -> u64 {
    var out: i64 = 0;
    try {
        throw (i64)42;
    } catch (e: i64) {
        out = e;
    }
    if (out != 42) { return 1; }
    return 0;
}
//=== END

//=== CASE 133_throw_nested_loop_try_success
func main() -> u64 {
    var x: u64 = 0;
    try {
        var i: u64 = 0;
        while (i < 3) {
            var j: u64 = 0;
            while (j < 3) {
                x = x + 1;
                if (i == 1 && j == 1) {
                    throw 99;
                }
                j = j + 1;
            }
            x = x + 100;
            i = i + 1;
        }
        x = x + 10000;
    } catch {
        x = x + 7;
    } finally {
        x = x + 1000;
    }

    if (x != 1112) { return 1; }
    return 0;
}
//=== END

//=== CASE 134_instance_method_named_args_success
struct NamedArgsBox {
    public v: u64;
}

impl NamedArgsBox {
    public func set(self: *NamedArgsBox, a: u64, b: u64 = 10, c: u64 = 1) -> u64 {
        self.v = a + b + c;
        return self.v;
    }
}

func main() -> u64 {
    var b: NamedArgsBox = NamedArgsBox { 0 };
    var r0: u64 = b.set(1, 10, 1);
    var r1: u64 = b.set(c: 2, a: 3, b: 4);
    var r2: u64 = b.set(a: 5, c: 6);

    if (r0 != 12) { return 1; }
    if (r1 != 9) { return 2; }
    if (r2 != 21) { return 3; }
    return 0;
}
//=== END

//=== CASE 135_array_copy_init_success
func main() -> u64 {
    var src: [3]u64;
    src[0] = 10;
    src[1] = 20;
    src[2] = 30;

    var dst: [3]u64 = src;
    if (dst[0] != 10 || dst[1] != 20 || dst[2] != 30) { return 1; }

    src[1] = 99;
    if (dst[1] != 20) { return 2; }
    return 0;
}
//=== END

//=== CASE 136_mixed_float_int_binary_success
func main() -> u64 {
    var a: f64 = 1.5 + 2;
    var b: f64 = 10 - 0.5;
    var c: f64 = 3 * 2.0;
    var d: f64 = 9.0 / 2;

    if (a != 3.5) { return 1; }
    if (b != 9.5) { return 2; }
    if (c != 6.0) { return 3; }
    if (d != 4.5) { return 4; }

    if ((2 + 0.25) != 2.25) { return 5; }
    if ((3.0 > 2) == 0) { return 6; }
    if ((3 < 3.5) == 0) { return 7; }
    return 0;
}
//=== END

//=== CASE 137_generic_function_decorator_success
func plus_one(next: u64, x: u64) -> u64 {
    return next(x) + 1;
}

@[plus_one]
func decorated_twice<T>(x: T) -> T {
    return x + x;
}

func main() -> u64 {
    var v: u64 = decorated_twice<u64>(20);
    if (v != 41) { return 1; }
    return 0;
}
//=== END

//=== CASE 141_impl_method_decorator_success
struct DecoratedCounter {
    public value: u64;
}

func add_one_method(next: u64, self: *DecoratedCounter, x: u64) -> u64 {
    return next(self, x) + 1;
}

impl DecoratedCounter {
    @[add_one_method]
    public func push(self: *DecoratedCounter, x: u64) -> u64 {
        self.value = self.value + x;
        return self.value;
    }
}

func main() -> u64 {
    var c: DecoratedCounter = DecoratedCounter { 0 };
    if (c.push(41) != 42) { return 1; }
    if (c.value != 41) { return 2; }
    return 0;
}
//=== END

//=== CASE 142_annotation_argument_syntax_success
@[config(mode="fast", retries=2, enabled=true)]
func with_ann_args() -> u64 {
    @[local(meta(1, 2, 3))]
    var v: u64 = 42;
    return v;
}

func main() -> u64 {
    return with_ann_args() - 42;
}
//=== END

//=== CASE 148_try_nested_rethrow_propagation_success
func main() -> u64 {
    var x: u64 = 0;
    try {
        x = x + 1;
        try {
            x = x + 10;
            throw 23;
            x = x + 1000;
        } finally {
            x = x + 100;
        }
        x = x + 10000;
    } catch (e: u64) {
        x = x + e;
    }

    if (x != 134) { return 1; }
    return 0;
}
//=== END

//=== CASE 149_enum_payload_composite_by_value_success
struct PayloadPair {
    public a: u64;
    public b: u64;
}

enum PayloadComposite {
    Pair(PayloadPair),
    Arr([2]u64),
    Slice([]u64),
}

func payload_score(v: PayloadComposite) -> u64 {
    match (v) {
        case PayloadComposite.Pair(p):
            return p.a + p.b;
        case PayloadComposite.Arr(a):
            return a[0] + a[1];
        case PayloadComposite.Slice(s):
            if (s.len == 0) { return 0; }
            return s[0];
    }
}

func main() -> u64 {
    var p: PayloadPair = PayloadPair { 10, 32 };
    if (payload_score(PayloadComposite.Pair(p)) != 42) { return 1; }

    var arr: [2]u64;
    arr[0] = 20;
    arr[1] = 22;
    if (payload_score(PayloadComposite.Arr(arr)) != 42) { return 2; }

    var s: []u64 = slice(&arr[0], 2);
    if (payload_score(PayloadComposite.Slice(s)) != 20) { return 3; }
    return 0;
}
//=== END

//=== CASE 150_match_expression_exhaustive_enum_without_default_success
enum ExprMatchEnum {
    None,
    Some(value: u64),
}

func main() -> u64 {
    var out: u64 = match (ExprMatchEnum.Some(42)) {
        case ExprMatchEnum.None:
            0;
        case ExprMatchEnum.Some(x):
            x;
    };
    if (out != 42) { return 1; }
    return 0;
}
//=== END

//=== CASE 151_generic_assoc_type_bound_success
trait AssocRun {
    alias Item;
    func run(self: *Self, x: u64) -> u64;
}

struct AssocRunBox {
    public bias: u64;
}

impl AssocRun<Item=u64> for AssocRunBox {
    public func run(self: *AssocRunBox, x: u64) -> u64 {
        return x + self.bias;
    }
}

func apply_assoc_run<T>(obj: *T, x: u64) -> u64 where T: AssocRun<Item=u64> {
    return obj.run(x);
}

func main() -> u64 {
    var b: AssocRunBox = AssocRunBox { 2 };
    if (apply_assoc_run(&b, 40) != 42) { return 1; }
    return 0;
}
//=== END
