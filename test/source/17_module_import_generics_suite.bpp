// Covers: module import + generics + static generic method via module (old 17,18,19,20,63)
// Mode: ssa|nossa
// Opt: O0|O1
// Expect exit code: 0

import modules.mod_b;
import modules.mod_cyc_b;
import make_pair_sum as alias_sum from modules.mod_alias_src;
import modules.mod_chain_c;
import modules.mod_static_generic_method;
import modules.mod_a;

func main() -> u64 {
    if (make_and_read() != 42) { return 1; }
    if (cyc_value() != 7) { return 2; }
    if (alias_sum() != 3) { return 3; }
    if (chain_call() != 5) { return 4; }

    var a: i64 = StaticGenericBox.pick<i64>(7);
    var b: u64 = StaticGenericBox.pick<u64>(5);
    if (a != 7) { return 5; }
    if (b != 5) { return 6; }

    // Corner: generic module type imported directly should be instantiable.
    var bx: Box<u64>;
    bx.value = 9;
    if (bx.value != 9) { return 7; }

    // Corner: repeated cross-module calls and mixed aggregation.
    var acc: u64 = 0;
    for (var i: u64 = 0; i < 4; i = i + 1) {
        if ((i & 1) == 0) {
            acc = acc + make_and_read();
        } else {
            acc = acc + chain_call() + cyc_value();
        }
    }
    if (acc != 108) { return 8; }

    var mix: u64 = StaticGenericBox.pick<u64>((u64)a + b + bx.value);
    if (mix != 21) { return 9; }

    var acc2: u64 = 0;
    for (var i2: u64 = 0; i2 < 6; i2 = i2 + 1) {
        var picked: u64 = StaticGenericBox.pick<u64>(i2 + 1);
        if ((i2 & 1) == 0) {
            acc2 = acc2 + picked + chain_call();
        } else {
            acc2 = acc2 + picked + make_and_read();
        }
    }
    if (acc2 != 162) { return 10; }

    var boxes: [3]Box<u64>;
    for (var j: u64 = 0; j < 3; j = j + 1) {
        boxes[j].value = (j + 1) * 3;
    }
    var box_sum: u64 = boxes[0].value + boxes[1].value + boxes[2].value;
    if (box_sum != 18) { return 11; }

    var alias_acc: u64 = 0;
    for (var k: u64 = 0; k < 5; k = k + 1) {
        alias_acc = alias_acc + alias_sum();
    }
    if (alias_acc != 15) { return 12; }

    return 0;
}
