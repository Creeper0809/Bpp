// Covers: core language extensions failure diagnostics suite

//=== CASE 115_lambda_generic_call_capture_target_fail
// Expect compile fail: 1
// Expect error contains: lambda generic call target must be global symbol

func main() -> u64 {
    var local_fp: u64 = 0;
    var f: u64 = func () -> u64 { local_fp<u64>() };
    return f();
}
//=== END

//=== CASE 145_match_variant_non_exhaustive_fail
// Expect compile fail: 1
// Expect error contains: non-exhaustive match: missing case ColorX.Blue

enum ColorX {
    Red,
    Blue,
}

func main() -> u64 {
    var c: ColorX = ColorX.Red();
    match (c) {
        case ColorX.Red:
            return 1;
    }
    return 0;
}
//=== END

//=== CASE 146_generic_where_bound_infer_fail
// Expect compile fail: 1
// Expect error contains: generic bound not satisfied

trait NeedRun {
    func run(self: *Self, x: u64) -> u64;
}

struct NoRun {
    public v: u64;
}

func call_run<T>(obj: *T, x: u64) -> u64 where T: NeedRun {
    return obj.run(x);
}

func main() -> u64 {
    return call_run<NoRun>(new NoRun { 0 }, 1);
}
//=== END

//=== CASE 144_function_type_variance_incompatible_fail
// Expect compile fail: 1
// Expect error contains: function pointer call argument type mismatch

func driver_variance_fail(cb: func (i64) -> i64) -> u64 {
    return (u64)cb((i64)1);
}

func cb_ptr_variance_fail(x: *u64) -> u64 {
    if (x == 0) { return 0; }
    return *x;
}

func main() -> u64 {
    var d: func (func (i64) -> i64) -> u64 = driver_variance_fail;
    var c: func (*u64) -> u64 = cb_ptr_variance_fail;
    return d(c);
}
//=== END

//=== CASE 125_statement_annotation_target_fail
// Expect compile fail: 1
// Expect error contains: statement annotation target must be variable declaration

func main() -> u64 {
    @[x]
    return 0;
}
//=== END

//=== CASE 126_top_level_annotation_target_fail
// Expect compile fail: 1
// Expect error contains: annotation target must be function or variable declaration

@[x]
import std.io;

func main() -> u64 {
    return 0;
}
//=== END

//=== CASE 116_named_argument_unknown_param_fail
// Expect compile fail: 1
// Expect error contains: unknown named argument

func addx(a: u64, b: u64 = 1) -> u64 {
    return a + b;
}

func main() -> u64 {
    return addx(a: 1, c: 2);
}
//=== END

//=== CASE 117_missing_required_argument_fail
// Expect compile fail: 1
// Expect error contains: missing required argument

func must_have_a_case117(a: u64, b: u64 = 9) -> u64 {
    return a + b;
}

func main() -> u64 {
    return must_have_a_case117(b: 1);
}
//=== END

//=== CASE 118_variadic_must_be_last_fail
// Expect compile fail: 1
// Expect error contains: variadic parameter must be the last parameter

func bad(...rest: u64, tail: u64) -> u64 {
    return rest + tail;
}

func main() -> u64 {
    return bad(1, 2);
}
//=== END

//=== CASE 119_variadic_cannot_have_default_fail
// Expect compile fail: 1
// Expect error contains: variadic parameter cannot have default value

func bad(...rest: u64 = 1) -> u64 {
    return rest;
}

func main() -> u64 {
    return bad();
}
//=== END

//=== CASE 120_throw_outside_try_fail
// Expect compile fail: 1
// Expect error contains: throw can only be used inside try

func main() -> u64 {
    throw 1;
    return 0;
}
//=== END

//=== CASE 121_match_wildcard_mixed_with_values_fail
// Expect compile fail: 1
// Expect error contains: wildcard '_' cannot be mixed with explicit case values

func main() -> u64 {
    match (1) {
        case 1, _:
            return 1;
        }
    }
    return 0;
}
//=== END

//=== CASE 122_try_requires_handler_fail
// Expect compile fail: 1
// Expect error contains: try statement requires catch and/or finally block

func main() -> u64 {
    try {
        var x: u64 = 1;
        x = x + 1;
    }
    return 0;
}
//=== END

//=== CASE 123_named_args_unknown_param_on_instance_method_fail
// Expect compile fail: 1
// Expect error contains: unknown named argument

struct BoxFail {
    public v: u64;
}

impl BoxFail {
    public func set(self: *BoxFail, a: u64, b: u64) -> u64 {
        self.v = a + b;
        return self.v;
    }
}

func main() -> u64 {
    var b: BoxFail = BoxFail { 0 };
    return b.set(c: 2, a: 1);
}
//=== END

//=== CASE 129_multiple_entry_functions_fail
// Expect compile fail: 1
// Expect error contains: multiple @[entry] functions are not allowed

@[entry]
func run_a() -> u64 {
    return 0;
}

@[entry]
func run_b() -> u64 {
    return 0;
}
//=== END

//=== CASE 130_decorator_signature_mismatch_fail
// Expect compile fail: 1
// Expect error contains: decorator parameter list must match target function after the first parameter

func bad_decorator(next: u64, x: i64) -> u64 {
    return next((u64)x);
}

@[bad_decorator]
func target_signature(x: u64) -> u64 {
    return x;
}

func main() -> u64 {
    return target_signature(1);
}
//=== END

//=== CASE 131_entry_annotation_requires_zero_params_fail
// Expect compile fail: 1
// Expect error contains: @[entry] function must not declare parameters

@[entry]
func bad_entry(argc: u64) -> u64 {
    return argc;
}
//=== END

//=== CASE 132_enum_member_assignment_forbidden_fail
// Expect compile fail: 1
// Expect error contains: Cannot assign to enum member constant

enum EnumAssignFail {
    A = 1,
}

func main() -> u64 {
    EnumAssignFail.A = 3;
    return 0;
}
//=== END

//=== CASE 138_match_expression_requires_default_fail
// Expect compile fail: 1
// Expect error contains: match expression requires a default arm

func main() -> u64 {
    var x: u64 = match (1) {
        case 1:
            10;
    };
    return x;
}
//=== END

//=== CASE 139_function_pointer_argument_count_mismatch_fail
// Expect compile fail: 1
// Expect error contains: function pointer call argument count mismatch

func plus_one_fail(v: u64) -> u64 {
    return v + 1;
}

func main() -> u64 {
    var f: func (u64) -> u64 = plus_one_fail;
    return f(1, 2);
}
//=== END

//=== CASE 140_function_pointer_variadic_type_mismatch_fail
// Expect compile fail: 1
// Expect error contains: function pointer variadic argument type mismatch

func sum_head_fail(head: u64, ...rest: u64) -> u64 {
    return head + rest;
}

func main() -> u64 {
    var f: func (u64, ...u64) -> u64 = sum_head_fail;
    return f(1, true);
}
//=== END

//=== CASE 141_trait_impl_method_decorator_forbidden_fail
// Expect compile fail: 1
// Expect error contains: decorators are not supported on trait impl methods

trait RunTrait {
    func run(self: *Self, x: u64) -> u64;
}

struct Runner {
    public v: u64;
}

func plus_one_trait(next: u64, self: *Runner, x: u64) -> u64 {
    return next(self, x) + 1;
}

impl RunTrait for Runner {
    @[plus_one_trait]
    public func run(self: *Runner, x: u64) -> u64 {
        self.v = x;
        return self.v;
    }
}

func main() -> u64 {
    var r: Runner = Runner { 0 };
    return r.run(1);
}
//=== END

//=== CASE 142_annotation_argument_unclosed_fail
// Expect compile fail: 1
// Expect error contains: annotation argument list is not closed

struct AnnFail {
}

impl AnnFail {
    @[broken(1, 2]
    public func run(self: *AnnFail) -> u64 {
        return 0;
    }
}

func main() -> u64 {
    var a: AnnFail = AnnFail {};
    return a.run();
}
//=== END

//=== CASE 143_generic_assoc_type_bound_mismatch_fail
// Expect compile fail: 1
// Expect error contains: generic associated type bound not satisfied

trait AssocRunFail {
    alias Item;
    func run(self: *Self, x: u64) -> u64;
}

struct AssocFailBox {
    public bias: u64;
}

impl AssocRunFail<Item=i64> for AssocFailBox {
    public func run(self: *AssocFailBox, x: u64) -> u64 {
        return x + self.bias;
    }
}

func apply_assoc_fail<T>(obj: *T, x: u64) -> u64 where T: AssocRunFail<Item=u64> {
    return obj.run(x);
}

func main() -> u64 {
    var b: AssocFailBox = AssocFailBox { 1 };
    return apply_assoc_fail(&b, 2);
}
//=== END

//=== CASE 144_trait_impl_missing_assoc_binding_fail
// Expect compile fail: 1
// Expect error contains: trait impl is missing associated type bindings

trait MissingAssocTrait {
    alias Item;
    func get(self: *Self, x: u64) -> u64;
}

struct MissingAssocBox {
    public bias: u64;
}

impl MissingAssocTrait for MissingAssocBox {
    public func get(self: *MissingAssocBox, x: u64) -> u64 {
        return x + self.bias;
    }
}

func main() -> u64 {
    var b: MissingAssocBox = MissingAssocBox { 1 };
    return b.get(1);
}
//=== END

//=== CASE 145_lambda_by_ref_local_capture_forbidden_fail
// Expect compile fail: 1
// Expect error contains: by-ref lambda capture requires current function parameter

func main() -> u64 {
    var x: u64 = 1;
    var by_ref: u64 = func [&x] () -> u64 { x + 1 };
    if (by_ref() != 2) { return 1; }
    x = 41;
    if (by_ref() != 42) { return 2; }
    return 0;
}
//=== END

//=== CASE 146_annotation_builtin_args_forbidden_fail
// Expect compile fail: 1
// Expect error contains: this built-in annotation does not take arguments

@[entry(1)]
func main() -> u64 {
    return 0;
}
//=== END

//=== CASE 147_annotation_decorator_args_forbidden_fail
// Expect compile fail: 1
// Expect error contains: decorator annotations currently do not accept arguments

func deco_bad(next: u64, x: u64) -> u64 {
    return next(x);
}

@[deco_bad(1)]
func main() -> u64 {
    return 0;
}
//=== END

//=== CASE 148_closure_handle_copy_init_forbidden_fail
// Expect compile fail: 1
// Expect error contains: closure handle copy in variable initialization is not supported

func main() -> u64 {
    var x: u64 = 1;
    var a: u64 = func () -> u64 { x };
    var b: u64 = a;
    return b();
}
//=== END

//=== CASE 149_undefined_identifier_in_return_fail
// Expect compile fail: 1
// Expect error contains: undefined identifier

func main() -> u64 {
    return x;
}
//=== END

//=== CASE 150_delete_plain_u64_forbidden_fail
// Expect compile fail: 1
// Expect error contains: delete expects pointer type or lambda closure handle

func main() -> u64 {
    var x: u64 = 1;
    delete x;
    return 0;
}
//=== END

//=== CASE 151_undefined_member_base_expr_fail
// Expect compile fail: 1
// Expect error contains: undefined identifier

func main() -> u64 {
    return a.b;
}
//=== END

//=== CASE 152_undefined_member_base_assign_fail
// Expect compile fail: 1
// Expect error contains: undefined identifier

func main() -> u64 {
    a.b = 1;
    return 0;
}
//=== END

//=== CASE 153_non_struct_member_access_expr_fail
// Expect compile fail: 1
// Expect error contains: member access on non-struct identifier

func main() -> u64 {
    var x: i64 = 1;
    return x.a;
}
//=== END

//=== CASE 154_non_struct_member_access_assign_fail
// Expect compile fail: 1
// Expect error contains: member assignment on non-struct identifier

func main() -> u64 {
    var x: i64 = 1;
    x.a = 2;
    return 0;
}
//=== END
