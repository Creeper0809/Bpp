// Covers: safe navigation .? for pointer member access, chaining, method calls
// Mode: ssa
// Opt: O0
// Expect exit code: 0

struct Node {
    public value: i64;
    public next: *Node;
}

var g_count: i64 = 0;

func inc() -> i64 {
    g_count = g_count + 1;
    return 5;
}

impl Node {
    public func add(self: *Node, x: i64) -> i64 {
        return self.value + x;
    }
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var n1: Node;
    n1.value = 7;
    n1.next = 0;

    var n0: Node;
    n0.value = 1;
    n0.next = &n1;

    var p: *Node = &n0;
    var nullp: *Node = 0;

    // Execution
    var v1: i64 = p.?next.?value;
    if (v1 != 7) { return 1; }

    var v2: i64 = nullp.?next.?value;
    if (v2 != 0) { return 2; }

    var v3: i64 = p.?next.?next.?value;
    if (v3 != 0) { return 3; }

    g_count = 0;
    var s1: i64 = nullp.?add(inc());
    if (s1 != 0) { return 4; }
    if (g_count != 0) { return 5; }

    var s2: i64 = p.?add(inc());
    if (s2 != 6) { return 6; }
    if (g_count != 1) { return 7; }

    var s3: i64 = p.?next.?add(2);
    if (s3 != 9) { return 8; }

    // Assertion
    return 0;
}
