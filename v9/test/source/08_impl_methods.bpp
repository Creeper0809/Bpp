// Covers: impl methods, self calls, method chaining (stress)
// Expect exit code: 0

struct Counter {
    public value: i64;
}

impl Counter {
    public func init(self: *Counter, v: i64) {
        self.value = v;
    }

    public func add(self: *Counter, n: i64) {
        self.value = self.value + n;
    }

    public func add_if_even(self: *Counter, n: i64) {
        if ((n & 1) == 0) {
            self.value = self.value + n;
        } else {
            self.value = self.value - n;
        }
    }

    public func get(self: *Counter) -> i64 {
        return self.value;
    }
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var counter: Counter;
    counter.init(3);

    // Execution
    counter.add(4);
    if (counter.get() != 7) { return 1; }
    counter.add(5);
    if (counter.get() != 12) { return 2; }

    // Stress: 반복 메서드 호출
    for (var i: i64 = 0; i < 1000; i = i + 1) {
        counter.add(1);
    }
    if (counter.get() != 1012) { return 3; }

    // Complex: conditional method calls + state-dependent aggregation
    var complex_sum: i64 = 0;
    for (var k: i64 = 0; k < 10; k = k + 1) {
        counter.add_if_even(k);
        if ((k % 3) == 0) { counter.add(2); }
        complex_sum = complex_sum + counter.get() - k;
    }
    if (counter.get() != 1015) { return 4; }
    if (complex_sum != 10114) { return 5; }

    // Assertion
    return 0;
}
