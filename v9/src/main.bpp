// main.b - Main entry point for v3.8 modular compiler

import std.io;
import std.str;
import std.os;
import std.path;
import std.util;
import compiler;
import codegen;
import opt;

// Explicit argv layouts for execve-style argument arrays.
// Each field is a single u64 pointer slot, matching the exact contiguous memory
// layout expected by execve without any manual byte offset calculations.
struct Argv6 { public a0: u64; public a1: u64; public a2: u64; public a3: u64; public a4: u64; public a5: u64; }
struct Argv5 { public a0: u64; public a1: u64; public a2: u64; public a3: u64; public a4: u64; }
struct Argv2 { public a0: u64; public a1: u64; }

impl Argv6 {
    public constructor() {
        self.a0 = 0;
        self.a1 = 0;
        self.a2 = 0;
        self.a3 = 0;
        self.a4 = 0;
        self.a5 = 0;
    }
}

impl Argv5 {
    public constructor() {
        self.a0 = 0;
        self.a1 = 0;
        self.a2 = 0;
        self.a3 = 0;
        self.a4 = 0;
    }
}

impl Argv2 {
    public constructor() {
        self.a0 = 0;
        self.a1 = 0;
    }
}

func main_print_usage() -> u64 {
    emit("Usage: bppc [-O0|-O1] [-dump-ir|-dump-ssa|-asm] <source.bpp>\n");
    return 0;
}

func main_parse_cli(argc: u64, argv_ptr: *u64, filename_out: *u64) -> u64 {
    // Default flags (avoid uninitialized globals affecting codegen)
    opt_init_defaults();

    if (argc < 2) { return 0; }

    var filename: u64 = 0;
    for (var i: u64 = 1; i < argc; i++) {
        var arg: u64 = argv_ptr[i];
        var arg_len: u64 = str_len(arg);

        if (str_eq(arg, arg_len, "-O1", 3)) {
            opt_set_level(1);
            continue;
        }
        if (str_eq(arg, arg_len, "-O0", 3)) {
            opt_set_level(0);
            continue;
        }
        if (str_eq(arg, arg_len, "-dump-ir", 8)) {
            opt_set_ir_mode(IR_3ADDR);
            opt_set_output_mode(OUT_IR);
            continue;
        }
        if (str_eq(arg, arg_len, "-dump-ssa", 9)) {
            opt_set_ir_mode(IR_SSA);
            opt_set_output_mode(OUT_IR);
            continue;
        }
        if (str_eq(arg, arg_len, "-asm", 4)) {
            opt_set_output_mode(OUT_ASM);
            continue;
        }

        if (arg_len > 0) {
            var arg_u8: []u8 = slice(arg, arg_len);
            if (arg_u8[0] == 45) { // '-'
                emit_stderr("[ERROR] unknown option: ");
                emit_stderr_len(arg, arg_len);
                emit_stderr("\n");
                return 0;
            }
        }

        filename = arg;
    }

    if (filename == 0) { return 0; }
    *filename_out = filename;
    return 1;
}

func main_run_compile_pipeline(filename: u64, filename_len: u64) -> *AstProgram {
    if (!load_std_prelude()) {
        emit_stderr("[ERROR] failed to load std prelude\n");
        return 0;
    }

    if (!load_module(filename, filename_len)) {
        emit_stderr("[ERROR] failed to load module: ");
        emit_stderr_len(filename, filename_len);
        emit_stderr("\n");
        return 0;
    }

    finalize_import_aliases();
    compiler_lower_parse_sugar();
    compiler_finalize_global_init_kinds();
    compiler_validate_direct_impl_calls();
    compiler_insert_default_constructors();
    compiler_insert_global_init_func();
    compiler_resolve_super_references();
    compiler_monomorphize_generics();
    compiler_finalize_abst_methods();
    compiler_finalize_traits();

    return build_merged_program();
}

func main_build_output_paths(base_name: u64, base_len: u64, asm_out: *u64, obj_out: *u64, exe_out: *u64) -> u64 {
    *asm_out = str_concat(base_name, base_len, ".s", 2);
    *obj_out = str_concat(base_name, base_len, ".o", 2);
    *exe_out = str_concat(base_name, base_len, ".out", 4);
    return 0;
}

func main_restore_stdout(saved_fd: u64) -> u64 {
    os_sys_dup2(saved_fd, 1);
    sys_close(saved_fd);
    return 0;
}

func main_emit_asm_file(asm_path: u64, merged_prog: *AstProgram) -> u64 {
    var flags: u64 = OS_O_WRONLY + OS_O_CREAT + OS_O_TRUNC;
    var fd_i: i64 = (i64)sys_open(asm_path, flags, 420);
    if (fd_i < 0) {
        emit_stderr("[ERROR] failed to open asm output: ");
        emit_stderr(asm_path);
        emit_stderr("\n");
        return 1;
    }
    var fd: u64 = (u64)fd_i;

    var saved_fd: u64 = 100;
    var dup_res: i64 = (i64)os_sys_dup2(1, saved_fd);
    if (dup_res < 0) {
        sys_close(fd);
        emit_stderr("[ERROR] failed to dup stdout\n");
        return 1;
    }

    var dup_res2: i64 = (i64)os_sys_dup2(fd, 1);
    if (dup_res2 < 0) {
        sys_close(fd);
        main_restore_stdout(saved_fd);
        emit_stderr("[ERROR] failed to redirect stdout to asm file\n");
        return 1;
    }

    cg_program_with_sigs(merged_prog, get_func_sigs());
    sys_close(fd);
    main_restore_stdout(saved_fd);
    return 0;
}

func main_run_nasm(asm_path: u64, obj_path: u64) -> u64 {
    var nasm_argv: *Argv6 = new Argv6();
    nasm_argv.a0 = (u64)"nasm";
    nasm_argv.a1 = (u64)"-felf64";
    nasm_argv.a2 = asm_path;
    nasm_argv.a3 = (u64)"-o";
    nasm_argv.a4 = obj_path;
    nasm_argv.a5 = 0;
    var nasm_status: i64 = os_execute((u64)"/usr/bin/nasm", (u64)nasm_argv);
    if (nasm_status != 0) {
        emit_stderr("[ERROR] nasm failed\n");
        return 1;
    }
    return 0;
}

func main_run_ld(obj_path: u64, exe_path: u64) -> u64 {
    var ld_argv: *Argv5 = new Argv5();
    ld_argv.a0 = (u64)"ld";
    ld_argv.a1 = obj_path;
    ld_argv.a2 = (u64)"-o";
    ld_argv.a3 = exe_path;
    ld_argv.a4 = 0;
    var ld_status: i64 = os_execute((u64)"/usr/bin/ld", (u64)ld_argv);
    if (ld_status != 0) {
        emit_stderr("[ERROR] ld failed\n");
        return 1;
    }
    return 0;
}

func main_run_output(exe_path: u64) -> u64 {
    var exe_argv: *Argv2 = new Argv2();
    exe_argv.a0 = exe_path;
    exe_argv.a1 = 0;
    var status: i64 = os_execute(exe_path, (u64)exe_argv);
    emit("[RUN] exit=");
    print_i64(status);
    emit("\n");
    if (status != 0) {
        emit_stderr("[ERROR] program exited with non-zero status\n");
        return 1;
    }
    return 0;
}

func main_emit_and_run(base_name: u64, base_len: u64, merged_prog: *AstProgram) -> u64 {
    var asm_path: u64 = 0;
    var obj_path: u64 = 0;
    var exe_path: u64 = 0;
    main_build_output_paths(base_name, base_len, &asm_path, &obj_path, &exe_path);

    if (main_emit_asm_file(asm_path, merged_prog) != 0) { return 1; }
    if (main_run_nasm(asm_path, obj_path) != 0) { return 1; }
    if (main_run_ld(obj_path, exe_path) != 0) { return 1; }

    emit("[OK] output: ");
    emit(exe_path);
    emit("\n");
    if (main_run_output(exe_path) != 0) { return 1; }
    return 0;
}


func main(argc: u64, argv: u64) -> u64 {
    init_stack_trace();

    var argv_ptr: *u64 = (*u64)argv;

    var filename: u64 = 0;
    if (main_parse_cli(argc, argv_ptr, &filename) == 0) {
        main_print_usage();
        return 1;
    }

    var filename_len: u64 = str_len(filename);

    setup_paths(filename, filename_len);

    push_trace("main", "main.bpp", __LINE__);
    defer pop_trace();

    var merged_prog: *AstProgram = main_run_compile_pipeline(filename, filename_len);
    if (merged_prog == 0) {
        return 1;
    }

    var out_mode: u64 = opt_get_output_mode();
    var base_name: u64 = path_basename_noext(filename, filename_len);
    var base_len: u64 = str_len(base_name);

    switch (out_mode) {
        case OUT_IR:
            cg_program_with_sigs_ir(merged_prog, get_func_sigs());
            break;
        case OUT_ASM:
            cg_program_with_sigs(merged_prog, get_func_sigs());
            break;
        default:
            if (main_emit_and_run(base_name, base_len, merged_prog) != 0) {
                return 1;
            }
            break;
    }
    
    return 0;
}
