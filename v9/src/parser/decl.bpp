// parse_decl.b - Declaration parsing
//
// Parses top-level declarations:
// - const declarations
// - import declarations
// - function declarations (parameters, return types, body)
// - struct definitions
// - enum definitions
// - impl blocks
// - parse_program (entry point)

import std.io;
import std.vec;
import std.util;
import std.str;
import module_utils;
import types;
import lexer;
import ast;
import compiler;
import parser.util;
import parser.type;
import parser.expr;
import parser.stmt;

// ============================================
// Const Declaration
// ============================================

func parse_const_decl(p: *Parser) -> *AstConstDecl {
    parse_consume(p, TOKEN_CONST);
    
    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;

    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_EQ);
    
    var value: u64 = 0;
    var neg: u64 = 0;
    
    // Handle negative numbers
    if (parse_match(p, TOKEN_MINUS)) {
        neg = 1;
    }
    
    if (parse_peek_kind(p) == TOKEN_NUMBER) {
        var val_tok: *Token = parse_peek(p);
        value = parse_num_val(val_tok);
        parse_consume(p, TOKEN_NUMBER);
    } else if (parse_peek_kind(p) == TOKEN_CHAR) {
        var char_tok: *Token = parse_peek(p);
        var char_ptr: u64 = char_tok.ptr;
        var char_len: u64 = char_tok.len;
        var char_u8: []u8 = slice(char_ptr, char_len);
        value = char_u8[1];
        // Handle escape sequences
        if (char_u8[1] == 92) {
            var escape_char: u64 = char_u8[2];
            if (escape_char == 110) { value = 10; }       // \n
            else if (escape_char == 116) { value = 9; }   // \t
            else if (escape_char == 114) { value = 13; }  // \r
            else if (escape_char == 48) { value = 0; }    // \0
            else if (escape_char == 92) { value = 92; }   // \\
            else if (escape_char == 39) { value = 39; }   // \'
            else { value = escape_char; }
        }
        parse_consume(p, TOKEN_CHAR);
    } else {
        emit_stderr("[ERROR] Expected number or char in const\n");
        parse_panic_here(p, "Parse error");
    }
    
    if (neg) { value = 0 - value; }
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    return ast_const_decl(name_ptr, name_len, value);
}

func parse_import_expect_module_token(p: *Parser) -> *Token {
    var tok: *Token = parse_peek(p);
    var kind: u64 = parse_peek_kind(p);
    if (kind != TOKEN_IDENTIFIER && kind != TOKEN_CHAR) {
        emit_stderr("[ERROR] Expected module identifier in import\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);
    return tok;
}

func parse_import_parse_path_suffix(p: *Parser, path_ptr_in: u64, path_len_in: u64) -> *NameInfo {
    var path_ptr: u64 = path_ptr_in;
    var path_len: u64 = path_len_in;
    while (parse_match(p, TOKEN_DOT)) {
        var next_tok: *Token = parse_import_expect_module_token(p);
        var joined_path: u64 = str_concat(path_ptr, path_len, "/", 1);
        path_ptr = str_concat(joined_path, path_len + 1, next_tok.ptr, next_tok.len);
        path_len = path_len + 1 + next_tok.len;
    }
    return new NameInfo{path_ptr, path_len};
}

// ============================================
// Import Declaration
// ============================================

func parse_import_decl(p: *Parser) -> *AstImport {
    parse_consume(p, TOKEN_IMPORT);

    var first_tok: *Token = parse_import_expect_module_token(p);

    // Selective import: import <symbol> [as <alias>] from <module>
    if (parse_peek_kind(p) == TOKEN_AS || parse_peek_kind(p) == TOKEN_FROM) {
        var symbol_ptr: u64 = first_tok.ptr;
        var symbol_len: u64 = first_tok.len;
        var alias_ptr: u64 = symbol_ptr;
        var alias_len: u64 = symbol_len;

        if (parse_match(p, TOKEN_AS)) {
            var alias_tok: *Token = parse_peek(p);
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] Expected alias identifier in import\n");
                parse_panic_here(p, "Parse error");
            }
            alias_ptr = alias_tok.ptr;
            alias_len = alias_tok.len;
            parse_consume(p, TOKEN_IDENTIFIER);
        }

        parse_consume(p, TOKEN_FROM);

        var mod_tok: *Token = parse_import_expect_module_token(p);
        var path_info: *NameInfo = parse_import_parse_path_suffix(p, mod_tok.ptr, mod_tok.len);

        parse_consume(p, TOKEN_SEMICOLON);

        return ast_import(path_info.ptr, path_info.len, symbol_ptr, symbol_len, alias_ptr, alias_len);
    }

    // Import module: import <module>;
    var path_info2: *NameInfo = parse_import_parse_path_suffix(p, first_tok.ptr, first_tok.len);
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    return ast_import(path_info2.ptr, path_info2.len, 0, 0, 0, 0);
}

// ============================================
// Function Parsing
// ============================================

// Skip a block without parsing its contents
func parse_skip_block(p: *Parser) -> u64 {
    parse_consume(p, TOKEN_LBRACE);
    var depth: u64 = 1;
    while (depth > 0) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_EOF:
                emit_stderr("[ERROR] Unexpected EOF while skipping block\n");
                parse_panic_here(p, "Parse error");
                break;
            case TOKEN_LBRACE:
                depth = depth + 1;
                break;
            case TOKEN_RBRACE:
                depth = depth - 1;
            default:
                break;
        }
        parse_adv(p);
    }
    return 0;
}

func parse_is_generic_param_list_impl(p: *Parser, require_follow_lparen: u64) -> u64 {
    return parse_scan_generic_list_followed_by(p, TOKEN_LPAREN, require_follow_lparen, 1);
}

func parse_is_generic_param_list(p: *Parser) -> u64 {
    return parse_is_generic_param_list_impl(p, 1);
}

func parse_is_generic_param_list_any(p: *Parser) -> u64 {
    return parse_is_generic_param_list_impl(p, 0);
}

func parse_is_impl_trait_block(p: *Parser) -> u64 {
    if (parse_peek_kind(p) != TOKEN_IMPL) { return false; }
    var saved: u64 = parser_pos(p);
    parse_adv(p);
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
        parser_set_pos(p, saved);
        return false;
    }
    parse_adv(p);
    var k: u64 = parse_peek_kind(p);
    parser_set_pos(p, saved);
    if (k == TOKEN_FOR) { return true; }
    return false;
}

// Parse generic parameter list: <T, U, const N: u64>
// allow_any:
//   0 => require the list to be directly followed by '(' (function generic params)
//   1 => accept any well-formed generic parameter list
func parse_generic_params_impl(p: *Parser, allow_any: u64) -> *Vec<*GenericParam> {
    var tok: *Token = parse_peek(p);
    if (tok == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_LT) { return 0; }
    if (allow_any != 0) {
        if (parse_is_generic_param_list_any(p) == 0) { return 0; }
    } else {
        if (parse_is_generic_param_list(p) == 0) { return 0; }
    }
    parse_consume(p, TOKEN_LT);

    var params: *Vec<*GenericParam> = new Vec<*GenericParam>(4);
    while (1) {
        var is_value: u64 = 0;
        if (parse_match(p, TOKEN_CONST)) { is_value = 1; }

        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected generic parameter name\n");
            parse_panic_here(p, "Parse error");
        }

        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok.ptr;
        var name_len: u64 = name_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);

        var value_type_kind: u64 = 0;
        if (parse_match(p, TOKEN_COLON)) {
            value_type_kind = parse_base_type(p);
            if (value_type_kind == TYPE_STRUCT || value_type_kind == TYPE_VOID) {
                emit_stderr("[ERROR] Invalid value generic type\n");
                parse_panic_here(p, "Parse error");
            }
            if (value_type_kind != TYPE_U64) {
                emit_stderr("[ERROR] Value generic type must be u64\n");
                parse_panic_here(p, "Parse error");
            }
            is_value = 1;
        } else if (is_value == 1) {
            emit_stderr("[ERROR] const generic requires type annotation\n");
            parse_panic_here(p, "Parse error");
        }

        var gp: *GenericParam = new GenericParam();
        if (is_value == 1) { gp.kind = GENERIC_KIND_VALUE; }
        else { gp.kind = GENERIC_KIND_TYPE; }
        gp.name_ptr = name_ptr;
        gp.name_len = name_len;
        gp.value_type_kind = value_type_kind;
        params.push(gp);

        if (parse_match(p, TOKEN_COMMA)) { continue; }
        break;
    }

    parse_consume_generic_gt(p);
    return params;
}

// Parse generic parameter list for structs/impls: <T, U, const N: u64>
func parse_generic_params_any(p: *Parser) -> *Vec<*GenericParam> {
    push_trace("parse_generic_params_any", "parser/decl.b", __LINE__);
    defer pop_trace();
    return parse_generic_params_impl(p, 1);
}

func parse_param(p: *Parser) -> *Param {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(p, generic_params);
    }

    var param: *Param = new Param();
    param.name_ptr = name_tok.ptr;
    param.name_len = name_tok.len;

    if (parse_match(p, TOKEN_COLON)) {
        var ty: *TypeInfo = parse_type_ex(p);
        param.fill_from_typeinfo(ty);
        param.decay_array_to_ptr();
    }

    return param;
}

struct ParsedFuncHeader {
    public name_tok: *Token;
    public generic_params: *Vec<*GenericParam>;
    public params: *Vec<*Param>;
    public ret_type: u64;
    public ret_ptr_depth: u64;
    public ret_is_tagged: u64;
    public ret_struct_name_ptr: u64;
    public ret_struct_name_len: u64;
    public ret_tag_layout_ptr: u64;
    public ret_tag_layout_len: u64;
}

impl ParsedFuncHeader {
    public constructor() {
        self.name_tok = 0;
        self.generic_params = 0;
        self.params = 0;
        self.ret_type = TYPE_VOID;
        self.ret_ptr_depth = 0;
        self.ret_is_tagged = 0;
        self.ret_struct_name_ptr = 0;
        self.ret_struct_name_len = 0;
        self.ret_tag_layout_ptr = 0;
        self.ret_tag_layout_len = 0;
    }
}

func parse_func_header(p: *Parser) -> *ParsedFuncHeader {
    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER && name_kind != TOKEN_NEW && name_kind != TOKEN_DELETE) {
        emit_stderr("[ERROR] Expected function name identifier\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(p, generic_params);
    }

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    var parsed: *ParsedFuncHeader = new ParsedFuncHeader();
    parsed.name_tok = name_tok;
    parsed.generic_params = generic_params;
    parsed.params = params;
    parsed.ret_type = ret_type;
    parsed.ret_ptr_depth = ret_ptr_depth;
    parsed.ret_is_tagged = ret_is_tagged;
    parsed.ret_struct_name_ptr = ret_struct_name_ptr;
    parsed.ret_struct_name_len = ret_struct_name_len;
    parsed.ret_tag_layout_ptr = ret_tag_layout_ptr;
    parsed.ret_tag_layout_len = ret_tag_layout_len;
    return parsed;
}

func parse_func_from_header(parsed: *ParsedFuncHeader, body: *AstNode) -> *AstFunc {
    var name_tok: *Token = parsed.name_tok;
    return ast_func_ex(name_tok.ptr, name_tok.len, parsed.params,
                       parsed.ret_type, parsed.ret_ptr_depth, parsed.ret_is_tagged,
                       parsed.ret_struct_name_ptr, parsed.ret_struct_name_len,
                       parsed.ret_tag_layout_ptr, parsed.ret_tag_layout_len, body);
}

func parse_register_generic_func(p: *Parser, name_tok: *Token, generic_params: *Vec<*GenericParam>, func_node: *AstFunc, is_definition: u64) -> u64 {
    if (generic_params == 0) { return 0; }
    type_parser_clear_generic_params(p);
    if (is_definition != 0) {
        compiler_register_generic_func_def(name_tok.ptr, name_tok.len, generic_params, func_node);
        return 0;
    }
    compiler_register_generic_func_sig(name_tok.ptr, name_tok.len, generic_params, func_node);
    return 0;
}

func parse_func_decl(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl", "parser/decl.b", __LINE__);
    defer pop_trace();

    var parsed: *ParsedFuncHeader = parse_func_header(p);
    var name_tok: *Token = parsed.name_tok;
    var generic_params: *Vec<*GenericParam> = parsed.generic_params;

    var body: *AstNode = parse_block(p);

    var func_node: *AstFunc = parse_func_from_header(parsed, body);
    parse_register_generic_func(p, name_tok, generic_params, func_node, 1);
    return func_node;
}

// Parse function signature only (skip body)
func parse_func_decl_signature(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl_signature", "parser/decl.b", __LINE__);
    defer pop_trace();

    var parsed: *ParsedFuncHeader = parse_func_header(p);
    var name_tok: *Token = parsed.name_tok;
    var generic_params: *Vec<*GenericParam> = parsed.generic_params;
    var is_generic_decl: u64 = 0;
    if (generic_params != 0) { is_generic_decl = 1; }

    // Skip function body
    parse_skip_block(p);

    var func_sig: *AstFunc = parse_func_from_header(parsed, 0);
    parse_register_generic_func(p, name_tok, generic_params, func_sig, 0);
    if (is_generic_decl != 0) { return 0; }
    return func_sig;
}

// Parse abstract function signature (no body, ends with ';')
func parse_func_decl_abst_signature(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl_abst_signature", "parser/decl.b", __LINE__);
    defer pop_trace();

    var parsed: *ParsedFuncHeader = parse_func_header(p);
    var name_tok: *Token = parsed.name_tok;
    var generic_params: *Vec<*GenericParam> = parsed.generic_params;

    parse_consume(p, TOKEN_SEMICOLON);

    var func_sig: *AstFunc = parse_func_from_header(parsed, 0);
    parse_register_generic_func(p, name_tok, generic_params, func_sig, 0);
    return func_sig;
}

// ============================================
// Struct Parsing
// ============================================

func parse_uwidth_from_ident(ptr: u64, len: u64) -> u64 {
    if (len < 2) { return 0; }
    var ptr_u8: *u8 = (*u8)ptr;
    var first: u64 = ptr_u8[0];
    if (first != 117) { return 0; }
    var value: u64 = 0;
    for (var i: u64 = 1; i < len; i++) {
        var c: u64 = ptr_u8[i];
        if (c < 48 || c > 57) { return 0; }
        value = value * 10 + (c - 48);
    }
    return value;
}

struct ParseStructInheritance {
    public parents: *Vec<*ParentDesc>;
    public traits: *Vec<*TraitRef>;
}

func parse_struct_parse_inheritance(p: *Parser, struct_name_ptr: u64, struct_name_len: u64) -> ParseStructInheritance {
    var inheritance: ParseStructInheritance;
    var parents: *Vec<*ParentDesc> = 0;
    var traits: *Vec<*TraitRef> = 0;
    if (parse_match(p, TOKEN_COLON)) {
        parents = new Vec<*ParentDesc>(4);
        while (1) {
            var parent_tok: *Token = parse_peek(p);
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] Expected parent struct name after ':'\n");
                parse_panic_here(p, "Parse error");
            }
            parse_adv(p);
            if (str_eq(parent_tok.ptr, parent_tok.len, struct_name_ptr, struct_name_len)) {
                emit_stderr("[ERROR] Struct cannot inherit from itself\n");
                parse_panic_here(p, "Parse error");
            }
            if (compiler_is_trait_name(parent_tok.ptr, parent_tok.len) != 0) {
                if (traits == 0) { traits = new Vec<*TraitRef>(4); }
                var tref: *TraitRef = new TraitRef();
                tref.name_ptr = parent_tok.ptr;
                tref.name_len = parent_tok.len;
                tref.trait_def = compiler_get_trait_def(parent_tok.ptr, parent_tok.len);
                traits.push(tref);
                if (!parse_match(p, TOKEN_COMMA)) { break; }
                continue;
            }
            var parent_desc: *ParentDesc = new ParentDesc();
            parent_desc.name_ptr = parent_tok.ptr;
            parent_desc.name_len = parent_tok.len;
            parents.push(parent_desc);
            if (!parse_match(p, TOKEN_COMMA)) { break; }
        }
    }
    inheritance.parents = parents;
    inheritance.traits = traits;
    return inheritance;
}

func parse_struct_validate_constraints(p: *Parser, is_packed: u64, parents: *Vec<*ParentDesc>, traits: *Vec<*TraitRef>) -> u64 {
    if (is_packed == 1 && parents != 0 && parents.len() > 0) {
        emit_stderr("[ERROR] packed struct cannot use inheritance\n");
        parse_panic_here(p, "Parse error");
    }
    if (is_packed == 1 && traits != 0 && traits.len() > 0) {
        emit_stderr("[ERROR] packed struct cannot use trait inheritance\n");
        parse_panic_here(p, "Parse error");
    }
    return 0;
}

struct ParsePackedFieldType {
    public type_kind: u64;
    public bit_width: u64;
}

func parse_struct_parse_packed_field_type(p: *Parser) -> ParsePackedFieldType {
    var packed_type: ParsePackedFieldType;
    packed_type.type_kind = 0;
    packed_type.bit_width = 0;
    var k: u64 = parse_peek_kind(p);
    switch (k) {
        case TOKEN_U8:
            parse_adv(p);
            packed_type.type_kind = TYPE_U8;
            packed_type.bit_width = 8;
            break;
        case TOKEN_U16:
            parse_adv(p);
            packed_type.type_kind = TYPE_U16;
            packed_type.bit_width = 16;
            break;
        case TOKEN_U32:
            parse_adv(p);
            packed_type.type_kind = TYPE_U32;
            packed_type.bit_width = 32;
            break;
        case TOKEN_U64:
            parse_adv(p);
            packed_type.type_kind = TYPE_U64;
            packed_type.bit_width = 64;
            break;
        case TOKEN_IDENTIFIER:
            var bw_tok: *Token = parse_peek(p);
            var bw_ptr: u64 = bw_tok.ptr;
            var bw_len: u64 = bw_tok.len;
            parse_adv(p);
            var bw: u64 = parse_uwidth_from_ident(bw_ptr, bw_len);
            if (bw == 0 || bw > 64) {
                emit_stderr("[ERROR] packed field must be u1..u64\n");
                parse_panic_here(p, "Parse error");
            }
            packed_type.type_kind = TYPE_U64;
            packed_type.bit_width = bw;
            break;
        default:
            emit_stderr("[ERROR] packed field must be u1..u64\n");
            parse_panic_here(p, "Parse error");
    }
    return packed_type;
}

func parse_member_access_modifier(p: *Parser, default_access: u64) -> u64 {
    if (parse_peek_kind(p) == TOKEN_PUBLIC) {
        parse_adv(p);
        return ACCESS_PUBLIC;
    }
    if (parse_peek_kind(p) == TOKEN_PRIVATE) {
        parse_adv(p);
        return ACCESS_PRIVATE;
    }
    if (parse_peek_kind(p) == TOKEN_PROTECTED) {
        parse_adv(p);
        return ACCESS_PROTECTED;
    }
    return default_access;
}

func parse_struct_parse_field(p: *Parser, is_packed: u64, struct_name_ptr: u64, struct_name_len: u64) -> *FieldDesc {
    var access: u64 = parse_member_access_modifier(p, ACCESS_PRIVATE);

    var field_name_tok: *Token = parse_peek(p);
    var field_name_ptr: u64 = field_name_tok.ptr;
    var field_name_len: u64 = field_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);
    parse_consume(p, TOKEN_COLON);

    var field_type_kind: u64 = 0;
    var field_ptr_depth: u64 = 0;
    var field_struct_name_ptr: u64 = 0;
    var field_struct_name_len: u64 = 0;
    var field_tag_layout_ptr: u64 = 0;
    var field_tag_layout_len: u64 = 0;
    var field_elem_type_kind: u64 = 0;
    var field_elem_ptr_depth: u64 = 0;
    var field_array_len: u64 = 0;
    var field_is_tagged: u64 = 0;
    var field_bit_width: u64 = 0;

    if (is_packed == 1) {
        var packed_type: ParsePackedFieldType = parse_struct_parse_packed_field_type(p);
        field_type_kind = packed_type.type_kind;
        field_bit_width = packed_type.bit_width;
    } else {
        var field_type: *TypeInfo = parse_type_ex(p);
        field_type_kind = field_type.type_kind;
        field_struct_name_ptr = field_type.struct_name_ptr;
        field_struct_name_len = field_type.struct_name_len;
        field_tag_layout_ptr = field_type.tag_layout_ptr;
        field_tag_layout_len = field_type.tag_layout_len;
        field_ptr_depth = field_type.ptr_depth;
        field_is_tagged = field_type.is_tagged;
        field_elem_type_kind = field_type.elem_type_kind;
        field_elem_ptr_depth = field_type.elem_ptr_depth;
        field_array_len = field_type.array_len;
    }

    parse_consume(p, TOKEN_SEMICOLON);

    var field_desc: *FieldDesc = new FieldDesc();
    field_desc.name_ptr = field_name_ptr;
    field_desc.name_len = field_name_len;
    field_desc.type_kind = field_type_kind;
    field_desc.struct_name_ptr = field_struct_name_ptr;
    field_desc.struct_name_len = field_struct_name_len;
    field_desc.ptr_depth = field_ptr_depth;
    field_desc.is_tagged = field_is_tagged;
    field_desc.tag_layout_ptr = field_tag_layout_ptr;
    field_desc.tag_layout_len = field_tag_layout_len;
    field_desc.bit_width = field_bit_width;
    field_desc.elem_type_kind = field_elem_type_kind;
    field_desc.elem_ptr_depth = field_elem_ptr_depth;
    field_desc.array_len = field_array_len;
    field_desc.access = access;
    field_desc.owner_struct_ptr = struct_name_ptr;
    field_desc.owner_struct_len = struct_name_len;
    return field_desc;
}

func parse_struct_def(p: *Parser) -> *AstStructDef {
    push_trace("parse_struct_def", "parser/decl.b", __LINE__);
    defer pop_trace();
    var is_packed: u64 = 0;
    if (parse_match(p, TOKEN_PACKED)) {
        is_packed = 1;
    }
    parse_consume(p, TOKEN_STRUCT);
    
    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(p, generic_params);
    }

    var inheritance: ParseStructInheritance = parse_struct_parse_inheritance(p, name_ptr, name_len);
    var parents: *Vec<*ParentDesc> = inheritance.parents;
    var traits: *Vec<*TraitRef> = inheritance.traits;
    parse_struct_validate_constraints(p, is_packed, parents, traits);

    parse_consume(p, TOKEN_LBRACE);
    
    var fields: *Vec<*FieldDesc> = new Vec<*FieldDesc>(8);
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        fields.push(parse_struct_parse_field(p, is_packed, name_ptr, name_len));
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    var struct_def: *AstStructDef = ast_struct_def(name_ptr, name_len, parents, fields, is_packed, traits);
    if (generic_params != 0) {
        type_parser_clear_generic_params(p);
        compiler_register_generic_struct_def(name_ptr, name_len, generic_params, struct_def);
    }
    return struct_def;
}

// ============================================
// Enum Parsing
// ============================================

func parse_enum_def(p: *Parser) -> *Vec<*AstConstDecl> {
    parse_consume(p, TOKEN_ENUM);
    
    var enum_name_tok: *Token = parse_peek(p);
    var enum_name_ptr: u64 = enum_name_tok.ptr;
    var enum_name_len: u64 = enum_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_LBRACE);
    
    var consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(16);
    var current_value: u64 = 0;
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        
        var member_tok: *Token = parse_peek(p);
        var member_ptr: u64 = member_tok.ptr;
        var member_len: u64 = member_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);
        
        // Check for explicit value
        if (parse_match(p, TOKEN_EQ)) {
            var val_tok: *Token = parse_peek(p);
            parse_consume(p, TOKEN_NUMBER);
            current_value = parse_num_val(val_tok);
        }
        
        // Create EnumName_MemberName
        var name_info: *NameInfo = module_util_build_joined_name(enum_name_ptr, enum_name_len, member_ptr, member_len);
        var const_node: *AstConstDecl = ast_const_decl(name_info.ptr, name_info.len, current_value);
        consts.push(const_node);
        
        current_value = current_value + 1;
        
        // Optional comma
        if (parse_peek_kind(p) == TOKEN_COMMA) {
            parse_consume(p, TOKEN_COMMA);
        }
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return consts;
}

// ============================================
// Impl Block Parsing
// ============================================

// ============================================
// Trait Parsing
// ============================================

func parse_trait_method_signature(p: *Parser, mode: u64) -> *AstFunc {
    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER) {
        emit_stderr("[ERROR] Expected trait method name identifier\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    var body: *AstNode = 0;
    if (parse_peek_kind(p) == TOKEN_SEMICOLON) {
        parse_adv(p);
    } else if (parse_peek_kind(p) == TOKEN_LBRACE) {
        // parse_program full mode is encoded as 0.
        if (mode == 0) {
            body = parse_block(p);
        } else {
            parse_skip_block(p);
        }
    } else {
        emit_stderr("[ERROR] trait method must end with ';' or method body\n");
        parse_panic_here(p, "Parse error");
    }
    return ast_func_ex(name_tok.ptr, name_tok.len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, body);
}

func parse_trait_def(p: *Parser, mode: u64) -> *TraitDef {
    parse_consume(p, TOKEN_TRAIT);

    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var methods: *Vec<*TraitMethod> = new Vec<*TraitMethod>(8);
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        if (parse_peek_kind(p) != TOKEN_FUNC) {
            emit_stderr("[ERROR] trait block can only contain methods\n");
            parse_panic_here(p, "Parse error");
        }
        var sig: *AstFunc = parse_trait_method_signature(p, mode);
        var tm: *TraitMethod = new TraitMethod();
        tm.name_ptr = sig.name_ptr;
        tm.name_len = sig.name_len;
        tm.sig = sig;
        tm.index = methods.len();
        methods.push(tm);
    }

    parse_consume(p, TOKEN_RBRACE);

    var td: *TraitDef = new TraitDef();
    td.name_ptr = name_ptr;
    td.name_len = name_len;
    td.methods_vec = methods;
    compiler_register_trait_def(td);
    return td;
}

func _make_self_param(struct_name_ptr: u64, struct_name_len: u64) -> *Param {
    var p: *Param = new Param();
    p.set_as_self_param(struct_name_ptr, struct_name_len);
    return p;
}

func parse_constructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_CONSTRUCTOR);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    if (parse_peek_kind(p) == TOKEN_ARROW) {
        emit_stderr("[ERROR] constructor cannot specify return type\n");
        parse_panic_here(p, "Parse error");
    }

    var params_out: *Vec<*Param> = new Vec<*Param>(params.len() + 1);
    params_out.push(_make_self_param(struct_name_ptr, struct_name_len));
    for (var i: u64 = 0; i < params.len(); i++) {
        params_out.push(params.get(i));
    }

    if (sig_only != 0) {
        parse_skip_block(p);
        var sig_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
        compiler_register_generic_func_sig(name_tok.ptr, name_tok.len, 0, sig_node);
        return sig_node;
    }

    var body: *AstNode = parse_block(p);
    var func_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
    compiler_register_generic_func_def(name_tok.ptr, name_tok.len, 0, func_node);
    return func_node;
}

func parse_destructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_DESTRUCTOR);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        parse_adv(p);
        if (parse_peek_kind(p) != TOKEN_RPAREN) {
            emit_stderr("[ERROR] destructor cannot take parameters\n");
            parse_panic_here(p, "Parse error");
        }
        parse_consume(p, TOKEN_RPAREN);
    }

    var params_out: *Vec<*Param> = new Vec<*Param>(1);
    params_out.push(_make_self_param(struct_name_ptr, struct_name_len));

    if (sig_only != 0) {
        parse_skip_block(p);
        return ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
    }

    var body: *AstNode = parse_block(p);
    return ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
}

func parser_mark_impl_method_metadata(struct_name_ptr: u64, struct_name_len: u64, func_node: *AstFunc, method_access: u64) -> u64 {
    if (func_node == 0) { return 0; }
    func_node.impl_owner_ptr = struct_name_ptr;
    func_node.impl_owner_len = struct_name_len;
    func_node.impl_method_access = method_access;
    func_node.impl_original_name_ptr = func_node.name_ptr;
    func_node.impl_original_name_len = func_node.name_len;
    func_node.impl_name_finalized = 0;
    return 0;
}

func parse_impl_parse_func_by_mode(p: *Parser, sig_only: u64) -> *AstFunc {
    if (sig_only != 0) {
        return parse_func_decl_signature(p);
    }
    return parse_func_decl(p);
}

struct ParseImplModifiers {
    public is_static: u64;
    public is_abst: u64;
    public access: u64;
}

func parse_impl_consume_modifiers(p: *Parser) -> ParseImplModifiers {
    var modifiers: ParseImplModifiers;
    modifiers.is_static = 0;
    modifiers.is_abst = 0;
    modifiers.access = ACCESS_PRIVATE;

    var seen_access: u64 = 0;
    while (1) {
        var k: u64 = parse_peek_kind(p);
        if (k == TOKEN_PUBLIC) {
            if (seen_access != 0) {
                emit_stderr("[ERROR] duplicate access modifier\n");
                parse_panic_here(p, "Parse error");
            }
            modifiers.access = ACCESS_PUBLIC;
            seen_access = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_PRIVATE) {
            if (seen_access != 0) {
                emit_stderr("[ERROR] duplicate access modifier\n");
                parse_panic_here(p, "Parse error");
            }
            modifiers.access = ACCESS_PRIVATE;
            seen_access = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_PROTECTED) {
            if (seen_access != 0) {
                emit_stderr("[ERROR] duplicate access modifier\n");
                parse_panic_here(p, "Parse error");
            }
            modifiers.access = ACCESS_PROTECTED;
            seen_access = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_STATIC) {
            if (modifiers.is_static != 0) {
                emit_stderr("[ERROR] duplicate static modifier\n");
                parse_panic_here(p, "Parse error");
            }
            modifiers.is_static = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_ABST) {
            if (modifiers.is_abst != 0) {
                emit_stderr("[ERROR] duplicate abstract modifier\n");
                parse_panic_here(p, "Parse error");
            }
            modifiers.is_abst = 1;
            parse_adv(p);
            continue;
        }
        break;
    }
    if (modifiers.is_static != 0 && modifiers.is_abst != 0) {
        emit_stderr("[ERROR] abstract method cannot be static\n");
        parse_panic_here(p, "Parse error");
    }
    return modifiers;
}

func parse_impl_try_special_method(p: *Parser, sig_only: u64, struct_name_ptr: u64, struct_name_len: u64, is_static: u64, is_abst: u64, method_access: u64, funcs: *Vec<*AstFunc>) -> u64 {
    var kind: u64 = parse_peek_kind(p);
    if (kind == TOKEN_CONSTRUCTOR) {
        if (is_static != 0) {
            emit_stderr("[ERROR] constructor cannot be static\n");
            parse_panic_here(p, "Parse error");
        }
        if (is_abst != 0) {
            emit_stderr("[ERROR] constructor cannot be abstract\n");
            parse_panic_here(p, "Parse error");
        }
        var ctor_node: *AstFunc = parse_constructor_decl(p, struct_name_ptr, struct_name_len, sig_only);
        parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, ctor_node, method_access);
        funcs.push(ctor_node);
        return 1;
    }
    if (kind == TOKEN_DESTRUCTOR) {
        if (is_static != 0) {
            emit_stderr("[ERROR] destructor cannot be static\n");
            parse_panic_here(p, "Parse error");
        }
        if (is_abst != 0) {
            emit_stderr("[ERROR] destructor cannot be abstract\n");
            parse_panic_here(p, "Parse error");
        }
        var dtor_node: *AstFunc = parse_destructor_decl(p, struct_name_ptr, struct_name_len, sig_only);
        parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, dtor_node, method_access);
        funcs.push(dtor_node);
        return 1;
    }
    return 0;
}

func parse_impl_block_impl(p: *Parser, sig_only: u64) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var struct_name_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_name_tok.ptr;
    var struct_name_len: u64 = struct_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        var modifiers: ParseImplModifiers = parse_impl_consume_modifiers(p);
        var is_static: u64 = modifiers.is_static;
        var is_abst: u64 = modifiers.is_abst;
        var method_access: u64 = modifiers.access;
        if (parse_impl_try_special_method(p, sig_only, struct_name_ptr, struct_name_len, is_static, is_abst, method_access, funcs) != 0) {
            continue;
        }

        if (parse_peek_kind(p) == TOKEN_FUNC) {
            if (is_abst != 0) {
                var abst_sig: *AstFunc = parse_func_decl_abst_signature(p);
                compiler_register_abst_method_ex(struct_name_ptr, struct_name_len, abst_sig.name_ptr, abst_sig.name_len, abst_sig, method_access);
                continue;
            }

            var func_node: *AstFunc = parse_impl_parse_func_by_mode(p, sig_only);
            if (func_node == 0) { continue; }

            parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, func_node, method_access);
            funcs.push(func_node);
            continue;
        }

        emit_stderr("[ERROR] impl block can only contain functions\n");
        break;
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();
    return funcs;
}

func parse_impl_block(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_block_impl(p, 0);
}

// Impl block parsing for signature-only pass
func parse_impl_block_signature(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_block_impl(p, 1);
}

func parse_impl_trait_block_impl(p: *Parser, sig_only: u64, register_trait_impl: u64) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var trait_tok: *Token = parse_peek(p);
    var trait_ptr: u64 = trait_tok.ptr;
    var trait_len: u64 = trait_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_FOR);

    var struct_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_tok.ptr;
    var struct_name_len: u64 = struct_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    var impl_methods: *Vec<*TraitImplMethod> = 0;
    if (register_trait_impl != 0) {
        impl_methods = new Vec<*TraitImplMethod>(8);
    }
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        var method_access: u64 = ACCESS_PRIVATE;
        var seen_access: u64 = 0;
        if (parse_peek_kind(p) == TOKEN_PUBLIC) {
            method_access = ACCESS_PUBLIC;
            parse_adv(p);
            seen_access = 1;
        } else if (parse_peek_kind(p) == TOKEN_PRIVATE) {
            method_access = ACCESS_PRIVATE;
            parse_adv(p);
            seen_access = 1;
        } else if (parse_peek_kind(p) == TOKEN_PROTECTED) {
            method_access = ACCESS_PROTECTED;
            parse_adv(p);
            seen_access = 1;
        }
        if (seen_access != 0) {
            if (parse_peek_kind(p) == TOKEN_PUBLIC || parse_peek_kind(p) == TOKEN_PRIVATE || parse_peek_kind(p) == TOKEN_PROTECTED) {
                emit_stderr("[ERROR] duplicate access modifier\n");
                parse_panic_here(p, "Parse error");
            }
        }

        if (parse_peek_kind(p) == TOKEN_STATIC) {
            emit_stderr("[ERROR] trait impl methods cannot be static\n");
            parse_panic_here(p, "Parse error");
        }

        if (parse_peek_kind(p) == TOKEN_ABST) {
            emit_stderr("[ERROR] trait impl methods cannot be abstract\n");
            parse_panic_here(p, "Parse error");
        }

        if (parse_peek_kind(p) != TOKEN_FUNC) {
            emit_stderr("[ERROR] impl Trait for Type block can only contain functions\n");
            parse_panic_here(p, "Parse error");
        }

        var func_node: *AstFunc = parse_impl_parse_func_by_mode(p, sig_only);
        if (func_node == 0) { continue; }

        var original_name_ptr: u64 = func_node.name_ptr;
        var original_name_len: u64 = func_node.name_len;
        parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, func_node, method_access);

        if (register_trait_impl != 0) {
            var impl_method: *TraitImplMethod = new TraitImplMethod();
            impl_method.name_ptr = original_name_ptr;
            impl_method.name_len = original_name_len;
            impl_method.func_def = func_node;
            impl_methods.push(impl_method);
        }

        funcs.push(func_node);
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();

    if (register_trait_impl != 0) {
        var impl_info: *TraitImpl = new TraitImpl();
        impl_info.trait_ptr = trait_ptr;
        impl_info.trait_len = trait_len;
        impl_info.struct_ptr = struct_name_ptr;
        impl_info.struct_len = struct_name_len;
        impl_info.methods_vec = impl_methods;
        impl_info.vtable_struct_def = 0;
        impl_info.vtable_global_ptr = 0;
        impl_info.vtable_global_len = 0;
        compiler_register_trait_impl(impl_info);
    }

    return funcs;
}

func parse_impl_trait_block(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_trait_block_impl(p, 0, 1);
}

func parse_impl_trait_block_signature(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_trait_block_impl(p, 1, 0);
}

// ============================================
// Program Parsing (Entry Point)
// ============================================

const PARSE_PROGRAM_MODE_FULL = 0;
const PARSE_PROGRAM_MODE_SIGNATURE = 1;

func parse_report_unexpected_top_level(p: *Parser) -> u64 {
    var err_tok: *Token = parse_peek(p);
    var err_ptr: u64 = err_tok.ptr;
    var err_len: u64 = err_tok.len;
    emit_stderr("[ERROR] Expected function, const, or import. Got token kind=");
    print_u64(parse_peek_kind(p));
    emit_stderr(" text=");
    emit_stderr_len(err_ptr, err_len);
    emit_stderr("\n");
    parse_adv(p);
    return 0;
}

func parse_skip_until_semicolon(p: *Parser) -> u64 {
    while (parse_peek_kind(p) != TOKEN_SEMICOLON && parse_peek_kind(p) != TOKEN_EOF) {
        parse_adv(p);
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return 0;
}

func parse_skip_const_decl_signature(p: *Parser) -> u64 {
    parse_consume(p, TOKEN_CONST);
    parse_consume(p, TOKEN_IDENTIFIER);
    if (parse_match(p, TOKEN_EQ)) {
        parse_skip_until_semicolon(p);
        return 0;
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return 0;
}

func parse_skip_global_var_decl_signature(p: *Parser) -> u64 {
    parse_consume(p, TOKEN_VAR);
    parse_consume(p, TOKEN_IDENTIFIER);
    if (parse_match(p, TOKEN_COLON)) {
        parse_type_ex(p);
    }
    if (parse_match(p, TOKEN_EQ)) {
        parse_skip_until_semicolon(p);
        return 0;
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return 0;
}

func parse_append_impl_funcs(dst: *Vec<*AstFunc>, src: *Vec<*AstFunc>, mode: u64) -> u64 {
    var num_impl_funcs: u64 = src.len();
    for (var i: u64 = 0; i < num_impl_funcs; i++) {
        var impl_fn: *AstFunc = src.get(i);
        if (mode == PARSE_PROGRAM_MODE_SIGNATURE && impl_fn == 0) { continue; }
        dst.push(impl_fn);
    }
    return 0;
}

func parse_global_var_decl_full(p: *Parser, globals: *Vec<*GlobalInfo>) -> u64 {
    parse_consume(p, TOKEN_VAR);
    var tok: *Token = parse_peek(p);

    parse_consume(p, TOKEN_IDENTIFIER);
    var gtype: *TypeInfo = 0;
    if (parse_match(p, TOKEN_COLON)) {
        gtype = parse_type_ex(p);
    } else {
        gtype = new TypeInfo(TYPE_U64, 0);
    }

    var init_kind: u64 = GLOBAL_INIT_NONE;
    var init_expr: *AstNode = 0;

    if (parse_match(p, TOKEN_EQ)) {
        init_expr = parse_expr(p);
        if (init_expr == 0) {
            emit_stderr("[ERROR] Global init expression missing\n");
            parse_panic_here(p, "Parse error");
        }
        init_kind = GLOBAL_INIT_EXPR;
    }

    parse_consume(p, TOKEN_SEMICOLON);

    var ginfo: *GlobalInfo = new GlobalInfo();
    ginfo.name_ptr = tok.ptr;
    ginfo.name_len = tok.len;
    ginfo.typeinfo_ptr = gtype;
    ginfo.init_kind = init_kind;
    ginfo.init_value = 0;
    ginfo.init_name_ptr = 0;
    ginfo.init_name_len = 0;
    ginfo.init_expr = (u64)init_expr;
    globals.push(ginfo);
    return 0;
}

func parse_program_handle_func(p: *Parser, mode: u64, funcs: *Vec<*AstFunc>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        var fn_ptr: *AstFunc = parse_func_decl(p);
        if (fn_ptr != 0) { funcs.push(fn_ptr); }
        return 0;
    }
    var sig_ptr: *AstFunc = parse_func_decl_signature(p);
    if (sig_ptr != 0) { funcs.push(sig_ptr); }
    return 0;
}

func parse_program_handle_const(p: *Parser, mode: u64, consts: *Vec<*AstConstDecl>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        var cdecl: *AstConstDecl = parse_const_decl(p);
        consts.push(cdecl);
        return 0;
    }
    parse_skip_const_decl_signature(p);
    return 0;
}

func parse_program_handle_enum(p: *Parser, mode: u64, consts: *Vec<*AstConstDecl>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        var enum_consts: *Vec<*AstConstDecl> = parse_enum_def(p);
        var num_enum_consts: u64 = enum_consts.len();
        for (var i: u64 = 0; i < num_enum_consts; i++) {
            var enum_cdecl: *AstConstDecl = enum_consts.get(i);
            consts.push(enum_cdecl);
        }
        return 0;
    }
    parse_consume(p, TOKEN_ENUM);
    parse_consume(p, TOKEN_IDENTIFIER);
    parse_skip_block(p);
    return 0;
}

func parse_program_handle_struct(p: *Parser, mode: u64, structs: *Vec<*AstStructDef>) -> u64 {
    var struct_def: *AstStructDef = parse_struct_def(p);
    if (mode != PARSE_PROGRAM_MODE_FULL) { return 0; }
    if (compiler_is_generic_struct_def(struct_def) == 0) {
        structs.push(struct_def);
    }
    register_struct_type(struct_def);
    return 0;
}

func parse_program_handle_impl(p: *Parser, mode: u64, funcs: *Vec<*AstFunc>) -> u64 {
    var impl_funcs: *Vec<*AstFunc> = 0;
    if (parse_is_impl_trait_block(p) != 0) {
        if (mode == PARSE_PROGRAM_MODE_FULL) {
            impl_funcs = parse_impl_trait_block(p);
        } else {
            impl_funcs = parse_impl_trait_block_signature(p);
        }
    } else {
        if (mode == PARSE_PROGRAM_MODE_FULL) {
            impl_funcs = parse_impl_block(p);
        } else {
            impl_funcs = parse_impl_block_signature(p);
        }
    }
    parse_append_impl_funcs(funcs, impl_funcs, mode);
    return 0;
}

func parse_program_handle_global(p: *Parser, mode: u64, globals: *Vec<*GlobalInfo>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        parse_global_var_decl_full(p, globals);
        return 0;
    }
    parse_skip_global_var_decl_signature(p);
    return 0;
}

func parse_program_impl(p: *Parser, mode: u64) -> *AstProgram {
    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(16);
    var consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(1);
    var imports: *Vec<*AstImport> = new Vec<*AstImport>(16);
    var globals: *Vec<*GlobalInfo> = 0;
    var structs: *Vec<*AstStructDef> = 0;

    if (mode == PARSE_PROGRAM_MODE_FULL) {
        consts = new Vec<*AstConstDecl>(64);
        globals = new Vec<*GlobalInfo>(32);
        structs = new Vec<*AstStructDef>(16);
    }

    while (parse_peek_kind(p) != TOKEN_EOF) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_FUNC:
                parse_program_handle_func(p, mode, funcs);
                break;
            case TOKEN_CONST:
                parse_program_handle_const(p, mode, consts);
                break;
            case TOKEN_ENUM:
                parse_program_handle_enum(p, mode, consts);
                break;
            case TOKEN_STRUCT:
            case TOKEN_PACKED:
                parse_program_handle_struct(p, mode, structs);
                break;
            case TOKEN_TRAIT:
                parse_trait_def(p, mode);
                break;
            case TOKEN_IMPL:
                parse_program_handle_impl(p, mode, funcs);
                break;
            case TOKEN_VAR:
                parse_program_handle_global(p, mode, globals);
                break;
            case TOKEN_IMPORT:
                imports.push(parse_import_decl(p));
                break;
            default:
                parse_report_unexpected_top_level(p);
                break;
        }
    }

    var prog: *AstProgram = ast_program(funcs, consts, imports);
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        prog.globals_vec = globals;
        prog.structs_vec = structs;
    }
    return prog;
}

func parse_program(p: *Parser) -> *AstProgram {
    push_trace("parse_program", "parser/decl.b", __LINE__);
    defer pop_trace();
    return parse_program_impl(p, PARSE_PROGRAM_MODE_FULL);
}

// ============================================
// Program Parsing (Signature Pass)
// ============================================

func parse_program_pass1(p: *Parser) -> *AstProgram {
    push_trace("parse_program_pass1", "parser/decl.b", __LINE__);
    defer pop_trace();
    return parse_program_impl(p, PARSE_PROGRAM_MODE_SIGNATURE);
}

// ============================================
// Program Parsing (Imports Only)
// ============================================

func parse_program_imports_only(p: *Parser) -> *Vec<*AstImport> {
    push_trace("parse_program_imports_only", "parser/decl.b", __LINE__);
    defer pop_trace();

    var imports: *Vec<*AstImport> = new Vec<*AstImport>(8);
    while (parse_peek_kind(p) != TOKEN_EOF) {
        if (parse_peek_kind(p) == TOKEN_IMPORT) {
            imports.push(parse_import_decl(p));
        } else {
            parse_adv(p);
        }
    }

    return imports;
}
