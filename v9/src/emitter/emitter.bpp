// emitter.b - ASM output helpers, labels, string/data tables, global state
//
// This module contains:
// - Global codegen state (symtab, label counter, strings, loops, etc.)
// - Label generation and emission
// - String literal table management
// - Global variable BSS emission
// - Constant lookup

import std.io;
import std.vec;
import std.util;
import std.str;
import std.hashmap;
import types;
import ast;
import compiler;
import emitter.typeinfo;
import emitter.symtab;

// ============================================
// Global Codegen State
// ============================================

var g_symtab: *Symtab;                       // Symbol table for current function
var g_label_counter;                // Label counter for unique labels
var g_consts: *Vec<*ConstInfo>;                // Global constants table
var g_consts_map: *HashMap<u64, *ConstInfo>;   // Const lookup cache: name -> const info
var g_strings: *Vec<*StringEntry>;             // String literals table
var g_strings_map: *HashMap<u64, *StringEntry>; // String dedup cache: literal -> entry
var g_floats: *Vec<*FloatEntry>;               // Float literals table
var g_loop_labels: *Vec<u64>;                  // Stack of loop end labels for break
var g_loop_continue_labels: *Vec<u64>;         // Stack of loop continue labels
var g_globals: *Vec<*GlobalInfo>;              // Global variables list
var g_globals_map: *HashMap<u64, *GlobalInfo>; // Global lookup cache: name -> global info
var g_defer_stack: *Vec<*AstNode>;              // Stack of deferred statements
var g_defer_markers: *Vec<u64>;                 // Block scope markers for defer
var g_defer_loop_markers: *Vec<u64>;            // Loop/switch scope markers for defer

// Current function return type information (for struct return)
var g_current_func_ret_type;
var g_current_func_ret_ptr_depth;
var g_current_func_ret_struct_name_ptr;
var g_current_func_ret_struct_name_len;

// ============================================
// State Accessors
// ============================================

func emitter_get_symtab() -> *Symtab { return g_symtab; }
func emitter_set_symtab(s: *Symtab) -> u64 { g_symtab = s; }

func emitter_get_globals() -> *Vec<*GlobalInfo> { return g_globals; }
func emitter_set_globals(g: *Vec<*GlobalInfo>) -> u64 {
    g_globals = g;
    emitter_rebuild_globals_map();
    return 0;
}

func emitter_get_consts() -> *Vec<*ConstInfo> { return g_consts; }
func emitter_set_consts(c: *Vec<*ConstInfo>) -> u64 {
    g_consts = c;
    emitter_rebuild_consts_map();
    return 0;
}

func emitter_get_loop_labels() -> *Vec<u64> { return g_loop_labels; }
func emitter_get_continue_labels() -> *Vec<u64> { return g_loop_continue_labels; }
func emitter_get_defer_stack() -> *Vec<*AstNode> { return g_defer_stack; }
func emitter_get_defer_markers() -> *Vec<u64> { return g_defer_markers; }
func emitter_get_defer_loop_markers() -> *Vec<u64> { return g_defer_loop_markers; }

func emitter_set_ret_type(t: u64) -> u64 { g_current_func_ret_type = t; }
func emitter_set_ret_ptr_depth(d: u64) -> u64 { g_current_func_ret_ptr_depth = d; }
func emitter_set_ret_struct_name(ptr: u64, len: u64) -> u64 {
    g_current_func_ret_struct_name_ptr = ptr;
    g_current_func_ret_struct_name_len = len;
}

func emitter_get_ret_type() -> u64 { return g_current_func_ret_type; }
func emitter_get_ret_ptr_depth() -> u64 { return g_current_func_ret_ptr_depth; }
func emitter_get_ret_struct_name_ptr() -> u64 { return g_current_func_ret_struct_name_ptr; }
func emitter_get_ret_struct_name_len() -> u64 { return g_current_func_ret_struct_name_len; }

// ============================================
// Initialization
// ============================================

func emitter_init() -> u64 {
    // Create symtab via helper for consistent initialization
    // symtab = [names_vec, offsets_vec, types_vec, count, stack_offset]
    g_symtab = symtab_new();
    var symtab: *Symtab = g_symtab;
    symtab.stack_offset = -8;
    
    g_label_counter = 0;
    g_strings = new Vec<*StringEntry>(32);
    g_strings_map = new HashMap<u64, *StringEntry>(64);
    g_floats = new Vec<*FloatEntry>(32);
    g_loop_labels = new Vec<u64>(16);
    g_loop_continue_labels = new Vec<u64>(16);
    g_consts = new Vec<*ConstInfo>(64);
    g_consts_map = new HashMap<u64, *ConstInfo>(128);
    g_globals_map = new HashMap<u64, *GlobalInfo>(128);
    g_defer_stack = new Vec<*AstNode>(32);
    g_defer_markers = new Vec<u64>(32);
    g_defer_loop_markers = new Vec<u64>(16);
}

func emitter_rebuild_globals_map() -> u64 {
    var cap: u64 = 16;
    if (g_globals != 0 && g_globals.len() > 0) {
        cap = g_globals.len() * 2;
        if (cap < 16) { cap = 16; }
    }
    g_globals_map = new HashMap<u64, *GlobalInfo>(cap);
    if (g_globals == 0) { return 0; }

    var len: u64 = g_globals.len();
    for (var i: u64 = 0; i < len; i++) {
        var ginfo: *GlobalInfo = g_globals.get(i);
        if (ginfo == 0) { continue; }
        g_globals_map.put(ginfo.name_ptr, ginfo.name_len, ginfo);
    }
    return 0;
}

func emitter_rebuild_consts_map() -> u64 {
    var cap: u64 = 16;
    if (g_consts != 0 && g_consts.len() > 0) {
        cap = g_consts.len() * 2;
        if (cap < 16) { cap = 16; }
    }
    g_consts_map = new HashMap<u64, *ConstInfo>(cap);
    if (g_consts == 0) { return 0; }

    var len: u64 = g_consts.len();
    for (var i: u64 = 0; i < len; i++) {
        var cinfo: *ConstInfo = g_consts.get(i);
        if (cinfo == 0) { continue; }
        g_consts_map.put(cinfo.name_ptr, cinfo.name_len, cinfo);
    }
    return 0;
}

func emitter_set_globals_from_prog(globals: *Vec<*GlobalInfo>) -> u64 {
    if (globals == 0) {
        g_globals = new Vec<*GlobalInfo>(32);
    } else {
        g_globals = globals;
    }
    emitter_rebuild_globals_map();
    return 0;
}

func emitter_load_consts(consts: *Vec<*AstConstDecl>) -> u64 {
    g_consts = new Vec<*ConstInfo>(64);
    g_consts_map = new HashMap<u64, *ConstInfo>(128);
    if (consts == 0) { return 0; }

    var clen: u64 = consts.len();
    for (var ci: u64 = 0; ci < clen; ci++) {
        var const_decl: *AstConstDecl = consts.get(ci);
        var cinfo_struct: *ConstInfo = new ConstInfo{const_decl.name_ptr, const_decl.name_len, const_decl.value};
        g_consts.push(cinfo_struct);
        g_consts_map.put(const_decl.name_ptr, const_decl.name_len, cinfo_struct);
    }
    return 0;
}

// ============================================
// Global Variable Check
// ============================================

func is_global_var(name_ptr: u64, name_len: u64) -> u64 {
    if (g_globals_map != 0) {
        var gm: *GlobalInfo = g_globals_map.get(name_ptr, name_len);
        if (gm != 0) { return true; }
        return false;
    }

    var len: u64 = g_globals.len();
    for (var i: u64 = 0; i < len; i++) {
        var ginfo: *GlobalInfo = g_globals.get(i);
        if (str_eq(ginfo.name_ptr, ginfo.name_len, name_ptr, name_len)) {
            return true;
        }
    }
    return false;
}

// ============================================
// ASM Alias Emission
// ============================================

func emit_asm_text_with_alias(text_vec: *Vec<u64>) -> u64 {
    var asm_len: u64 = text_vec.?len();
    var i: u64 = 0;
    var at_line_start: u64 = 1;

    while (i < asm_len) {
        var ch: u64 = text_vec.get(i);
        if (ch == 10) {
            emit_nl();
            at_line_start = 1;
            i = i + 1;
            continue;
        }
        if (ch == 32) {
            if (at_line_start == 1) {
                emit("    ");
                at_line_start = 0;
            }
            emit_char(ch);
            i = i + 1;
            continue;
        }

        var tok_start: u64 = i;
        while (i < asm_len) {
            var ch2: u64 = text_vec.get(i);
            if (ch2 == 10 || ch2 == 32) { break; }
            i = i + 1;
        }
        var tok_len: u64 = i - tok_start;
        if (tok_len == 0) { continue; }

        if (at_line_start == 1) {
            emit("    ");
            at_line_start = 0;
        }

        var tok_ptr: u64 = heap_alloc((tok_len + 1) * sizeof(u8));
        var tok_u8: []u8 = slice(tok_ptr, tok_len + 1);
        for (var j: u64 = 0; j < tok_len; j++) {
            tok_u8[j] = (u8)text_vec.get(tok_start + j);
        }
        tok_u8[tok_len] = 0;

        var alias_info_ptr: *NameInfo = compiler_reg_alias_get(tok_ptr, tok_len);
        if (alias_info_ptr != 0) {
            emit_len(alias_info_ptr.ptr, alias_info_ptr.len);
        } else {
            emit_len(tok_ptr, tok_len);
        }
    }

    emit_nl();
    return 0;
}

// ============================================
// Constants Lookup
// ============================================

func const_find(name_ptr: u64, name_len: u64) -> ConstResult {
    if (g_consts_map != 0) {
        var cached: *ConstInfo = g_consts_map.get(name_ptr, name_len);
        if (cached != 0) {
            return ConstResult{1, cached.value};
        }
        return ConstResult{0, 0};
    }

    var len: u64 = g_consts.len();
    for (var i: u64 = 0; i < len; i++) {
        var cinfo: *ConstInfo = g_consts.get(i);
        if (str_eq(cinfo.name_ptr, cinfo.name_len, name_ptr, name_len)) {
            return ConstResult{1, cinfo.value};
        }
    }
    return ConstResult{0, 0};
}

// ============================================
// Labels
// ============================================

func new_label() -> u64 {
    var l: u64 = g_label_counter;
    g_label_counter = g_label_counter + 1;
    return l;
}

func emit_label(n: u64) -> u64 {
    emit(".L");
    emit_u64(n);
}

func emit_label_def(n: u64) -> u64 {
    emit_label(n);
    emit(":");
    emit_nl();
}

func emit_signed_disp(disp: u64) -> u64 {
    var disp_i64: i64 = (i64)disp;
    if (disp_i64 < 0) {
        emit_i64(disp_i64);
    } else {
        emit("+");
        emit_u64(disp);
    }
    return 0;
}

func emit_load_rax_from_addr(type_kind: u64, ptr_depth: u64) -> u64 {
    if (type_kind == TYPE_ARRAY) { return 0; }
    if (type_kind == TYPE_SLICE) {
        emit("    mov rax, [rax]\n");
        return 1;
    }
    if (ptr_depth == 0) {
        if (type_kind == TYPE_U8) {
            emit("    movzx rax, byte [rax]\n");
            return 1;
        }
        if (type_kind == TYPE_U16) {
            emit("    movzx rax, word [rax]\n");
            return 1;
        }
        if (type_kind == TYPE_U32) {
            emit("    mov eax, [rax]\n");
            return 1;
        }
    }
    emit("    mov rax, [rax]\n");
    return 1;
}

func emit_store_rbx_to_addr(type_kind: u64, ptr_depth: u64) -> u64 {
    if (ptr_depth == 0) {
        if (type_kind == TYPE_U8) {
            emit("    mov [rax], bl\n");
            return 1;
        }
        if (type_kind == TYPE_U16) {
            emit("    mov [rax], bx\n");
            return 1;
        }
        if (type_kind == TYPE_U32) {
            emit("    mov [rax], ebx\n");
            return 1;
        }
    }
    emit("    mov [rax], rbx\n");
    return 1;
}

func emit_store_rax_to_addr(type_kind: u64, ptr_depth: u64) -> u64 {
    if (ptr_depth == 0) {
        if (type_kind == TYPE_U8) {
            emit("    mov [rax], al\n");
            return 1;
        }
        if (type_kind == TYPE_U16) {
            emit("    mov [rax], ax\n");
            return 1;
        }
        if (type_kind == TYPE_U32) {
            emit("    mov [rax], eax\n");
            return 1;
        }
    }
    emit("    mov [rax], rax\n");
    return 1;
}

func emit_copy_bytes_with_regs(src_reg_ptr: u64, src_reg_len: u64, dst_reg_ptr: u64, dst_reg_len: u64, size: u64) -> u64 {
    var off: u64 = 0;
    while (off + 8 <= size) {
        emit("    mov rcx, [");
        emit_len(src_reg_ptr, src_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("]\n");
        emit("    mov [");
        emit_len(dst_reg_ptr, dst_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("], rcx\n");
        off = off + 8;
    }
    var rem: u64 = size - off;
    if (rem >= 4) {
        emit("    mov ecx, [");
        emit_len(src_reg_ptr, src_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("]\n");
        emit("    mov [");
        emit_len(dst_reg_ptr, dst_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("], ecx\n");
        off = off + 4;
        rem = rem - 4;
    }
    if (rem >= 2) {
        emit("    mov cx, [");
        emit_len(src_reg_ptr, src_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("]\n");
        emit("    mov [");
        emit_len(dst_reg_ptr, dst_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("], cx\n");
        off = off + 2;
        rem = rem - 2;
    }
    if (rem >= 1) {
        emit("    mov cl, [");
        emit_len(src_reg_ptr, src_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("]\n");
        emit("    mov [");
        emit_len(dst_reg_ptr, dst_reg_len);
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("], cl\n");
    }
    return 0;
}

// ============================================
// String Literals Table
// ============================================

func string_table_init() -> u64 {
    g_strings = new Vec<*StringEntry>(32);
    g_strings_map = new HashMap<u64, *StringEntry>(64);
    return 0;
}

func string_get_label(str_ptr: u64, str_len: u64) -> u64 {
    if (g_strings_map == 0) {
        g_strings_map = new HashMap<u64, *StringEntry>(64);
    }
    var cached: *StringEntry = g_strings_map.get(str_ptr, str_len);
    if (cached != 0) {
        return cached.label_id;
    }
    
    var label_id: u64 = g_label_counter;
    g_label_counter = g_label_counter + 1;
    
    var str_entry: *StringEntry = new StringEntry{str_ptr, str_len, label_id};
    g_strings.push(str_entry);
    g_strings_map.put(str_ptr, str_len, str_entry);
    
    return label_id;
}

func string_emit_data() -> u64 {
    var count: u64 = g_strings.len();
    
    if (count == 0) { return; }
    
    emitln("\nsection .data");
    
    for (var i: u64 = 0; i < count; i++) {
        var str_entry: *StringEntry = g_strings.get(i);
        var str_ptr: u64 = str_entry.str_ptr;
        var str_len: u64 = str_entry.str_len;
        var label_id: u64 = str_entry.label_id;
        var str_u8: []u8 = slice(str_ptr, str_len);
        
        emit("_str");
        emit_u64(label_id);
        emit(": db ");
        
        for (var j: u64 = 1; j < str_len - 1; ) {
            var c: u64 = str_u8[j];
            
            if (c == 92) {  // backslash
                j = j + 1;
                if (j < str_len - 1) {
                    var ec: u64 = str_u8[j];
                    if (ec == 110) { emit("10"); }       // \n
                    else if (ec == 116) { emit("9"); }   // \t
                    else if (ec == 48) { emit("0"); }    // \0
                    else if (ec == 92) { emit("92"); }   // \\
                    else if (ec == 34) { emit("34"); }   // \"
                    else { emit_u64(ec); }
                }
            } else {
                emit_u64(c);
            }

            j = j + 1;
            if (j < str_len - 1) { emit(","); }
        }
        
        emitln(",0");
    }
}

// ============================================
// Float Literals Table
// ============================================

func float_get_label(str_ptr: u64, str_len: u64) -> u64 {
    var count: u64 = g_floats.len();
    for (var i: u64 = 0; i < count; i++) {
        var entry: *FloatEntry = g_floats.get(i);
        if (str_eq(entry.str_ptr, entry.str_len, str_ptr, str_len)) {
            return entry.label_id;
        }
    }

    var label_id: u64 = g_label_counter;
    g_label_counter = g_label_counter + 1;

    var fe: *FloatEntry = new FloatEntry{str_ptr, str_len, label_id};
    g_floats.push(fe);
    return label_id;
}

func float_emit_data() -> u64 {
    var count: u64 = g_floats.len();
    if (count == 0) { return; }

    emitln("\nsection .data");
    for (var i: u64 = 0; i < count; i++) {
        var entry: *FloatEntry = g_floats.get(i);
        emit("_flt");
        emit_u64(entry.label_id);
        emit(": dq ");
        emit_len(entry.str_ptr, entry.str_len);
        emit_nl();
    }
}

// ============================================
// Global Variables Data/BSS Emission
// ============================================

func _global_eval_const_value(name_ptr: u64, name_len: u64, out_value: *u64) -> u64 {
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    if (resolved_len > 6 && str_eq(resolved_ptr, 6, "_gvar_", 6)) {
        resolved_ptr = resolved_ptr + 6;
        resolved_len = resolved_len - 6;
    }
    var resolved: *NameInfo = resolve_name(resolved_ptr, resolved_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    var res: ConstResult = const_find(resolved_ptr, resolved_len);
    if (res.found != 0) {
        *(*u64)out_value = res.value;
        return true;
    }

    var res2: ConstResult = const_find(name_ptr, name_len);
    if (res2.found != 0) {
        *(*u64)out_value = res2.value;
        return true;
    }

    // Fallback: try unqualified name match for mangled consts (prefix__NAME)
    // Only accept a single unique match. Multiple matches are ambiguous.
    if (g_consts != 0) {
        var matched: u64 = 0;
        var matched_value: u64 = 0;
        var matched_name_ptr: u64 = 0;
        var matched_name_len: u64 = 0;
        var n: u64 = g_consts.len();
        for (var i: u64 = 0; i < n; i++) {
            var cinfo: *ConstInfo = g_consts.get(i);
            if (cinfo.name_len <= name_len + 2) { continue; }
            var suffix_pos: u64 = cinfo.name_len - name_len;
            var name_u8: []u8 = slice(cinfo.name_ptr, cinfo.name_len);
            if (name_u8[suffix_pos - 2] != 95 || name_u8[suffix_pos - 1] != 95) { continue; }
            if (str_eq(cinfo.name_ptr + suffix_pos, name_len, name_ptr, name_len)) {
                if (matched == 0) {
                    matched = 1;
                    matched_value = cinfo.value;
                    matched_name_ptr = cinfo.name_ptr;
                    matched_name_len = cinfo.name_len;
                    continue;
                }
                emit_stderr("[ERROR] Ambiguous global const init fallback for name: ");
                emit_stderr_len(name_ptr, name_len);
                emit_stderr("\n");
                emit_stderr("  candidate1: ");
                emit_stderr_len(matched_name_ptr, matched_name_len);
                emit_stderr("\n");
                emit_stderr("  candidate2: ");
                emit_stderr_len(cinfo.name_ptr, cinfo.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }
        }
        if (matched != 0) {
            *(*u64)out_value = matched_value;
            return true;
        }
    }
    return false;
}

func _global_eval_scalar_expr(expr: *AstNode, out_value: *u64) -> u64 {
    if (expr == 0) { return false; }
    var kind: u64 = ast_kind(expr);
    if (kind == AST_LITERAL) {
        var lit: *AstLiteral = (*AstLiteral)expr;
        *(*u64)out_value = lit.value;
        return true;
    }
    if (kind == AST_IDENT) {
        var id: *AstIdent = (*AstIdent)expr;
        return _global_eval_const_value(id.name_ptr, id.name_len, out_value);
    }
    if (kind == AST_UNARY) {
        var un: *AstUnary = (*AstUnary)expr;
        if (un.op == TOKEN_MINUS) {
            var inner_value: u64 = 0;
            if (_global_eval_scalar_expr(un.operand, &inner_value) == 0) { return false; }
            *(*u64)out_value = 0 - inner_value;
            return true;
        }
    }
    return false;
}

func _global_emit_padding(pad: u64) -> u64 {
    if (pad == 0) { return 0; }
    emit("    times ");
    emit_u64(pad);
    emit(" db 0");
    emit_nl();
    return 0;
}

func _global_emit_scalar_value(size: u64, value: u64) -> u64 {
    if (size == 1) {
        emit("    db ");
        emit_u64(value & 255);
        emit_nl();
        return 0;
    }
    if (size == 2) {
        emit("    dw ");
        emit_u64(value & 65535);
        emit_nl();
        return 0;
    }
    if (size == 4) {
        emit("    dd ");
        emit_u64(value & 4294967295);
        emit_nl();
        return 0;
    }
    if (size == 8) {
        emit("    dq ");
        emit_u64(value);
        emit_nl();
        return 0;
    }
    emit_stderr("[ERROR] Unsupported global init size\n");
    panic("Parse error");
}

func _global_emit_struct_literal_label(ginfo: *GlobalInfo) -> u64 {
    emit("_gvar_");
    emit_len(ginfo.name_ptr, ginfo.name_len);
    emit(":");
    emit_nl();
    return 0;
}

func _global_emit_struct_literal_field_size_or_panic(f: *FieldDesc) -> u64 {
    if (f.type_kind == TYPE_STRUCT && f.ptr_depth == 0) {
        emit_stderr("[ERROR] Nested struct init not supported\n");
        panic("Parse error");
    }
    if (f.type_kind == TYPE_ARRAY || f.type_kind == TYPE_SLICE) {
        emit_stderr("[ERROR] Array/slice struct init not supported\n");
        panic("Parse error");
    }
    var field_size: u64 = sizeof_field_desc(f);
    if (field_size == 0) {
        emit_stderr("[ERROR] Global struct field size invalid\n");
        panic("Parse error");
    }
    return field_size;
}

func _global_emit_struct_literal_vptr_or_panic(struct_def: *AstStructDef, f: *FieldDesc) -> u64 {
    var impls: *Vec<*TraitImpl> = compiler_get_trait_impls();
    if (impls == 0) {
        emit_stderr("[ERROR] Trait impl list missing for global vptr init\n");
        panic("Parse error");
    }
    var found_impl: u64 = 0;
    var impl_count: u64 = impls.len();
    for (var ti: u64 = 0; ti < impl_count; ti++) {
        var impl_info: *TraitImpl = impls.get(ti);
        if (!str_eq(impl_info.struct_ptr, impl_info.struct_len, struct_def.name_ptr, struct_def.name_len)) { continue; }
        var vptr_name: *NameInfo = compiler_build_vptr_field_name(impl_info.trait_ptr, impl_info.trait_len);
        if (!str_eq(vptr_name.ptr, vptr_name.len, f.name_ptr, f.name_len)) { continue; }
        emit("    dq _gvar_");
        emit_len(impl_info.vtable_global_ptr, impl_info.vtable_global_len);
        emit_nl();
        found_impl = 1;
        break;
    }
    if (found_impl == 0) {
        emit_stderr("[ERROR] Trait impl not found for global vptr init\n");
        panic("Parse error");
    }
    return 0;
}

func _global_emit_struct_literal_value_or_panic(field_size: u64, val_expr: *AstNode) -> u64 {
    var val_kind: u64 = ast_kind(val_expr);
    if (val_kind == AST_IDENT && field_size == 8) {
        var id: *AstIdent = (*AstIdent)val_expr;
        var resolved_ptr: u64 = id.name_ptr;
        var resolved_len: u64 = id.name_len;
        var resolved: *NameInfo = resolve_name(id.name_ptr, id.name_len);
        if (resolved != 0) {
            resolved_ptr = resolved.ptr;
            resolved_len = resolved.len;
        }
        if (compiler_func_exists(resolved_ptr, resolved_len) != 0 || compiler_func_exists(id.name_ptr, id.name_len) != 0) {
            emit("    dq ");
            emit_len(resolved_ptr, resolved_len);
            emit_nl();
            return 0;
        }
    }
    var value: u64 = 0;
    if (_global_eval_scalar_expr(val_expr, &value) == 0) {
        emit_stderr("[ERROR] Unsupported global struct literal value\n");
        panic("Parse error");
    }
    _global_emit_scalar_value(field_size, value);
    return 0;
}

func _global_emit_struct_literal(ginfo: *GlobalInfo, lit: *AstStructLiteral) -> u64 {
    var struct_def: *AstStructDef = lit.struct_def;
    if (struct_def == 0 && ginfo.typeinfo_ptr != 0) {
        struct_def = get_struct_def(ginfo.typeinfo_ptr.struct_name_ptr, ginfo.typeinfo_ptr.struct_name_len);
    }
    if (struct_def == 0) {
        emit_stderr("[ERROR] Missing struct def for global init\n");
        panic("Parse error");
    }

    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var values: *Vec<*AstNode> = lit.values_vec;
    if (fields == 0 || values == 0) {
        emit_stderr("[ERROR] Global struct literal missing fields\n");
        panic("Parse error");
    }
    var fn: u64 = fields.len();
    var vn: u64 = values.len();

    _global_emit_struct_literal_label(ginfo);

    var cursor: u64 = 0;
    var value_index: u64 = 0;
    for (var i: u64 = 0; i < fn; i++) {
        var f: *FieldDesc = fields.get(i);
        var field_size: u64 = _global_emit_struct_literal_field_size_or_panic(f);

        if (compiler_is_vptr_field_name(f.name_ptr, f.name_len) != 0) {
            _global_emit_struct_literal_vptr_or_panic(struct_def, f);
            cursor = cursor + field_size;
            continue;
        }

        if (value_index >= vn) { break; }
        var val_expr: *AstNode = values.get(value_index);
        _global_emit_struct_literal_value_or_panic(field_size, val_expr);
        cursor = cursor + field_size;
        value_index = value_index + 1;
    }

    if (ginfo.typeinfo_ptr != 0) {
        var struct_size: u64 = sizeof_type_ex(ginfo.typeinfo_ptr);
        if (cursor < struct_size) {
            _global_emit_padding(struct_size - cursor);
        }
    }
    return 0;
}

func globals_emit_data() -> u64 {
    var count: u64 = g_globals.len();
    if (count == 0) { return; }

    var emitted: u64 = 0;
    for (var i: u64 = 0; i < count; i++) {
        var ginfo: *GlobalInfo = g_globals.get(i);
        if (ginfo.init_kind == GLOBAL_INIT_NONE || ginfo.init_kind == GLOBAL_INIT_RUNTIME) { continue; }

        set_current_module_for_global(ginfo.name_ptr, ginfo.name_len);

        if (emitted == 0) {
            emitln("\nsection .data");
            emitted = 1;
        }

        if (ginfo.init_kind == GLOBAL_INIT_EXPR) {
            var expr: *AstNode = (*AstNode)ginfo.init_expr;
            if (expr == 0) {
                emit_stderr("[ERROR] Global init expr missing\n");
                panic("Parse error");
            }
            var ek: u64 = ast_kind(expr);
            if (ek == AST_STRUCT_LITERAL) {
                _global_emit_struct_literal(ginfo, (*AstStructLiteral)expr);
                continue;
            }
            emit_stderr("[ERROR] Unsupported global init expr kind\n");
            panic("Parse error");
        }

        var size: u64 = 8;
        if (ginfo.typeinfo_ptr != 0) {
            size = sizeof_type_ex(ginfo.typeinfo_ptr);
        }
        if (size == 0) { size = 8; }

        var value: u64 = ginfo.init_value;
        if (ginfo.init_kind == GLOBAL_INIT_CONST) {
            var ok: u64 = _global_eval_const_value(ginfo.init_name_ptr, ginfo.init_name_len, &value);
            if (ok == 0) {
                emit_stderr("[ERROR] Global init const not found: ");
                emit_stderr_len(ginfo.init_name_ptr, ginfo.init_name_len);
                emit_stderr("\n");
                panic("Parse error");
            }
        }

        emit("_gvar_");
        emit_len(ginfo.name_ptr, ginfo.name_len);
        emit(":");
        emit_nl();
        _global_emit_scalar_value(size, value);
    }
}

func globals_emit_bss() -> u64 {
    var count: u64 = g_globals.len();
    
    if (count == 0) { return; }
    
    emitln("\nsection .bss");
    
    for (var i: u64 = 0; i < count; i++) {
        var ginfo: *GlobalInfo = g_globals.get(i);
        if (ginfo.init_kind != GLOBAL_INIT_NONE && ginfo.init_kind != GLOBAL_INIT_RUNTIME) { continue; }
        var size: u64 = 8;
        if (ginfo.typeinfo_ptr != 0) {
            size = sizeof_type_ex(ginfo.typeinfo_ptr);
        }
        if (size == 0) { size = 8; }
        
        emit("_gvar_");
        emit_len(ginfo.name_ptr, ginfo.name_len);
        emit(": resb ");
        emit_u64(size);
        emit_nl();
        
    }
}
