// symtab.b - Symbol table for code generation
//
// Symbol table structure: [names_vec, offsets_vec, types_vec, count, stack_offset]
// - names_vec: vector of [name_ptr, name_len] pairs
// - offsets_vec: vector of stack offsets (i64)
// - types_vec: vector of TypeInfo (TypeInfo is 40 bytes)
// - count: number of symbols
// - stack_offset: current stack offset for allocation

import std.io;
import std.vec;
import std.str;
import std.hashmap;
import types;

func symtab_new_nameinfo(ptr: u64, len: u64) -> *NameInfo {
    var info: *NameInfo = (*NameInfo)heap_alloc(sizeof(NameInfo));
    info.ptr = ptr;
    info.len = len;
    return info;
}

func symtab_new_typeinfo(type_kind: u64, ptr_depth: u64) -> *TypeInfo {
    return new TypeInfo(type_kind, ptr_depth);
}

// ============================================
// Symbol Table
// ============================================

func symtab_new() -> *Symtab {
    var symtab: *Symtab = new Symtab();
    var names_vec: *Vec<*NameInfo> = new Vec<*NameInfo>(64);
    var offsets_vec: *Vec<u64> = new Vec<u64>(64);
    var types_vec: *Vec<*TypeInfo> = new Vec<*TypeInfo>(64);
    symtab.names_vec = names_vec;
    symtab.offsets_vec = offsets_vec;
    symtab.types_vec = types_vec;
    symtab.count = 0;
    symtab.stack_offset = 0;
    symtab.name_to_offset_map = new HashMap<u64, u64>(128);
    symtab.name_to_type_map = new HashMap<u64, *TypeInfo>(128);
    return symtab;
}

func symtab_reset_offset_cache(symtab: *Symtab) -> u64 {
    var map: *HashMap<u64, u64> = symtab.name_to_offset_map;
    if (map == 0) {
        symtab.name_to_offset_map = new HashMap<u64, u64>(128);
        return 0;
    }
    map.ensure_capacity(128);
    map.clear();
    return 0;
}

func symtab_reset_type_cache(symtab: *Symtab) -> u64 {
    var map: *HashMap<u64, *TypeInfo> = symtab.name_to_type_map;
    if (map == 0) {
        symtab.name_to_type_map = new HashMap<u64, *TypeInfo>(128);
        return 0;
    }
    map.ensure_capacity(128);
    map.clear();
    return 0;
}

func symtab_clear(symtab: *Symtab) -> u64 {
    symtab.count = 0;
    symtab.stack_offset = 0;

    var names: *Vec<*NameInfo> = symtab.names_vec;
    names.clear();
    var offsets: *Vec<u64> = symtab.offsets_vec;
    offsets.clear();
    var types: *Vec<*TypeInfo> = symtab.types_vec;
    types.clear();
    symtab_reset_offset_cache(symtab);
    symtab_reset_type_cache(symtab);
    return 0;
}

func symtab_add(symtab: *Symtab, name_ptr: u64, name_len: u64, type_kind: u64, ptr_depth: u64, size: u64) -> u64 {
    
    // Allocate on stack (grow downward)
    var offset: u64 = symtab.stack_offset - size;
    symtab.stack_offset = offset;
    
    // Add name info
    var name_info: *NameInfo = symtab_new_nameinfo(name_ptr, name_len);
    symtab.names_vec.push(name_info);
    
    // Add offset
    symtab.offsets_vec.push(offset);
    
    // Add type info
    var type_info: *TypeInfo = symtab_new_typeinfo(type_kind, ptr_depth);
    symtab.types_vec.push(type_info);

    if (name_ptr != 0 && name_len != 0) {
        symtab.name_to_offset_map.?put(name_ptr, name_len, offset);
        symtab.name_to_type_map.?put(name_ptr, name_len, type_info);
    }
    
    symtab.count = symtab.count + 1;
    
    return offset;
}

func symtab_find(symtab: *Symtab, name_ptr: u64, name_len: u64) -> u64 {
    if (name_ptr == 0 || name_len == 0) { return 0; }
    if (symtab.name_to_offset_map != 0 && symtab.name_to_offset_map.has(name_ptr, name_len) != 0) {
        return symtab.name_to_offset_map.?get(name_ptr, name_len);
    }

    var names: *Vec<*NameInfo> = symtab.names_vec;
    var offsets: *Vec<u64> = symtab.offsets_vec;
    var count: u64 = symtab.count;
    
    if (count == 0) { return 0; }

    for (var idx: i64 = (i64)count - 1; idx >= 0; idx = idx - 1) {
        var i: u64 = (u64)idx;
        var name_info: *NameInfo = names.get(i);
        var n_ptr: u64 = name_info.ptr;
        var n_len: u64 = name_info.len;
        
        if (str_eq(n_ptr, n_len, name_ptr, name_len)) {
            var found: u64 = offsets.get(i);
            symtab.name_to_offset_map.?put(name_ptr, name_len, found);
            return found;
        }

    }
    
    return 0;
}

func symtab_get_type(symtab: *Symtab, name_ptr: u64, name_len: u64) -> *TypeInfo {
    if (name_ptr == 0 || name_len == 0) { return 0; }
    if (symtab.name_to_type_map != 0 && symtab.name_to_type_map.has(name_ptr, name_len) != 0) {
        return symtab.name_to_type_map.?get(name_ptr, name_len);
    }

    var names: *Vec<*NameInfo> = symtab.names_vec;
    var types: *Vec<*TypeInfo> = symtab.types_vec;
    var count: u64 = symtab.count;
    
    if (count == 0) { return 0; }

    for (var idx: i64 = (i64)count - 1; idx >= 0; idx = idx - 1) {
        var i: u64 = (u64)idx;
        var name_info: *NameInfo = names.get(i);
        var n_ptr: u64 = name_info.ptr;
        var n_len: u64 = name_info.len;
        
        if (str_eq(n_ptr, n_len, name_ptr, name_len)) {
            var found: *TypeInfo = types.get(i);
            symtab.name_to_type_map.?put(name_ptr, name_len, found);
            return found;
        }

    }
    
    return 0;
}

func symtab_update_type(symtab: *Symtab, name_ptr: u64, name_len: u64, type_kind: u64, ptr_depth: u64) -> u64 {
    var names: *Vec<*NameInfo> = symtab.names_vec;
    var types: *Vec<*TypeInfo> = symtab.types_vec;
    var count: u64 = symtab.count;
    
    if (count == 0) { return; }

    for (var idx: i64 = (i64)count - 1; idx >= 0; idx = idx - 1) {
        var i: u64 = (u64)idx;
        var name_info: *NameInfo = names.get(i);
        var n_ptr: u64 = name_info.ptr;
        var n_len: u64 = name_info.len;
        
        if (str_eq(n_ptr, n_len, name_ptr, name_len)) {
            var type_info: *TypeInfo = types.get(i);
            type_info.type_kind = type_kind;
            type_info.ptr_depth = ptr_depth;
            symtab.name_to_type_map.?put(name_ptr, name_len, type_info);
            return;
        }

    }
}
