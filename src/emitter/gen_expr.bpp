// gen_expr.b - Expression code generation
//
// Generates x86-64 assembly for expressions:
// - cg_expr: evaluate expression, result in RAX
// - cg_lvalue: compute address of lvalue, result in RAX

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import ast;
import compiler;
import emitter.emitter;
import emitter.symtab;
import emitter.typeinfo;

// ============================================
// Expression Codegen
// ============================================

func _cg_find_global_info(name_ptr: u64, name_len: u64) -> *GlobalInfo {
    var globals: *Vec<*GlobalInfo> = emitter_get_globals();
    var n: u64 = globals.?len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = globals.get(i);
        if (str_eq(ginfo.name_ptr, ginfo.name_len, name_ptr, name_len)) { return ginfo; }
    }
    return 0;
}
var g_tmp_struct_arg_id;

func cg_codegen_error(msg: u64) -> u64 {
    emit_stderr(msg);
    panic("Codegen error");
    return 0;
}

func cg_emit_jump(label_id: u64) -> u64 {
    emit("    jmp ");
    emit_label(label_id);
    emit_nl();
    return 0;
}

func cg_emit_safe_null_epilogue(label_null: u64, label_end: u64) -> u64 {
    cg_emit_jump(label_end);
    emit_label_def(label_null);
    emit("    xor eax, eax\n");
    emit_label_def(label_end);
    return 0;
}

func emit_tagged_mask() -> u64 {
    emit("    mov rbx, ");
    emit_u64(281474976710655);
    emit_nl();
    emit("    and rax, rbx\n");
}

func emit_mask_to_rdx(bit_width: u64) -> u64 {
    emit("    mov rdx, 1\n");
    emit("    mov rcx, ");
    emit_u64(bit_width);
    emit_nl();
    emit("    shl rdx, cl\n");
    emit("    sub rdx, 1\n");
}

func cg_emit_field_load_from_rax(fd: *FieldDesc) -> u64 {
    if (fd == 0) { return 0; }
    emit_load_rax_from_addr(fd.type_kind, fd.ptr_depth);
    return 0;
}

func cg_require_tagged_layout_struct(tag_layout_ptr: u64, tag_layout_len: u64) -> *AstStructDef {
    var layout_info: *AstStructDef = get_struct_def(tag_layout_ptr, tag_layout_len);
    if (layout_info == 0) {
        cg_codegen_error("[ERROR] Tagged layout struct not found\n");
        return 0;
    }
    if (layout_info.is_packed == 0) {
        cg_codegen_error("[ERROR] Tagged layout must be packed struct\n");
        return 0;
    }
    return layout_info;
}

func cg_emit_tagged_layout_extract_from_rax(layout_info: *AstStructDef, member_ptr: u64, member_len: u64) -> u64 {
    var total_bits: u64 = get_packed_layout_total_bits(layout_info);
    var field_offset: u64 = get_packed_field_bit_offset(layout_info, member_ptr, member_len);
    var field_width: u64 = get_packed_field_bit_width(layout_info, member_ptr, member_len);
    var start_bit: u64 = 64 - total_bits;
    var shift_bits: u64 = start_bit + field_offset;

    if (shift_bits > 0) {
        emit("    mov rcx, ");
        emit_u64(shift_bits);
        emit_nl();
        emit("    shr rax, cl\n");
    }
    if (field_width < 64) {
        emit_mask_to_rdx(field_width);
        emit("    and rax, rdx\n");
    }
    return 0;
}

// ============================================
// Stack Constructor Helpers
// ============================================

func cg_stack_ctor_emit_memzero(size: u64) -> u64 {
    var memset_ptr: u64 = (u64)"memset";
    var memset_len: u64 = 6;
    var memset_res: *NameInfo = resolve_name(memset_ptr, memset_len);
    if (memset_res != 0) {
        memset_ptr = memset_res.ptr;
        memset_len = memset_res.len;
    }

    emit("    mov rdi, r12\n");
    emit("    xor esi, esi\n");
    emit("    mov rdx, ");
    emit_u64(size);
    emit_nl();
    emit("    call ");
    emit_len(memset_ptr, memset_len);
    emit_nl();
    emit_nl();
    return 0;
}

func cg_resolve_constructor_call(struct_ptr: u64, struct_len: u64, args: *Vec<*AstNode>, symtab: *Symtab, site_ptr: u64, site_len: u64) -> CompilerMethodResolveResult {
    var resolved: CompilerMethodResolveResult = compiler_method_resolve_none();
    var method_ptr: u64 = (u64)"constructor";
    var method_len: u64 = 11;
    var base_len: u64 = compiler_find_generic_suffix_index(struct_ptr, struct_len);
    var suffix_len: u64 = struct_len - base_len;
    var name_info: *NameInfo = compiler_build_method_name_base(struct_ptr, base_len, method_ptr, method_len, suffix_len);
    var alt_info: *NameInfo = compiler_build_method_name_base(struct_ptr, base_len, method_ptr, method_len, 0);
    if (compiler_func_exists(name_info.ptr, name_info.len) == 0) {
        name_info = alt_info;
    }
    if (compiler_func_exists(name_info.ptr, name_info.len) != 0) {
        var fn_ctor: *AstFunc = typeinfo_find_func(name_info.ptr, name_info.len);
        if (fn_ctor == 0) {
            var resolved_name: *NameInfo = resolve_name(name_info.ptr, name_info.len);
            if (resolved_name != 0) {
                fn_ctor = typeinfo_find_func(resolved_name.ptr, resolved_name.len);
            }
        }
        if (fn_ctor != 0) {
            resolved.found = 1;
            resolved.fn = fn_ctor;
            var owner_map: *NameInfo = compiler_get_impl_method_owner(name_info.ptr, name_info.len);
            if (owner_map != 0) {
                resolved.owner_ptr = owner_map.ptr;
                resolved.owner_len = owner_map.len;
            } else {
                resolved.owner_ptr = fn_ctor.impl_owner_ptr;
                resolved.owner_len = fn_ctor.impl_owner_len;
            }
            resolved.access = compiler_get_impl_method_access(name_info.ptr, name_info.len);
        }
    }
    if (resolved.found == 0 || resolved.fn == 0) {
        emit_stderr("[ERROR] constructor not found for ");
        emit_stderr_len(site_ptr, site_len);
        emit_stderr(": ");
        emit_stderr_len(struct_ptr, struct_len);
        emit_stderr("\n");
        panic("Codegen error");
    }
    if (resolved.owner_ptr == 0 || resolved.owner_len == 0) {
        resolved.owner_ptr = struct_ptr;
        resolved.owner_len = struct_len;
    }
    if (resolved.access == 0) { resolved.access = ACCESS_PUBLIC; }
    if (compiler_can_access_member(resolved.owner_ptr, resolved.owner_len, resolved.access) == 0) {
        emit_stderr("[ERROR] constructor access denied: ");
        emit_stderr_len(resolved.owner_ptr, resolved.owner_len);
        emit_stderr(".constructor\n");
        panic("Codegen error");
    }
    return resolved;
}

func cg_stack_ctor_emit_constructor_call(sc: *AstStackCtor, symtab: *Symtab, fn_ctor: *AstFunc, call_ptr: u64, call_len: u64) -> u64 {
    var args: *Vec<*AstNode> = sc.ctor_args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }
    var total_arg_words: u64 = 0;
    if (nargs != 0) {
        var ai: u64 = nargs;
        while (ai > 0) {
            ai = ai - 1;
            var arg: *AstNode = args.get(ai);
            var param: *Param = cg_call_param_at(fn_ctor, ai + 1);
            total_arg_words = total_arg_words + cg_call_push_arg_with_param(arg, param, symtab);
        }
    }
    emit("    push r12\n");
    total_arg_words = total_arg_words + 1;
    var stack_words: u64 = _cg_sysv_pop_arg_regs(total_arg_words);
    emit("    call ");
    emit_len(call_ptr, call_len);
    emit_nl();
    if (stack_words > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words * 8);
        emit_nl();
    }
    return 0;
}

func cg_stack_ctor_call_at_r12(sc: *AstStackCtor, symtab: *Symtab) -> u64 {
    if (sc.type_kind != TYPE_STRUCT) {
        emit_stderr("[ERROR] stack constructor requires struct type\n");
        panic("Codegen error");
    }

    var size: u64 = sizeof_type(sc.type_kind, sc.ptr_depth, sc.struct_name_ptr, sc.struct_name_len);
    cg_stack_ctor_emit_memzero(size);

    cg_emit_trait_vptr_init_at_r12(sc.struct_name_ptr, sc.struct_name_len);
    var resolved_ctor: CompilerMethodResolveResult = cg_resolve_constructor_call(sc.struct_name_ptr, sc.struct_name_len, sc.ctor_args_vec, symtab, "stack ctor", 10);
    var call_ptr: u64 = resolved_ctor.fn.name_ptr;
    var call_len: u64 = resolved_ctor.fn.name_len;
    var alias_name: *NameInfo = resolve_name(call_ptr, call_len);
    if (alias_name != 0) {
        call_ptr = alias_name.ptr;
        call_len = alias_name.len;
    }
    return cg_stack_ctor_emit_constructor_call(sc, symtab, resolved_ctor.fn, call_ptr, call_len);
}

func cg_stack_ctor_init_to_offset(sc: *AstStackCtor, dest_offset: u64, symtab: *Symtab) -> u64 {
    emit("    lea r12, [rbp");
    emit_signed_disp(dest_offset);
    emit("]\n");
    return cg_stack_ctor_call_at_r12(sc, symtab);
}

func cg_emit_trait_vptr_init_at_r12(struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    var impls: *Vec<*TraitImpl> = compiler_get_trait_impls();
    if (impls == 0) { return 0; }
    var struct_def: *AstStructDef = get_struct_def(struct_name_ptr, struct_name_len);
    if (struct_def == 0) { return 0; }

    var n: u64 = impls.len();
    for (var i: u64 = 0; i < n; i++) {
        var impl_info: *TraitImpl = impls.get(i);
        if (!str_eq(impl_info.struct_ptr, impl_info.struct_len, struct_name_ptr, struct_name_len)) { continue; }
        var vptr_name: *NameInfo = compiler_build_vptr_field_name(impl_info.trait_ptr, impl_info.trait_len);
        var field_offset: u64 = 0;
        var field_desc: *FieldDesc = 0;
        var found: u64 = struct_find_field_desc_scoped(struct_def, 0, 0, vptr_name.ptr, vptr_name.len, &field_offset, &field_desc);
        if (found == 0) {
            emit_stderr("[ERROR] vptr field not found for trait init\n");
            panic("Codegen error");
        }
        emit("    lea rax, [rel _gvar_");
        emit_len(impl_info.vtable_global_ptr, impl_info.vtable_global_len);
        emit("]\n");
        emit("    mov [r12");
        if (field_offset != 0) { emit("+"); emit_u64(field_offset); }
        emit("], rax\n");
    }
    return 0;
}

func emit_call_resolved_expr(name_ptr: u64, name_len: u64) -> u64 {
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    emit("    call ");
    emit_len(resolved_ptr, resolved_len);
    emit_nl();
    return 0;
}

func cg_alloc_tmp_struct(symtab: *Symtab, struct_size: u64) -> u64 {
    var base_ptr: u64 = (u64)"__cg_tmp_struct_arg";
    var base_len: u64 = 19;
    var name_len: u64 = base_len + 8;
    var name_ptr: u64 = heap_alloc(name_len);
    var name_u8: []u8 = slice(name_ptr, name_len);
    var base_u8: []u8 = slice(base_ptr, base_len);
    for (var i: u64 = 0; i < base_len; i++) {
        name_u8[i] = base_u8[i];
    }
    var id: u64 = g_tmp_struct_arg_id;
    g_tmp_struct_arg_id = g_tmp_struct_arg_id + 1;
    for (var j: u64 = 0; j < 8; j++) {
        name_u8[base_len + j] = (id >> (j * 8)) & 255;
    }
    return symtab_add(symtab, name_ptr, name_len, TYPE_STRUCT, 0, struct_size);
}

func cg_call_sret_to_offset(call_ptr: u64, dest_offset: u64, symtab: *Symtab) -> u64 {
    var call: *AstCall = (*AstCall)call_ptr;
    var fn_call: *AstFunc = typeinfo_find_func(call.name_ptr, call.name_len);
    var args: *Vec<*AstNode> = call.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }
    var total_arg_words: u64 = 0;
    if (nargs > 0) {
        var i: u64 = nargs;
        while (i > 0) {
            i = i - 1;
            var arg: *AstNode = args.get(i);
            var param: *Param = cg_call_param_at(fn_call, i);
            total_arg_words = total_arg_words + cg_call_push_arg_with_param(arg, param, symtab);
        }
    }

    emit("    lea rdi, [rbp");
    emit_signed_disp(dest_offset);
    emit("]\n");

    var stack_words: u64 = _cg_sysv_pop_arg_regs_sret(total_arg_words);
    emit_call_resolved_expr(call.name_ptr, call.name_len);
    if (stack_words > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words * 8);
        emit_nl();
    }
    return 0;
}

func cg_method_call_ret_struct_size(mc: *AstMethodCall, symtab: *Symtab) -> u64 {
    var receiver: u64 = mc.receiver;
    var recv_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)receiver, symtab);
    if (recv_ti == 0) { return 0; }
    if (recv_ti.type_kind != TYPE_STRUCT) { return 0; }
    var struct_ptr: u64 = recv_ti.struct_name_ptr;
    var struct_len: u64 = recv_ti.struct_name_len;
    if (struct_ptr == 0 || struct_len == 0) { return 0; }

    var args: *Vec<*AstNode> = mc.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }
    var arg_types: *Vec<*TypeInfo> = typeinfo_collect_arg_types(args, symtab);
    var resolved: CompilerMethodResolveResult = compiler_resolve_method_overload(struct_ptr, struct_len, mc.method_ptr, mc.method_len, arg_types, nargs);
    var fn: *AstFunc = 0;
    if (resolved.found != 0) { fn = resolved.fn; }
    if (fn == 0) {
        var name_info: *NameInfo = compiler_build_method_name(struct_ptr, struct_len, mc.method_ptr, mc.method_len);
        fn = typeinfo_find_func(name_info.ptr, name_info.len);
    }
    if (fn == 0) { return 0; }
    if (fn.ret_type != TYPE_STRUCT || fn.ret_ptr_depth != 0) { return 0; }
    var struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, fn.ret_struct_name_ptr, fn.ret_struct_name_len);
    if (struct_size <= 16) { return 0; }
    return struct_size;
}

func cg_method_call_sret_to_offset(mc: *AstMethodCall, dest_offset: u64, symtab: *Symtab) -> u64 {
    var receiver: u64 = mc.receiver;
    var type_info: *TypeInfo = get_expr_type_with_symtab((*AstNode)receiver, symtab);
    var struct_name_ptr: u64 = 0;
    var struct_name_len: u64 = 0;
    if (type_info != 0) {
        struct_name_ptr = type_info.struct_name_ptr;
        struct_name_len = type_info.struct_name_len;
    }
    var args: *Vec<*AstNode> = mc.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }
    var arg_types: *Vec<*TypeInfo> = typeinfo_collect_arg_types(args, symtab);
    var resolved_ptr: u64 = 0;
    var resolved_len: u64 = 0;
    var fn_call: *AstFunc = 0;
    var resolved_m: CompilerMethodResolveResult = compiler_resolve_method_overload(struct_name_ptr, struct_name_len, mc.method_ptr, mc.method_len, arg_types, nargs);
    if (resolved_m.found != 0 && resolved_m.fn != 0) {
        fn_call = resolved_m.fn;
        resolved_ptr = fn_call.name_ptr;
        resolved_len = fn_call.name_len;
    }
    if (fn_call == 0) {
        var name_info: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, mc.method_ptr, mc.method_len);
        resolved_ptr = name_info.ptr;
        resolved_len = name_info.len;
        var resolved: *NameInfo = resolve_name(name_info.ptr, name_info.len);
        if (resolved != 0) {
            resolved_ptr = resolved.ptr;
            resolved_len = resolved.len;
        }
        fn_call = typeinfo_find_func(resolved_ptr, resolved_len);
        if (fn_call == 0) {
            fn_call = typeinfo_find_func(name_info.ptr, name_info.len);
        }
    }
    var total_arg_words: u64 = 0;

    if (nargs != 0) {
        var i: u64 = nargs;
        while (i > 0) {
            i = i - 1;
            var arg: *AstNode = args.get(i);
            var param: *Param = cg_call_param_at(fn_call, i + 1);
            total_arg_words = total_arg_words + cg_call_push_arg_with_param(arg, param, symtab);
        }
    }

    var recv_is_ptr: u64 = 0;
    if (type_info != 0 && type_info.ptr_depth > 0) {
        recv_is_ptr = 1;
    }

    if (recv_is_ptr != 0) {
        cg_expr(receiver);
        if (type_info.is_tagged == 1) {
            emit_tagged_mask();
        }
    } else {
        cg_lvalue(receiver);
    }
    emit("    push rax\n");
    total_arg_words = total_arg_words + 1;

    emit("    lea rdi, [rbp");
    emit_signed_disp(dest_offset);
    emit("]\n");

    var stack_words: u64 = _cg_sysv_pop_arg_regs_sret(total_arg_words);
    emit("    call ");
    emit_len(resolved_ptr, resolved_len);
    emit_nl();
    if (stack_words > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words * 8);
        emit_nl();
    }
    return 0;
}

func get_packed_layout_total_bits(struct_def: *AstStructDef) -> u64 {
    var struct_info: *AstStructDef = struct_def;
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
        var total_bits: u64 = 0;
    for (var i: u64 = 0; i < num_fields; i++) {
            var field: *FieldDesc = fields.get(i);
        if (field.bit_width > 0) {
            total_bits = total_bits + field.bit_width;
        } else {
            var fsize: u64 = sizeof_field_desc(field);
            total_bits = total_bits + fsize * 8;
        }
    }
    return total_bits;
}

func get_packed_field_bit_offset(struct_def: *AstStructDef, field_name_ptr: u64, field_name_len: u64) -> u64 {
    var struct_info: *AstStructDef = struct_def;
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    var bit_cursor: u64 = 0;
    for (var i: u64 = 0; i < num_fields; i++) {
            var field: *FieldDesc = fields.get(i);
        if (str_eq(field.name_ptr, field.name_len, field_name_ptr, field_name_len)) {
            return bit_cursor;
        }
        if (field.bit_width > 0) {
            bit_cursor = bit_cursor + field.bit_width;
        } else {
            var fsize2: u64 = sizeof_field_desc(field);
            bit_cursor = bit_cursor + fsize2 * 8;
        }
    }
    return cg_codegen_error("[ERROR] Packed field not found\n");
}

func get_packed_field_bit_width(struct_def: *AstStructDef, field_name_ptr: u64, field_name_len: u64) -> u64 {
    var struct_info: *AstStructDef = struct_def;
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    for (var i: u64 = 0; i < num_fields; i++) {
            var field: *FieldDesc = fields.get(i);
        if (str_eq(field.name_ptr, field.name_len, field_name_ptr, field_name_len)) {
            if (field.bit_width > 0) { return field.bit_width; }
            return sizeof_field_desc(field) * 8;
        }
    }
    return cg_codegen_error("[ERROR] Packed field not found\n");
}

func _cg_sysv_emit_pop_arg_reg(i: u64, sret: u64) -> u64 {
    emit("    pop ");
    if (sret == 0) {
        if (i == 0) { emit("rdi"); }
        else if (i == 1) { emit("rsi"); }
        else if (i == 2) { emit("rdx"); }
        else if (i == 3) { emit("rcx"); }
        else if (i == 4) { emit("r8"); }
        else if (i == 5) { emit("r9"); }
    } else {
        if (i == 0) { emit("rsi"); }
        else if (i == 1) { emit("rdx"); }
        else if (i == 2) { emit("rcx"); }
        else if (i == 3) { emit("r8"); }
        else if (i == 4) { emit("r9"); }
    }
    emit_nl();
    return 0;
}

func _cg_sysv_pop_arg_regs_common(total_words: u64, reg_limit: u64, sret: u64) -> u64 {
    var reg_count: u64 = total_words;
    if (reg_count > reg_limit) { reg_count = reg_limit; }
    for (var i: u64 = 0; i < reg_count; i++) {
        _cg_sysv_emit_pop_arg_reg(i, sret);
    }
    if (total_words > reg_limit) { return total_words - reg_limit; }
    return 0;
}

func _cg_sysv_pop_arg_regs(total_words: u64) -> u64 {
    return _cg_sysv_pop_arg_regs_common(total_words, 6, 0);
}

func _cg_sysv_pop_arg_regs_sret(total_words: u64) -> u64 {
    return _cg_sysv_pop_arg_regs_common(total_words, 5, 1);
}

func cg_push_struct_words_from_tmp(tmp_offset: u64, struct_size: u64) -> u64 {
    if (struct_size <= 8) {
        emit("    mov rax, [rbp");
        emit_signed_disp(tmp_offset);
        emit("]\n");
        emit("    push rax\n");
        return 1;
    }
    if (struct_size <= 16) {
        emit("    mov rbx, [rbp");
        var tmp_hi: u64 = tmp_offset + 8;
        emit_signed_disp(tmp_hi);
        emit("]\n");
        emit("    mov rax, [rbp");
        emit_signed_disp(tmp_offset);
        emit("]\n");
        emit("    push rbx\n");
        emit("    push rax\n");
        return 2;
    }
    emit("    lea rax, [rbp");
    emit_signed_disp(tmp_offset);
    emit("]\n");
    emit("    push rax\n");
    return 1;
}

func cg_sysv_push_slice_arg(arg: *AstNode, arg_kind: u64) -> u64 {
    if (arg_kind == AST_SLICE) {
        var slice_node: *AstSlice = (*AstSlice)arg;
        cg_expr(slice_node.len_expr);
        emit("    push rax\n");
        cg_expr(slice_node.ptr_expr);
        emit("    push rax\n");
    } else {
        cg_lvalue(arg);
        emit("    mov rbx, [rax+8]\n");
        emit("    push rbx\n");
        emit("    mov rbx, [rax]\n");
        emit("    push rbx\n");
    }
    return 2;
}

func cg_sysv_push_struct_arg(arg: *AstNode, arg_kind: u64, struct_size: u64, symtab: *Symtab) -> u64 {
    if (arg_kind == AST_STACK_CTOR) {
        var tmp_offset_sc: u64 = cg_alloc_tmp_struct(symtab, struct_size);
        cg_stack_ctor_init_to_offset((*AstStackCtor)arg, tmp_offset_sc, symtab);
        return cg_push_struct_words_from_tmp(tmp_offset_sc, struct_size);
    }
    if (arg_kind == AST_CALL) {
        if (struct_size <= 8) {
            cg_expr(arg);
            emit("    push rax\n");
            return 1;
        } else if (struct_size <= 16) {
            cg_expr(arg);
            emit("    push rdx\n");
            emit("    push rax\n");
            return 2;
        }
        var tmp_offset2: u64 = cg_alloc_tmp_struct(symtab, struct_size);
        cg_call_sret_to_offset(arg, tmp_offset2, symtab);
        emit("    lea rax, [rbp");
        emit_signed_disp(tmp_offset2);
        emit("]\n");
        emit("    push rax\n");
        return 1;
    }
    if (struct_size <= 8) {
        cg_lvalue(arg);
        emit("    mov rax, [rax]\n");
        emit("    push rax\n");
        return 1;
    } else if (struct_size <= 16) {
        cg_lvalue(arg);
        emit("    mov rbx, [rax+8]\n");
        emit("    push rbx\n");
        emit("    mov rbx, [rax]\n");
        emit("    push rbx\n");
        return 2;
    }
    // Larger structs: materialize into a stack temp and pass pointer
    var tmp_offset: u64 = cg_alloc_tmp_struct(symtab, struct_size);
    if (arg_kind == AST_CALL) {
        cg_call_sret_to_offset(arg, tmp_offset, symtab);
    } else {
        cg_lvalue(arg);
        emit("    mov rbx, rax\n");
        emit("    lea r8, [rbp");
        emit_signed_disp(tmp_offset);
        emit("]\n");

        emit_copy_bytes_with_regs("rbx", 3, "r8", 2, struct_size);
    }

    emit("    lea rax, [rbp");
    emit_signed_disp(tmp_offset);
    emit("]\n");
    emit("    push rax\n");
    return 1;
}

func _cg_sysv_push_call_arg(arg: *AstNode, symtab: *Symtab) -> u64 {
    var arg_kind: u64 = ast_kind(arg);
    if (arg_kind == AST_CALL) {
        var call_arg: *AstCall = (*AstCall)arg;
        var fn: *AstFunc = typeinfo_find_func(call_arg.name_ptr, call_arg.name_len);
        if (fn != 0) {
            if (fn.ret_type == TYPE_STRUCT && fn.ret_ptr_depth == 0) {
                var call_struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, fn.ret_struct_name_ptr, fn.ret_struct_name_len);
                if (call_struct_size <= 8) {
                    cg_expr(arg);
                    emit("    push rax\n");
                    return 1;
                } else if (call_struct_size <= 16) {
                    cg_expr(arg);
                    emit("    push rdx\n");
                    emit("    push rax\n");
                    return 2;
                }
                var tmp_offset_call: u64 = cg_alloc_tmp_struct(symtab, call_struct_size);
                cg_call_sret_to_offset(arg, tmp_offset_call, symtab);
                emit("    lea rax, [rbp");
                emit_signed_disp(tmp_offset_call);
                emit("]\n");
                emit("    push rax\n");
                return 1;
            }
        }
    }

    var at: *TypeInfo = get_expr_type_with_symtab((*AstNode)arg, symtab);
    if (at != 0) {
        if (at.type_kind == TYPE_SLICE && at.ptr_depth == 0) {
            return cg_sysv_push_slice_arg(arg, arg_kind);
        }
        if (at.type_kind == TYPE_STRUCT && at.ptr_depth == 0) {
            var struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, at.struct_name_ptr, at.struct_name_len);
            return cg_sysv_push_struct_arg(arg, arg_kind, struct_size, symtab);
        }
    }
    cg_expr(arg);
    emit("    push rax\n");
    return 1;
}

func cg_call_param_at(fn: *AstFunc, index: u64) -> *Param {
    if (fn == 0 || fn.params_vec == 0) { return 0; }
    if (index >= fn.params_vec.len()) { return 0; }
    return fn.params_vec.get(index);
}

func cg_call_push_arg_with_param(arg: *AstNode, expected: *Param, symtab: *Symtab) -> u64 {
    if (expected == 0) { return _cg_sysv_push_call_arg(arg, symtab); }
    if (expected.type_kind != TYPE_STRUCT || expected.ptr_depth == 0) {
        return _cg_sysv_push_call_arg(arg, symtab);
    }

    var at: *TypeInfo = get_expr_type_with_symtab((*AstNode)arg, symtab);
    if (at == 0) { return _cg_sysv_push_call_arg(arg, symtab); }
    if (at.type_kind != TYPE_STRUCT || at.ptr_depth == 0) {
        return _cg_sysv_push_call_arg(arg, symtab);
    }

    var src_name_ptr: u64 = at.struct_name_ptr;
    var src_name_len: u64 = at.struct_name_len;
    var src_resolved: *NameInfo = resolve_name(src_name_ptr, src_name_len);
    if (src_resolved != 0) {
        src_name_ptr = src_resolved.ptr;
        src_name_len = src_resolved.len;
    }

    var expected_name_ptr: u64 = expected.struct_name_ptr;
    var expected_name_len: u64 = expected.struct_name_len;
    var expected_resolved: *NameInfo = resolve_name(expected_name_ptr, expected_name_len);
    if (expected_resolved != 0) {
        expected_name_ptr = expected_resolved.ptr;
        expected_name_len = expected_resolved.len;
    }

    if (str_eq(src_name_ptr, src_name_len, expected_name_ptr, expected_name_len) != 0) {
        cg_expr(arg);
        if (at.is_tagged == 1) { emit_tagged_mask(); }
        emit("    push rax\n");
        return 1;
    }

    var src_def: *AstStructDef = get_struct_def(src_name_ptr, src_name_len);
    if (src_def == 0 && (src_name_ptr != at.struct_name_ptr || src_name_len != at.struct_name_len)) {
        src_def = get_struct_def(at.struct_name_ptr, at.struct_name_len);
    }
    if (src_def != 0) {
        var up_offset: u64 = 0;
        var up_def: *AstStructDef = 0;
        var found_upcast: u64 = typeinfo_find_parent_offset(src_def, expected_name_ptr, expected_name_len, &up_offset, &up_def);
        if (found_upcast == 0 && (expected_name_ptr != expected.struct_name_ptr || expected_name_len != expected.struct_name_len)) {
            found_upcast = typeinfo_find_parent_offset(src_def, expected.struct_name_ptr, expected.struct_name_len, &up_offset, &up_def);
        }
        if (found_upcast != 0) {
            cg_expr(arg);
            if (at.is_tagged == 1) { emit_tagged_mask(); }
            cg_emit_adjust_rax_add(up_offset);
            emit("    push rax\n");
            return 1;
        }
    }

    return _cg_sysv_push_call_arg(arg, symtab);
}

func cg_index_addr(node: u64, symtab: *Symtab) -> u64 {
    var idx: *AstIndex = (*AstIndex)node;
    var base: u64 = idx.base;
    var index: u64 = idx.index;

    var elem_size: u64 = 1;
    var use_array_addr: u64 = 0;
    var use_slice_ptr: u64 = 0;
    var use_tagged_ptr: u64 = 0;

    var bt: *TypeInfo = get_expr_type_with_symtab((*AstNode)base, symtab);
    if (bt != 0) {
        if (bt.ptr_depth > 0) {
            elem_size = get_pointee_size(bt.type_kind, bt.ptr_depth);
            if (bt.is_tagged == 1) { use_tagged_ptr = 1; }
        } else if (bt.type_kind == TYPE_ARRAY) {
            elem_size = typeinfo_elem_size_from_container(bt);
            use_array_addr = 1;
        } else if (bt.type_kind == TYPE_SLICE) {
            elem_size = typeinfo_elem_size_from_container(bt);
            use_slice_ptr = 1;
        }
    }

    if (use_array_addr == 1) {
        cg_lvalue(base);
    } else if (use_slice_ptr == 1) {
        cg_lvalue(base);
        emit("    mov rax, [rax]\n");
    } else {
        cg_expr(base);
        if (use_tagged_ptr == 1) {
            emit_tagged_mask();
        }
    }

    emit("    push rax\n");
    cg_expr(index);
    if (elem_size != 1) {
        emit("    imul rax, ");
        emit_u64(elem_size);
        emit_nl();
    }
    emit("    pop rbx\n");
    emit("    add rax, rbx\n");
    return;
}

func cg_try_materialize_operand(operand: u64, op_kind: u64, struct_size: u64, tmp_offset: u64, symtab: *Symtab) -> u64 {
    if (struct_size > 16) {
        if (op_kind == AST_CALL) {
            cg_call_sret_to_offset(operand, tmp_offset, symtab);
        } else if (op_kind == AST_METHOD_CALL) {
            cg_method_call_sret_to_offset((*AstMethodCall)operand, tmp_offset, symtab);
        } else {
            cg_lvalue(operand);
            emit("    mov rbx, rax\n");
            emit("    lea r8, [rbp");
            emit_signed_disp(tmp_offset);
            emit("]\n");
            emit_copy_bytes_with_regs("rbx", 3, "r8", 2, struct_size);
        }
        return;
    }
    if (op_kind == AST_CALL || op_kind == AST_METHOD_CALL || op_kind == AST_CALL_PTR) {
        cg_expr(operand);
        emit("    lea rbx, [rbp");
        emit_signed_disp(tmp_offset);
        emit("]\n");
        emit("    mov [rbx], rax\n");
        if (struct_size > 8) {
            emit("    mov [rbx+8], rdx\n");
        }
    } else {
        cg_lvalue(operand);
        emit("    mov rbx, rax\n");
        emit("    lea r8, [rbp");
        emit_signed_disp(tmp_offset);
        emit("]\n");
        emit_copy_bytes_with_regs("rbx", 3, "r8", 2, struct_size);
    }
    return;
}

func cg_try_emit_fail_return(tmp_offset: u64, check_off: u64, ret_struct_name_ptr: u64, ret_struct_name_len: u64, label_ok: u64) -> u64 {
    emit("    lea rbx, [rbp");
    emit_signed_disp(tmp_offset);
    emit("]\n");
    emit("    mov rax, [rbx");
    if (check_off != 0) { emit("+"); emit_u64(check_off); }
    emit("]\n");
    emit("    test rax, rax\n");
    emit("    jne ");
    emit_label(label_ok);
    emit_nl();

    var ret_struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, ret_struct_name_ptr, ret_struct_name_len);
    if (ret_struct_size > 16) {
        emit_copy_bytes_with_regs("rbx", 3, "rdi", 3, ret_struct_size);
    } else if (ret_struct_size <= 8) {
        emit("    mov rax, [rbx]\n");
    } else {
        emit("    mov rax, [rbx]\n");
        emit("    mov rdx, [rbx+8]\n");
    }
    emit("    mov rsp, rbp\n");
    emit("    pop rbp\n");
    emit("    ret\n");
    return;
}

func cg_try_emit_value_load(value_desc: *FieldDesc, value_off: u64) -> u64 {
    var value_size: u64 = sizeof_field_desc(value_desc);
    if (value_size <= 8) {
        if (value_desc.ptr_depth == 0 && (value_desc.type_kind == TYPE_BOOL || value_desc.type_kind == TYPE_U8)) {
            emit("    movzx rax, byte [rbx");
            if (value_off != 0) { emit("+"); emit_u64(value_off); }
            emit("]\n");
        } else if (value_desc.ptr_depth == 0 && value_desc.type_kind == TYPE_U16) {
            emit("    movzx rax, word [rbx");
            if (value_off != 0) { emit("+"); emit_u64(value_off); }
            emit("]\n");
        } else if (value_desc.ptr_depth == 0 && value_desc.type_kind == TYPE_U32) {
            emit("    mov eax, [rbx");
            if (value_off != 0) { emit("+"); emit_u64(value_off); }
            emit("]\n");
        } else if (value_desc.ptr_depth == 0 && value_desc.type_kind == TYPE_I8) {
            emit("    movsx rax, byte [rbx");
            if (value_off != 0) { emit("+"); emit_u64(value_off); }
            emit("]\n");
        } else if (value_desc.ptr_depth == 0 && value_desc.type_kind == TYPE_I16) {
            emit("    movsx rax, word [rbx");
            if (value_off != 0) { emit("+"); emit_u64(value_off); }
            emit("]\n");
        } else if (value_desc.ptr_depth == 0 && value_desc.type_kind == TYPE_I32) {
            emit("    movsxd rax, dword [rbx");
            if (value_off != 0) { emit("+"); emit_u64(value_off); }
            emit("]\n");
        } else {
            emit("    mov rax, [rbx");
            if (value_off != 0) { emit("+"); emit_u64(value_off); }
            emit("]\n");
        }
        return;
    }
    if (value_size <= 16) {
        emit("    mov rax, [rbx");
        if (value_off != 0) { emit("+"); emit_u64(value_off); }
        emit("]\n");
        emit("    mov rdx, [rbx");
        if (value_off + 8 != 0) { emit("+"); emit_u64(value_off + 8); }
        emit("]\n");
        return;
    }
    emit_stderr("[ERROR] try value size too large for expression result\n");
    panic("Codegen error");
}

func cg_try_expr(node: u64, symtab: *Symtab) -> u64 {
    var tr: *AstTry = (*AstTry)node;
    var operand: u64 = tr.operand;

    var opt_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)operand, symtab);
    if (opt_ti == 0) {
        emit_stderr("[ERROR] try operand type not found\n");
        panic("Codegen error");
    }
    var try_kind: u64 = compiler_try_kind_from_typeinfo(opt_ti);
    if (try_kind == COMPILER_TRY_KIND_INVALID) {
        if (opt_ti.type_kind != TYPE_STRUCT || opt_ti.ptr_depth != 0) {
            emit_stderr("[ERROR] try operator requires Option/Result value\n");
        } else {
            emit_stderr("[ERROR] try operator requires Option or Result\n");
        }
        panic("Codegen error");
    }

    var ret_type: u64 = emitter_get_ret_type();
    var ret_ptr_depth: u64 = emitter_get_ret_ptr_depth();
    var ret_struct_name_ptr: u64 = emitter_get_ret_struct_name_ptr();
    var ret_struct_name_len: u64 = emitter_get_ret_struct_name_len();
    if (compiler_try_return_matches_type(opt_ti, ret_type, ret_ptr_depth, ret_struct_name_ptr, ret_struct_name_len) == 0) {
        if (ret_type != TYPE_STRUCT || ret_ptr_depth != 0) {
            emit_stderr("[ERROR] try operator requires Option/Result return type\n");
        } else {
            emit_stderr("[ERROR] try operand type must match function return type\n");
        }
        panic("Codegen error");
    }

    var struct_def: *AstStructDef = compiler_try_resolve_struct_def(opt_ti);
    if (struct_def == 0) {
        emit_stderr("[ERROR] try operand struct definition not found\n");
        panic("Codegen error");
    }

    var try_fields: CompilerTryFieldNames = compiler_try_field_names(try_kind);
    if (try_fields.found == 0) {
        emit_stderr("[ERROR] invalid try kind\n");
        panic("Codegen error");
    }
    var check_ptr: u64 = try_fields.check_ptr;
    var check_len: u64 = try_fields.check_len;
    var value_ptr: u64 = try_fields.value_ptr;
    var value_len: u64 = try_fields.value_len;

    var value_desc: *FieldDesc = get_field_desc(struct_def, value_ptr, value_len);
    if (value_desc == 0) {
        emit_stderr("[ERROR] try value field not found\n");
        panic("Codegen error");
    }

    var check_off: u64 = get_field_offset(struct_def, check_ptr, check_len);
    var value_off: u64 = get_field_offset(struct_def, value_ptr, value_len);

    var struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, opt_ti.struct_name_ptr, opt_ti.struct_name_len);
    var tmp_offset: u64 = cg_alloc_tmp_struct(symtab, struct_size);
    var op_kind: u64 = ast_kind(operand);

    cg_try_materialize_operand(operand, op_kind, struct_size, tmp_offset, symtab);

    var label_ok: u64 = new_label();
    cg_try_emit_fail_return(tmp_offset, check_off, ret_struct_name_ptr, ret_struct_name_len, label_ok);

    emit_label_def(label_ok);
    cg_try_emit_value_load(value_desc, value_off);
    return;
}

func cg_expr_call(node: u64, symtab: *Symtab) -> u64 {
    var call: *AstCall = (*AstCall)node;
    var name_ptr: u64 = call.name_ptr;
    var name_len: u64 = call.name_len;
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }

    var impl_check_ptr: u64 = name_ptr;
    var impl_check_len: u64 = name_len;
    if (compiler_is_impl_method(impl_check_ptr, impl_check_len) == 0 && resolved != 0 && compiler_is_impl_method(resolved_ptr, resolved_len) != 0) {
        impl_check_ptr = resolved_ptr;
        impl_check_len = resolved_len;
    }
    if (compiler_is_impl_method(impl_check_ptr, impl_check_len) != 0) {
        var impl_access: u64 = compiler_get_impl_method_access(impl_check_ptr, impl_check_len);
        var owner: *NameInfo = compiler_get_impl_method_owner(impl_check_ptr, impl_check_len);
        var allow_access: u64 = 0;
        if (owner != 0) {
            allow_access = compiler_can_access_member(owner.ptr, owner.len, impl_access);
        }
        if (allow_access == 0) {
            emit_stderr("[ERROR] private method access denied: ");
            emit_stderr_len(impl_check_ptr, impl_check_len);
            emit_stderr("\n");
            panic("Codegen error");
        }
    }

    var var_type: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
    var is_global: u64 = is_global_var(resolved_ptr, resolved_len);
    if (var_type != 0 || is_global != 0) {
        var args2: *Vec<*AstNode> = call.args_vec;
        var nargs2: u64 = 0;
        if (args2 != 0) { nargs2 = args2.len(); }

        if (var_type != 0) {
            var offset2: u64 = symtab_find(symtab, name_ptr, name_len);
            emit("    mov rax, [rbp");
            emit_signed_disp(offset2);
            emit("]\n");
        } else {
            emit("    mov rax, [rel _gvar_");
            emit_len(resolved_ptr, resolved_len);
            emit("]\n");
        }
        emit("    push rax\n");

        var total_arg_words2: u64 = 0;
        if (nargs2 != 0) {
            var i2: u64 = nargs2;
            while (i2 > 0) {
                i2 = i2 - 1;
                var arg2: *AstNode = args2.get(i2);
                total_arg_words2 = total_arg_words2 + _cg_sysv_push_call_arg(arg2, symtab);
            }
        }
        var stack_words2: u64 = _cg_sysv_pop_arg_regs(total_arg_words2);

        emit("    pop rax\n");
        emit("    call rax\n");

        if (stack_words2 > 0) {
            emit("    add rsp, ");
            emit_u64(stack_words2 * 8);
            emit_nl();
        }
        return;
    }
    var fn_call_direct: *AstFunc = typeinfo_find_func(name_ptr, name_len);
    if (fn_call_direct == 0) {
        fn_call_direct = typeinfo_find_func(resolved_ptr, resolved_len);
    }
    var args: *Vec<*AstNode> = call.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }
    var total_arg_words: u64 = 0;
    if (nargs != 0) {
        var i: u64 = nargs;
        while (i > 0) {
            i = i - 1;
            var arg: *AstNode = args.get(i);
            var param: *Param = cg_call_param_at(fn_call_direct, i);
            total_arg_words = total_arg_words + cg_call_push_arg_with_param(arg, param, symtab);
        }
    }
    var stack_words: u64 = _cg_sysv_pop_arg_regs(total_arg_words);

    emit("    call ");
    emit_len(resolved_ptr, resolved_len);
    emit_nl();
    
    if (stack_words > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words * 8);
        emit_nl();
    }
    return;
}

func cg_expr_call_ptr(node: u64, symtab: *Symtab) -> u64 {
    var cp: *AstCallPtr = (*AstCallPtr)node;
    var args3: *Vec<*AstNode> = cp.args_vec;
    var nargs3: u64 = 0;
    if (args3 != 0) { nargs3 = args3.len(); }

    // Preserve callee address across arg evaluation.
    cg_expr(cp.callee);
    emit("    push rax\n");

    var total_arg_words3: u64 = 0;
    if (nargs3 != 0) {
        var i3: u64 = nargs3;
        while (i3 > 0) {
            i3 = i3 - 1;
            var arg3: *AstNode = args3.get(i3);
            total_arg_words3 = total_arg_words3 + _cg_sysv_push_call_arg(arg3, symtab);
        }
    }
    var stack_words3: u64 = _cg_sysv_pop_arg_regs(total_arg_words3);

    emit("    pop rax\n");
    emit("    call rax\n");

    if (stack_words3 > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words3 * 8);
        emit_nl();
    }
    return;
}

func cg_expr_stack_ctor(node: u64, symtab: *Symtab) -> u64 {
    var sc: *AstStackCtor = (*AstStackCtor)node;
    var sc_ti: *TypeInfo = get_expr_type_with_symtab(node, symtab);
    if (sc_ti == 0 || sc_ti.type_kind != TYPE_STRUCT || sc_ti.ptr_depth != 0) {
        emit_stderr("[ERROR] stack constructor expression requires struct value\n");
        panic("Codegen error");
    }
    var sc_size: u64 = sizeof_type(TYPE_STRUCT, 0, sc_ti.struct_name_ptr, sc_ti.struct_name_len);
    var tmp_offset_expr: u64 = cg_alloc_tmp_struct(symtab, sc_size);
    cg_stack_ctor_init_to_offset(sc, tmp_offset_expr, symtab);
    if (sc_size <= 8) {
        emit("    mov rax, [rbp");
        emit_signed_disp(tmp_offset_expr);
        emit("]\n");
        return;
    } else if (sc_size <= 16) {
        emit("    mov rax, [rbp");
        emit_signed_disp(tmp_offset_expr);
        emit("]\n");
        emit("    mov rdx, [rbp");
        var tmp_expr_hi: u64 = tmp_offset_expr + 8;
        emit_signed_disp(tmp_expr_hi);
        emit("]\n");
        return;
    }
    emit_stderr("[ERROR] stack constructor expression requires destination for large structs\n");
    panic("Codegen error");
}

func cg_expr_emit_local_typed(var_type: *TypeInfo, offset: u64) -> u64 {
    if (var_type == 0) { return 0; }
    if (var_type.ptr_depth != 0) { return 0; }
    if (var_type.type_kind == TYPE_ARRAY) {
        emit("    lea rax, [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    if (var_type.type_kind == TYPE_SLICE) {
        emit("    mov rax, [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    if (var_type.type_kind == TYPE_BOOL || var_type.type_kind == TYPE_U8) {
        emit("    movzx rax, byte [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    if (var_type.type_kind == TYPE_U16) {
        emit("    movzx rax, word [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    if (var_type.type_kind == TYPE_U32) {
        emit("    mov eax, [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    if (var_type.type_kind == TYPE_I8) {
        emit("    movsx rax, byte [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    if (var_type.type_kind == TYPE_I16) {
        emit("    movsx rax, word [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    if (var_type.type_kind == TYPE_I32) {
        emit("    movsxd rax, dword [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return 1;
    }
    return 0;
}

func cg_expr_emit_global_typed(gt: *TypeInfo, resolved_ptr: u64, resolved_len: u64) -> u64 {
    if (gt == 0 || gt.ptr_depth != 0) {
        return 0;
    }
    if (gt.type_kind == TYPE_ARRAY) {
        emit("    lea rax, [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    if (gt.type_kind == TYPE_SLICE) {
        emit("    mov rax, [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    if (gt.type_kind == TYPE_BOOL || gt.type_kind == TYPE_U8) {
        emit("    movzx rax, byte [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    if (gt.type_kind == TYPE_U16) {
        emit("    movzx rax, word [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    if (gt.type_kind == TYPE_U32) {
        emit("    mov eax, [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    if (gt.type_kind == TYPE_I8) {
        emit("    movsx rax, byte [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    if (gt.type_kind == TYPE_I16) {
        emit("    movsx rax, word [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    if (gt.type_kind == TYPE_I32) {
        emit("    movsxd rax, dword [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return 1;
    }
    return 0;
}

func cg_expr_ident(node: u64, symtab: *Symtab) -> u64 {
    var ident: *AstIdent = (*AstIdent)node;
    var name_ptr: u64 = ident.name_ptr;
    var name_len: u64 = ident.name_len;
    var var_type: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
    if (var_type != 0) {
        var offset0: u64 = symtab_find(symtab, name_ptr, name_len);
        if (cg_expr_emit_local_typed(var_type, offset0) != 0) {
            return;
        }
    }

    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }

    var result: ConstResult = const_find(resolved_ptr, resolved_len);
    if (result.found == 1) {
        emit("    mov rax, ");
        emit_u64(result.value);
        emit_nl();
        return;
    }

    if (is_global_var(resolved_ptr, resolved_len)) {
        var ginfo: *GlobalInfo = _cg_find_global_info(resolved_ptr, resolved_len);
        if (ginfo != 0) {
            var gt: *TypeInfo = ginfo.typeinfo_ptr;
            if (cg_expr_emit_global_typed(gt, resolved_ptr, resolved_len) != 0) {
                return;
            }
        }

        emit("    mov rax, [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        return;
    }

    var offset: u64 = symtab_find(symtab, name_ptr, name_len);
    emit("    mov rax, [rbp");
    emit_signed_disp(offset);
    emit("]\n");
    return;
}

func cg_expr_unary(node: u64, symtab: *Symtab) -> u64 {
    var unary: *AstUnary = (*AstUnary)node;
    var op: u64 = unary.op;
    var operand: u64 = unary.operand;
    
    cg_expr(operand);
    if (op == TOKEN_MINUS) {
        var ot: *TypeInfo = get_expr_type_with_symtab((*AstNode)operand, symtab);
        if (ot != 0 && ot.ptr_depth == 0 && ot.type_kind == TYPE_F64) {
            emit("    mov rbx, 1\n");
            emit("    mov rcx, 63\n");
            emit("    shl rbx, cl\n");
            emit("    movq xmm1, rbx\n");
            emit("    movq xmm0, rax\n");
            emit("    xorpd xmm0, xmm1\n");
            emit("    movq rax, xmm0\n");
            return;
        }
        emit("    neg rax\n");
    }
    else if (op == TOKEN_BANG) {
        emit("    test rax, rax\n");
        emit("    setz al\n");
        emit("    movzx rax, al\n");
    } else if (op == TOKEN_TILDE) {
        emit("    not rax\n");
    }
    return;
}

func cg_expr_addr_of(node: u64, symtab: *Symtab) -> u64 {
    var addr_of: *AstAddrOf = (*AstAddrOf)node;
    var operand: u64 = addr_of.operand;
    if (ast_kind(operand) == AST_IDENT) {
        var ident: *AstIdent = (*AstIdent)operand;
        var name_ptr: u64 = ident.name_ptr;
        var name_len: u64 = ident.name_len;
        var offset: u64 = symtab_find(symtab, name_ptr, name_len);

        if (offset != 0) {
            emit("    lea rax, [rbp");
            emit_signed_disp(offset);
            emit("]\n");
            return;
        }

        if (compiler_func_exists(name_ptr, name_len) != 0) {
            var resolved_ptr: u64 = name_ptr;
            var resolved_len: u64 = name_len;
            var resolved: *NameInfo = resolve_name(name_ptr, name_len);
            if (resolved != 0) {
                resolved_ptr = resolved.ptr;
                resolved_len = resolved.len;
            }
            emit("    lea rax, [rel ");
            emit_len(resolved_ptr, resolved_len);
            emit("]\n");
            return;
        }

        if (compiler_global_exists(name_ptr, name_len) != 0) {
            var resolved_ptr2: u64 = name_ptr;
            var resolved_len2: u64 = name_len;
            var resolved2: *NameInfo = resolve_name(name_ptr, name_len);
            if (resolved2 != 0) {
                resolved_ptr2 = resolved2.ptr;
                resolved_len2 = resolved2.len;
            }
            emit("    lea rax, [rel _gvar_");
            emit_len(resolved_ptr2, resolved_len2);
            emit("]\n");
            return;
        }
    }

    cg_lvalue(operand);
    return;
}

func cg_expr_deref(node: u64, symtab: *Symtab) -> u64 {
    var deref: *AstDeref = (*AstDeref)node;
    var operand: u64 = deref.operand;
    cg_expr(operand);
    
    var type_info: *TypeInfo = get_expr_type_with_symtab((*AstNode)operand, symtab);
    var base_type: u64 = type_info.type_kind;
    var ptr_depth: u64 = type_info.ptr_depth;
    if (ptr_depth > 0 && type_info.is_tagged == 1) {
        emit_tagged_mask();
    }
    
    if (ptr_depth == 1) {
        if (base_type == TYPE_BOOL || base_type == TYPE_U8) {
            emit("    movzx rax, byte [rax]\n");
            return;
        }
        if (base_type == TYPE_U16) {
            emit("    movzx rax, word [rax]\n");
            return;
        }
        if (base_type == TYPE_U32) {
            emit("    mov eax, [rax]\n");
            return;
        }
        if (base_type == TYPE_I8) {
            emit("    movsx rax, byte [rax]\n");
            return;
        }
        if (base_type == TYPE_I16) {
            emit("    movsx rax, word [rax]\n");
            return;
        }
        if (base_type == TYPE_I32) {
            emit("    movsxd rax, dword [rax]\n");
            return;
        }
    }
    emit("    mov rax, [rax]\n");
    return;
}

func cg_expr_deref8(node: u64, symtab: *Symtab) -> u64 {
    var deref8: *AstDeref8 = (*AstDeref8)node;
    var operand: u64 = deref8.operand;
    cg_expr(operand);
    var ti2: *TypeInfo = get_expr_type_with_symtab((*AstNode)operand, symtab);
    if (ti2 != 0) {
        if (ti2.ptr_depth > 0 && ti2.is_tagged == 1) {
            emit_tagged_mask();
        }
    }
    emit("    movzx rax, byte [rax]\n");
    return;
}

func cg_expr_index(node: u64, symtab: *Symtab) -> u64 {
    cg_index_addr(node, symtab);
    var et: *TypeInfo = get_expr_type_with_symtab((*AstNode)node, symtab);
    if (et != 0) {
        if (et.ptr_depth == 0) {
            if (et.type_kind == TYPE_BOOL || et.type_kind == TYPE_U8) {
                emit("    movzx rax, byte [rax]\n");
                return;
            }
            if (et.type_kind == TYPE_U16) {
                emit("    movzx rax, word [rax]\n");
                return;
            }
            if (et.type_kind == TYPE_U32) {
                emit("    mov eax, [rax]\n");
                return;
            }
            if (et.type_kind == TYPE_I8) {
                emit("    movsx rax, byte [rax]\n");
                return;
            }
            if (et.type_kind == TYPE_I16) {
                emit("    movsx rax, word [rax]\n");
                return;
            }
            if (et.type_kind == TYPE_I32) {
                emit("    movsxd rax, dword [rax]\n");
                return;
            }
        }
    }
    emit("    mov rax, [rax]\n");
    return;
}

func cg_emit_adjust_rax_add(offset: u64) -> u64 {
    if (offset == 0) { return 0; }
    emit("    add rax, ");
    emit_u64(offset);
    emit_nl();
    return 0;
}

func cg_emit_adjust_rax_sub(offset: u64) -> u64 {
    if (offset == 0) { return 0; }
    emit("    sub rax, ");
    emit_u64(offset);
    emit_nl();
    return 0;
}

func cg_emit_checked_trait_to_struct_guard(expected_vtable_ptr: u64, expected_vtable_len: u64) -> u64 {
    if (expected_vtable_ptr == 0 || expected_vtable_len == 0) { return 0; }
    var ok_label: u64 = new_label();
    emit("    mov r11, [rax]\n");
    emit("    lea r10, [rel _gvar_");
    emit_len(expected_vtable_ptr, expected_vtable_len);
    emit("]\n");
    emit("    cmp r11, r10\n");
    emit("    je ");
    emit_label(ok_label);
    emit_nl();
    emit("    ud2\n");
    emit_label_def(ok_label);
    return 0;
}

func cg_emit_checked_struct_downcast_guard(check_info: CompilerDowncastCheckInfo) -> u64 {
    if (check_info.found == 0) { return 0; }
    var ok_label: u64 = new_label();
    if (check_info.src_vptr_offset == 0) {
        emit("    mov r11, [rax]\n");
    } else {
        emit("    mov r11, [rax + ");
        emit_u64(check_info.src_vptr_offset);
        emit("]\n");
    }
    emit("    lea r10, [rel _gvar_");
    emit_len(check_info.expected_vtable_ptr, check_info.expected_vtable_len);
    emit("]\n");
    emit("    cmp r11, r10\n");
    emit("    je ");
    emit_label(ok_label);
    emit_nl();
    emit("    ud2\n");
    emit_label_def(ok_label);
    return 0;
}

func cg_try_adjust_struct_ptr_cast(src_ti: *TypeInfo, target_struct_ptr: u64, target_struct_len: u64) -> u64 {
    if (src_ti == 0) { return 0; }
    if (src_ti.type_kind != TYPE_STRUCT || src_ti.ptr_depth == 0) { return 0; }
    if (target_struct_ptr == 0 || target_struct_len == 0) { return 0; }

    var src_def: *AstStructDef = get_struct_def(src_ti.struct_name_ptr, src_ti.struct_name_len);
    if (src_def != 0) {
        var up_offset: u64 = 0;
        var up_def: *AstStructDef = 0;
        if (typeinfo_find_parent_offset(src_def, target_struct_ptr, target_struct_len, &up_offset, &up_def) != 0) {
            cg_emit_adjust_rax_add(up_offset);
            return 1;
        }
    }

    var target_def: *AstStructDef = get_struct_def(target_struct_ptr, target_struct_len);
    if (target_def != 0) {
        var down_offset: u64 = 0;
        var down_def: *AstStructDef = 0;
        if (typeinfo_find_parent_offset(target_def, src_ti.struct_name_ptr, src_ti.struct_name_len, &down_offset, &down_def) != 0) {
            cg_emit_adjust_rax_sub(down_offset);
            return 1;
        }
    }

    return 0;
}

func cg_cast_is_int_scalar(kind: u64) -> u64 {
    if (kind == TYPE_BOOL) { return 1; }
    if (kind == TYPE_U8) { return 1; }
    if (kind == TYPE_U16) { return 1; }
    if (kind == TYPE_U32) { return 1; }
    if (kind == TYPE_U64) { return 1; }
    if (kind == TYPE_I8) { return 1; }
    if (kind == TYPE_I16) { return 1; }
    if (kind == TYPE_I32) { return 1; }
    if (kind == TYPE_I64) { return 1; }
    return 0;
}

func cg_cast_emit_int_truncate(target_kind: u64) -> u64 {
    if (target_kind == TYPE_BOOL || target_kind == TYPE_U8) {
        emit("    and rax, 255\n");
        return 1;
    }
    if (target_kind == TYPE_U16) {
        emit("    and rax, 65535\n");
        return 1;
    }
    if (target_kind == TYPE_U32) {
        emit("    mov eax, eax\n");
        return 1;
    }
    if (target_kind == TYPE_I8) {
        emit("    movsx rax, al\n");
        return 1;
    }
    if (target_kind == TYPE_I16) {
        emit("    movsx rax, ax\n");
        return 1;
    }
    if (target_kind == TYPE_I32) {
        emit("    movsxd rax, eax\n");
        return 1;
    }
    return 0;
}

func cg_cast_emit_u64_to_f64() -> u64 {
    var l_non_negative: u64 = new_label();
    var l_done: u64 = new_label();
    emit("    test rax, rax\n");
    emit("    jns ");
    emit_label(l_non_negative);
    emit_nl();
    emit("    shr rax, 1\n");
    emit("    adc rax, 0\n");
    emit("    cvtsi2sd xmm0, rax\n");
    emit("    addsd xmm0, xmm0\n");
    emit("    jmp ");
    emit_label(l_done);
    emit_nl();
    emit_label_def(l_non_negative);
    emit("    cvtsi2sd xmm0, rax\n");
    emit_label_def(l_done);
    emit("    movq rax, xmm0\n");
    return 1;
}

func cg_cast_emit_int_to_f64(src_kind: u64) -> u64 {
    if (src_kind == TYPE_BOOL || src_kind == TYPE_U8 || src_kind == TYPE_U16 || src_kind == TYPE_U32 ||
        src_kind == TYPE_I8 || src_kind == TYPE_I16 || src_kind == TYPE_I32) {
        cg_cast_emit_int_truncate(src_kind);
    }
    if (src_kind == TYPE_U64) {
        return cg_cast_emit_u64_to_f64();
    }
    emit("    cvtsi2sd xmm0, rax\n");
    emit("    movq rax, xmm0\n");
    return 1;
}

func cg_cast_emit_f64_to_int(target_kind: u64) -> u64 {
    emit("    movq xmm0, rax\n");
    if (target_kind == TYPE_U64) {
        var l_lt_2p63: u64 = new_label();
        var l_done: u64 = new_label();
        emit("    mov rdx, 4890909195324358656\n");
        emit("    movq xmm1, rdx\n");
        emit("    ucomisd xmm0, xmm1\n");
        emit("    jb ");
        emit_label(l_lt_2p63);
        emit_nl();
        emit("    subsd xmm0, xmm1\n");
        emit("    cvttsd2si rax, xmm0\n");
        emit("    bts rax, 63\n");
        emit("    jmp ");
        emit_label(l_done);
        emit_nl();
        emit_label_def(l_lt_2p63);
        emit("    cvttsd2si rax, xmm0\n");
        emit_label_def(l_done);
        return 1;
    }
    emit("    cvttsd2si rax, xmm0\n");
    cg_cast_emit_int_truncate(target_kind);
    return 1;
}

func cg_expr_cast(node: u64, symtab: *Symtab) -> u64 {
    var cast: *AstCast = (*AstCast)node;
    var expr: u64 = cast.expr;
    if (cast.target_type == TYPE_TRAIT) {
        var src_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)expr, symtab);
        if (src_ti == 0 || src_ti.type_kind != TYPE_STRUCT || src_ti.ptr_depth == 0) {
            emit_stderr("[ERROR] Trait cast requires struct pointer source\n");
            panic("Codegen error");
        }
        var impl_info2: *TraitImpl = compiler_find_trait_impl(cast.struct_name_ptr, cast.struct_name_len, src_ti.struct_name_ptr, src_ti.struct_name_len);
        if (impl_info2 == 0) {
            emit_stderr("[ERROR] Struct does not implement trait for cast: ");
            emit_stderr_len(cast.struct_name_ptr, cast.struct_name_len);
            emit_stderr("\n");
            panic("Codegen error");
        }
        var struct_def: *AstStructDef = get_struct_def(src_ti.struct_name_ptr, src_ti.struct_name_len);
        var vptr_name: *NameInfo = compiler_build_vptr_field_name(cast.struct_name_ptr, cast.struct_name_len);
        var field_offset: u64 = 0;
        var field_desc: *FieldDesc = 0;
        var found: u64 = struct_find_field_desc_scoped(struct_def, 0, 0, vptr_name.ptr, vptr_name.len, &field_offset, &field_desc);
        if (found == 0) {
            emit_stderr("[ERROR] vptr field not found for trait cast\n");
            panic("Codegen error");
        }
        cg_expr(expr);
        if (src_ti.is_tagged == 1) { emit_tagged_mask(); }
        cg_emit_adjust_rax_add(field_offset);
        return;
    }
    if (cast.target_type == TYPE_STRUCT) {
        var src_ti2: *TypeInfo = get_expr_type_with_symtab((*AstNode)expr, symtab);
        if (src_ti2 != 0 && src_ti2.type_kind == TYPE_TRAIT && src_ti2.ptr_depth > 0) {
            var impl2: *TraitImpl = compiler_find_trait_impl(src_ti2.struct_name_ptr, src_ti2.struct_name_len, cast.struct_name_ptr, cast.struct_name_len);
            if (impl2 == 0) {
                emit_stderr("[ERROR] Trait cast target struct not implemented: ");
                emit_stderr_len(cast.struct_name_ptr, cast.struct_name_len);
                emit_stderr("\n");
                panic("Codegen error");
            }
            var struct_def2: *AstStructDef = get_struct_def(cast.struct_name_ptr, cast.struct_name_len);
            var vptr_name2: *NameInfo = compiler_build_vptr_field_name(src_ti2.struct_name_ptr, src_ti2.struct_name_len);
            var field_offset2: u64 = 0;
            var field_desc2: *FieldDesc = 0;
            var found2: u64 = struct_find_field_desc_scoped(struct_def2, 0, 0, vptr_name2.ptr, vptr_name2.len, &field_offset2, &field_desc2);
            if (found2 == 0) {
                emit_stderr("[ERROR] vptr field not found for trait cast\n");
                panic("Codegen error");
            }
            cg_expr(expr);
            if (src_ti2.is_tagged == 1) { emit_tagged_mask(); }
            cg_emit_checked_trait_to_struct_guard(impl2.vtable_global_ptr, impl2.vtable_global_len);
            cg_emit_adjust_rax_sub(field_offset2);
            return;
        }

        if (cast.target_ptr_depth > 0 && src_ti2 != 0 && src_ti2.type_kind == TYPE_STRUCT && src_ti2.ptr_depth > 0) {
            cg_expr(expr);
            if (src_ti2.is_tagged == 1) { emit_tagged_mask(); }
            if (str_eq(src_ti2.struct_name_ptr, src_ti2.struct_name_len, cast.struct_name_ptr, cast.struct_name_len) == 0 &&
                compiler_struct_is_same_or_descendant(cast.struct_name_ptr, cast.struct_name_len, src_ti2.struct_name_ptr, src_ti2.struct_name_len) != 0) {
                var check_info: CompilerDowncastCheckInfo = compiler_require_checked_struct_downcast_info(src_ti2.struct_name_ptr, src_ti2.struct_name_len, cast.struct_name_ptr, cast.struct_name_len);
                cg_emit_checked_struct_downcast_guard(check_info);
            }
            cg_try_adjust_struct_ptr_cast(src_ti2, cast.struct_name_ptr, cast.struct_name_len);
            return;
        }
    }
    var src_ti3: *TypeInfo = get_expr_type_with_symtab((*AstNode)expr, symtab);
    if (src_ti3 != 0 && src_ti3.ptr_depth == 0 && cast.target_ptr_depth == 0) {
        var src_kind: u64 = src_ti3.type_kind;
        var target_kind: u64 = cast.target_type;
        if (src_kind == target_kind) {
            cg_expr(expr);
            return;
        }
        if (cg_cast_is_int_scalar(src_kind) != 0 && cg_cast_is_int_scalar(target_kind) != 0) {
            cg_expr(expr);
            cg_cast_emit_int_truncate(target_kind);
            return;
        }
        if (cg_cast_is_int_scalar(src_kind) != 0 && target_kind == TYPE_F64) {
            cg_expr(expr);
            cg_cast_emit_int_to_f64(src_kind);
            return;
        }
        if (src_kind == TYPE_F64 && cg_cast_is_int_scalar(target_kind) != 0) {
            cg_expr(expr);
            cg_cast_emit_f64_to_int(target_kind);
            return;
        }
    }
    cg_expr(expr);
    return;
}

func cg_expr_sizeof(node: u64) -> u64 {
    var sizeof_node: *AstSizeof = (*AstSizeof)node;
    var type_kind: u64 = sizeof_node.type_kind;
    var ptr_depth: u64 = sizeof_node.ptr_depth;
    var struct_name_ptr: u64 = sizeof_node.struct_name_ptr;
    var struct_name_len: u64 = sizeof_node.struct_name_len;
    var size: u64 = 0;
    if (type_kind == TYPE_ARRAY || type_kind == TYPE_SLICE) {
        if (sizeof_node.array_len_is_param != 0) {
            emit_stderr("[ERROR] sizeof array with unresolved generic length\n");
            panic("Codegen error");
        }
        var ti_ptr: *TypeInfo = 0;
        if (type_kind == TYPE_ARRAY) {
            ti_ptr = typeinfo_make_array(ptr_depth, sizeof_node.elem_type_kind, sizeof_node.elem_ptr_depth, struct_name_ptr, struct_name_len, 0, sizeof_node.array_len);
        } else {
            ti_ptr = typeinfo_make_slice(ptr_depth, sizeof_node.elem_type_kind, sizeof_node.elem_ptr_depth, struct_name_ptr, struct_name_len, 0);
        }
        ti_ptr.elem_typeinfo = sizeof_node.elem_typeinfo;
        size = sizeof_type_ex(ti_ptr);
    } else {
        // Calculate size at compile time
        size = sizeof_type(type_kind, ptr_depth, struct_name_ptr, struct_name_len);
    }
    
    // Emit as literal constant
    emit("    mov rax, ");
    emit_u64(size);
    emit_nl();
    return;
}

func cg_expr_sizeof_expr(node: u64, symtab: *Symtab) -> u64 {
    var sz_expr: *AstSizeofExpr = (*AstSizeofExpr)node;
    var ti_ptr: *TypeInfo = get_expr_type_with_symtab((*AstNode)sz_expr.expr, symtab);
    var size_val: u64 = 8;
    if (ti_ptr != 0) {
        size_val = sizeof_type_ex(ti_ptr);
    }
    emit("    mov rax, ");
    emit_u64(size_val);
    emit_nl();
    return;
}

func cg_new_alloc_zero(size: u64) -> u64 {
    var malloc_ptr: u64 = (u64)"malloc";
    var malloc_len: u64 = 6;
    var malloc_res: *NameInfo = resolve_name(malloc_ptr, malloc_len);
    if (malloc_res != 0) {
        malloc_ptr = malloc_res.ptr;
        malloc_len = malloc_res.len;
    }

    emit("    mov rdi, ");
    emit_u64(size);
    emit_nl();
    emit("    call ");
    emit_len(malloc_ptr, malloc_len);
    emit_nl();
    emit("    mov r12, rax\n");

    var memset_ptr: u64 = (u64)"memset";
    var memset_len: u64 = 6;
    var memset_res: *NameInfo = resolve_name(memset_ptr, memset_len);
    if (memset_res != 0) {
        memset_ptr = memset_res.ptr;
        memset_len = memset_res.len;
    }

    emit("    mov rdi, r12\n");
    emit("    xor esi, esi\n");
    emit("    mov rdx, ");
    emit_u64(size);
    emit_nl();
    emit("    call ");
    emit_len(memset_ptr, memset_len);
    emit_nl();
    return 0;
}

func cg_new_invoke_constructor(nw: *AstNew, symtab: *Symtab) -> u64 {
    if (nw.ctor_args_vec == 0) {
        return 0;
    }
    if (nw.type_kind != TYPE_STRUCT) {
        emit_stderr("[ERROR] new constructor call requires struct type\n");
        panic("Codegen error");
    }

    var args: *Vec<*AstNode> = nw.ctor_args_vec;
    var resolved_ctor: CompilerMethodResolveResult = cg_resolve_constructor_call(nw.struct_name_ptr, nw.struct_name_len, args, symtab, "new", 3);
    var fn_ctor: *AstFunc = resolved_ctor.fn;
    var call_ptr: u64 = fn_ctor.name_ptr;
    var call_len: u64 = fn_ctor.name_len;
    var resolved_name: *NameInfo = resolve_name(call_ptr, call_len);
    if (resolved_name != 0) {
        call_ptr = resolved_name.ptr;
        call_len = resolved_name.len;
    }
    var nargs: u64 = args.len();
    var total_arg_words: u64 = 0;
    if (nargs != 0) {
        var ai: u64 = nargs;
        while (ai > 0) {
            ai = ai - 1;
            var arg: *AstNode = args.get(ai);
            var param: *Param = cg_call_param_at(fn_ctor, ai + 1);
            total_arg_words = total_arg_words + cg_call_push_arg_with_param(arg, param, symtab);
        }
    }
    emit("    push r12\n");
    total_arg_words = total_arg_words + 1;
    var stack_words: u64 = _cg_sysv_pop_arg_regs(total_arg_words);

    emit("    call ");
    emit_len(call_ptr, call_len);
    emit_nl();

    if (stack_words > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words * 8);
        emit_nl();
    }
    return 0;
}

func cg_expr_new(node: u64, symtab: *Symtab) -> u64 {
    var nw: *AstNew = (*AstNew)node;
    if (nw.array_len_is_param != 0) {
        emit_stderr("[ERROR] new with unresolved generic array length\n");
        panic("Codegen error");
    }

    var size: u64 = 0;
    if (nw.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = 0;
        if (nw.elem_typeinfo != 0) {
            elem_size = sizeof_type_ex(nw.elem_typeinfo);
        } else {
            elem_size = sizeof_type(nw.elem_type_kind, nw.elem_ptr_depth, nw.struct_name_ptr, nw.struct_name_len);
        }
        size = elem_size * nw.array_len;
    } else if (nw.type_kind == TYPE_SLICE) {
        size = 16;
    } else {
        size = sizeof_type(nw.type_kind, nw.ptr_depth, nw.struct_name_ptr, nw.struct_name_len);
    }

    cg_new_alloc_zero(size);

    if (nw.type_kind == TYPE_STRUCT) {
        cg_emit_trait_vptr_init_at_r12(nw.struct_name_ptr, nw.struct_name_len);
    }

    if (nw.literal_expr != 0) {
        if (ast_kind(nw.literal_expr) == AST_STRUCT_LITERAL) {
            cg_struct_literal_init_ptr(nw.literal_expr);
        }
    }

    cg_new_invoke_constructor(nw, symtab);

    emit("    mov rax, r12\n");
    return;
}

func cg_expr_try_immediate(kind: u64, node: u64) -> u64 {
    if (kind == AST_LITERAL) {
        var lit: *AstLiteral = (*AstLiteral)node;
        var val: u64 = lit.value;
        var signed_val: i64 = (i64)val;
        emit("    mov rax, ");
        if (signed_val < 0) {
            emit_i64(signed_val);
        } else {
            emit_u64(val);
        }
        emit_nl();
        return 1;
    }
    if (kind == AST_FLOAT) {
        var fl: *AstFloat = (*AstFloat)node;
        var label_id: u64 = float_get_label(fl.str_ptr, fl.str_len);
        emit("    mov rax, [rel _flt");
        emit_u64(label_id);
        emit("]\n");
        return 1;
    }
    if (kind == AST_STRING) {
        var str: *AstString = (*AstString)node;
        var label_id: u64 = string_get_label(str.str_ptr, str.str_len);
        emit("    lea rax, [rel _str");
        emit_u64(label_id);
        emit("]\n");
        return 1;
    }
    if (kind == AST_STRUCT_LITERAL) {
        emit("    xor eax, eax\n");
        return 1;
    }
    if (kind == AST_SLICE) {
        emit_stderr("[ERROR] Slice literal cannot be used as rvalue\n");
        panic("Codegen error");
        return 1;
    }
    return 0;
}

func cg_expr_dispatch_with_symtab(kind: u64, node: u64, symtab: *Symtab) -> u64 {
    if (kind == AST_IDENT) { cg_expr_ident(node, symtab); return 1; }
    if (kind == AST_MEMBER_ACCESS) { cg_member_access_expr(node, symtab); return 1; }
    if (kind == AST_SAFE_MEMBER_ACCESS) { cg_safe_member_access_expr(node, symtab); return 1; }
    if (kind == AST_BINARY) { cg_binary_expr(node, symtab); return 1; }
    if (kind == AST_UNARY) { cg_expr_unary(node, symtab); return 1; }
    if (kind == AST_TRY) { cg_try_expr(node, symtab); return 1; }
    if (kind == AST_ADDR_OF) { cg_expr_addr_of(node, symtab); return 1; }
    if (kind == AST_DEREF) { cg_expr_deref(node, symtab); return 1; }
    if (kind == AST_DEREF8) { cg_expr_deref8(node, symtab); return 1; }
    if (kind == AST_INDEX) { cg_expr_index(node, symtab); return 1; }
    if (kind == AST_CAST) { cg_expr_cast(node, symtab); return 1; }
    if (kind == AST_SIZEOF) { cg_expr_sizeof(node); return 1; }
    if (kind == AST_SIZEOF_EXPR) { cg_expr_sizeof_expr(node, symtab); return 1; }
    if (kind == AST_NEW) { cg_expr_new(node, symtab); return 1; }
    if (kind == AST_CALL) { cg_expr_call(node, symtab); return 1; }
    if (kind == AST_CALL_PTR) { cg_expr_call_ptr(node, symtab); return 1; }
    if (kind == AST_METHOD_CALL) { cg_method_call(node, symtab); return 1; }
    if (kind == AST_SAFE_METHOD_CALL) { cg_safe_method_call(node, symtab); return 1; }
    if (kind == AST_STACK_CTOR) { cg_expr_stack_ctor(node, symtab); return 1; }
    return 0;
}

func cg_expr(node: u64) -> u64 {
    var kind: u64 = ast_kind(node);
    if (cg_expr_try_immediate(kind, node) != 0) { return; }
    var symtab: *Symtab = emitter_get_symtab();
    cg_expr_dispatch_with_symtab(kind, node, symtab);
}

func cg_struct_literal_init_ptr(init: u64) -> u64 {
    var lit: *AstStructLiteral = (*AstStructLiteral)init;
    var values: *Vec<u64> = lit.values_vec;
    var num_values: u64 = values.len();
    var fields: *Vec<*FieldDesc> = lit.struct_def.fields_vec;
    var num_fields: u64 = fields.len();

    var impls: *Vec<*TraitImpl> = compiler_get_trait_impls();
    if (impls != 0) {
        var ni: u64 = impls.len();
        for (var ti: u64 = 0; ti < ni; ti++) {
            var impl_info3: *TraitImpl = impls.get(ti);
            if (!str_eq(impl_info3.struct_ptr, impl_info3.struct_len, lit.struct_def.name_ptr, lit.struct_def.name_len)) { continue; }
            var vptr_name: *NameInfo = compiler_build_vptr_field_name(impl_info3.trait_ptr, impl_info3.trait_len);
            var field_offset_v: u64 = 0;
            var field_desc_v: *FieldDesc = 0;
            var found_v: u64 = struct_find_field_desc_scoped(lit.struct_def, 0, 0, vptr_name.ptr, vptr_name.len, &field_offset_v, &field_desc_v);
            if (found_v == 0) {
                emit_stderr("[ERROR] vptr field not found for struct literal init\n");
                panic("Codegen error");
            }
            emit("    lea rax, [rel _gvar_");
            emit_len(impl_info3.vtable_global_ptr, impl_info3.vtable_global_len);
            emit("]\n");
            emit("    mov [r12");
            if (field_offset_v != 0) { emit("+"); emit_u64(field_offset_v); }
            emit("], rax\n");
        }
    }

    var field_offset: u64 = 0;
    var value_index: u64 = 0;
    for (var fi: u64 = 0; fi < num_fields && value_index < num_values; fi++) {
        var field: *FieldDesc = fields.get(fi);
        var field_size: u64 = sizeof_field_desc(field);
        if (compiler_is_vptr_field_name(field.name_ptr, field.name_len) != 0) {
            field_offset = field_offset + field_size;
            continue;
        }

        cg_expr(values.get(value_index));

        emit("    mov [r12");
        if (field_offset != 0) { emit("+"); emit_u64(field_offset); }
        emit("], rax\n");

        field_offset = field_offset + field_size;
        value_index = value_index + 1;
    }
    return 0;
}

// ============================================
// Member Access Expression
// ============================================

func cg_safe_member_access_expr(node: u64, symtab: *Symtab) -> u64 {
    var member_access: *AstMemberAccess = (*AstMemberAccess)node;
    var object: u64 = member_access.object;
    var member_ptr: u64 = member_access.member_ptr;
    var member_len: u64 = member_access.member_len;
    var parent_ptr: u64 = member_access.parent_ptr;
    var parent_len: u64 = member_access.parent_len;

    var ot: *TypeInfo = get_expr_type_with_symtab((*AstNode)object, symtab);
    if (ot == 0) {
        emit_stderr("[ERROR] Safe member access type not found\n");
        return 0;
    }
    if (ot.ptr_depth == 0) {
        emit_stderr("[ERROR] Safe member access requires pointer receiver\n");
        return 0;
    }
    if (ot.type_kind != TYPE_STRUCT) {
        emit_stderr("[ERROR] Safe member access requires struct pointer\n");
        return 0;
    }

    var label_null: u64 = new_label();
    var label_end: u64 = new_label();

    cg_expr(object);
    if (ot.is_tagged == 1) {
        emit_tagged_mask();
    }
    emit("    test rax, rax\n");
    emit("    je ");
    emit_label(label_null);
    emit_nl();

    if (ot.is_tagged == 1 && ot.tag_layout_ptr != 0) {
        var layout_info: *AstStructDef = cg_require_tagged_layout_struct(ot.tag_layout_ptr, ot.tag_layout_len);
        cg_emit_tagged_layout_extract_from_rax(layout_info, member_ptr, member_len);
        cg_emit_safe_null_epilogue(label_null, label_end);
        return 0;
    }

    var struct_def: *AstStructDef = ot.struct_def;
    if (struct_def == 0) {
        emit("    ; ERROR: Struct definition not found for pointer type\n");
        cg_emit_safe_null_epilogue(label_null, label_end);
        return 0;
    }

    var field_offset2: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found2: u64 = struct_find_field_desc_scoped(struct_def, parent_ptr, parent_len, member_ptr, member_len, &field_offset2, &field_desc);
    if (found2 == 0) { return 0; }
    if (field_desc != 0 && compiler_check_field_access(field_desc) == 0) {
        emit_stderr("[ERROR] private field access denied: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(member_ptr, member_len);
        emit_stderr("\n");
        return 0;
    }
    if (field_offset2 > 0) {
        emit("    add rax, ");
        emit_u64(field_offset2);
        emit("\n");
    }
    if (field_desc == 0) {
        cg_emit_safe_null_epilogue(label_null, label_end);
        return 0;
    }
    var fd: *FieldDesc = field_desc;
    if (fd.type_kind == TYPE_STRUCT && fd.ptr_depth == 0) {
        emit("    ; ERROR: Safe member access cannot return struct by value\n");
        cg_emit_safe_null_epilogue(label_null, label_end);
        return 0;
    }
    if (fd.type_kind == TYPE_ARRAY) {
        cg_emit_safe_null_epilogue(label_null, label_end);
        return 0;
    }
    cg_emit_field_load_from_rax(fd);

    cg_emit_safe_null_epilogue(label_null, label_end);
    return 0;
}

func cg_member_load_sized_at_rax(size_bytes: u64) -> u64 {
    if (size_bytes == 1) {
        emit("    movzx rax, byte [rax]\n");
        return 0;
    }
    if (size_bytes == 2) {
        emit("    movzx rax, word [rax]\n");
        return 0;
    }
    if (size_bytes == 4) {
        emit("    mov eax, [rax]\n");
        return 0;
    }
    emit("    mov rax, [rax]\n");
    return 0;
}

func cg_member_emit_load_or_deref(field_desc: *FieldDesc, load_when_missing: u64) -> u64 {
    if (field_desc == 0) {
        if (load_when_missing != 0) {
            emit("    mov rax, [rax]\n");
        }
        return 1;
    }
    if (field_desc.type_kind == TYPE_ARRAY) { return 1; }
    cg_emit_field_load_from_rax(field_desc);
    return 1;
}

func cg_member_emit_struct_field_at_rax(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64, load_when_missing: u64) -> u64 {
    var field_offset: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found: u64 = struct_find_field_desc_scoped(struct_def, parent_ptr, parent_len, member_ptr, member_len, &field_offset, &field_desc);
    if (found == 0) { return 0; }
    if (field_desc != 0 && compiler_check_field_access(field_desc) == 0) {
        emit_stderr("[ERROR] private field access denied: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(member_ptr, member_len);
        emit_stderr("\n");
        panic("Codegen error");
    }
    cg_member_add_offset_to_rax(field_offset);
    cg_member_emit_load_or_deref(field_desc, load_when_missing);
    return 1;
}

func cg_member_expr_tagged_layout(object: u64, ot: *TypeInfo, member_ptr: u64, member_len: u64) -> u64 {
    var layout_info: *AstStructDef = cg_require_tagged_layout_struct(ot.tag_layout_ptr, ot.tag_layout_len);
    cg_expr(object);
    cg_emit_tagged_layout_extract_from_rax(layout_info, member_ptr, member_len);
    return 0;
}

func cg_member_expr_ptr_struct(object: u64, ot: *TypeInfo, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    cg_expr(object);
    if (ot.is_tagged == 1) {
        emit_tagged_mask();
    }
    var struct_def_ptr: *AstStructDef = ot.struct_def;
    if (struct_def_ptr == 0) {
        emit("    ; ERROR: Struct definition not found for pointer type\n");
        return 0;
    }
    cg_member_emit_struct_field_at_rax(struct_def_ptr, parent_ptr, parent_len, member_ptr, member_len, 0);
    return 0;
}

func cg_member_expr_packed_struct(object: u64, struct_info: *AstStructDef, member_ptr: u64, member_len: u64) -> u64 {
    var total_bits: u64 = get_packed_layout_total_bits(struct_info);
    var field_offset: u64 = get_packed_field_bit_offset(struct_info, member_ptr, member_len);
    var field_width: u64 = get_packed_field_bit_width(struct_info, member_ptr, member_len);
    var size_bytes: u64 = (total_bits + 7) / 8;

    if (total_bits > 64 || (field_offset + field_width) > 64) {
        var byte_offset: u64 = field_offset / 8;
        var bit_shift: u64 = field_offset % 8;
        var byte_width: u64 = (field_width + 7) / 8;

        cg_lvalue(object);
        cg_member_add_offset_to_rax(byte_offset);
        cg_member_load_sized_at_rax(byte_width);

        if (bit_shift > 0) {
            emit("    mov rcx, ");
            emit_u64(bit_shift);
            emit_nl();
            emit("    shr rax, cl\n");
        }
        if (field_width < 64) {
            emit_mask_to_rdx(field_width);
            emit("    and rax, rdx\n");
        }
        return 0;
    }

    cg_lvalue(object);
    cg_member_load_sized_at_rax(size_bytes);
    if (field_offset > 0) {
        emit("    mov rcx, ");
        emit_u64(field_offset);
        emit_nl();
        emit("    shr rax, cl\n");
    }
    if (field_width < 64) {
        emit_mask_to_rdx(field_width);
        emit("    and rax, rdx\n");
    }
    return 0;
}

func cg_member_expr_deref(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    var deref_obj: *AstDeref = (*AstDeref)object;
    var ptr_expr: u64 = deref_obj.operand;

    cg_expr(ptr_expr);

    var ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)ptr_expr, symtab);
    if (ti == 0) {
        emit("    ; ERROR: Cannot determine pointer type in arrow operator\n");
        return 0;
    }
    if (ti.ptr_depth > 0 && ti.is_tagged == 1) {
        emit_tagged_mask();
    }
    if (ti.ptr_depth == 0 || ti.type_kind != TYPE_STRUCT) {
        emit("    ; ERROR: Arrow operator requires pointer to struct\n");
        return 0;
    }
    var struct_def: *AstStructDef = ti.struct_def;
    if (struct_def == 0) {
        emit("    ; ERROR: Struct definition not found for pointer type\n");
        return 0;
    }
    cg_member_emit_struct_field_at_rax(struct_def, parent_ptr, parent_len, member_ptr, member_len, 0);
    return 0;
}

func cg_member_expr_nested(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    var nt: *TypeInfo = get_expr_type_with_symtab((*AstNode)object, symtab);
    if (nt == 0) {
        emit("    ; ERROR: Nested member access type not found\n");
        return 0;
    }
    if (nt.type_kind != TYPE_STRUCT || nt.struct_def == 0) {
        emit("    ; ERROR: Nested member access on non-struct\n");
        return 0;
    }
    cg_lvalue(object);
    cg_member_emit_struct_field_at_rax(nt.struct_def, parent_ptr, parent_len, member_ptr, member_len, 1);
    return 0;
}

func cg_member_expr_indexed(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    var it: *TypeInfo = get_expr_type_with_symtab((*AstNode)object, symtab);
    if (it == 0) {
        emit("    ; ERROR: Indexed member access type not found\n");
        return 0;
    }
    if (it.type_kind != TYPE_STRUCT || it.struct_def == 0) {
        emit("    ; ERROR: Indexed member access on non-struct\n");
        return 0;
    }
    cg_lvalue(object);
    cg_member_emit_struct_field_at_rax(it.struct_def, parent_ptr, parent_len, member_ptr, member_len, 1);
    return 0;
}

func cg_member_expr_ident(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    var obj_ident: *AstIdent = (*AstIdent)object;
    var obj_name_ptr: u64 = obj_ident.name_ptr;
    var obj_name_len: u64 = obj_ident.name_len;

    var resolved_ptr: u64 = obj_name_ptr;
    var resolved_len: u64 = obj_name_len;
    var resolved: *NameInfo = resolve_name(obj_name_ptr, obj_name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }

    var ginfo: *GlobalInfo = _cg_find_global_info(resolved_ptr, resolved_len);
    if (ginfo == 0 && (resolved_ptr != obj_name_ptr || resolved_len != obj_name_len)) {
        ginfo = _cg_find_global_info(obj_name_ptr, obj_name_len);
    }
    if (ginfo != 0) {
        var struct_def_g: *AstStructDef = 0;
        var gti: *TypeInfo = ginfo.typeinfo_ptr;
        if (gti != 0) {
            if (gti.struct_def == 0 && gti.struct_name_ptr != 0) {
                gti.struct_def = get_struct_def(gti.struct_name_ptr, gti.struct_name_len);
            }
            struct_def_g = gti.struct_def;
        }
        if (struct_def_g == 0) {
            emit("    ; ERROR: Struct definition not found in global lvalue\n");
            return 0;
        }
        emit("    lea rax, [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        cg_member_emit_struct_field_at_rax(struct_def_g, parent_ptr, parent_len, member_ptr, member_len, 1);
        return 0;
    }

    var var_offset: u64 = symtab_find(symtab, obj_name_ptr, obj_name_len);
    var var_ti: *TypeInfo = symtab_get_type(symtab, obj_name_ptr, obj_name_len);
    if (var_ti == 0) {
        emit("    ; ERROR: Member access type not found in symtab\n");
        return 0;
    }
    if (var_ti.type_kind != TYPE_STRUCT) {
        emit("    ; ERROR: Member access on non-struct type\n");
        return 0;
    }

    var struct_def: *AstStructDef = var_ti.struct_def;
    if (struct_def == 0) {
        emit("    ; ERROR: Struct definition not found in type_info\n");
        return 0;
    }

    emit("    lea rax, [rbp");
    emit_signed_disp(var_offset);
    emit("]\n");
    cg_member_emit_struct_field_at_rax(struct_def, parent_ptr, parent_len, member_ptr, member_len, 1);
    return 0;
}

func cg_member_access_expr(node: u64, symtab: *Symtab) -> u64 {
    var member_access: *AstMemberAccess = (*AstMemberAccess)node;
    var object: u64 = member_access.object;
    var member_ptr: u64 = member_access.member_ptr;
    var member_len: u64 = member_access.member_len;
    var parent_ptr: u64 = member_access.parent_ptr;
    var parent_len: u64 = member_access.parent_len;

    if (ast_kind(object) == AST_IDENT && parent_ptr == 0) {
        var scope_id: *AstIdent = (*AstIdent)object;
        var scope_local_ti: *TypeInfo = symtab_get_type(symtab, scope_id.name_ptr, scope_id.name_len);
        var scope_global_ptr: u64 = scope_id.name_ptr;
        var scope_global_len: u64 = scope_id.name_len;
        var scope_resolved: *NameInfo = resolve_name(scope_id.name_ptr, scope_id.name_len);
        if (scope_resolved != 0) {
            scope_global_ptr = scope_resolved.ptr;
            scope_global_len = scope_resolved.len;
        }
        var scope_global: *GlobalInfo = _cg_find_global_info(scope_global_ptr, scope_global_len);
        if (scope_global == 0 && (scope_global_ptr != scope_id.name_ptr || scope_global_len != scope_id.name_len)) {
            scope_global = _cg_find_global_info(scope_id.name_ptr, scope_id.name_len);
        }
        if (scope_local_ti == 0 && scope_global == 0) {
            var scoped_const: *ConstResult = (*ConstResult)compiler_find_scoped_const(scope_id.name_ptr, scope_id.name_len, member_ptr, member_len);
            if (scoped_const != 0 && scoped_const.found != 0) {
                emit("    mov rax, ");
                emit_u64(scoped_const.value);
                emit_nl();
                return;
            }
        }
    }

    var ot: *TypeInfo = get_expr_type_with_symtab((*AstNode)object, symtab);
    if (ot != 0) {
        if (ot.ptr_depth > 0 && ot.is_tagged == 1 && ot.tag_layout_ptr != 0) {
            cg_member_expr_tagged_layout(object, ot, member_ptr, member_len);
            return;
        }
        if (ot.ptr_depth > 0 && ot.type_kind == TYPE_STRUCT) {
            cg_member_expr_ptr_struct(object, ot, parent_ptr, parent_len, member_ptr, member_len);
            return;
        }
        if (ot.ptr_depth == 0 && ot.type_kind == TYPE_STRUCT && ot.struct_def != 0 && ot.struct_def.is_packed == 1) {
            cg_member_expr_packed_struct(object, ot.struct_def, member_ptr, member_len);
            return;
        }
    }

    var obj_kind: u64 = ast_kind(object);
    if (obj_kind == AST_DEREF) {
        cg_member_expr_deref(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }
    if (obj_kind == AST_MEMBER_ACCESS) {
        cg_member_expr_nested(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }
    if (obj_kind == AST_INDEX) {
        cg_member_expr_indexed(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }
    if (obj_kind == AST_IDENT) {
        cg_member_expr_ident(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }

    emit("    ; ERROR: Member access on non-identifier\n");
}

// ============================================
// Binary Expression
// ============================================

func cg_binary_short_circuit_and(left: u64, right: u64) -> u64 {
    var l_false: u64 = new_label();
    var l_end: u64 = new_label();

    cg_expr(left);
    emit("    test rax, rax\n");
    emit("    jz ");
    emit_label(l_false);
    emit("\n");

    cg_expr(right);
    emit("    test rax, rax\n");
    emit("    setne al\n");
    emit("    movzx rax, al\n");
    emit("    jmp ");
    emit_label(l_end);
    emit("\n");

    emit_label_def(l_false);
    emit("    xor eax, eax\n");
    emit_label_def(l_end);
    return;
}

func cg_binary_short_circuit_or(left: u64, right: u64) -> u64 {
    var l_true: u64 = new_label();
    var l_end: u64 = new_label();

    cg_expr(left);
    emit("    test rax, rax\n");
    emit("    jnz ");
    emit_label(l_true);
    emit("\n");

    cg_expr(right);
    emit("    test rax, rax\n");
    emit("    setne al\n");
    emit("    movzx rax, al\n");
    emit("    jmp ");
    emit_label(l_end);
    emit("\n");

    emit_label_def(l_true);
    emit("    mov eax, 1\n");
    emit_label_def(l_end);
    return;
}

func cg_binary_emit_float_op(op: u64) -> u64 {
    if (op == TOKEN_PLUS) { emit("    addsd xmm0, xmm1\n"); }
    else if (op == TOKEN_MINUS) { emit("    subsd xmm0, xmm1\n"); }
    else if (op == TOKEN_STAR) { emit("    mulsd xmm0, xmm1\n"); }
    else if (op == TOKEN_SLASH) { emit("    divsd xmm0, xmm1\n"); }
    else if (op == TOKEN_LT || op == TOKEN_GT || op == TOKEN_LTEQ || op == TOKEN_GTEQ || op == TOKEN_EQEQ || op == TOKEN_BANGEQ) {
        emit("    ucomisd xmm0, xmm1\n");
        if (op == TOKEN_LT) { emit("    setb al\n"); }
        else if (op == TOKEN_GT) { emit("    seta al\n"); }
        else if (op == TOKEN_LTEQ) { emit("    setbe al\n"); }
        else if (op == TOKEN_GTEQ) { emit("    setae al\n"); }
        else if (op == TOKEN_EQEQ) { emit("    sete al\n"); }
        else if (op == TOKEN_BANGEQ) { emit("    setne al\n"); }
        emit("    movzx rax, al\n");
        return 1;
    } else {
        emit_stderr("[ERROR] Unsupported float operator\n");
        panic("Codegen error");
    }
    emit("    movq rax, xmm0\n");
    return 1;
}

func cg_binary_emit_int_op(op: u64, use_signed: u64) -> u64 {
    // Arithmetic operators
    if (op == TOKEN_PLUS) { emit("    add rax, rbx\n"); }
    else if (op == TOKEN_MINUS) { emit("    sub rax, rbx\n"); }
    else if (op == TOKEN_STAR) { emit("    imul rax, rbx\n"); }
    else if (op == TOKEN_SLASH) {
        if (use_signed == 1) {
            emit("    cqo\n");
            emit("    idiv rbx\n");
        } else {
            emit("    xor rdx, rdx\n");
            emit("    div rbx\n");
        }
    }
    else if (op == TOKEN_PERCENT) {
        if (use_signed == 1) {
            emit("    cqo\n");
            emit("    idiv rbx\n");
        } else {
            emit("    xor rdx, rdx\n");
            emit("    div rbx\n");
        }
        emit("    mov rax, rdx\n");
    }
    // Bitwise operators
    else if (op == TOKEN_CARET) { emit("    xor rax, rbx\n"); }
    else if (op == TOKEN_AMPERSAND) { emit("    and rax, rbx\n"); }
    else if (op == TOKEN_PIPE) { emit("    or rax, rbx\n"); }
    // Shift operators
    else if (op == TOKEN_LSHIFT) {
        emit("    mov rcx, rbx\n");
        emit("    shl rax, cl\n");
    }
    else if (op == TOKEN_RSHIFT) {
        emit("    mov rcx, rbx\n");
        if (use_signed == 1) { emit("    sar rax, cl\n"); }
        else { emit("    shr rax, cl\n"); }
    }
    // Comparison operators
    else if (op == TOKEN_LT) {
        emit("    cmp rax, rbx\n");
        if (use_signed == 1) { emit("    setl al\n"); }
        else { emit("    setb al\n"); }
        emit("    movzx rax, al\n");
    }
    else if (op == TOKEN_GT) {
        emit("    cmp rax, rbx\n");
        if (use_signed == 1) { emit("    setg al\n"); }
        else { emit("    seta al\n"); }
        emit("    movzx rax, al\n");
    }
    else if (op == TOKEN_LTEQ) {
        emit("    cmp rax, rbx\n");
        if (use_signed == 1) { emit("    setle al\n"); }
        else { emit("    setbe al\n"); }
        emit("    movzx rax, al\n");
    }
    else if (op == TOKEN_GTEQ) {
        emit("    cmp rax, rbx\n");
        if (use_signed == 1) { emit("    setge al\n"); }
        else { emit("    setae al\n"); }
        emit("    movzx rax, al\n");
    }
    else if (op == TOKEN_EQEQ) {
        emit("    cmp rax, rbx\n");
        emit("    sete al\n");
        emit("    movzx rax, al\n");
    }
    else if (op == TOKEN_BANGEQ) {
        emit("    cmp rax, rbx\n");
        emit("    setne al\n");
        emit("    movzx rax, al\n");
    }
    return;
}

func cg_binary_emit_int_rax_to_f64(ti: *TypeInfo) -> u64 {
    if (ti != 0 && ti.ptr_depth == 0) {
        if (ti.type_kind == TYPE_I8) { emit("    movsx rax, al\n"); }
        else if (ti.type_kind == TYPE_I16) { emit("    movsx rax, ax\n"); }
        else if (ti.type_kind == TYPE_I32) { emit("    movsxd rax, eax\n"); }
        else if (ti.type_kind == TYPE_U8 || ti.type_kind == TYPE_BOOL) { emit("    movzx eax, al\n"); }
        else if (ti.type_kind == TYPE_U16) { emit("    movzx eax, ax\n"); }
        else if (ti.type_kind == TYPE_U32) { emit("    mov eax, eax\n"); }
    }
    emit("    cvtsi2sd xmm0, rax\n");
    return 0;
}

func cg_binary_emit_int_rbx_to_f64(ti: *TypeInfo) -> u64 {
    if (ti != 0 && ti.ptr_depth == 0) {
        if (ti.type_kind == TYPE_I8) { emit("    movsx rbx, bl\n"); }
        else if (ti.type_kind == TYPE_I16) { emit("    movsx rbx, bx\n"); }
        else if (ti.type_kind == TYPE_I32) { emit("    movsxd rbx, ebx\n"); }
        else if (ti.type_kind == TYPE_U8 || ti.type_kind == TYPE_BOOL) { emit("    movzx ebx, bl\n"); }
        else if (ti.type_kind == TYPE_U16) { emit("    movzx ebx, bx\n"); }
        else if (ti.type_kind == TYPE_U32) { emit("    mov ebx, ebx\n"); }
    }
    emit("    cvtsi2sd xmm1, rbx\n");
    return 0;
}

func cg_binary_expr(node: u64, symtab: *Symtab) -> u64 {
    var binary: *AstBinary = (*AstBinary)node;
    var op: u64 = binary.op;
    var left: u64 = binary.left;
    var right: u64 = binary.right;

    // Short-circuit evaluation for && and ||
    if (op == TOKEN_ANDAND) {
        cg_binary_short_circuit_and(left, right);
        return;
    }

    if (op == TOKEN_OROR) {
        cg_binary_short_circuit_or(left, right);
        return;
    }
    
    // Standard binary: evaluate both sides
    cg_expr(left);
    emit("    push rax\n");
    cg_expr(right);
    emit("    mov rbx, rax\n");
    emit("    pop rax\n");

    var left_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)left, symtab);
    var right_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)right, symtab);
    var l_is_f: u64 = 0;
    var r_is_f: u64 = 0;
    if (left_ti != 0) { l_is_f = (left_ti.ptr_depth == 0 && left_ti.type_kind == TYPE_F64); }
    if (right_ti != 0) { r_is_f = (right_ti.ptr_depth == 0 && right_ti.type_kind == TYPE_F64); }
    if (l_is_f != 0 || r_is_f != 0) {
        if (l_is_f == 0 && left_ti != 0 && left_ti.ptr_depth > 0) {
            emit_stderr("[ERROR] Float/integer binary operation does not support pointer operands\n");
            panic("Codegen error");
        }
        if (r_is_f == 0 && right_ti != 0 && right_ti.ptr_depth > 0) {
            emit_stderr("[ERROR] Float/integer binary operation does not support pointer operands\n");
            panic("Codegen error");
        }

        if (l_is_f != 0) { emit("    movq xmm0, rax\n"); }
        else { cg_binary_emit_int_rax_to_f64(left_ti); }

        if (r_is_f != 0) { emit("    movq xmm1, rbx\n"); }
        else { cg_binary_emit_int_rbx_to_f64(right_ti); }

        cg_binary_emit_float_op(op);
        return;
    }
    
    // Pointer arithmetic scaling
    var left_ti2: *TypeInfo = left_ti;
    if (left_ti2 == 0) { left_ti2 = typeinfo_make(TYPE_I64, 0); }
    var ptr_depth: u64 = left_ti2.ptr_depth;
    var use_signed: u64 = 0;
    if (left_ti2.ptr_depth == 0 &&
        (left_ti2.type_kind == TYPE_I8 || left_ti2.type_kind == TYPE_I16 ||
         left_ti2.type_kind == TYPE_I32 || left_ti2.type_kind == TYPE_I64)) {
        use_signed = 1;
    }
    
    if (ptr_depth > 0) {
        if (op == TOKEN_PLUS || op == TOKEN_MINUS) {
            var psize: u64 = get_pointee_size(left_ti2.type_kind, ptr_depth);
            if (psize > 1) {
                emit("    imul rbx, ");
                emit_u64(psize);
                emit_nl();
            }
        }
    }
    
    cg_binary_emit_int_op(op, use_signed);
}

// ============================================
// LValue Codegen
// ============================================

func cg_lvalue(node: u64) -> u64 {
    var kind: u64 = ast_kind(node);
    var symtab: *Symtab = emitter_get_symtab();
    
    if (kind == AST_IDENT) {
        var ident: *AstIdent = (*AstIdent)node;
        var name_ptr: u64 = ident.name_ptr;
        var name_len: u64 = ident.name_len;

        var resolved_ptr: u64 = name_ptr;
        var resolved_len: u64 = name_len;
        var resolved: *NameInfo = resolve_name(name_ptr, name_len);
        if (resolved != 0) {
            resolved_ptr = resolved.ptr;
            resolved_len = resolved.len;
        }

        if (is_global_var(resolved_ptr, resolved_len)) {
            emit("    lea rax, [rel _gvar_");
            emit_len(resolved_ptr, resolved_len);
            emit("]\n");
            return;
        }
        
        var offset: u64 = symtab_find(symtab, name_ptr, name_len);
        
        emit("    lea rax, [rbp");
        emit_signed_disp(offset);
        emit("]\n");
        return;
    }

    if (kind == AST_CAST) {
        var cast_node: *AstCast = (*AstCast)node;
        cg_lvalue(cast_node.expr);
        return;
    }
    
    if (kind == AST_DEREF) {
        var deref: *AstDeref = (*AstDeref)node;
        var operand: u64 = deref.operand;
        cg_expr(operand);
        var ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)operand, symtab);
        if (ti != 0) {
            if (ti.ptr_depth > 0 && ti.is_tagged == 1) {
                emit_tagged_mask();
            }
        }
        return;
    }
    
    if (kind == AST_DEREF8) {
        var deref8: *AstDeref8 = (*AstDeref8)node;
        var operand: u64 = deref8.operand;
        cg_expr(operand);
        var ti2: *TypeInfo = get_expr_type_with_symtab((*AstNode)operand, symtab);
        if (ti2 != 0) {
            if (ti2.ptr_depth > 0 && ti2.is_tagged == 1) {
                emit_tagged_mask();
            }
        }
        return;
    }

    if (kind == AST_INDEX) {
        cg_index_addr(node, symtab);
        return;
    }
    
    if (kind == AST_MEMBER_ACCESS) {
        cg_member_access_lvalue(node, symtab);
        return;
    }

    if (kind == AST_SAFE_MEMBER_ACCESS) {
        emit_stderr("[ERROR] Safe member access cannot be used as lvalue\n");
        return;
    }
}

// ============================================
// Member Access LValue
// ============================================

func cg_member_add_offset_to_rax(field_offset: u64) -> u64 {
    if (field_offset == 0) { return 0; }
    emit("    add rax, ");
    emit_u64(field_offset);
    emit("\n");
    return 0;
}

struct CgMemberFieldOffsetInfo {
    public found: u64;
    public offset: u64;
}

func cg_member_resolve_field_offset(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> CgMemberFieldOffsetInfo {
    var info: CgMemberFieldOffsetInfo;
    info.found = 0;
    info.offset = 0;
    if (struct_def == 0) { return info; }
    var field_offset: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found: u64 = struct_find_field_desc_scoped(struct_def, parent_ptr, parent_len, member_ptr, member_len, &field_offset, &field_desc);
    if (found == 0) { return info; }
    if (field_desc != 0 && compiler_check_field_access(field_desc) == 0) {
        emit_stderr("[ERROR] private field access denied: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(member_ptr, member_len);
        emit_stderr("\n");
        panic("Codegen error");
    }
    info.found = 1;
    info.offset = field_offset;
    return info;
}

func cg_member_lvalue_ptr_struct(object: u64, obj_ti: *TypeInfo, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    cg_expr(object);
    if (obj_ti.is_tagged == 1) {
        emit_tagged_mask();
    }
    var struct_def_ptr: *AstStructDef = obj_ti.struct_def;
    if (struct_def_ptr == 0) {
        emit("    ; ERROR: Struct definition not found for pointer type\n");
        return 0;
    }
    var field_info_ptr: CgMemberFieldOffsetInfo = cg_member_resolve_field_offset(struct_def_ptr, parent_ptr, parent_len, member_ptr, member_len);
    if (field_info_ptr.found == 0) { return 0; }
    var field_offset_ptr: u64 = field_info_ptr.offset;
    cg_member_add_offset_to_rax(field_offset_ptr);
    return 1;
}

func cg_member_lvalue_deref(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    var deref_obj: *AstDeref = (*AstDeref)object;
    var ptr_expr: u64 = deref_obj.operand;
    
    // Evaluate pointer expression to get pointer value
    cg_expr(ptr_expr);
    
    // Get pointer type to find struct_def
    var ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)ptr_expr, symtab);
    if (ti == 0) {
        emit("    ; ERROR: Cannot determine pointer type in arrow operator\n");
        return 1;
    }

    var base_type: u64 = ti.type_kind;
    var ptr_depth: u64 = ti.ptr_depth;
    if (ptr_depth > 0 && ti.is_tagged == 1) {
        emit_tagged_mask();
    }
    emit("    push rax\n");
    
    if (ptr_depth == 0 || base_type != TYPE_STRUCT) {
        emit("    ; ERROR: Arrow operator requires pointer to struct\n");
        return 1;
    }
    
    // Get struct_def from pointer's base type
    var struct_def: *AstStructDef = ti.struct_def;
    if (struct_def == 0) {
        emit("    ; ERROR: Struct definition not found for pointer type\n");
        return 1;
    }
    
    var field_info: CgMemberFieldOffsetInfo = cg_member_resolve_field_offset(struct_def, parent_ptr, parent_len, member_ptr, member_len);
    if (field_info.found == 0) { return 1; }
    var field_offset: u64 = field_info.offset;
    
    // Pop pointer value and add field offset
    emit("    pop rax\n");
    cg_member_add_offset_to_rax(field_offset);
    return 1;
}

func cg_member_lvalue_nested(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    // Recursively get the address of the nested object
    cg_lvalue(object);
    emit("    push rax\n");
    
    // Get the type of the nested object
    var obj_lv_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)object, symtab);
    if (obj_lv_ti == 0) {
        emit("    ; ERROR: Cannot determine type of nested member in lvalue\n");
        return 1;
    }
    var base_type: u64 = obj_lv_ti.type_kind;
    if (base_type != TYPE_STRUCT) {
        emit("    ; ERROR: Nested member access on non-struct in lvalue\n");
        return 1;
    }
    
    var struct_def: *AstStructDef = obj_lv_ti.struct_def;
    if (struct_def == 0) {
        emit("    ; ERROR: Struct definition not found for nested lvalue\n");
        return 1;
    }
    
    var field_info2: CgMemberFieldOffsetInfo = cg_member_resolve_field_offset(struct_def, parent_ptr, parent_len, member_ptr, member_len);
    if (field_info2.found == 0) { return 1; }
    var field_offset: u64 = field_info2.offset;
    
    // Pop base address and add field offset
    emit("    pop rax\n");
    cg_member_add_offset_to_rax(field_offset);
    return 1;
}

func cg_member_lvalue_index(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    cg_lvalue(object);
    emit("    push rax\n");

    var idx_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)object, symtab);
    if (idx_ti == 0) {
        emit("    ; ERROR: Cannot determine type of indexed member in lvalue\n");
        return 1;
    }
    if (idx_ti.type_kind != TYPE_STRUCT) {
        emit("    ; ERROR: Indexed member access on non-struct in lvalue\n");
        return 1;
    }
    var idx_struct_def: *AstStructDef = idx_ti.struct_def;
    if (idx_struct_def == 0) {
        emit("    ; ERROR: Struct definition not found for indexed lvalue\n");
        return 1;
    }

    var idx_field_info: CgMemberFieldOffsetInfo = cg_member_resolve_field_offset(idx_struct_def, parent_ptr, parent_len, member_ptr, member_len);
    if (idx_field_info.found == 0) { return 1; }
    var idx_field_offset: u64 = idx_field_info.offset;
    emit("    pop rax\n");
    cg_member_add_offset_to_rax(idx_field_offset);
    return 1;
}

func cg_member_lvalue_ident(object: u64, symtab: *Symtab, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    var obj_ident: *AstIdent = (*AstIdent)object;
    var obj_name_ptr: u64 = obj_ident.name_ptr;
    var obj_name_len: u64 = obj_ident.name_len;

    var resolved_ptr: u64 = obj_name_ptr;
    var resolved_len: u64 = obj_name_len;
    var resolved: *NameInfo = resolve_name(obj_name_ptr, obj_name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    var ginfo: *GlobalInfo = _cg_find_global_info(resolved_ptr, resolved_len);
    if (ginfo == 0 && (resolved_ptr != obj_name_ptr || resolved_len != obj_name_len)) {
        ginfo = _cg_find_global_info(obj_name_ptr, obj_name_len);
    }
    if (ginfo != 0) {
        var struct_def_g: *AstStructDef = 0;
        var gti: *TypeInfo = ginfo.typeinfo_ptr;
        if (gti != 0) {
            if (gti.struct_def == 0 && gti.struct_name_ptr != 0) {
                gti.struct_def = get_struct_def(gti.struct_name_ptr, gti.struct_name_len);
            }
            struct_def_g = gti.struct_def;
        }
        if (struct_def_g == 0) {
            emit("    ; ERROR: Struct definition not found in global lvalue\n");
            return 1;
        }
        var field_info_g: CgMemberFieldOffsetInfo = cg_member_resolve_field_offset(struct_def_g, parent_ptr, parent_len, member_ptr, member_len);
        if (field_info_g.found == 0) { return 1; }
        var field_offset_g: u64 = field_info_g.offset;
        emit("    lea rax, [rel _gvar_");
        emit_len(resolved_ptr, resolved_len);
        emit("]\n");
        cg_member_add_offset_to_rax(field_offset_g);
        return 1;
    }
    
    // Get variable info from symtab
    var var_offset: u64 = symtab_find(symtab, obj_name_ptr, obj_name_len);
    var var_type: *TypeInfo = symtab_get_type(symtab, obj_name_ptr, obj_name_len);
    
    // Get struct_def directly from type_info
    var struct_def: *AstStructDef = 0;
    if (var_type != 0) {
        struct_def = var_type.struct_def;
    }
    
    if (struct_def == 0) {
        emit("    ; ERROR: Struct definition not found in lvalue\n");
        return 1;
    }
    
    var field_info3: CgMemberFieldOffsetInfo = cg_member_resolve_field_offset(struct_def, parent_ptr, parent_len, member_ptr, member_len);
    if (field_info3.found == 0) { return 1; }
    var field_offset: u64 = field_info3.offset;
    
    // Calculate address: lea rax, [rbp + var_offset + field_offset]
    emit("    lea rax, [rbp");
    var total_offset: u64 = var_offset + field_offset;
    emit_signed_disp(total_offset);
    emit("]\n");
    return 1;
}

func cg_member_access_lvalue(node: u64, symtab: *Symtab) -> u64 {
    var member_access: *AstMemberAccess = (*AstMemberAccess)node;
    var object: u64 = member_access.object;
    var member_ptr: u64 = member_access.member_ptr;
    var member_len: u64 = member_access.member_len;
    var parent_ptr: u64 = member_access.parent_ptr;
    var parent_len: u64 = member_access.parent_len;

    if (ast_kind(object) == AST_IDENT && parent_ptr == 0) {
        var scope_id2: *AstIdent = (*AstIdent)object;
        var scoped_const2: *ConstResult = (*ConstResult)compiler_find_scoped_const(scope_id2.name_ptr, scope_id2.name_len, member_ptr, member_len);
        if (scoped_const2 != 0 && scoped_const2.found != 0) {
            emit_stderr("[ERROR] Cannot assign to enum member constant: ");
            emit_stderr_len(scope_id2.name_ptr, scope_id2.name_len);
            emit_stderr(".");
            emit_stderr_len(member_ptr, member_len);
            emit_stderr("\n");
            panic("Codegen error");
            return;
        }
    }

    var obj_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)object, symtab);
    if (obj_ti != 0 && obj_ti.ptr_depth > 0 && obj_ti.type_kind == TYPE_STRUCT) {
        cg_member_lvalue_ptr_struct(object, obj_ti, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }

    var obj_kind: u64 = ast_kind(object);

    if (obj_kind == AST_DEREF) {
        cg_member_lvalue_deref(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }

    if (obj_kind == AST_MEMBER_ACCESS) {
        cg_member_lvalue_nested(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }

    if (obj_kind == AST_INDEX) {
        cg_member_lvalue_index(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }

    if (obj_kind == AST_IDENT) {
        cg_member_lvalue_ident(object, symtab, parent_ptr, parent_len, member_ptr, member_len);
        return;
    }

    emit("    ; ERROR: Member access on non-identifier in lvalue\n");
}

// ============================================
// Method Call Code Generation
// ============================================

func cg_method_push_user_args(args: *Vec<*AstNode>, nargs: u64, fn_sig: *AstFunc, param_base_index: u64, symtab: *Symtab) -> u64 {
    var total_arg_words: u64 = 0;
    if (nargs != 0) {
        var i: u64 = nargs;
        while (i > 0) {
            i = i - 1;
            var arg: *AstNode = args.get(i);
            var param: *Param = cg_call_param_at(fn_sig, param_base_index + i);
            total_arg_words = total_arg_words + cg_call_push_arg_with_param(arg, param, symtab);
        }
    }
    return total_arg_words;
}

func cg_method_push_receiver_from_tmp(tmp_offset: u64) -> u64 {
    emit("    mov rax, [rbp");
    emit_signed_disp(tmp_offset);
    emit("]\n");
    emit("    push rax\n");
    return 1;
}

func cg_method_push_receiver(receiver: u64, recv_ti: *TypeInfo, recv_is_ptr: u64) -> u64 {
    if (recv_is_ptr != 0) {
        cg_expr(receiver);
        if (recv_ti != 0 && recv_ti.is_tagged == 1) {
            emit_tagged_mask();
        }
    } else {
        cg_lvalue(receiver);
    }
    emit("    push rax\n");
    return 1;
}

func cg_find_trait_method_sig(trait_ptr: u64, trait_len: u64, method_ptr: u64, method_len: u64) -> *AstFunc {
    var trait_def: *TraitDef = compiler_get_trait_def(trait_ptr, trait_len);
    if (trait_def == 0 || trait_def.methods_vec == 0) { return 0; }
    var method_index: u64 = compiler_find_trait_method_index(trait_ptr, trait_len, method_ptr, method_len);
    if (compiler_is_not_found_u64(method_index) != 0) { return 0; }
    if (method_index >= trait_def.methods_vec.len()) { return 0; }
    var method_desc: *TraitMethod = trait_def.methods_vec.get(method_index);
    if (method_desc == 0) { return 0; }
    return method_desc.sig;
}

func cg_method_try_normalize_named_args(method_call: *AstMethodCall, recv_ti: *TypeInfo) -> *AstFunc {
    if (method_call == 0) { return 0; }
    if (compiler_call_has_named_args(method_call.arg_names_vec) == 0) { return 0; }

    var args: *Vec<*AstNode> = method_call.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }

    var fn_sig: *AstFunc = 0;
    if (recv_ti != 0 && (recv_ti.type_kind == TYPE_TRAIT || compiler_is_trait_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len) != 0)) {
        fn_sig = cg_find_trait_method_sig(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_call.method_ptr, method_call.method_len);
    } else if (recv_ti != 0 && recv_ti.type_kind == TYPE_STRUCT) {
        var owner_ptr: u64 = recv_ti.struct_name_ptr;
        var owner_len: u64 = recv_ti.struct_name_len;
        if ((owner_ptr == 0 || owner_len == 0) && recv_ti.struct_def != 0) {
            owner_ptr = recv_ti.struct_def.name_ptr;
            owner_len = recv_ti.struct_def.name_len;
        }
        if (owner_ptr != 0 && owner_len != 0) {
            var resolved: CompilerMethodResolveResult = compiler_resolve_method_overload_with_count_fallback(owner_ptr, owner_len, method_call.method_ptr, method_call.method_len, 0, nargs);
            if (resolved.found != 0 && resolved.fn != 0) {
                fn_sig = resolved.fn;
            } else if (recv_ti.struct_def != 0) {
                fn_sig = compiler_find_method_func_in_hierarchy(recv_ti.struct_def, method_call.method_ptr, method_call.method_len);
            }
        }
    }

    if (fn_sig == 0) {
        emit_stderr("[ERROR] named arguments require a known method signature: ");
        if (recv_ti != 0 && recv_ti.struct_name_ptr != 0 && recv_ti.struct_name_len != 0) {
            emit_stderr_len(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
            emit_stderr(".");
        }
        emit_stderr_len(method_call.method_ptr, method_call.method_len);
        emit_stderr("\n");
        panic("Codegen error");
    }

    var params_start: u64 = compiler_method_param_start_index(fn_sig);
    method_call.args_vec = compiler_normalize_call_args_for_params(method_call.method_ptr, method_call.method_len, fn_sig.params_vec, params_start, method_call.args_vec, method_call.arg_names_vec);
    method_call.arg_names_vec = 0;
    return fn_sig;
}

func cg_method_find_virtual_vptr_offset(recv_ti: *TypeInfo, trait_ptr: u64, trait_len: u64) -> u64 {
    if (recv_ti == 0) { return COMPILER_NOT_FOUND_U64; }
    var struct_def: *AstStructDef = recv_ti.struct_def;
    if (struct_def == 0) {
        struct_def = get_struct_def(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
    }
    if (struct_def == 0) { return COMPILER_NOT_FOUND_U64; }
    var vptr_name: *NameInfo = compiler_build_vptr_field_name(trait_ptr, trait_len);
    var field_offset: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found: u64 = struct_find_field_desc_scoped(struct_def, 0, 0, vptr_name.ptr, vptr_name.len, &field_offset, &field_desc);
    if (found == 0) { return COMPILER_NOT_FOUND_U64; }
    return field_offset;
}

func cg_method_push_virtual_receiver(receiver: u64, recv_ti: *TypeInfo, trait_ptr: u64, trait_len: u64) -> u64 {
    var off: u64 = cg_method_find_virtual_vptr_offset(recv_ti, trait_ptr, trait_len);
    if (compiler_is_not_found_u64(off) != 0) {
        emit_stderr("[ERROR] virtual dispatch vptr not found: ");
        emit_stderr_len(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
        emit_stderr("\n");
        panic("Codegen error");
    }
    cg_expr(receiver);
    if (recv_ti != 0 && recv_ti.is_tagged == 1) {
        emit_tagged_mask();
    }
    if (off != 0) {
        emit("    add rax, ");
        emit_u64(off);
        emit_nl();
    }
    emit("    push rax\n");
    return 1;
}

func cg_method_push_virtual_receiver_from_tmp(tmp_offset: u64, recv_ti: *TypeInfo, trait_ptr: u64, trait_len: u64) -> u64 {
    var off: u64 = cg_method_find_virtual_vptr_offset(recv_ti, trait_ptr, trait_len);
    if (compiler_is_not_found_u64(off) != 0) {
        emit_stderr("[ERROR] virtual dispatch vptr not found: ");
        emit_stderr_len(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
        emit_stderr("\n");
        panic("Codegen error");
    }
    emit("    mov rax, [rbp");
    emit_signed_disp(tmp_offset);
    emit("]\n");
    if (off != 0) {
        emit("    add rax, ");
        emit_u64(off);
        emit_nl();
    }
    emit("    push rax\n");
    return 1;
}

func cg_method_stack_cleanup(stack_words: u64) -> u64 {
    if (stack_words > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words * 8);
        emit_nl();
    }
    return 0;
}

func cg_method_emit_trait_vtable_call(method_index: u64, stack_words: u64) -> u64 {
    emit("    mov rax, [rdi]\n");
    if (method_index != 0) {
        emit("    add rax, ");
        emit_u64(method_index * 8);
        emit_nl();
    }
    emit("    mov rax, [rax]\n");
    emit("    call rax\n");
    cg_method_stack_cleanup(stack_words);
    return 0;
}

func cg_method_emit_direct_call(resolved_ptr: u64, resolved_len: u64, stack_words: u64) -> u64 {
    emit("    call ");
    emit_len(resolved_ptr, resolved_len);
    emit_nl();
    cg_method_stack_cleanup(stack_words);
    return 0;
}

func cg_method_prepare_safe_receiver(receiver: u64, recv_ti: *TypeInfo, label_null: u64, symtab: *Symtab, out_tmp_offset: *u64) -> u64 {
    cg_expr(receiver);
    if (recv_ti.is_tagged == 1) {
        emit_tagged_mask();
    }
    emit("    test rax, rax\n");
    emit("    je ");
    emit_label(label_null);
    emit_nl();

    var tmp_offset: u64 = cg_alloc_tmp_struct(symtab, 8);
    emit("    mov [rbp");
    emit_signed_disp(tmp_offset);
    emit("], rax\n");
    *out_tmp_offset = tmp_offset;
    return 0;
}

func cg_safe_method_call_trait_ptr(method_call: *AstMethodCall, recv_ti: *TypeInfo, args: *Vec<*AstNode>, nargs: u64, symtab: *Symtab) -> u64 {
    var receiver: u64 = method_call.receiver;
    var method_ptr: u64 = method_call.method_ptr;
    var method_len: u64 = method_call.method_len;
    var method_index: u64 = compiler_find_trait_method_index(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len);
    if (compiler_is_not_found_u64(method_index) != 0) {
        emit_stderr("[ERROR] Trait method not found: ");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        return 0;
    }

    var label_null_t: u64 = new_label();
    var label_end_t: u64 = new_label();

    var tmp_offset_t: u64 = 0;
    cg_method_prepare_safe_receiver(receiver, recv_ti, label_null_t, symtab, &tmp_offset_t);

    var total_arg_words_t: u64 = cg_method_push_user_args(args, nargs, 0, 0, symtab);
    total_arg_words_t = total_arg_words_t + cg_method_push_receiver_from_tmp(tmp_offset_t);
    var stack_words_t: u64 = _cg_sysv_pop_arg_regs(total_arg_words_t);
    cg_method_emit_trait_vtable_call(method_index, stack_words_t);

    emit("    jmp ");
    emit_label(label_end_t);
    emit_nl();

    emit_label_def(label_null_t);
    emit("    xor eax, eax\n");
    emit_label_def(label_end_t);
    return 0;
}

func cg_safe_method_call_struct_ptr(method_call: *AstMethodCall, recv_ti: *TypeInfo, recv_mode: u64, args: *Vec<*AstNode>, nargs: u64, symtab: *Symtab) -> u64 {
    var receiver: u64 = method_call.receiver;
    var method_ptr: u64 = method_call.method_ptr;
    var method_len: u64 = method_call.method_len;
    var arg_types: *Vec<*TypeInfo> = typeinfo_collect_arg_types(args, symtab);
    if (recv_mode == COMPILER_SAFE_RECV_INVALID) {
        if (recv_ti.ptr_depth == 0) {
            emit_stderr("[ERROR] Safe method call requires pointer receiver\n");
            return 0;
        }
        emit_stderr("[ERROR] Safe method call requires struct pointer\n");
        return 0;
    }

    if (compiler_check_method_access_overload(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len, arg_types, nargs) == 0) {
        emit_stderr("[ERROR] private method access denied: ");
        emit_stderr_len(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        return 0;
    }

    var virt_trait: *NameInfo = 0;
    if (recv_ti.ptr_depth > 0) {
        virt_trait = compiler_find_virtual_dispatch_trait(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len);
    }
    if (virt_trait != 0) {
        var method_index_v: u64 = compiler_find_trait_method_index(virt_trait.ptr, virt_trait.len, method_ptr, method_len);
        if (compiler_is_not_found_u64(method_index_v) != 0) {
            emit_stderr("[ERROR] Virtual method not found: ");
            emit_stderr_len(method_ptr, method_len);
            emit_stderr("\n");
            return 0;
        }

        var label_null_v: u64 = new_label();
        var label_end_v: u64 = new_label();
        var tmp_offset_v: u64 = 0;
        cg_method_prepare_safe_receiver(receiver, recv_ti, label_null_v, symtab, &tmp_offset_v);

        var total_arg_words_v: u64 = cg_method_push_user_args(args, nargs, 0, 0, symtab);
        total_arg_words_v = total_arg_words_v + cg_method_push_virtual_receiver_from_tmp(tmp_offset_v, recv_ti, virt_trait.ptr, virt_trait.len);
        var stack_words_v: u64 = _cg_sysv_pop_arg_regs(total_arg_words_v);
        cg_method_emit_trait_vtable_call(method_index_v, stack_words_v);

        emit("    jmp ");
        emit_label(label_end_v);
        emit_nl();

        emit_label_def(label_null_v);
        emit("    xor eax, eax\n");
        emit_label_def(label_end_v);
        return 0;
    }

    var resolved_ptr: u64 = 0;
    var resolved_len: u64 = 0;
    var resolved_method: CompilerMethodResolveResult = compiler_resolve_method_overload(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len, arg_types, nargs);
    var fn: *AstFunc = 0;
    if (resolved_method.found != 0 && resolved_method.fn != 0) {
        fn = resolved_method.fn;
        resolved_ptr = fn.name_ptr;
        resolved_len = fn.name_len;
    }
    if (fn == 0 && recv_ti.struct_def != 0) {
        fn = compiler_find_method_func_in_hierarchy(recv_ti.struct_def, method_ptr, method_len);
        if (fn != 0) {
            resolved_ptr = fn.name_ptr;
            resolved_len = fn.name_len;
        }
    }
    if (fn == 0) {
        var name_info: *NameInfo = compiler_build_method_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len);
        resolved_ptr = name_info.ptr;
        resolved_len = name_info.len;
        var resolved: *NameInfo = resolve_name(name_info.ptr, name_info.len);
        if (resolved != 0) {
            resolved_ptr = resolved.ptr;
            resolved_len = resolved.len;
        }
        fn = typeinfo_find_func(resolved_ptr, resolved_len);
        if (fn == 0) {
            fn = typeinfo_find_func(name_info.ptr, name_info.len);
        }
    }
    var ret_type: u64 = TYPE_I64;
    var ret_ptr_depth: u64 = 0;
    if (fn != 0) {
        ret_type = fn.ret_type;
        ret_ptr_depth = fn.ret_ptr_depth;
        if (ret_type == TYPE_STRUCT && ret_ptr_depth == 0) {
            emit_stderr("[ERROR] Safe method call cannot return struct by value\n");
            return 0;
        }
    }

    var label_null: u64 = new_label();
    var label_end: u64 = new_label();

    var tmp_offset: u64 = 0;
    cg_method_prepare_safe_receiver(receiver, recv_ti, label_null, symtab, &tmp_offset);

    var total_arg_words: u64 = cg_method_push_user_args(args, nargs, fn, 1, symtab);
    total_arg_words = total_arg_words + cg_method_push_receiver_from_tmp(tmp_offset);
    var stack_words: u64 = _cg_sysv_pop_arg_regs(total_arg_words);
    cg_method_emit_direct_call(resolved_ptr, resolved_len, stack_words);

    emit("    jmp ");
    emit_label(label_end);
    emit_nl();

    emit_label_def(label_null);
    if (ret_type != TYPE_VOID) {
        emit("    xor eax, eax\n");
    }
    emit_label_def(label_end);
    return 0;
}

func cg_safe_method_call(node: u64, symtab: *Symtab) -> u64 {
    var method_call: *AstMethodCall = (*AstMethodCall)node;
    var receiver: u64 = method_call.receiver;

    var recv_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)receiver, symtab);
    if (recv_ti == 0) {
        emit_stderr("[ERROR] Safe method call receiver type not found\n");
        return 0;
    }
    cg_method_try_normalize_named_args(method_call, recv_ti);

    var args: *Vec<*AstNode> = method_call.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }

    var recv_mode: u64 = compiler_safe_receiver_mode(recv_ti);
    if (recv_mode == COMPILER_SAFE_RECV_TRAIT_PTR) {
        return cg_safe_method_call_trait_ptr(method_call, recv_ti, args, nargs, symtab);
    }
    return cg_safe_method_call_struct_ptr(method_call, recv_ti, recv_mode, args, nargs, symtab);
}

func cg_method_call(node: u64, symtab: *Symtab) -> u64 {
    var method_call: *AstMethodCall = (*AstMethodCall)node;
    var receiver: u64 = method_call.receiver;
    var method_ptr: u64 = method_call.method_ptr;
    var method_len: u64 = method_call.method_len;

    var recv_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)receiver, symtab);
    cg_method_try_normalize_named_args(method_call, recv_ti);

    var args: *Vec<*AstNode> = method_call.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }
    var arg_types: *Vec<*TypeInfo> = typeinfo_collect_arg_types(args, symtab);
    var total_arg_words: u64 = 0;

    var recv_is_ptr: u64 = 0;
    if (recv_ti != 0 && recv_ti.ptr_depth > 0) {
        recv_is_ptr = 1;
    }

    if (recv_ti != 0 && (recv_ti.type_kind == TYPE_TRAIT || compiler_is_trait_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len) != 0)) {
        var method_index: u64 = compiler_find_trait_method_index(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len);
        if (compiler_is_not_found_u64(method_index) != 0) {
            emit_stderr("[ERROR] Trait method not found: ");
            emit_stderr_len(method_ptr, method_len);
            emit_stderr("\n");
            panic("Codegen error");
        }

        total_arg_words = cg_method_push_user_args(args, nargs, 0, 0, symtab);
        total_arg_words = total_arg_words + cg_method_push_receiver(receiver, recv_ti, 1);
        var stack_words_t2: u64 = _cg_sysv_pop_arg_regs(total_arg_words);
        cg_method_emit_trait_vtable_call(method_index, stack_words_t2);
        return 0;
    }

    if (recv_ti != 0 && recv_ti.type_kind == TYPE_STRUCT) {
        if (compiler_check_method_access_overload(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len, arg_types, nargs) == 0) {
            emit_stderr("[ERROR] private method access denied: ");
            emit_stderr_len(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
            emit_stderr(".");
            emit_stderr_len(method_ptr, method_len);
            emit_stderr("\n");
            panic("Codegen error");
        }

        if (recv_ti.ptr_depth > 0) {
            var virt_trait: *NameInfo = compiler_find_virtual_dispatch_trait(recv_ti.struct_name_ptr, recv_ti.struct_name_len, method_ptr, method_len);
            if (virt_trait != 0) {
                var method_index_v: u64 = compiler_find_trait_method_index(virt_trait.ptr, virt_trait.len, method_ptr, method_len);
                if (compiler_is_not_found_u64(method_index_v) != 0) {
                    emit_stderr("[ERROR] Virtual method not found: ");
                    emit_stderr_len(method_ptr, method_len);
                    emit_stderr("\n");
                    panic("Codegen error");
                }
                total_arg_words = cg_method_push_user_args(args, nargs, 0, 0, symtab);
                total_arg_words = total_arg_words + cg_method_push_virtual_receiver(receiver, recv_ti, virt_trait.ptr, virt_trait.len);
                var stack_words_v: u64 = _cg_sysv_pop_arg_regs(total_arg_words);
                cg_method_emit_trait_vtable_call(method_index_v, stack_words_v);
                return 0;
            }
        }
    }

    // Get receiver type to determine struct name
    var type_info: *TypeInfo = recv_ti;
    if (type_info == 0 || type_info.struct_name_ptr == 0 || type_info.struct_name_len == 0) {
        if (ast_kind(receiver) == AST_IDENT) {
            var rid: *AstIdent = (*AstIdent)receiver;
            var ti_alt: *TypeInfo = symtab_get_type(symtab, rid.name_ptr, rid.name_len);
            if (ti_alt != 0) { type_info = ti_alt; }
        }
    }
    if (type_info == 0 || type_info.struct_name_ptr == 0 || type_info.struct_name_len == 0) {
        emit_stderr("[ERROR] Method call receiver type missing struct name\n");
        panic("Codegen error");
    }
    var struct_name_ptr: u64 = type_info.struct_name_ptr;
    var struct_name_len: u64 = type_info.struct_name_len;

    var resolved_ptr: u64 = 0;
    var resolved_len: u64 = 0;
    var fn_direct: *AstFunc = 0;
    var resolved_method2: CompilerMethodResolveResult = compiler_resolve_method_overload(struct_name_ptr, struct_name_len, method_ptr, method_len, arg_types, nargs);
    if (resolved_method2.found != 0 && resolved_method2.fn != 0) {
        fn_direct = resolved_method2.fn;
        resolved_ptr = fn_direct.name_ptr;
        resolved_len = fn_direct.name_len;
    }
    if (fn_direct == 0 && type_info.struct_def != 0) {
        var fn_fallback: *AstFunc = compiler_find_method_func_in_hierarchy(type_info.struct_def, method_ptr, method_len);
        if (fn_fallback != 0) {
            fn_direct = fn_fallback;
            resolved_ptr = fn_fallback.name_ptr;
            resolved_len = fn_fallback.name_len;
        }
    }
    if (fn_direct == 0) {
        // Legacy fallback for non-overloaded/older names.
        var name_info: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, method_ptr, method_len);
        resolved_ptr = name_info.ptr;
        resolved_len = name_info.len;
        var resolved: *NameInfo = resolve_name(name_info.ptr, name_info.len);
        if (resolved != 0) {
            resolved_ptr = resolved.ptr;
            resolved_len = resolved.len;
        }
        fn_direct = typeinfo_find_func(resolved_ptr, resolved_len);
        if (fn_direct == 0) {
            fn_direct = typeinfo_find_func(name_info.ptr, name_info.len);
        }
    }
    total_arg_words = cg_method_push_user_args(args, nargs, fn_direct, 1, symtab);
    total_arg_words = total_arg_words + cg_method_push_receiver(receiver, recv_ti, recv_is_ptr);

    var stack_words: u64 = _cg_sysv_pop_arg_regs(total_arg_words);

    cg_method_emit_direct_call(resolved_ptr, resolved_len, stack_words);
}
