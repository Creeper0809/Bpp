// gen_stmt.b - Statement code generation
//
// Generates x86-64 assembly for statements:
// - cg_stmt: generate code for a single statement
// - cg_block: generate code for a block of statements

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import ast;
import compiler;
import emitter.emitter;
import emitter.symtab;
import emitter.typeinfo;
import emitter.gen_expr;

// ============================================
// Block Codegen
// ============================================

var g_defer_emit_mode;

func cg_defer_stack_len() -> u64 {
    var stack: *Vec<*AstNode> = emitter_get_defer_stack();
    return stack.?len();
}

func cg_defer_mark_block_begin() -> u64 {
    var markers: *Vec<u64> = emitter_get_defer_markers();
    markers.push(cg_defer_stack_len());
    return 0;
}

func cg_defer_emit_to(marker: u64, pop_after_emit: u64) -> u64 {
    var stack: *Vec<*AstNode> = emitter_get_defer_stack();
    if (pop_after_emit != 0) {
        while (stack.len() > marker) {
            var stmt: *AstNode = stack.get(stack.len() - 1);
            stack.pop();
            var prev_mode: u64 = g_defer_emit_mode;
            g_defer_emit_mode = 1;
            cg_stmt((u64)stmt);
            g_defer_emit_mode = prev_mode;
        }
        return 0;
    }

    if (stack.len() <= marker) { return 0; }
    var idx: i64 = (i64)stack.len() - 1;
    var min_idx: i64 = (i64)marker;
    while (idx >= min_idx) {
        var stmt2: *AstNode = stack.get((u64)idx);
        var prev_mode2: u64 = g_defer_emit_mode;
        g_defer_emit_mode = 1;
        cg_stmt((u64)stmt2);
        g_defer_emit_mode = prev_mode2;
        idx = idx - 1;
    }
    return 0;
}

func cg_defer_mark_block_end() -> u64 {
    var markers: *Vec<u64> = emitter_get_defer_markers();
    if (markers.len() == 0) { return 0; }
    var marker: u64 = markers.get(markers.len() - 1);
    markers.pop();
    cg_defer_emit_to(marker, 1);
    return 0;
}

func cg_defer_push_loop_marker() -> u64 {
    var loop_markers: *Vec<u64> = emitter_get_defer_loop_markers();
    loop_markers.push(cg_defer_stack_len());
    return 0;
}

func cg_defer_pop_loop_marker() -> u64 {
    var loop_markers: *Vec<u64> = emitter_get_defer_loop_markers();
    if (loop_markers.len() > 0) { loop_markers.pop(); }
    return 0;
}

func cg_defer_emit_to_loop_marker() -> u64 {
    var loop_markers: *Vec<u64> = emitter_get_defer_loop_markers();
    if (loop_markers.len() == 0) { return 0; }
    var marker: u64 = loop_markers.get(loop_markers.len() - 1);
    cg_defer_emit_to(marker, 0);
    return 0;
}

func cg_block(node: u64) -> u64 {
    var block: *AstBlock = (*AstBlock)node;
    var stmts: *Vec<u64> = block.stmts_vec;
    var len: u64 = stmts.len();
    cg_defer_mark_block_begin();
    for(var i: u64 = 0; i < len;i++){
        cg_stmt(stmts.get(i));
   }
    cg_defer_mark_block_end();
}

// ============================================
// Statement Codegen
// ============================================

func cg_stmt_expr_stmt(node: u64, symtab: *Symtab) -> u64 {
    var expr_stmt: *AstExprStmt = (*AstExprStmt)node;
    var expr: u64 = expr_stmt.expr;
    if (expr != 0) {
        var expr_kind: u64 = ast_kind(expr);
        if (expr_kind == AST_CALL) {
            var call_node: *AstCall = (*AstCall)expr;
            var fn: *AstFunc = typeinfo_find_func(call_node.name_ptr, call_node.name_len);
            if (fn != 0) {
                if (fn.ret_type == TYPE_STRUCT && fn.ret_ptr_depth == 0) {
                    var sret_size: u64 = sizeof_type(TYPE_STRUCT, 0, fn.ret_struct_name_ptr, fn.ret_struct_name_len);
                    if (sret_size > 16) {
                        var tmp_offset: u64 = cg_alloc_tmp_struct(symtab, sret_size);
                        cg_call_sret(call_node, tmp_offset, symtab);
                        return 0;
                    }
                }
            }
        } else if (expr_kind == AST_METHOD_CALL) {
            var mc: *AstMethodCall = (*AstMethodCall)expr;
            var mc_sret_size: u64 = cg_method_call_ret_struct_size(mc, symtab);
            if (mc_sret_size > 16) {
                var tmp_offset2: u64 = cg_alloc_tmp_struct(symtab, mc_sret_size);
                cg_method_call_sret_to_offset(mc, tmp_offset2, symtab);
                return 0;
            }
        }
    }
    cg_expr(expr);
    return 0;
}

func cg_stmt_emit_loop_jump(labels: *Vec<u64>, err_msg: u64) -> u64 {
    var len: u64 = labels.len();
    if (len == 0) {
        emit_stderr("[ERROR] ");
        emit_stderr(err_msg);
        compiler_panic("Compilation failed");
    }
    cg_defer_emit_to_loop_marker();
    var label: u64 = labels.get(len - 1);
    emit("    jmp ");
    emit_label(label);
    emit_nl();
    return 0;
}

func cg_stmt_break() -> u64 {
    var labels: *Vec<u64> = emitter_get_loop_labels();
    return cg_stmt_emit_loop_jump(labels, "break can only be used inside loop/switch\n");
}

func cg_stmt_continue() -> u64 {
    var labels: *Vec<u64> = emitter_get_continue_labels();
    return cg_stmt_emit_loop_jump(labels, "continue can only be used inside loop\n");
}

func cg_stmt_handle_defer(node: u64) -> u64 {
    var df: *AstDefer = (*AstDefer)node;
    if (g_defer_emit_mode != 0) {
        cg_stmt((u64)df.stmt);
        return 0;
    }
    var defer_stack: *Vec<*AstNode> = emitter_get_defer_stack();
    defer_stack.push(df.stmt);
    return 0;
}

func cg_stmt(node: u64) -> u64 {
    var kind: u64 = ast_kind(node);
    var symtab: *Symtab = emitter_get_symtab();
    var g_structs_vec: *Vec<*AstStructDef> = typeinfo_get_structs();

    switch (kind) {
        case AST_RETURN:
            cg_return_stmt(node, symtab);
            return;
        case AST_VAR_DECL:
            cg_var_decl_stmt(node, symtab, g_structs_vec);
            return;
        case AST_ASSIGN:
            cg_assign_stmt(node, symtab);
            return;
        case AST_EXPR_STMT:
            cg_stmt_expr_stmt(node, symtab);
            return;
        case AST_IF:
            cg_if_stmt(node);
            return;
        case AST_WHILE:
            cg_while_stmt(node);
            return;
        case AST_FOR:
            cg_for_stmt(node);
            return;
        case AST_SWITCH:
        case AST_MATCH:
            cg_switch_stmt(node);
            return;
        case AST_BREAK:
            cg_stmt_break();
            return;
        case AST_CONTINUE:
            cg_stmt_continue();
            return;
        case AST_ASM:
            cg_asm_stmt(node);
            return;
        case AST_ALIAS:
            var al: *AstAlias = (*AstAlias)node;
            compiler_reg_alias_set(al.reg_ptr, al.reg_len, al.name_ptr, al.name_len);
            return;
        case AST_DEFER:
            cg_stmt_handle_defer(node);
            return;
        case AST_DELETE:
            cg_delete_stmt(node, symtab);
            return;
        case AST_BLOCK:
            cg_block(node);
            return;
    }

}

func emit_call_resolved(name_ptr: u64, name_len: u64) -> u64 {
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    emit("    call ");
    emit_len(resolved_ptr, resolved_len);
    emit_nl();
    return 0;
}

func cg_call_sret(call: *AstCall, dest_offset: u64, symtab: *Symtab) -> u64 {
    var args: *Vec<*AstNode> = call.args_vec;
    var nargs: u64 = 0;
    if (args != 0) { nargs = args.len(); }
    var total_arg_words: u64 = 0;
    if (nargs > 0) {
        var i: u64 = nargs;
        while (i > 0) {
            i = i - 1;
            var arg: *AstNode = args.get(i);
            total_arg_words = total_arg_words + _cg_sysv_push_call_arg(arg, symtab);
        }
    }

    emit("    lea rdi, [rbp");
    emit_signed_disp(dest_offset);
    emit("]\n");

    var stack_words: u64 = _cg_sysv_pop_arg_regs_sret(total_arg_words);
    emit_call_resolved(call.name_ptr, call.name_len);
    if (stack_words > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words * 8);
        emit_nl();
    }
    return 0;
}

func cg_ensure_heap_brk_global() -> u64 {
    var globals: *Vec<*GlobalInfo> = emitter_get_globals();
    if (globals == 0) { return 0; }
    if (is_global_var("__cg_heap_brk", 13) != 0) { return 0; }
    var ginfo: *GlobalInfo = new GlobalInfo();
    ginfo.name_ptr = "__cg_heap_brk";
    ginfo.name_len = 13;
    ginfo.typeinfo_ptr = typeinfo_make(TYPE_U64, 0);
        ginfo.init_kind = GLOBAL_INIT_NONE;
        ginfo.init_value = 0;
        ginfo.init_name_ptr = 0;
        ginfo.init_name_len = 0;
        ginfo.init_expr = 0;
        globals.push(ginfo);
    return 0;
}

// ============================================
// Return Statement
// ============================================

func cg_return_emit_epilogue() -> u64 {
    emit("    mov rsp, rbp\n");
    emit("    pop rbp\n");
    emit("    ret\n");
    return 0;
}

func cg_return_struct_large_from_literal(expr: u64, struct_size: u64) -> u64 {
    var lit2: *AstStructLiteral = (*AstStructLiteral)expr;
    var values2: *Vec<u64> = lit2.values_vec;
    var vcount2: u64 = 0;
    if (values2 != 0) { vcount2 = values2.len(); }
    var off: u64 = 0;
    for (var i2: u64 = 0; i2 < vcount2; i2++) {
        emit("    push rdi\n");
        cg_expr(values2.get(i2));
        emit("    pop rdi\n");
        emit("    mov [rdi");
        if (off != 0) { emit("+"); emit_u64(off); }
        emit("], rax\n");
        off = off + 8;
    }
    if (off < struct_size) {
        emit("    xor eax, eax\n");
        for (var fill_off: u64 = off; fill_off < struct_size; fill_off = fill_off + 8) {
            emit("    mov [rdi");
            if (fill_off != 0) { emit("+"); emit_u64(fill_off); }
            emit("], rax\n");
        }
    }
    return 0;
}

func cg_return_struct_large_from_call(expr: u64, symtab: *Symtab) -> u64 {
    var call_expr: *AstCall = (*AstCall)expr;
    var args_call: *Vec<*AstNode> = call_expr.args_vec;
    var nargs_call: u64 = 0;
    if (args_call != 0) { nargs_call = args_call.len(); }

    emit("    push rdi\n");
    var total_arg_words_call: u64 = 0;
    if (nargs_call > 0) {
        var ci: u64 = nargs_call;
        while (ci > 0) {
            ci = ci - 1;
            var carg: *AstNode = args_call.get(ci);
            total_arg_words_call = total_arg_words_call + _cg_sysv_push_call_arg(carg, symtab);
        }
    }
    var stack_words_call: u64 = _cg_sysv_pop_arg_regs_sret(total_arg_words_call);
    emit("    pop rdi\n");
    emit_call_resolved(call_expr.name_ptr, call_expr.name_len);
    if (stack_words_call > 0) {
        emit("    add rsp, ");
        emit_u64(stack_words_call * 8);
        emit_nl();
    }
    return 0;
}

func cg_return_struct_large_from_lvalue(expr: u64, struct_size: u64) -> u64 {
    emit("    push rdi\n");
    cg_lvalue(expr);
    emit("    mov rbx, rax\n");
    emit("    pop rdi\n");
    for (var off2: u64 = 0; off2 < struct_size; off2 = off2 + 8) {
        emit("    mov rax, [rbx");
        if (off2 != 0) { emit("+"); emit_u64(off2); }
        emit("]\n");
        emit("    mov [rdi");
        if (off2 != 0) { emit("+"); emit_u64(off2); }
        emit("], rax\n");
    }
    return 0;
}

func cg_return_struct_large(expr: u64, expr_kind: u64, struct_size: u64, symtab: *Symtab) -> u64 {
    var sret_ptr_name: u64 = (u64)"__sret_ptr";
    var sret_ptr_len: u64 = 10;
    var sret_offset: u64 = symtab_find(symtab, sret_ptr_name, sret_ptr_len);
    if (sret_offset == 0) {
        emit_stderr("[ERROR] sret pointer not saved for large struct return\n");
        panic("Codegen error");
    }
    emit("    mov rdi, [rbp");
    emit_signed_disp(sret_offset);
    emit("]\n");

    if (expr_kind == AST_STRUCT_LITERAL) {
        cg_return_struct_large_from_literal(expr, struct_size);
    } else if (expr_kind == AST_CALL) {
        cg_return_struct_large_from_call(expr, symtab);
    } else if (expr_kind == AST_STACK_CTOR) {
        emit("    mov r12, rdi\n");
        cg_stack_ctor_call_at_r12((*AstStackCtor)expr, symtab);
    } else {
        cg_return_struct_large_from_lvalue(expr, struct_size);
    }
    cg_return_emit_epilogue();
    return 0;
}

func cg_return_struct_small(expr: u64, expr_kind: u64, struct_size: u64, symtab: *Symtab) -> u64 {
    if (expr_kind == AST_CALL) {
        cg_expr(expr);
        return 0;
    }
    if (expr_kind == AST_STACK_CTOR) {
        var tmp_offset_ret: u64 = cg_alloc_tmp_struct(symtab, struct_size);
        cg_stack_ctor_init_to_offset((*AstStackCtor)expr, tmp_offset_ret, symtab);
        emit("    mov rax, [rbp");
        emit_signed_disp(tmp_offset_ret);
        emit("]\n");
        if (struct_size > 8) {
            emit("    mov rdx, [rbp");
            var tmp_ret_hi: u64 = tmp_offset_ret + 8;
            emit_signed_disp(tmp_ret_hi);
            emit("]\n");
        }
        return 0;
    }
    if (expr_kind == AST_STRUCT_LITERAL) {
        var lit: *AstStructLiteral = (*AstStructLiteral)expr;
        var values: *Vec<u64> = lit.values_vec;
        if (values == 0) {
            emit("    xor eax, eax\n");
            emit("    xor edx, edx\n");
            return 0;
        }
        var vcount: u64 = values.len();
        if (vcount > 0) {
            cg_expr(values.get(0));
        } else {
            emit("    xor eax, eax\n");
        }
        if (struct_size > 8) {
            if (vcount > 1) {
                emit("    push rax\n");
                cg_expr(values.get(1));
                emit("    mov rdx, rax\n");
                emit("    pop rax\n");
            } else {
                emit("    xor edx, edx\n");
            }
        }
        return 0;
    }

    cg_lvalue(expr);
    emit("    mov r10, rax\n");
    emit("    mov rax, [r10]\n");
    if (struct_size > 8) {
        emit("    mov rdx, [r10+8]\n");
    }
    return 0;
}

func cg_return_slice_try_array_heap_copy(slice_node: *AstSlice, symtab: *Symtab) -> u64 {
    var ptr_kind: u64 = ast_kind(slice_node.ptr_expr);
    if (ptr_kind != AST_IDENT) { return 0; }

    var idn: *AstIdent = (*AstIdent)slice_node.ptr_expr;
    var ti2: *TypeInfo = symtab_get_type(symtab, idn.name_ptr, idn.name_len);
    if (ti2 == 0 || ti2.type_kind != TYPE_ARRAY || ti2.ptr_depth != 0) { return 0; }

    cg_ensure_heap_brk_global();
    var elem_size: u64 = typeinfo_elem_size_from_container(ti2);
    cg_expr(slice_node.len_expr);
    emit("    mov r12, rax\n");
    emit("    mov r8, rax\n");
    emit("    mov rax, ");
    emit_u64(elem_size);
    emit_nl();
    emit("    imul r8, rax\n");
    var init_label: u64 = new_label();
    var ok_label: u64 = new_label();
    var fail_label: u64 = new_label();
    emit("    mov rax, [_gvar___cg_heap_brk]\n");
    emit("    cmp rax, 0\n");
    emit("    jne ");
    emit_label(init_label);
    emit_nl();
    emit("    mov rax, 12\n");
    emit("    xor rdi, rdi\n");
    emit("    syscall\n");
    emit("    mov [_gvar___cg_heap_brk], rax\n");
    emit_label_def(init_label);
    emit("    mov rbx, [_gvar___cg_heap_brk]\n");
    emit("    mov rdi, rbx\n");
    emit("    add rdi, r8\n");
    emit("    mov rax, 12\n");
    emit("    syscall\n");
    emit("    cmp rax, rdi\n");
    emit("    jb ");
    emit_label(fail_label);
    emit_nl();
    emit("    mov [_gvar___cg_heap_brk], rax\n");
    emit("    jmp ");
    emit_label(ok_label);
    emit_nl();
    emit_label_def(fail_label);
    emit("    xor rbx, rbx\n");
    emit_label_def(ok_label);
    emit("    mov rdx, r12\n");
    cg_expr(slice_node.ptr_expr);
    emit("    mov rsi, rax\n");
    emit("    mov rdi, rbx\n");
    emit("    xor r9, r9\n");
    var loop_label: u64 = new_label();
    var end_label: u64 = new_label();
    emit_label_def(loop_label);
    emit("    cmp r9, r8\n");
    emit("    jge ");
    emit_label(end_label);
    emit_nl();
    emit("    mov r10b, [rsi+r9]\n");
    emit("    mov [rdi+r9], r10b\n");
    emit("    add r9, 1\n");
    emit("    jmp ");
    emit_label(loop_label);
    emit_nl();
    emit_label_def(end_label);
    emit("    mov rax, rbx\n");
    return 1;
}

func cg_return_slice(expr: u64, symtab: *Symtab) -> u64 {
    var expr_kind2: u64 = ast_kind(expr);
    if (expr_kind2 == AST_SLICE) {
        var slice_node: *AstSlice = (*AstSlice)expr;
        if (cg_return_slice_try_array_heap_copy(slice_node, symtab) == 0) {
            cg_expr(slice_node.ptr_expr);
            emit("    mov rbx, rax\n");
            cg_expr(slice_node.len_expr);
            emit("    mov rdx, rax\n");
            emit("    mov rax, rbx\n");
        }
        return 0;
    }
    if (expr_kind2 == AST_CALL) {
        cg_expr(expr);
        return 0;
    }

    cg_lvalue(expr);
    emit("    mov rbx, [rax]\n");
    emit("    mov rdx, [rax+8]\n");
    emit("    mov rax, rbx\n");
    return 0;
}

func cg_return_stmt(node: u64, symtab: *Symtab) -> u64 {
    var ret: *AstReturn = (*AstReturn)node;
    var expr: u64 = ret.expr;

    cg_defer_emit_to(0, 0);

    if (expr == 0) {
        emit("    xor eax, eax\n");
        cg_return_emit_epilogue();
        return 0;
    }

    var ret_type: u64 = emitter_get_ret_type();
    var ret_ptr_depth: u64 = emitter_get_ret_ptr_depth();
    var ret_struct_name_ptr: u64 = emitter_get_ret_struct_name_ptr();
    var ret_struct_name_len: u64 = emitter_get_ret_struct_name_len();

    if (ret_type == TYPE_STRUCT && ret_ptr_depth == 0) {
        var expr_kind: u64 = ast_kind(expr);
        var struct_size: u64 = sizeof_type(ret_type, 0, ret_struct_name_ptr, ret_struct_name_len);
        if (struct_size > 16) {
            cg_return_struct_large(expr, expr_kind, struct_size, symtab);
            return 0;
        }
        cg_return_struct_small(expr, expr_kind, struct_size, symtab);
        cg_return_emit_epilogue();
        return 0;
    }

    if (ret_type == TYPE_SLICE && ret_ptr_depth == 0) {
        cg_return_slice(expr, symtab);
        cg_return_emit_epilogue();
        return 0;
    }

    cg_expr(expr);
    cg_return_emit_epilogue();
    return 0;
}

// ============================================
// Variable Declaration Statement
// ============================================

struct CgDeclTypeSpec {
    public type_kind: u64;
    public ptr_depth: u64;
    public is_tagged: u64;
    public struct_name_ptr: u64;
    public struct_name_len: u64;
    public tag_layout_ptr: u64;
    public tag_layout_len: u64;
    public elem_type_kind: u64;
    public elem_ptr_depth: u64;
    public array_len: u64;
    public elem_typeinfo: *TypeInfo;
}

func cg_var_decl_try_ctor_or_sret_init(init: u64, init_kind: u64, spec: *CgDeclTypeSpec, offset: u64, symtab: *Symtab) -> u64 {
    if (init_kind == AST_STACK_CTOR) {
        cg_stack_ctor_init_to_offset((*AstStackCtor)init, offset, symtab);
        return 1;
    }
    if (spec.type_kind == TYPE_STRUCT && spec.ptr_depth == 0) {
        var struct_size0: u64 = sizeof_type(spec.type_kind, spec.ptr_depth, spec.struct_name_ptr, spec.struct_name_len);
        if (struct_size0 > 16) {
            if (init_kind == AST_CALL) {
                cg_call_sret((*AstCall)init, offset, symtab);
                return 1;
            }
            if (init_kind == AST_METHOD_CALL) {
                cg_method_call_sret_to_offset((*AstMethodCall)init, offset, symtab);
                return 1;
            }
        }
    }
    if (init_kind == AST_STRUCT_LITERAL) {
        cg_struct_literal_init(init, offset);
        return 1;
    }
    return 0;
}

func cg_var_decl_check_init_compat(decl: *AstVarDecl, init: u64, type_kind: u64, ptr_depth: u64, symtab: *Symtab) -> u64 {
    if (type_kind == 0) { return 0; }
    var it_info: *TypeInfo = get_expr_type_with_symtab((*AstNode)init, symtab);
    if (it_info == 0) { return 0; }
    check_type_compat(it_info.type_kind, it_info.ptr_depth, it_info.is_tagged, it_info.tag_layout_ptr, it_info.tag_layout_len, type_kind, ptr_depth, decl.is_tagged, decl.tag_layout_ptr, decl.tag_layout_len);
    return 0;
}

func cg_var_decl_try_slice_init(init: u64, init_kind: u64, spec: *CgDeclTypeSpec, offset: u64) -> u64 {
    if (spec.type_kind != TYPE_SLICE) { return 0; }
    if (init_kind == AST_SLICE) {
        var slice_node: *AstSlice = (*AstSlice)init;
        cg_expr(slice_node.ptr_expr);
        emit("    mov [rbp");
        emit_signed_disp(offset);
        emit("], rax\n");
        cg_expr(slice_node.len_expr);
        emit("    mov [rbp");
        var off2: u64 = offset + 8;
        emit_signed_disp(off2);
        emit("], rax\n");
        return 1;
    }
    if (init_kind == AST_CALL) {
        cg_expr(init);
        emit("    mov [rbp");
        emit_signed_disp(offset);
        emit("], rax\n");
        emit("    mov [rbp");
        var offc: u64 = offset + 8;
        emit_signed_disp(offc);
        emit("], rdx\n");
        return 1;
    }
    cg_lvalue(init);
    emit("    mov rbx, [rax]\n");
    emit("    mov rcx, [rax+8]\n");
    emit("    mov [rbp");
    emit_signed_disp(offset);
    emit("], rbx\n");
    emit("    mov [rbp");
    var off3: u64 = offset + 8;
    emit_signed_disp(off3);
    emit("], rcx\n");
    return 1;
}

func cg_var_decl_try_struct_copy_init(init: u64, init_kind: u64, spec: *CgDeclTypeSpec, offset: u64) -> u64 {
    if (!(spec.type_kind == TYPE_STRUCT && spec.ptr_depth == 0 && init_kind != AST_CALL && init_kind != AST_METHOD_CALL && init_kind != AST_CALL_PTR && init_kind != AST_STRUCT_LITERAL)) {
        return 0;
    }
    var struct_size_copy: u64 = sizeof_type(spec.type_kind, spec.ptr_depth, spec.struct_name_ptr, spec.struct_name_len);
    cg_lvalue(init);
    emit("    mov rbx, rax\n");
    emit("    lea r8, [rbp");
    emit_signed_disp(offset);
    emit("]\n");
    emit_copy_bytes_with_regs("rbx", 3, "r8", 2, struct_size_copy);
    return 1;
}

func cg_var_decl_try_array_copy_init(init: u64, spec: *CgDeclTypeSpec, offset: u64, symtab: *Symtab) -> u64 {
    if (spec.type_kind != TYPE_ARRAY) { return 0; }
    var init_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)init, symtab);
    if (init_ti == 0 || init_ti.type_kind != TYPE_ARRAY || init_ti.ptr_depth != 0) {
        emit_stderr("[ERROR] array initialization requires array lvalue source of the same type\n");
        panic("Codegen error");
    }
    if (init_ti.array_len != 0 && spec.array_len != 0 && init_ti.array_len != spec.array_len) {
        emit_stderr("[ERROR] array initialization length mismatch\n");
        panic("Codegen error");
    }
    if (init_ti.elem_type_kind != 0 && spec.elem_type_kind != 0 && init_ti.elem_type_kind != spec.elem_type_kind) {
        emit_stderr("[ERROR] array initialization element type mismatch\n");
        panic("Codegen error");
    }
    if (init_ti.elem_ptr_depth != spec.elem_ptr_depth) {
        emit_stderr("[ERROR] array initialization element pointer depth mismatch\n");
        panic("Codegen error");
    }

    var total_size: u64 = 0;
    if (spec.elem_typeinfo != 0) {
        total_size = sizeof_type_ex(spec.elem_typeinfo) * spec.array_len;
    } else {
        var elem_size: u64 = sizeof_type(spec.elem_type_kind, spec.elem_ptr_depth, spec.struct_name_ptr, spec.struct_name_len);
        total_size = elem_size * spec.array_len;
    }

    cg_lvalue(init);
    emit("    mov rbx, rax\n");
    emit("    lea r8, [rbp");
    emit_signed_disp(offset);
    emit("]\n");
    emit_copy_bytes_with_regs("rbx", 3, "r8", 2, total_size);
    return 1;
}

func cg_var_decl_apply_tagged_mask_if_needed(init: u64, is_tagged: u64, ptr_depth: u64, symtab: *Symtab) -> u64 {
    if (!(is_tagged == 1 && ptr_depth > 0)) { return 0; }
    var it2: *TypeInfo = get_expr_type_with_symtab((*AstNode)init, symtab);
    if (it2 != 0 && it2.ptr_depth > 0 && it2.is_tagged == 1) { return 0; }
    emit_tagged_mask();
    return 0;
}

func cg_var_decl_try_store_small_int(type_kind: u64, ptr_depth: u64, offset: u64) -> u64 {
    if (ptr_depth != 0) { return 0; }
    if (type_kind == TYPE_BOOL || type_kind == TYPE_U8 || type_kind == TYPE_I8) {
        emit("    mov [rbp");
        emit_signed_disp(offset);
        emit("], al\n");
        return 1;
    }
    if (type_kind == TYPE_U16 || type_kind == TYPE_I16) {
        emit("    mov [rbp");
        emit_signed_disp(offset);
        emit("], ax\n");
        return 1;
    }
    if (type_kind == TYPE_U32 || type_kind == TYPE_I32) {
        emit("    mov [rbp");
        emit_signed_disp(offset);
        emit("], eax\n");
        return 1;
    }
    return 0;
}

func cg_var_decl_store_eval_result(type_kind: u64, ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64, offset: u64) -> u64 {
    if (type_kind == TYPE_STRUCT && ptr_depth == 0) {
        emit("    mov [rbp");
        emit_signed_disp(offset);
        emit("], rax\n");
        var struct_size: u64 = sizeof_type(type_kind, ptr_depth, struct_name_ptr, struct_name_len);
        if (struct_size > 8) {
            emit("    mov [rbp");
            var offset2: u64 = offset + 8;
            emit_signed_disp(offset2);
            emit("], rdx\n");
        }
        return 0;
    }
    emit("    mov [rbp");
    emit_signed_disp(offset);
    emit("], rax\n");
    return 0;
}

func cg_var_decl_init_value(decl: *AstVarDecl, init: u64, spec: *CgDeclTypeSpec, offset: u64, symtab: *Symtab) -> u64 {
    var init_kind: u64 = ast_kind(init);

    if (cg_var_decl_try_array_copy_init(init, spec, offset, symtab) != 0) { return 1; }
    if (cg_var_decl_try_ctor_or_sret_init(init, init_kind, spec, offset, symtab) != 0) { return 1; }
    cg_var_decl_check_init_compat(decl, init, spec.type_kind, spec.ptr_depth, symtab);
    if (cg_var_decl_try_slice_init(init, init_kind, spec, offset) != 0) { return 1; }
    if (cg_var_decl_try_struct_copy_init(init, init_kind, spec, offset) != 0) { return 1; }

    cg_expr(init);
    cg_var_decl_apply_tagged_mask_if_needed(init, spec.is_tagged, spec.ptr_depth, symtab);
    if (cg_var_decl_try_store_small_int(spec.type_kind, spec.ptr_depth, offset) != 0) { return 1; }
    cg_var_decl_store_eval_result(spec.type_kind, spec.ptr_depth, spec.struct_name_ptr, spec.struct_name_len, offset);
    return 0;
}

func cg_var_decl_calc_size(spec: *CgDeclTypeSpec) -> u64 {
    if (spec.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = 0;
        if (spec.elem_typeinfo != 0) {
            elem_size = sizeof_type_ex(spec.elem_typeinfo);
        } else {
            elem_size = sizeof_type(spec.elem_type_kind, spec.elem_ptr_depth, spec.struct_name_ptr, spec.struct_name_len);
        }
        return elem_size * spec.array_len;
    }
    if (spec.type_kind == TYPE_SLICE) { return 16; }

    var size: u64 = sizeof_type(spec.type_kind, spec.ptr_depth, spec.struct_name_ptr, spec.struct_name_len);
    if (spec.type_kind == TYPE_STRUCT && spec.ptr_depth == 0) {
        var align_rem: u64 = size % 8;
        if (align_rem != 0) { size = size + (8 - align_rem); }
    }
    return size;
}

func cg_var_decl_find_struct_def(g_structs_vec: *Vec<*AstStructDef>, struct_name_ptr: u64, struct_name_len: u64) -> *AstStructDef {
    if (g_structs_vec == 0 || struct_name_ptr == 0) { return 0; }
    var num_structs: u64 = g_structs_vec.len();
    for (var i: u64 = 0; i < num_structs; i++) {
        var sd: *AstStructDef = g_structs_vec.get(i);
        if (str_eq(sd.name_ptr, sd.name_len, struct_name_ptr, struct_name_len)) {
            return sd;
        }
    }
    return 0;
}

func cg_var_decl_setup_typeinfo(symtab: *Symtab, name_ptr: u64, name_len: u64, spec: *CgDeclTypeSpec, g_structs_vec: *Vec<*AstStructDef>) -> u64 {
    var ti0: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
    ti0.is_tagged = spec.is_tagged;
    if (spec.is_tagged == 1 && spec.struct_name_ptr != 0 && spec.type_kind != TYPE_STRUCT && spec.type_kind != TYPE_ARRAY && spec.type_kind != TYPE_SLICE) {
        ti0.struct_name_ptr = spec.struct_name_ptr;
        ti0.struct_name_len = spec.struct_name_len;
    }
    if (spec.is_tagged == 1 && spec.tag_layout_ptr != 0) {
        ti0.tag_layout_ptr = spec.tag_layout_ptr;
        ti0.tag_layout_len = spec.tag_layout_len;
    }

    if (spec.type_kind == TYPE_STRUCT) {
        var ti: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
        ti.struct_def = cg_var_decl_find_struct_def(g_structs_vec, spec.struct_name_ptr, spec.struct_name_len);
        ti.struct_name_ptr = spec.struct_name_ptr;
        ti.struct_name_len = spec.struct_name_len;
        ti.elem_type_kind = 0;
        ti.elem_ptr_depth = 0;
        ti.array_len = 0;
        ti.elem_typeinfo = 0;
        return 0;
    }

    if (spec.type_kind == TYPE_TRAIT) {
        var ti_trait: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
        ti_trait.struct_name_ptr = spec.struct_name_ptr;
        ti_trait.struct_name_len = spec.struct_name_len;
        ti_trait.struct_def = 0;
        ti_trait.elem_type_kind = 0;
        ti_trait.elem_ptr_depth = 0;
        ti_trait.array_len = 0;
        ti_trait.elem_typeinfo = 0;
        return 0;
    }

    if (spec.type_kind == TYPE_FUNC) {
        var ti_fn: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
        ti_fn.elem_typeinfo = spec.elem_typeinfo;
        if (spec.elem_typeinfo != 0 && spec.elem_typeinfo.type_kind == TYPE_FUNC) {
            ti_fn.fn_params_vec = spec.elem_typeinfo.fn_params_vec;
            ti_fn.fn_ret_typeinfo = spec.elem_typeinfo.fn_ret_typeinfo;
            ti_fn.fn_is_variadic = spec.elem_typeinfo.fn_is_variadic;
        }
        return 0;
    }

    if (spec.type_kind == TYPE_ARRAY || spec.type_kind == TYPE_SLICE) {
        var ti2: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
        ti2.elem_type_kind = spec.elem_type_kind;
        ti2.elem_ptr_depth = spec.elem_ptr_depth;
        ti2.array_len = spec.array_len;
        ti2.elem_typeinfo = spec.elem_typeinfo;
        ti2.struct_name_ptr = spec.struct_name_ptr;
        ti2.struct_name_len = spec.struct_name_len;
        if (spec.elem_type_kind == TYPE_STRUCT) {
            ti2.struct_def = cg_var_decl_find_struct_def(g_structs_vec, spec.struct_name_ptr, spec.struct_name_len);
        }
    }
    return 0;
}

func cg_var_decl_emit_struct_vptr_init(spec: *CgDeclTypeSpec, offset: u64) -> u64 {
    if (!(spec.type_kind == TYPE_STRUCT && spec.ptr_depth == 0)) { return 0; }
    emit("    lea r12, [rbp");
    emit_signed_disp(offset);
    emit("]\n");
    cg_emit_trait_vptr_init_at_r12(spec.struct_name_ptr, spec.struct_name_len);
    return 0;
}

func cg_var_decl_stmt(node: u64, symtab: *Symtab, g_structs_vec: *Vec<*AstStructDef>) -> u64 {
    var decl: *AstVarDecl = (*AstVarDecl)node;
    var name_ptr: u64 = decl.name_ptr;
    var name_len: u64 = decl.name_len;
    var init: u64 = decl.init_expr;
    var spec: *CgDeclTypeSpec = new CgDeclTypeSpec();
    spec.type_kind = decl.type_kind;
    spec.ptr_depth = decl.ptr_depth;
    spec.is_tagged = decl.is_tagged;
    spec.struct_name_ptr = decl.struct_name_ptr;
    spec.struct_name_len = decl.struct_name_len;
    spec.tag_layout_ptr = decl.tag_layout_ptr;
    spec.tag_layout_len = decl.tag_layout_len;
    spec.elem_type_kind = decl.elem_type_kind;
    spec.elem_ptr_depth = decl.elem_ptr_depth;
    spec.array_len = decl.array_len;
    spec.elem_typeinfo = decl.elem_typeinfo;

    var size: u64 = cg_var_decl_calc_size(spec);
    var offset: u64 = symtab_add(symtab, name_ptr, name_len, spec.type_kind, spec.ptr_depth, size);
    cg_var_decl_setup_typeinfo(symtab, name_ptr, name_len, spec, g_structs_vec);
    
    if (init != 0) {
        if (cg_var_decl_init_value(decl, init, spec, offset, symtab) != 0) {
            return;
        }
        emitter_track_closure_handle_from_expr(name_ptr, name_len, init);
    } else {
        emitter_set_closure_handle(name_ptr, name_len, 0);
    }

    cg_var_decl_emit_struct_vptr_init(spec, offset);
}

func cg_struct_literal_init(init: u64, offset: u64) -> u64 {
    var lit: *AstStructLiteral = (*AstStructLiteral)init;
    var values: *Vec<u64> = lit.values_vec;
    var num_values: u64 = values.len();
    var fields: *Vec<*FieldDesc> = lit.struct_def.fields_vec;
    var num_fields: u64 = fields.len();

    var parent_total: u64 = 0;
    if (lit.struct_def.parents_vec != 0) {
        var parents: *Vec<*ParentDesc> = lit.struct_def.parents_vec;
        var pn: u64 = parents.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = parents.get(pi);
            var parent_def: *AstStructDef = parent_desc.struct_def;
            if (parent_def == 0) {
                parent_def = get_struct_def(parent_desc.name_ptr, parent_desc.name_len);
                if (parent_def == 0) {
                    emit("[ERROR] Parent struct not found\n");
                    panic("Codegen error");
                }
                parent_desc.struct_def = parent_def;
            }
            var parent_size: u64 = sizeof_type(TYPE_STRUCT, 0, parent_desc.name_ptr, parent_desc.name_len);
            parent_total = parent_total + parent_size;
        }
    }

    var impls: *Vec<*TraitImpl> = compiler_get_trait_impls();
    if (impls != 0) {
        var ni: u64 = impls.len();
        for (var ti: u64 = 0; ti < ni; ti++) {
            var impl_info: *TraitImpl = impls.get(ti);
            if (!str_eq(impl_info.struct_ptr, impl_info.struct_len, lit.struct_def.name_ptr, lit.struct_def.name_len)) { continue; }
            var vptr_name: *NameInfo = compiler_build_vptr_field_name(impl_info.trait_ptr, impl_info.trait_len);
            var field_offset_v: u64 = 0;
            var field_desc_v: *FieldDesc = 0;
            var found_v: u64 = struct_find_field_desc_scoped(lit.struct_def, 0, 0, vptr_name.ptr, vptr_name.len, &field_offset_v, &field_desc_v);
            if (found_v == 0) {
                emit_stderr("[ERROR] vptr field not found for struct literal init\n");
                panic("Codegen error");
            }
            emit("    lea rax, [rel _gvar_");
            emit_len(impl_info.vtable_global_ptr, impl_info.vtable_global_len);
            emit("]\n");
            emit("    mov [rbp");
            var total_off_v: u64 = offset + field_offset_v;
            emit_signed_disp(total_off_v);
            emit("], rax\n");
        }
    }
    
    // Initialize each field
    var field_offset: u64 = parent_total;
    var value_index: u64 = 0;
    for (var fi: u64 = 0; fi < num_fields && value_index < num_values; fi++) {
        var field: *FieldDesc = fields.get(fi);
        var field_size: u64 = sizeof_field_desc(field);
        if (compiler_is_vptr_field_name(field.name_ptr, field.name_len) != 0) {
            field_offset = field_offset + field_size;
            continue;
        }

        cg_expr(values.get(value_index));

        emit("    mov [rbp");
        var total_offset: u64 = offset + field_offset;
        emit_signed_disp(total_offset);
        emit("], rax\n");

        field_offset = field_offset + field_size;
        value_index = value_index + 1;
    }
}

// ============================================
// Assignment Statement
// ============================================

func cg_assign_try_member_tagged_layout(obj: u64, member_ptr: u64, member_len: u64, ot: *TypeInfo, value: u64) -> u64 {
    if (ot.ptr_depth > 0 && ot.is_tagged == 1 && ot.tag_layout_ptr != 0) {
        var layout_info: *AstStructDef = get_struct_def(ot.tag_layout_ptr, ot.tag_layout_len);
        if (layout_info == 0) {
            emit("[ERROR] Tagged layout struct not found\n");
            panic("Codegen error");
        }
        var packed_flag: u64 = layout_info.is_packed;
        if (packed_flag == 0) {
            emit("[ERROR] Tagged layout must be packed struct\n");
            panic("Codegen error");
        }
        if (ast_kind(obj) != AST_IDENT) {
            emit("[ERROR] Tagged layout assignment requires identifier base\n");
            panic("Codegen error");
        }

        var total_bits: u64 = get_packed_layout_total_bits(layout_info);
        var field_offset: u64 = get_packed_field_bit_offset(layout_info, member_ptr, member_len);
        var field_width: u64 = get_packed_field_bit_width(layout_info, member_ptr, member_len);
        var start_bit: u64 = 64 - total_bits;
        var shift_bits: u64 = start_bit + field_offset;

        cg_expr(value);
        emit("    mov r9, rax\n");
        cg_expr(obj);
        emit("    mov rbx, rax\n");

        if (field_width < 64) {
            emit_mask_to_rdx(field_width);
            emit("    and r9, rdx\n");
        }
        if (shift_bits > 0) {
            emit("    mov rcx, ");
            emit_u64(shift_bits);
            emit_nl();
            emit("    shl r9, cl\n");
        }

        if (field_width < 64) {
            emit_mask_to_rdx(field_width);
            if (shift_bits > 0) {
                emit("    mov r10, rdx\n");
                emit("    mov rcx, ");
                emit_u64(shift_bits);
                emit_nl();
                emit("    shl r10, cl\n");
            } else {
                emit("    mov r10, rdx\n");
            }
            emit("    not r10\n");
            emit("    and rbx, r10\n");
        } else {
            emit("    xor rbx, rbx\n");
        }

        emit("    or rbx, r9\n");
        cg_lvalue(obj);
        emit("    mov [rax], rbx\n");
        return 1;
    }
    return 0;
}

func cg_assign_store_packed_aligned_bytes(obj: u64, value: u64, byte_offset: u64, byte_width: u64) -> u64 {
    cg_expr(value);
    emit("    mov r9, rax\n");
    cg_lvalue(obj);
    if (byte_offset > 0) {
        emit("    add rax, ");
        emit_u64(byte_offset);
        emit("\n");
    }
    if (byte_width == 1) {
        emit("    mov [rax], r9b\n");
    } else if (byte_width == 2) {
        emit("    mov [rax], r9w\n");
    } else if (byte_width == 4) {
        emit("    mov [rax], r9d\n");
    } else {
        emit("    mov [rax], r9\n");
    }
    return 1;
}

func cg_assign_store_packed_in_word(obj: u64, value: u64, size_bytes: u64, field_width: u64, shift_bits: u64) -> u64 {
    cg_expr(value);
    emit("    mov r9, rax\n");
    cg_lvalue(obj);
    if (size_bytes == 1) {
        emit("    movzx rbx, byte [rax]\n");
    } else if (size_bytes == 2) {
        emit("    movzx rbx, word [rax]\n");
    } else if (size_bytes == 4) {
        emit("    mov ebx, [rax]\n");
    } else {
        emit("    mov rbx, [rax]\n");
    }

    if (field_width < 64) {
        emit_mask_to_rdx(field_width);
        emit("    and r9, rdx\n");
    }
    if (shift_bits > 0) {
        emit("    mov rcx, ");
        emit_u64(shift_bits);
        emit_nl();
        emit("    shl r9, cl\n");
    }

    if (field_width < 64) {
        emit_mask_to_rdx(field_width);
        if (shift_bits > 0) {
            emit("    mov r10, rdx\n");
            emit("    mov rcx, ");
            emit_u64(shift_bits);
            emit_nl();
            emit("    shl r10, cl\n");
        } else {
            emit("    mov r10, rdx\n");
        }
        emit("    not r10\n");
        emit("    and rbx, r10\n");
    } else {
        emit("    xor rbx, rbx\n");
    }

    emit("    or rbx, r9\n");
    cg_lvalue(obj);
    if (size_bytes == 1) {
        emit("    mov [rax], bl\n");
    } else if (size_bytes == 2) {
        emit("    mov [rax], bx\n");
    } else if (size_bytes == 4) {
        emit("    mov [rax], ebx\n");
    } else {
        emit("    mov [rax], rbx\n");
    }
    return 1;
}

func cg_assign_try_member_packed_struct(obj: u64, member_ptr: u64, member_len: u64, ot: *TypeInfo, value: u64) -> u64 {
    if (ot.ptr_depth == 0 && ot.type_kind == TYPE_STRUCT && ot.struct_def != 0) {
        var struct_info: *AstStructDef = ot.struct_def;
        var packed_flag2: u64 = struct_info.is_packed;
        if (packed_flag2 == 1) {
            var total_bits2: u64 = get_packed_layout_total_bits(struct_info);
            var field_offset2: u64 = get_packed_field_bit_offset(struct_info, member_ptr, member_len);
            var field_width2: u64 = get_packed_field_bit_width(struct_info, member_ptr, member_len);
            if (total_bits2 > 64 || (field_offset2 + field_width2) > 64) {
                var byte_offset2: u64 = field_offset2 / 8;
                var bit_shift2: u64 = field_offset2 % 8;
                var byte_width2: u64 = (field_width2 + 7) / 8;

                if (bit_shift2 != 0) {
                    emit("[ERROR] Packed field write requires byte alignment\n");
                    panic("Codegen error");
                }

                return cg_assign_store_packed_aligned_bytes(obj, value, byte_offset2, byte_width2);
            }
            var shift_bits2: u64 = field_offset2;
            var size_bytes2: u64 = (total_bits2 + 7) / 8;
            return cg_assign_store_packed_in_word(obj, value, size_bytes2, field_width2, shift_bits2);
        }
    }
    return 0;
}

func cg_assign_try_member_packed_special(target: u64, value: u64, symtab: *Symtab) -> u64 {
    if (ast_kind(target) != AST_MEMBER_ACCESS) { return 0; }

    var m: *AstMemberAccess = (*AstMemberAccess)target;
    var obj: u64 = m.object;
    var member_ptr: u64 = m.member_ptr;
    var member_len: u64 = m.member_len;
    var ot: *TypeInfo = get_expr_type_with_symtab((*AstNode)obj, symtab);
    if (ot == 0) { return 0; }

    if (cg_assign_try_member_tagged_layout(obj, member_ptr, member_len, ot, value) != 0) { return 1; }
    if (cg_assign_try_member_packed_struct(obj, member_ptr, member_len, ot, value) != 0) { return 1; }
    return 0;
}

func cg_assign_update_ident_ptr_type(target: u64, target_kind: u64, value: u64, symtab: *Symtab) -> u64 {
    if (target_kind != AST_IDENT) { return 0; }

    var ident: *AstIdent = (*AstIdent)target;
    var name_ptr: u64 = ident.name_ptr;
    var name_len: u64 = ident.name_len;
    var target_type: *TypeInfo = symtab_get_type(symtab, name_ptr, name_len);
    var value_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)value, symtab);
    if (target_type == 0 || value_ti == 0) { return 0; }
    if (value_ti.ptr_depth == 0) { return 0; }
    symtab_update_type(symtab, name_ptr, name_len, value_ti.type_kind, value_ti.ptr_depth);
    return 0;
}

func cg_assign_store_slice_pair_to_target(target: u64) -> u64 {
    cg_lvalue(target);
    emit("    mov [rax], rbx\n");
    emit("    mov [rax+8], rcx\n");
    return 0;
}

func cg_assign_try_slice_copy(target: u64, target_kind: u64, value: u64, value_kind: u64, symtab: *Symtab) -> u64 {
    if (!(target_kind == AST_IDENT || target_kind == AST_MEMBER_ACCESS)) { return 0; }

    var target_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)target, symtab);
    if (target_ti == 0 || target_ti.type_kind != TYPE_SLICE || target_ti.ptr_depth != 0) { return 0; }

    if (value_kind == AST_SLICE) {
        var slice_node: *AstSlice = (*AstSlice)value;
        cg_expr(slice_node.ptr_expr);
        emit("    mov rbx, rax\n");
        cg_expr(slice_node.len_expr);
        emit("    mov rcx, rax\n");
        cg_assign_store_slice_pair_to_target(target);
        return 1;
    }

    if (value_kind == AST_CALL) {
        cg_expr(value);
        emit("    mov rbx, rax\n");
        emit("    mov rcx, rdx\n");
        cg_assign_store_slice_pair_to_target(target);
        return 1;
    }

    cg_lvalue(value);
    emit("    mov rbx, [rax]\n");
    emit("    mov rcx, [rax+8]\n");
    cg_assign_store_slice_pair_to_target(target);
    return 1;
}

func cg_assign_array_elem_struct_name_matches(target_ti: *TypeInfo, value_ti: *TypeInfo) -> u64 {
    if (target_ti == 0 || value_ti == 0) { return 0; }
    if (target_ti.elem_type_kind != TYPE_STRUCT) { return 1; }
    if (target_ti.struct_name_ptr == 0 || target_ti.struct_name_len == 0) { return 1; }

    var value_struct_ptr: u64 = value_ti.struct_name_ptr;
    var value_struct_len: u64 = value_ti.struct_name_len;
    if (value_ti.type_kind == TYPE_ARRAY) {
        value_struct_ptr = value_ti.struct_name_ptr;
        value_struct_len = value_ti.struct_name_len;
    }
    if (value_struct_ptr == 0 || value_struct_len == 0) { return 0; }
    if (str_eq(target_ti.struct_name_ptr, target_ti.struct_name_len, value_struct_ptr, value_struct_len) == 0) { return 0; }
    return 1;
}

func cg_assign_array_total_size(target_ti: *TypeInfo) -> u64 {
    if (target_ti == 0 || target_ti.type_kind != TYPE_ARRAY || target_ti.ptr_depth != 0) { return 0; }
    if (target_ti.array_len == 0) { return 0; }
    var elem_size: u64 = 0;
    if (target_ti.elem_typeinfo != 0) {
        elem_size = sizeof_type_ex(target_ti.elem_typeinfo);
    } else {
        elem_size = sizeof_type(target_ti.elem_type_kind, target_ti.elem_ptr_depth, target_ti.struct_name_ptr, target_ti.struct_name_len);
    }
    return elem_size * target_ti.array_len;
}

func cg_assign_try_array_copy(target: u64, value: u64, symtab: *Symtab) -> u64 {
    var target_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)target, symtab);
    if (target_ti == 0 || target_ti.type_kind != TYPE_ARRAY || target_ti.ptr_depth != 0) { return 0; }

    var value_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)value, symtab);
    if (value_ti == 0) {
        emit_stderr("[ERROR] array assignment requires array source or compatible element pointer\n");
        panic("Codegen error");
    }

    var source_mode: u64 = 0; // 1=array lvalue, 2=element pointer
    if (value_ti.type_kind == TYPE_ARRAY && value_ti.ptr_depth == 0) {
        if (value_ti.array_len != 0 && target_ti.array_len != 0 && value_ti.array_len != target_ti.array_len) {
            emit_stderr("[ERROR] array assignment length mismatch\n");
            panic("Codegen error");
        }
        if (value_ti.elem_type_kind != 0 && target_ti.elem_type_kind != 0 && value_ti.elem_type_kind != target_ti.elem_type_kind) {
            emit_stderr("[ERROR] array assignment element type mismatch\n");
            panic("Codegen error");
        }
        if (value_ti.elem_ptr_depth != target_ti.elem_ptr_depth) {
            emit_stderr("[ERROR] array assignment element pointer depth mismatch\n");
            panic("Codegen error");
        }
        if (cg_assign_array_elem_struct_name_matches(target_ti, value_ti) == 0) {
            emit_stderr("[ERROR] array assignment struct element type mismatch\n");
            panic("Codegen error");
        }
        source_mode = 1;
    } else if (value_ti.ptr_depth == target_ti.elem_ptr_depth + 1 && value_ti.type_kind == target_ti.elem_type_kind) {
        if (cg_assign_array_elem_struct_name_matches(target_ti, value_ti) == 0) {
            emit_stderr("[ERROR] array assignment pointer source element type mismatch\n");
            panic("Codegen error");
        }
        source_mode = 2;
    } else {
        emit_stderr("[ERROR] array assignment requires array source or compatible element pointer\n");
        panic("Codegen error");
    }

    var total_size: u64 = cg_assign_array_total_size(target_ti);
    if (total_size == 0) {
        emit_stderr("[ERROR] array assignment requires concrete array length\n");
        panic("Codegen error");
    }

    if (source_mode == 1) {
        cg_lvalue(value);
    } else {
        cg_expr(value);
    }
    emit("    mov rbx, rax\n");
    cg_lvalue(target);
    emit("    mov r8, rax\n");
    emit_copy_bytes_with_regs("rbx", 3, "r8", 2, total_size);
    return 1;
}

func cg_assign_apply_tagged_mask_if_needed(target_type_info: *TypeInfo, value_type_info: *TypeInfo) -> u64 {
    if (target_type_info == 0) { return 0; }
    if (!(target_type_info.ptr_depth > 0 && target_type_info.is_tagged == 1)) { return 0; }
    if (value_type_info != 0 && value_type_info.ptr_depth > 0 && value_type_info.is_tagged == 1) { return 0; }
    emit_tagged_mask();
    return 0;
}

func cg_assign_try_store_by_target_kind(target: u64, target_kind: u64, symtab: *Symtab) -> u64 {
    if (target_kind == AST_DEREF) {
        var deref: *AstDeref = (*AstDeref)target;
        var ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)deref.operand, symtab);
        if (ti != 0 && ti.ptr_depth == 1) {
            emit_store_rbx_to_addr(ti.type_kind, 0);
            return 1;
        }
        return 0;
    }

    if (target_kind == AST_DEREF8) {
        emit_store_rbx_to_addr(TYPE_U8, 0);
        return 1;
    }

    if (target_kind == AST_INDEX) {
        var it: *TypeInfo = get_expr_type_with_symtab((*AstNode)target, symtab);
        if (it != 0) {
            if (it.type_kind == TYPE_STRUCT && it.ptr_depth == 0) { return 0; }
            emit_store_rbx_to_addr(it.type_kind, it.ptr_depth);
            return 1;
        }
        emit_store_rbx_to_addr(TYPE_I64, 1);
        return 1;
    }

    if (target_kind == AST_IDENT) {
        var tt: *TypeInfo = get_expr_type_with_symtab((*AstNode)target, symtab);
        if (tt != 0) {
            emit_store_rbx_to_addr(tt.type_kind, tt.ptr_depth);
            return 1;
        }
        return 0;
    }

    return 0;
}

func cg_assign_try_struct_copy(target: u64, value: u64, symtab: *Symtab) -> u64 {
    var target_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)target, symtab);
    if (target_ti == 0 || target_ti.type_kind != TYPE_STRUCT || target_ti.ptr_depth != 0) { return 0; }

    var struct_def: *AstStructDef = target_ti.struct_def;
    if (struct_def == 0) { return 0; }

    var struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, struct_def.name_ptr, struct_def.name_len);
    emit("    mov r8, rax  ; save dest addr\n");
    cg_lvalue(value);
    emit_copy_bytes_with_regs("rax", 3, "r8", 2, struct_size);
    return 1;
}

func cg_assign_stmt(node: u64, symtab: *Symtab) -> u64 {
    var assign: *AstAssign = (*AstAssign)node;
    var target: u64 = assign.target;
    var value: u64 = assign.value;
    
    var target_kind: u64 = ast_kind(target);
    var value_kind: u64 = ast_kind(value);
    if (target_kind == AST_IDENT) {
        var idn_tgt: *AstIdent = (*AstIdent)target;
        emitter_track_closure_handle_from_expr(idn_tgt.name_ptr, idn_tgt.name_len, value);
    }
    if (target_kind == AST_SAFE_MEMBER_ACCESS) {
        emit_stderr("[ERROR] Safe member access cannot be used in assignment\n");
        panic("Codegen error");
    }
    if (value_kind == AST_STACK_CTOR) {
        var target_ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)target, symtab);
        if (target_ti == 0 || target_ti.type_kind != TYPE_STRUCT || target_ti.ptr_depth != 0) {
            emit_stderr("[ERROR] stack constructor assignment requires struct lvalue\n");
            panic("Codegen error");
        }
        cg_lvalue(target);
        emit("    mov r12, rax\n");
        cg_stack_ctor_call_at_r12((*AstStackCtor)value, symtab);
        return;
    }
    if (cg_assign_try_member_packed_special(target, value, symtab) != 0) {
        return;
    }
    cg_assign_update_ident_ptr_type(target, target_kind, value, symtab);

    var target_type_info: *TypeInfo = 0;
    if (target_kind == AST_IDENT) {
        var ident3: *AstIdent = (*AstIdent)target;
        target_type_info = symtab_get_type(symtab, ident3.name_ptr, ident3.name_len);
    }
    var value_type_info: *TypeInfo = get_expr_type_with_symtab((*AstNode)value, symtab);

    if (cg_assign_try_slice_copy(target, target_kind, value, value_kind, symtab) != 0) {
        return;
    }
    if (cg_assign_try_array_copy(target, value, symtab) != 0) {
        return;
    }
    
    cg_expr(value);
    cg_assign_apply_tagged_mask_if_needed(target_type_info, value_type_info);
    emit("    push rax\n");
    cg_lvalue(target);
    emit("    pop rbx\n");

    if (cg_assign_try_store_by_target_kind(target, target_kind, symtab) != 0) { return; }
    if (cg_assign_try_struct_copy(target, value, symtab) != 0) { return; }
    
    emit_store_rbx_to_addr(TYPE_I64, 1);
}

// ============================================
// Delete Statement
// ============================================

func cg_delete_stmt(node: u64, symtab: *Symtab) -> u64 {
    var dl: *AstDelete = (*AstDelete)node;
    var expr: u64 = dl.expr;
    if (expr == 0) { return 0; }

    cg_expr(expr);
    emit("    test rax, rax\n");
    var label_end: u64 = new_label();
    emit("    je ");
    emit_label(label_end);
    emit_nl();

    emit("    mov rbx, rax\n");

    var ti: *TypeInfo = get_expr_type_with_symtab((*AstNode)expr, symtab);
    if (ti != 0 && ti.type_kind == TYPE_STRUCT && ti.ptr_depth > 0) {
        var method_ptr: u64 = (u64)"destructor";
        var method_len: u64 = 10;
        var name_info: *NameInfo = compiler_build_method_name(ti.struct_name_ptr, ti.struct_name_len, method_ptr, method_len);
        var resolved_ptr: u64 = name_info.ptr;
        var resolved_len: u64 = name_info.len;
        var resolved: *NameInfo = resolve_name(name_info.ptr, name_info.len);
        if (resolved != 0) {
            resolved_ptr = resolved.ptr;
            resolved_len = resolved.len;
        }

        if (compiler_func_exists(name_info.ptr, name_info.len) != 0) {
            emit("    push rbx\n");
            var stack_words: u64 = _cg_sysv_pop_arg_regs(1);
            emit("    call ");
            emit_len(resolved_ptr, resolved_len);
            emit_nl();
            if (stack_words > 0) {
                emit("    add rsp, ");
                emit_u64(stack_words * 8);
                emit_nl();
            }
        }
    }

    var free_ptr: u64 = (u64)"free";
    var free_len: u64 = 4;
    var free_res: *NameInfo = resolve_name(free_ptr, free_len);
    if (free_res != 0) {
        free_ptr = free_res.ptr;
        free_len = free_res.len;
    }

    emit("    mov rdi, rbx\n");
    emit("    call ");
    emit_len(free_ptr, free_len);
    emit_nl();

    emit_label_def(label_end);
    return 0;
}

// ============================================
// Control Flow Statements
// ============================================

func cg_if_stmt(node: u64) -> u64 {
    var if_stmt: *AstIf = (*AstIf)node;
    var cond: u64 = if_stmt.cond;
    var then_blk: u64 = if_stmt.then_block;
    var else_blk: u64 = if_stmt.else_block;
    
    var else_label: u64 = new_label();
    var end_label: u64 = new_label();
    
    cg_expr(cond);
    emit("    test rax, rax\n");
    emit("    jz ");
    emit_label(else_label);
    emit_nl();
    
    cg_block(then_blk);
    
    if (else_blk != 0) {
        emit("    jmp ");
        emit_label(end_label);
        emit_nl();
    }
    
    emit_label_def(else_label);
    
    if (else_blk != 0) {
        cg_block(else_blk);
        emit_label_def(end_label);
    }
}

func cg_while_stmt(node: u64) -> u64 {
    var while_stmt: *AstWhile = (*AstWhile)node;
    var cond: u64 = while_stmt.cond;
    var body: u64 = while_stmt.body;
    
    var start_label: u64 = new_label();
    var end_label: u64 = new_label();
    
    emit_label_def(start_label);
    
    cg_expr(cond);
    emit("    test rax, rax\n");
    emit("    jz ");
    emit_label(end_label);
    emit_nl();
    
    var g_loop_labels: *Vec<u64> = emitter_get_loop_labels();
    var g_loop_continue_labels: *Vec<u64> = emitter_get_continue_labels();
    g_loop_labels.push(end_label);
    g_loop_continue_labels.push(start_label);
    cg_defer_push_loop_marker();
    
    cg_block(body);
    
    cg_defer_pop_loop_marker();
    g_loop_labels.pop();
    g_loop_continue_labels.pop();
    
    emit("    jmp ");
    emit_label(start_label);
    emit_nl();
    
    emit_label_def(end_label);
}

func cg_for_stmt(node: u64) -> u64 {
    var for_stmt: *AstFor = (*AstFor)node;
    var init: u64 = for_stmt.init;
    var cond: u64 = for_stmt.cond;
    var update: u64 = for_stmt.update;
    var body: u64 = for_stmt.body;
    
    if (init != 0) { cg_stmt(init); }
    
    var start_label: u64 = new_label();
    var update_label: u64 = new_label();
    var end_label: u64 = new_label();
    
    emit_label_def(start_label);
    
    if (cond != 0) {
        cg_expr(cond);
        emit("    test rax, rax\n");
        emit("    jz ");
        emit_label(end_label);
        emit_nl();
    }
    
    var g_loop_labels: *Vec<u64> = emitter_get_loop_labels();
    var g_loop_continue_labels: *Vec<u64> = emitter_get_continue_labels();
    g_loop_labels.push(end_label);
    g_loop_continue_labels.push(update_label);
    cg_defer_push_loop_marker();
    
    cg_block(body);
    
    cg_defer_pop_loop_marker();
    g_loop_labels.pop();
    g_loop_continue_labels.pop();
    
    emit_label_def(update_label);
    
    if (update != 0) { cg_stmt(update); }
    
    emit("    jmp ");
    emit_label(start_label);
    emit_nl();
    
    emit_label_def(end_label);
}

func cg_switch_stmt(node: u64) -> u64 {
    var switch_stmt: *AstSwitch = (*AstSwitch)node;
    var expr: u64 = switch_stmt.expr;
    var cases: *Vec<u64> = switch_stmt.cases_vec;
    
    // Evaluate switch expression once
    cg_expr(expr);
    
    var end_label: u64 = new_label();
    var default_label: u64 = 0;
    var has_default: u64 = 0;
    
    // Push end_label to g_loop_labels so that break works
    var g_loop_labels: *Vec<u64> = emitter_get_loop_labels();
    g_loop_labels.push(end_label);
    cg_defer_push_loop_marker();
    
    var num_cases: u64 = cases.len();
    
    // Analyze cases to decide optimization strategy
    var use_jump_table: u64 = 0;
    var min_val: i64 = 0;
    var max_val: i64 = 0;
    var case_count: u64 = 0;
    
    // Count non-default cases and find min/max values
    for (var i: u64 = 0; i < num_cases; i++) {
        var case_node: u64 = cases.get(i);
        var case_stmt: *AstCase = (*AstCase)case_node;
        
        if (case_stmt.is_default == 0) {
            // Try to evaluate case value as constant
            var value_node: u64 = case_stmt.value;
            var value_kind: u64 = ast_kind(value_node);
            
            if (value_kind == AST_LITERAL) {
                var lit: *AstLiteral = (*AstLiteral)value_node;
                var val: i64 = (i64)(lit.value);
                
                if (case_count == 0) {
                    min_val = val;
                    max_val = val;
                } else {
                    if (val < min_val) { min_val = val; }
                    if (val > max_val) { max_val = val; }
                }
                case_count = case_count + 1;
            }
        } else {
            has_default = 1;
        }
        
    }
    
    // Use jump table if: 3+ cases, range <= 256, density > 40%
    var range: i64 = max_val - min_val + 1;
    if (case_count >= 3 && range > 0 && range <= 256) {
        var range_u64: u64 = (u64)range;
        var density: u64 = (case_count * 100) / range_u64;
        if (density >= 40) {
            use_jump_table = 1;
        }
    }
    
    if (use_jump_table == 1) {
        cg_switch_jump_table(cases, min_val, max_val, end_label, has_default);
    } else {
        cg_switch_linear(cases, end_label, has_default);
    }
    
    cg_defer_pop_loop_marker();
    // Pop end_label from g_loop_labels
    g_loop_labels.pop();
    
    emit_label_def(end_label);
}

// Linear comparison switch (original behavior, improved)
func cg_switch_emit_string_compare(value: u64, case_label: u64) -> u64 {
    cg_expr(value);
    emitln("    sub rsp, 16");
    emitln("    mov [rsp], rax    ; s2");
    emitln("    mov rdi, rax");
    emit_call_resolved("str_len", 7);
    emitln("    mov [rsp+8], rax    ; len2");
    emitln("    mov rdi, [rsp+16]    ; s1");
    emit_call_resolved("str_len", 7);
    emitln("    mov rsi, rax    ; len1");
    emitln("    mov rdi, [rsp+16]    ; s1");
    emitln("    mov rdx, [rsp]    ; s2");
    emitln("    mov rcx, [rsp+8]    ; len2");
    emit_call_resolved("str_eq", 6);
    emitln("    add rsp, 16");
    emitln("    test rax, rax");
    emit("    jnz ");
    emit_label(case_label);
    emit_nl();
    return 0;
}

func cg_switch_emit_int_compare(value: u64, case_label: u64) -> u64 {
    emitln("    mov rax, [rsp]    ; reload switch value");
    emitln("    push rax");
    cg_expr(value);
    emit("    mov rbx, rax\n");
    emit("    pop rax\n");
    emit("    cmp rax, rbx\n");
    emit("    je ");
    emit_label(case_label);
    emit_nl();
    return 0;
}

func cg_switch_emit_case_bodies(cases: *Vec<u64>, case_labels: *Vec<u64>) -> u64 {
    var num_cases: u64 = cases.len();
    for (var i: u64 = 0; i < num_cases; i++) {
        var case_stmt: *AstCase = (*AstCase)cases.get(i);
        emit_label_def(case_labels.get(i));
        cg_block(case_stmt.body);
    }
    return 0;
}

func cg_switch_linear(cases: *Vec<u64>, end_label: u64, has_default: u64) -> u64 {
    emitln("    push rax    ; switch value");

    var num_cases: u64 = cases.len();
    var default_label: u64 = 0;
    var case_labels: *Vec<u64> = new Vec<u64>(num_cases);
    for (var i: u64 = 0; i < num_cases; i++) {
        var case_stmt: *AstCase = (*AstCase)cases.get(i);
        var case_label: u64 = new_label();
        case_labels.push(case_label);
        if (case_stmt.is_default == 1) {
            default_label = case_label;
            continue;
        }

        var value: u64 = case_stmt.value;
        if (ast_kind(value) == AST_STRING) {
            cg_switch_emit_string_compare(value, case_label);
        } else {
            cg_switch_emit_int_compare(value, case_label);
        }
    }

    emit("    jmp ");
    if (has_default == 1) {
        emit_label(default_label);
    } else {
        emit_label(end_label);
    }
    emit_nl();

    cg_switch_emit_case_bodies(cases, case_labels);
    emit("    add rsp, 8    ; pop switch value\n");
}

// Jump table switch (optimized for dense integer ranges)
func cg_switch_jump_table(cases: *Vec<u64>, min_val: i64, max_val: i64, end_label: u64, has_default: u64) -> u64 {
    var num_cases: u64 = cases.len();
    var range: i64 = max_val - min_val + 1;
    var range_u64: u64 = (u64)range;
    var table_label: u64 = new_label();
    var default_label: u64 = end_label;
    
    // Create case label mapping
    var case_labels: *Vec<u64> = new Vec<u64>(num_cases);
    var value_to_label: *Vec<u64> = new Vec<u64>(range_u64);
    
    // Initialize all table entries to default
    for (var j: u64 = 0; j < range_u64; j++) {
        value_to_label.push(end_label);
    }
    
    // First pass: create labels and build value.label mapping
    for (var i: u64 = 0; i < num_cases; i++) {
        var case_node: u64 = cases.get(i);
        var case_stmt: *AstCase = (*AstCase)case_node;
        var case_label: u64 = new_label();
        case_labels.push(case_label);
        
        if (case_stmt.is_default == 1) {
            default_label = case_label;
            // Update all unassigned entries to point to default
            for (var j: u64 = 0; j < range_u64; j++) {
                if (value_to_label.get(j) == end_label) {
                    value_to_label.set(j, default_label);
                }
            }
        } else {
            var value_node: u64 = case_stmt.value;
            var value_kind: u64 = ast_kind(value_node);
            if (value_kind == AST_LITERAL) {
                var lit: *AstLiteral = (*AstLiteral)value_node;
                var val: i64 = (i64)(lit.value);
                var idx: u64 = (u64)(val - min_val);
                value_to_label.set(idx, case_label);
            }
        }
        
    }
    
    // Generate bounds check and jump table lookup
    emit("    ; Jump table switch (range: ");
    emit_i64(min_val);
    emit(" to ");
    emit_i64(max_val);
    emit(")\n");
    
    // Check if value is in range [min_val, max_val]
    if (min_val != 0) {
        emit("    sub rax, ");
        emit_i64(min_val);
        emit("    ; normalize to 0-based\n");
    }
    emit("    cmp rax, ");
    emit_u64(range_u64);
    emit_nl();
    emit("    jae ");
    emit_label(default_label);
    emit("    ; out of range\n");
    
    // Jump via table: jmp [table + rax*8]
    emit("    lea rbx, [rel ");
    emit(" ");
    emit_label(table_label);
    emit("]\n");
    emit("    jmp [rbx + rax*8]\n");
    
    // Emit jump table
    emit_nl();
    emit_label_def(table_label);
    for (var j: u64 = 0; j < range_u64; j++) {
        emit("    dq ");
        emit_label(value_to_label.get(j));
        emit_nl();
    }
    emit_nl();
    
    // Second pass: generate case bodies
    for (var i: u64 = 0; i < num_cases; i++) {
        var case_node: u64 = cases.get(i);
        var case_stmt: *AstCase = (*AstCase)case_node;
        var body: u64 = case_stmt.body;
        var case_label: u64 = case_labels.get(i);
        
        emit_label_def(case_label);
        cg_block(body);
        
    }
}

func cg_asm_stmt(node: u64) -> u64 {
    var asm_stmt: *AstAsm = (*AstAsm)node;
    var text_vec: *Vec<u64> = asm_stmt.text_vec;
    emit_asm_text_with_alias(text_vec);
}
