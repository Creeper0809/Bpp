// typeinfo.b - Type size/compatibility calculations and struct layout
//
// This module handles type-related calculations:
// - Type size computation (primitives, pointers, structs)
// - Type compatibility checking
// - Struct field offset calculation
// - Expression type inference

import std.io;
import std.vec;
import std.util;
import std.str;
import std.hashmap;
import types;
import ast;
import compiler;

func typeinfo_make(base_type: u64, ptr_depth: u64) -> *TypeInfo {
    return new TypeInfo(base_type, ptr_depth);
}

func typeinfo_make_struct(ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64, struct_def: *AstStructDef) -> *TypeInfo {
    var ti: *TypeInfo = typeinfo_make(TYPE_STRUCT, ptr_depth);
    ti.struct_name_ptr = struct_name_ptr;
    ti.struct_name_len = struct_name_len;
    ti.struct_def = struct_def;
    return ti;
}

func typeinfo_make_array(ptr_depth: u64, elem_type_kind: u64, elem_ptr_depth: u64, elem_struct_name_ptr: u64, elem_struct_name_len: u64, elem_struct_def: *AstStructDef, array_len: u64) -> *TypeInfo {
    var ti: *TypeInfo = typeinfo_make(TYPE_ARRAY, ptr_depth);
    ti.struct_name_ptr = elem_struct_name_ptr;
    ti.struct_name_len = elem_struct_name_len;
    ti.struct_def = elem_struct_def;
    ti.elem_type_kind = elem_type_kind;
    ti.elem_ptr_depth = elem_ptr_depth;
    ti.array_len = array_len;
    return ti;
}

func typeinfo_make_slice(ptr_depth: u64, elem_type_kind: u64, elem_ptr_depth: u64, elem_struct_name_ptr: u64, elem_struct_name_len: u64, elem_struct_def: *AstStructDef) -> *TypeInfo {
    var ti: *TypeInfo = typeinfo_make(TYPE_SLICE, ptr_depth);
    ti.struct_name_ptr = elem_struct_name_ptr;
    ti.struct_name_len = elem_struct_name_len;
    ti.struct_def = elem_struct_def;
    ti.elem_type_kind = elem_type_kind;
    ti.elem_ptr_depth = elem_ptr_depth;
    return ti;
}

func typeinfo_resolve_struct_defs_recursive(ti: *TypeInfo) -> u64 {
    if (ti == 0) { return 0; }
    if (ti.type_kind == TYPE_STRUCT && ti.struct_def == 0 && ti.struct_name_ptr != 0) {
        ti.struct_def = get_struct_def(ti.struct_name_ptr, ti.struct_name_len);
    }
    if (ti.type_kind == TYPE_ARRAY || ti.type_kind == TYPE_SLICE) {
        if (ti.elem_type_kind == TYPE_STRUCT && ti.struct_def == 0 && ti.struct_name_ptr != 0) {
            ti.struct_def = get_struct_def(ti.struct_name_ptr, ti.struct_name_len);
        }
        if (ti.elem_typeinfo != 0) {
            typeinfo_resolve_struct_defs_recursive(ti.elem_typeinfo);
        }
    }
    return 0;
}

func typeinfo_clone(src: *TypeInfo) -> *TypeInfo {
    if (src == 0) { return 0; }
    var ti: *TypeInfo = typeinfo_make(src.type_kind, src.ptr_depth);
    ti.copy_from(src);
    typeinfo_resolve_struct_defs_recursive(ti);
    return ti;
}

func typeinfo_elem_type_from_container(container: *TypeInfo) -> *TypeInfo {
    if (container == 0) { return 0; }
    if (container.elem_typeinfo != 0) {
        return typeinfo_clone(container.elem_typeinfo);
    }
    if (container.elem_type_kind == TYPE_STRUCT) {
        var sdef: *AstStructDef = container.struct_def;
        if (sdef == 0 && container.struct_name_ptr != 0) {
            sdef = get_struct_def(container.struct_name_ptr, container.struct_name_len);
        }
        return typeinfo_make_struct(container.elem_ptr_depth, container.struct_name_ptr, container.struct_name_len, sdef);
    }
    var ti: *TypeInfo = typeinfo_make(container.elem_type_kind, container.elem_ptr_depth);
    ti.struct_name_ptr = container.struct_name_ptr;
    ti.struct_name_len = container.struct_name_len;
    return ti;
}

func typeinfo_elem_size_from_container(container: *TypeInfo) -> u64 {
    var elem_ti: *TypeInfo = typeinfo_elem_type_from_container(container);
    if (elem_ti != 0) {
        return sizeof_type_ex(elem_ti);
    }
    return sizeof_type(container.elem_type_kind, container.elem_ptr_depth, container.struct_name_ptr, container.struct_name_len);
}

func typeinfo_make_trait(ptr_depth: u64, trait_ptr: u64, trait_len: u64) -> *TypeInfo {
    var ti: *TypeInfo = typeinfo_make(TYPE_TRAIT, ptr_depth);
    ti.struct_name_ptr = trait_ptr;
    ti.struct_name_len = trait_len;
    return ti;
}

// Global struct definitions (set by codegen before use)
var g_structs_vec: *Vec<*AstStructDef>;
// Global function definitions (set by codegen before use)
var g_funcs_vec: *Vec<*AstFunc>;
var g_funcs_map: *HashMap<u64, *AstFunc>;

func typeinfo_set_structs(structs: *Vec<*AstStructDef>) -> u64 {
    g_structs_vec = structs;
    return 0;
}

func typeinfo_get_structs() -> *Vec<*AstStructDef> {
    return g_structs_vec;
}

func typeinfo_set_funcs(funcs: *Vec<*AstFunc>) -> u64 {
    g_funcs_vec = funcs;
    g_funcs_map = 0;
    if (funcs != 0) {
        var n: u64 = funcs.len();
        var cap: u64 = n * 2;
        if (cap < 16) { cap = 16; }
        g_funcs_map = new HashMap<u64, *AstFunc>(cap);
        for (var i: u64 = 0; i < n; i++) {
            var fn: *AstFunc = funcs.get(i);
            if (g_funcs_map.has(fn.name_ptr, fn.name_len) == 0) {
                g_funcs_map.put(fn.name_ptr, fn.name_len, fn);
            }
        }
    }
    return 0;
}

func typeinfo_find_func(name_ptr: u64, name_len: u64) -> *AstFunc {
    if (g_funcs_vec == 0) { return 0; }
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    if (g_funcs_map != 0) {
        var mfn_resolved: *AstFunc = g_funcs_map.get(resolved_ptr, resolved_len);
        if (mfn_resolved != 0) { return mfn_resolved; }
        var mfn_raw: *AstFunc = g_funcs_map.get(name_ptr, name_len);
        if (mfn_raw != 0) { return mfn_raw; }
    }
    var num_funcs: u64 = g_funcs_vec.len();
    for (var i: u64 = 0; i < num_funcs; i++) {
        var fn: *AstFunc = g_funcs_vec.get(i);
        if (str_eq(fn.name_ptr, fn.name_len, resolved_ptr, resolved_len)) {
            return fn;
        }
        if (str_eq(fn.name_ptr, fn.name_len, name_ptr, name_len)) {
            return fn;
        }
    }
    return 0;
}

func typeinfo_from_func_ret(fn: *AstFunc, disallow_struct_value: u64) -> *TypeInfo {
    if (fn == 0) { return typeinfo_make(TYPE_I64, 0); }
    if (fn.ret_type == TYPE_STRUCT) {
        if (disallow_struct_value != 0 && fn.ret_ptr_depth == 0) {
            return typeinfo_make(TYPE_I64, 0);
        }
        var struct_def: *AstStructDef = get_struct_def(fn.ret_struct_name_ptr, fn.ret_struct_name_len);
        var rs: *TypeInfo = typeinfo_make_struct(fn.ret_ptr_depth, fn.ret_struct_name_ptr, fn.ret_struct_name_len, struct_def);
        rs.is_tagged = fn.ret_is_tagged;
        rs.tag_layout_ptr = fn.ret_tag_layout_ptr;
        rs.tag_layout_len = fn.ret_tag_layout_len;
        return rs;
    }
    if (fn.ret_type == TYPE_SLICE) {
        var rsl: *TypeInfo = typeinfo_make(fn.ret_type, fn.ret_ptr_depth);
        rsl.is_tagged = fn.ret_is_tagged;
        return rsl;
    }
    var rb: *TypeInfo = typeinfo_make(fn.ret_type, fn.ret_ptr_depth);
    rb.is_tagged = fn.ret_is_tagged;
    rb.struct_name_ptr = fn.ret_struct_name_ptr;
    rb.struct_name_len = fn.ret_struct_name_len;
    rb.tag_layout_ptr = fn.ret_tag_layout_ptr;
    rb.tag_layout_len = fn.ret_tag_layout_len;
    return rb;
}

func typeinfo_from_field_desc(field: *FieldDesc, disallow_struct_value: u64) -> *TypeInfo {
    if (field == 0) { return 0; }
    if (field.type_kind == TYPE_STRUCT) {
        if (disallow_struct_value != 0 && field.ptr_depth == 0) { return 0; }
        var field_struct_def: *AstStructDef = 0;
        if (field.struct_name_ptr != 0) {
            field_struct_def = get_struct_def(field.struct_name_ptr, field.struct_name_len);
        }
        var rs: *TypeInfo = typeinfo_make_struct(field.ptr_depth, field.struct_name_ptr, field.struct_name_len, field_struct_def);
        rs.is_tagged = field.is_tagged;
        rs.tag_layout_ptr = field.tag_layout_ptr;
        rs.tag_layout_len = field.tag_layout_len;
        return rs;
    }
    if (field.type_kind == TYPE_ARRAY) {
        var elem_struct_def: *AstStructDef = 0;
        if (field.elem_type_kind == TYPE_STRUCT && field.struct_name_ptr != 0) {
            elem_struct_def = get_struct_def(field.struct_name_ptr, field.struct_name_len);
        }
        var ti_arr: *TypeInfo = typeinfo_make_array(field.ptr_depth, field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len, elem_struct_def, field.array_len);
        ti_arr.elem_typeinfo = field.elem_typeinfo;
        return ti_arr;
    }
    if (field.type_kind == TYPE_SLICE) {
        var elem_struct_def2: *AstStructDef = 0;
        if (field.elem_type_kind == TYPE_STRUCT && field.struct_name_ptr != 0) {
            elem_struct_def2 = get_struct_def(field.struct_name_ptr, field.struct_name_len);
        }
        var ti_sl: *TypeInfo = typeinfo_make_slice(field.ptr_depth, field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len, elem_struct_def2);
        ti_sl.elem_typeinfo = field.elem_typeinfo;
        return ti_sl;
    }
    var rf: *TypeInfo = typeinfo_make(field.type_kind, field.ptr_depth);
    rf.is_tagged = field.is_tagged;
    rf.struct_name_ptr = field.struct_name_ptr;
    rf.struct_name_len = field.struct_name_len;
    rf.tag_layout_ptr = field.tag_layout_ptr;
    rf.tag_layout_len = field.tag_layout_len;
    return rf;
}

// ============================================
// Type Size Helpers
// ============================================

func get_type_size(base_type: u64, ptr_depth: u64) -> u64 {
    if (ptr_depth > 0) { return 8; }
    if (base_type == TYPE_BOOL) { return 1; }
    if (base_type == TYPE_U8) { return 1; }
    if (base_type == TYPE_U16) { return 2; }
    if (base_type == TYPE_U32) { return 4; }
    if (base_type == TYPE_U64) { return 8; }
    if (base_type == TYPE_I8) { return 1; }
    if (base_type == TYPE_I16) { return 2; }
    if (base_type == TYPE_I32) { return 4; }
    if (base_type == TYPE_I64) { return 8; }
    if (base_type == TYPE_F64) { return 8; }
    if (base_type == TYPE_SLICE) { return 16; }
    if (base_type == TYPE_TRAIT) { return 8; }
    return 8;
}

func get_pointee_size(base_type: u64, ptr_depth: u64) -> u64 {
    if (ptr_depth > 1) { return 8; }
    if (ptr_depth == 1) {
        if (base_type == TYPE_BOOL) { return 1; }
        if (base_type == TYPE_U8) { return 1; }
        if (base_type == TYPE_U16) { return 2; }
        if (base_type == TYPE_U32) { return 4; }
        if (base_type == TYPE_U64) { return 8; }
        if (base_type == TYPE_I8) { return 1; }
        if (base_type == TYPE_I16) { return 2; }
        if (base_type == TYPE_I32) { return 4; }
        if (base_type == TYPE_I64) { return 8; }
        if (base_type == TYPE_F64) { return 8; }
        if (base_type == TYPE_SLICE) { return 16; }
        if (base_type == TYPE_TRAIT) { return 8; }
    }
    return 8;
}

func sizeof_field_desc(field: *FieldDesc) -> u64 {
    if (field.bit_width > 0) {
        return (field.bit_width + 7) / 8;
    }
    if (field.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = 0;
        if (field.elem_typeinfo != 0) {
            elem_size = sizeof_type_ex(field.elem_typeinfo);
        } else {
            elem_size = sizeof_type(field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len);
        }
        return elem_size * field.array_len;
    }
    if (field.type_kind == TYPE_SLICE) { return 16; }
    return sizeof_type(field.type_kind, field.ptr_depth, field.struct_name_ptr, field.struct_name_len);
}

func get_field_desc(struct_def: *AstStructDef, field_name_ptr: u64, field_name_len: u64) -> *FieldDesc {
    var field_desc: *FieldDesc = typeinfo_find_field_desc_scoped(struct_def, 0, 0, field_name_ptr, field_name_len);
    return field_desc;
}

func check_type_compat(from_base: u64, from_depth: u64, from_tagged: u64, from_layout_ptr: u64, from_layout_len: u64, to_base: u64, to_depth: u64, to_tagged: u64, to_layout_ptr: u64, to_layout_len: u64) -> u64 {
    if (from_base == TYPE_ARRAY || to_base == TYPE_ARRAY || from_base == TYPE_SLICE || to_base == TYPE_SLICE) {
        if (from_base == to_base && from_depth == to_depth) { return false; }
        return true;
    }
    if (from_base == to_base) {
        if (from_depth == to_depth) {
            if (from_depth > 0 && from_tagged != to_tagged) { return true; }
            if (from_depth > 0 && from_tagged == 1) {
                if (!str_eq(from_layout_ptr, from_layout_len, to_layout_ptr, to_layout_len)) { return true; }
            }
            return false;
        }
    }
    if (from_depth > 0) {
        if (to_depth > 0) { return true; }
    }
    if (from_depth == 0) {
        if (to_depth == 0) {
            var from_size: u64 = get_type_size(from_base, 0);
            var to_size: u64 = get_type_size(to_base, 0);
            if (from_size == to_size) { return false; }
            return true;
        }
    }
    if (from_depth == 0) {
        if (to_depth > 0) { return true; }
    }
    if (from_depth > 0) {
        if (to_depth == 0) { return true; }
    }
    return true;
}

// Calculate size of a type including structs
// Returns size in bytes for allocating on stack
func sizeof_type(type_kind: u64, ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    // Pointers are always 8 bytes
    if (ptr_depth > 0) { return 8; }

    // Primitive types
    switch (type_kind) {
        case TYPE_BOOL: return 1;
        case TYPE_U8: return 1;
        case TYPE_U16: return 2;
        case TYPE_U32: return 4;
        case TYPE_U64: return 8;
        case TYPE_I8: return 1;
        case TYPE_I16: return 2;
        case TYPE_I32: return 4;
        case TYPE_I64: return 8;
        case TYPE_F64: return 8;
        case TYPE_SLICE: return 16;
        case TYPE_TRAIT: return 8;
        case TYPE_STRUCT:
            var struct_def: *AstStructDef = _typeinfo_find_struct_def(struct_name_ptr, struct_name_len);
            if (struct_def == 0) { return 8; }
            return _typeinfo_struct_size(struct_def);
    }

    // Default: 8 bytes
    return 8;
}

func _typeinfo_find_struct_def(struct_name_ptr: u64, struct_name_len: u64) -> *AstStructDef {
    var num_structs: u64 = g_structs_vec.?len();
    for (var si: u64 = 0; si < num_structs; si++) {
        var candidate: *AstStructDef = g_structs_vec.get(si);
        if (str_eq(candidate.name_ptr, candidate.name_len, struct_name_ptr, struct_name_len)) {
            return candidate;
        }
    }
    return 0;
}

func _typeinfo_packed_struct_size(struct_info: *AstStructDef) -> u64 {
    var fields_p: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields_p: u64 = fields_p.len();
    var total_bits: u64 = 0;
    for (var pi: u64 = 0; pi < num_fields_p; pi++) {
        var field_p: *FieldDesc = fields_p.get(pi);
        if (field_p.bit_width > 0) {
            total_bits = total_bits + field_p.bit_width;
        } else {
            var fsize: u64 = sizeof_field_desc(field_p);
            total_bits = total_bits + fsize * 8;
        }
    }
    return (total_bits + 7) / 8;
}

func _typeinfo_struct_size(struct_info: *AstStructDef) -> u64 {
    return _typeinfo_struct_size_internal(struct_info, 0);
}

// Sizeof helper for extended types (array/slice)
func sizeof_type_ex(info: *TypeInfo) -> u64 {
    if (info.ptr_depth > 0) { return 8; }
    if (info.type_kind == TYPE_STRUCT && info.ptr_depth == 0) {
        if (info.struct_name_ptr == 0 && info.struct_def != 0) {
            var struct_def: *AstStructDef = info.struct_def;
            return _typeinfo_struct_size_internal(struct_def, 0);
        }
    }
    if (info.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = typeinfo_elem_size_from_container(info);
        return elem_size * info.array_len;
    }
    if (info.type_kind == TYPE_SLICE) { return 16; }
    if (info.type_kind == TYPE_TRAIT) { return 8; }
    return sizeof_type(info.type_kind, info.ptr_depth, info.struct_name_ptr, info.struct_name_len);
}

// ============================================
// Struct Helper Functions
// ============================================

func _typeinfo_resolve_parent_def(parent: *ParentDesc) -> *AstStructDef {
    if (parent.struct_def != 0) { return parent.struct_def; }
    var sd: *AstStructDef = get_struct_def(parent.name_ptr, parent.name_len);
    if (sd == 0) {
        emit_stderr("[ERROR] Parent struct not found: ");
        emit_stderr_len(parent.name_ptr, parent.name_len);
        emit_stderr("\n");
        panic("TypeInfo error");
    }
    parent.struct_def = sd;
    return sd;
}

func _typeinfo_struct_size_internal(struct_info: *AstStructDef, depth: u64) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("TypeInfo error");
    }
    if (struct_info.is_union == 1) {
        if (struct_info.is_packed == 1) {
            emit_stderr("[ERROR] packed union is not supported\n");
            panic("TypeInfo error");
        }
        if ((struct_info.parents_vec != 0 && struct_info.parents_vec.len() > 0) ||
            (struct_info.traits_vec != 0 && struct_info.traits_vec.len() > 0)) {
            emit_stderr("[ERROR] union cannot use inheritance or traits\n");
            panic("TypeInfo error");
        }
        var max_size: u64 = 0;
        var fields_u: *Vec<*FieldDesc> = struct_info.fields_vec;
        var num_fields_u: u64 = fields_u.len();
        for (var ui: u64 = 0; ui < num_fields_u; ui++) {
            var field_u: *FieldDesc = fields_u.get(ui);
            var size_u: u64 = sizeof_field_desc(field_u);
            if (size_u > max_size) { max_size = size_u; }
        }
        return max_size;
    }
    if (struct_info.is_packed == 1) {
        if (struct_info.parents_vec != 0 && struct_info.parents_vec.len() > 0) {
            emit_stderr("[ERROR] packed struct cannot use inheritance\n");
            panic("TypeInfo error");
        }
        return _typeinfo_packed_struct_size(struct_info);
    }
    var total_size: u64 = 0;
    if (struct_info.parents_vec != 0) {
        var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
        var pn: u64 = parents.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = parents.get(pi);
            var parent_def: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc);
            var parent_size: u64 = _typeinfo_struct_size_internal(parent_def, depth + 1);
            total_size = total_size + parent_size;
        }
    }
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    for (var i: u64 = 0; i < num_fields; i++) {
        var field: *FieldDesc = fields.get(i);
        var field_size: u64 = sizeof_field_desc(field);
        total_size = total_size + field_size;
    }
    return total_size;
}

func _typeinfo_find_parent_offset(struct_info: *AstStructDef, target_ptr: u64, target_len: u64, base_offset: u64, depth: u64, out_offset: *u64, out_def: **AstStructDef) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("TypeInfo error");
    }
    if (str_eq(struct_info.name_ptr, struct_info.name_len, target_ptr, target_len)) {
        *out_offset = base_offset;
        *out_def = struct_info;
        return 1;
    }
    if (struct_info.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
    var pn: u64 = parents.len();
    var cumulative: u64 = 0;
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc);
        var found: u64 = _typeinfo_find_parent_offset(parent_def, target_ptr, target_len, base_offset + cumulative, depth + 1, out_offset, out_def);
        if (found != 0) { return 1; }
        var parent_size: u64 = _typeinfo_struct_size_internal(parent_def, depth + 1);
        cumulative = cumulative + parent_size;
    }
    return 0;
}

func typeinfo_find_parent_offset(struct_info: *AstStructDef, target_ptr: u64, target_len: u64, out_offset: *u64, out_def: **AstStructDef) -> u64 {
    if (struct_info == 0) { return 0; }
    return _typeinfo_find_parent_offset(struct_info, target_ptr, target_len, 0, 0, out_offset, out_def);
}

func _typeinfo_struct_parent_total_size(struct_info: *AstStructDef, depth: u64) -> u64 {
    if (struct_info != 0 && struct_info.is_union == 1) { return 0; }
    if (struct_info == 0 || struct_info.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
    var pn: u64 = parents.len();
    var total: u64 = 0;
    for (var pi: u64 = 0; pi < pn; pi++) {
        var parent_desc: *ParentDesc = parents.get(pi);
        var parent_def: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc);
        var parent_size: u64 = _typeinfo_struct_size_internal(parent_def, depth + 1);
        total = total + parent_size;
    }
    return total;
}

func _typeinfo_struct_find_field_local(struct_info: *AstStructDef, field_ptr: u64, field_len: u64, start_offset: u64, out_offset: *u64, out_desc: **FieldDesc) -> u64 {
    if (struct_info == 0 || struct_info.fields_vec == 0) { return 0; }
    if (struct_info.is_union == 1) {
        var fields_u: *Vec<*FieldDesc> = struct_info.fields_vec;
        var num_fields_u: u64 = fields_u.len();
        for (var ui: u64 = 0; ui < num_fields_u; ui++) {
            var field_u: *FieldDesc = fields_u.get(ui);
            if (str_eq(field_u.name_ptr, field_u.name_len, field_ptr, field_len)) {
                *out_offset = 0;
                *out_desc = field_u;
                return 1;
            }
        }
        return 0;
    }
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    var offset: u64 = start_offset;
    for (var i: u64 = 0; i < num_fields; i++) {
        var field: *FieldDesc = fields.get(i);
        if (str_eq(field.name_ptr, field.name_len, field_ptr, field_len)) {
            *out_offset = offset;
            *out_desc = field;
            return 1;
        }
        var field_size: u64 = sizeof_field_desc(field);
        offset = offset + field_size;
    }
    return 0;
}

func _typeinfo_struct_find_field_in_parents(struct_info: *AstStructDef, field_ptr: u64, field_len: u64, depth: u64, out_offset: *u64, out_desc: **FieldDesc) -> u64 {
    if (struct_info == 0 || struct_info.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
    var pn: u64 = parents.len();
    var match_count: u64 = 0;
    var match_offset: u64 = 0;
    var match_desc: *FieldDesc = 0;
    var cumulative: u64 = 0;

    for (var j: u64 = 0; j < pn; j++) {
        var parent_desc: *ParentDesc = parents.get(j);
        var parent_def: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc);
        var child_offset: u64 = 0;
        var child_desc: *FieldDesc = 0;
        var found: u64 = _typeinfo_struct_find_field_internal(parent_def, field_ptr, field_len, depth + 1, &child_offset, &child_desc);
        if (found != 0) {
            match_count = match_count + 1;
            if (match_count == 1) {
                match_offset = cumulative + child_offset;
                match_desc = child_desc;
            }
        }
        var parent_size: u64 = _typeinfo_struct_size_internal(parent_def, depth + 1);
        cumulative = cumulative + parent_size;
    }

    if (match_count > 1) {
        emit_stderr("[ERROR] Ambiguous field access: ");
        emit_stderr_len(struct_info.name_ptr, struct_info.name_len);
        emit_stderr(".");
        emit_stderr_len(field_ptr, field_len);
        emit_stderr("\n");
        panic("TypeInfo error");
    }
    if (match_count == 1) {
        *out_offset = match_offset;
        *out_desc = match_desc;
        return 1;
    }
    return 0;
}

func _typeinfo_struct_find_field_internal(struct_info: *AstStructDef, field_ptr: u64, field_len: u64, depth: u64, out_offset: *u64, out_desc: **FieldDesc) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("TypeInfo error");
    }
    if (struct_info.is_union == 1) {
        return _typeinfo_struct_find_field_local(struct_info, field_ptr, field_len, 0, out_offset, out_desc);
    }
    if (struct_info.is_packed == 1) {
        emit_stderr("[ERROR] Packed struct field address is not supported\n");
        panic("TypeInfo error");
    }

    var parent_total: u64 = _typeinfo_struct_parent_total_size(struct_info, depth);
    if (_typeinfo_struct_find_field_local(struct_info, field_ptr, field_len, parent_total, out_offset, out_desc) != 0) {
        return 1;
    }
    return _typeinfo_struct_find_field_in_parents(struct_info, field_ptr, field_len, depth, out_offset, out_desc);
}

func struct_find_field_desc_scoped(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, field_ptr: u64, field_len: u64, out_offset: *u64, out_desc: **FieldDesc) -> u64 {
    if (struct_def == 0) { return 0; }
    if (struct_def.is_union == 1) {
        if (parent_ptr != 0) {
            emit_stderr("[ERROR] union cannot use parent scope\n");
            panic("TypeInfo error");
        }
        return _typeinfo_struct_find_field_local(struct_def, field_ptr, field_len, 0, out_offset, out_desc);
    }
    if (parent_ptr != 0) {
        var parent_offset: u64 = 0;
        var parent_def: *AstStructDef = 0;
        var found_parent: u64 = _typeinfo_find_parent_offset(struct_def, parent_ptr, parent_len, 0, 0, &parent_offset, &parent_def);
        if (found_parent == 0 || parent_def == 0) {
            emit_stderr("[ERROR] Parent scope not found: ");
            emit_stderr_len(parent_ptr, parent_len);
            emit_stderr("\n");
            panic("TypeInfo error");
        }
        var field_offset: u64 = 0;
        var field_desc: *FieldDesc = 0;
        var found_field: u64 = _typeinfo_struct_find_field_internal(parent_def, field_ptr, field_len, 0, &field_offset, &field_desc);
        if (found_field == 0 || field_desc == 0) {
            emit_stderr("[ERROR] Field not found in parent scope: ");
            emit_stderr_len(parent_ptr, parent_len);
            emit_stderr(".");
            emit_stderr_len(field_ptr, field_len);
            emit_stderr("\n");
            panic("TypeInfo error");
        }
        *out_offset = parent_offset + field_offset;
        *out_desc = field_desc;
        return 1;
    }
    return _typeinfo_struct_find_field_internal(struct_def, field_ptr, field_len, 0, out_offset, out_desc);
}

func typeinfo_find_field_desc_scoped(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, field_ptr: u64, field_len: u64) -> *FieldDesc {
    if (struct_def == 0) { return 0; }
    if (struct_def.is_union == 1) {
        var field_offset_u: u64 = 0;
        var field_desc_u: *FieldDesc = 0;
        var found_u: u64 = struct_find_field_desc_scoped(struct_def, parent_ptr, parent_len, field_ptr, field_len, &field_offset_u, &field_desc_u);
        if (found_u == 0) { return 0; }
        return field_desc_u;
    }
    if (struct_def.is_packed == 1) {
        if (parent_ptr != 0) {
            emit_stderr("[ERROR] Packed struct cannot use parent scope\n");
            panic("TypeInfo error");
        }
        var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
        var num_fields: u64 = fields.len();
        for (var i: u64 = 0; i < num_fields; i++) {
            var field: *FieldDesc = fields.get(i);
            if (str_eq(field.name_ptr, field.name_len, field_ptr, field_len)) {
                return field;
            }
        }
        return 0;
    }
    var field_offset: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found: u64 = struct_find_field_desc_scoped(struct_def, parent_ptr, parent_len, field_ptr, field_len, &field_offset, &field_desc);
    if (found == 0) { return 0; }
    return field_desc;
}

// Get field offset in bytes from struct definition
// Returns 0 if field not found (caller must handle)
func get_field_offset(struct_def: *AstStructDef, field_name_ptr: u64, field_name_len: u64) -> u64 {
    var field_offset: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found: u64 = struct_find_field_desc_scoped(struct_def, 0, 0, field_name_ptr, field_name_len, &field_offset, &field_desc);
    if (found == 0) { return 0; }
    return field_offset;
}

// ============================================
// Expression Type Inference
// ============================================

// Forward declarations for symtab functions (imported by codegen)
// We need g_symtab from emitter module

func typeinfo_collect_arg_types(args: *Vec<*AstNode>, symtab: *Symtab) -> *Vec<*TypeInfo> {
    if (args == 0) { return new Vec<*TypeInfo>(0); }
    var n: u64 = args.len();
    var out: *Vec<*TypeInfo> = new Vec<*TypeInfo>(n);
    for (var i: u64 = 0; i < n; i++) {
        out.push(get_expr_type_with_symtab(args.get(i), symtab));
    }
    return out;
}

func typeinfo_method_call_ret(mc: *AstMethodCall, symtab: *Symtab, is_safe: u64) -> *TypeInfo {
    if (g_funcs_vec == 0) { return typeinfo_make(TYPE_I64, 0); }
    var recv_ti: *TypeInfo = get_expr_type_with_symtab(mc.receiver, symtab);
    if (recv_ti == 0) { return typeinfo_make(TYPE_I64, 0); }
    var arg_types: *Vec<*TypeInfo> = typeinfo_collect_arg_types(mc.args_vec, symtab);
    var arg_count_hint: u64 = 0;
    if (mc.args_vec != 0) { arg_count_hint = mc.args_vec.len(); }

    if (is_safe != 0) {
        var safe_mode: u64 = compiler_safe_receiver_mode(recv_ti);
        if (safe_mode == COMPILER_SAFE_RECV_INVALID) {
            if (recv_ti.ptr_depth == 0) {
                emit_stderr("[ERROR] Safe method call requires pointer receiver\n");
            }
            return typeinfo_make(TYPE_I64, 0);
        }
    }

    var is_trait_recv: u64 = 0;
    if (recv_ti.type_kind == TYPE_TRAIT || compiler_is_trait_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len) != 0) {
        is_trait_recv = 1;
    }
    if (is_trait_recv != 0) {
        var trait_def: *TraitDef = compiler_get_trait_def(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
        if (trait_def == 0) { return typeinfo_make(TYPE_I64, 0); }
        var mcount: u64 = trait_def.methods_vec.len();
        for (var mi: u64 = 0; mi < mcount; mi++) {
            var tm: *TraitMethod = trait_def.methods_vec.get(mi);
            if (str_eq(tm.name_ptr, tm.name_len, mc.method_ptr, mc.method_len)) {
                var sig: *AstFunc = tm.sig;
                if (is_safe != 0 && sig.ret_type == TYPE_STRUCT && sig.ret_ptr_depth == 0) {
                    emit_stderr("[ERROR] Safe method call cannot return struct by value\n");
                    return typeinfo_make(TYPE_I64, 0);
                }
                if (is_safe != 0) { return typeinfo_from_func_ret(sig, 1); }
                return typeinfo_from_func_ret(sig, 0);
            }
        }
        return typeinfo_make(TYPE_I64, 0);
    }

    if (recv_ti.type_kind != TYPE_STRUCT) { return typeinfo_make(TYPE_I64, 0); }

    if (compiler_check_method_access_overload(recv_ti.struct_name_ptr, recv_ti.struct_name_len, mc.method_ptr, mc.method_len, arg_types, arg_count_hint) == 0) {
        emit_stderr("[ERROR] private method access denied: ");
        emit_stderr_len(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
        emit_stderr(".");
        emit_stderr_len(mc.method_ptr, mc.method_len);
        emit_stderr("\n");
        return typeinfo_make(TYPE_I64, 0);
    }

    var recv_struct_def: *AstStructDef = recv_ti.struct_def;
    if (recv_struct_def == 0) {
        recv_struct_def = get_struct_def(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
    }

    if (recv_ti.ptr_depth > 0) {
        var virt_trait: *NameInfo = compiler_find_virtual_dispatch_trait(recv_ti.struct_name_ptr, recv_ti.struct_name_len, mc.method_ptr, mc.method_len);
        if (virt_trait != 0) {
            var vtd: *TraitDef = compiler_get_trait_def(virt_trait.ptr, virt_trait.len);
            if (vtd != 0) {
                var vmn: u64 = vtd.methods_vec.len();
                for (var vmi: u64 = 0; vmi < vmn; vmi++) {
                    var vtm: *TraitMethod = vtd.methods_vec.get(vmi);
                    if (str_eq(vtm.name_ptr, vtm.name_len, mc.method_ptr, mc.method_len)) {
                        var vsig: *AstFunc = vtm.sig;
                        if (is_safe != 0 && vsig.ret_type == TYPE_STRUCT && vsig.ret_ptr_depth == 0) {
                            emit_stderr("[ERROR] Safe method call cannot return struct by value\n");
                            return typeinfo_make(TYPE_I64, 0);
                        }
                        if (is_safe != 0) { return typeinfo_from_func_ret(vsig, 1); }
                        return typeinfo_from_func_ret(vsig, 0);
                    }
                }
            }
        }
    }

    var resolved_method: CompilerMethodResolveResult = compiler_resolve_method_overload(recv_ti.struct_name_ptr, recv_ti.struct_name_len, mc.method_ptr, mc.method_len, arg_types, arg_count_hint);
    var fn: *AstFunc = 0;
    if (resolved_method.found != 0) {
        fn = resolved_method.fn;
    }
    if (fn == 0 && recv_struct_def != 0) {
        fn = compiler_find_method_func_in_hierarchy(recv_struct_def, mc.method_ptr, mc.method_len);
    }
    if (fn == 0) {
        var name_info: *NameInfo = compiler_build_method_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len, mc.method_ptr, mc.method_len);
        fn = typeinfo_find_func(name_info.ptr, name_info.len);
    }
    if (fn == 0) { return typeinfo_make(TYPE_I64, 0); }
    if (is_safe != 0 && fn.ret_type == TYPE_STRUCT && fn.ret_ptr_depth == 0) {
        emit_stderr("[ERROR] Safe method call cannot return struct by value\n");
        return typeinfo_make(TYPE_I64, 0);
    }
    if (is_safe != 0) { return typeinfo_from_func_ret(fn, 1); }
    return typeinfo_from_func_ret(fn, 0);
}

func typeinfo_try_value_type(tr: *AstTry, symtab: *Symtab) -> *TypeInfo {
    var opt_ti: *TypeInfo = get_expr_type_with_symtab(tr.operand, symtab);
    if (opt_ti == 0) { return 0; }
    var try_kind: u64 = compiler_try_kind_from_typeinfo(opt_ti);
    if (try_kind == COMPILER_TRY_KIND_INVALID) { return 0; }

    var try_fields: CompilerTryFieldNames = compiler_try_field_names(try_kind);
    if (try_fields.found == 0) {
        return 0;
    }
    var value_ptr: u64 = try_fields.value_ptr;
    var value_len: u64 = try_fields.value_len;

    var struct_def: *AstStructDef = compiler_try_resolve_struct_def(opt_ti);
    if (struct_def == 0) { return 0; }
    var field: *FieldDesc = get_field_desc(struct_def, value_ptr, value_len);
    if (field == 0) { return 0; }
    return typeinfo_from_field_desc(field, 0);
}

func typeinfo_safe_member_access_type(sm: *AstMemberAccess, symtab: *Symtab) -> *TypeInfo {
    var sobj_ti: *TypeInfo = get_expr_type_with_symtab(sm.object, symtab);
    if (sobj_ti == 0) { return 0; }
    var recv_mode: u64 = compiler_safe_receiver_mode(sobj_ti);
    if (recv_mode == COMPILER_SAFE_RECV_INVALID) {
        if (sobj_ti.ptr_depth == 0) {
            emit_stderr("[ERROR] Safe member access requires pointer receiver\n");
        }
        return 0;
    }
    if (recv_mode != COMPILER_SAFE_RECV_STRUCT_PTR) { return 0; }

    var sstruct_def: *AstStructDef = sobj_ti.struct_def;
    if (sstruct_def == 0) { return 0; }
    var sfield: *FieldDesc = typeinfo_find_field_desc_scoped(sstruct_def, sm.parent_ptr, sm.parent_len, sm.member_ptr, sm.member_len);
    if (sfield == 0) { return 0; }
    if (compiler_check_field_access(sfield) == 0) {
        emit_stderr("[ERROR] private field access denied: ");
        emit_stderr_len(sstruct_def.name_ptr, sstruct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(sm.member_ptr, sm.member_len);
        emit_stderr("\n");
        return 0;
    }
    var sfield_type: u64 = sfield.type_kind;
    var sfield_ptr_depth: u64 = sfield.ptr_depth;
    if (sfield_type == TYPE_STRUCT && sfield_ptr_depth == 0) {
        emit_stderr("[ERROR] Safe member access on struct value is not supported\n");
        return 0;
    }
    return typeinfo_from_field_desc(sfield, 0);
}

func typeinfo_clone_with_depth(src: *TypeInfo, new_ptr_depth: u64) -> *TypeInfo {
    if (src == 0) { return 0; }
    var ti: *TypeInfo = typeinfo_make(src.type_kind, new_ptr_depth);
    ti.copy_from(src);
    ti.ptr_depth = new_ptr_depth;
    return ti;
}

func typeinfo_from_new_expr(nw: *AstNew) -> *TypeInfo {
    var out_ptr_depth: u64 = nw.ptr_depth + 1;
    if (nw.type_kind == TYPE_STRUCT) {
        var struct_def: *AstStructDef = get_struct_def(nw.struct_name_ptr, nw.struct_name_len);
        var ti_s: *TypeInfo = typeinfo_make_struct(out_ptr_depth, nw.struct_name_ptr, nw.struct_name_len, struct_def);
        ti_s.is_tagged = nw.is_tagged;
        return ti_s;
    }
    if (nw.type_kind == TYPE_ARRAY) {
        var elem_def: *AstStructDef = 0;
        if (nw.elem_type_kind == TYPE_STRUCT) {
            elem_def = get_struct_def(nw.struct_name_ptr, nw.struct_name_len);
        }
        var ti_arr: *TypeInfo = typeinfo_make_array(out_ptr_depth, nw.elem_type_kind, nw.elem_ptr_depth, nw.struct_name_ptr, nw.struct_name_len, elem_def, nw.array_len);
        ti_arr.elem_typeinfo = nw.elem_typeinfo;
        return ti_arr;
    }
    if (nw.type_kind == TYPE_SLICE) {
        var elem_def2: *AstStructDef = 0;
        if (nw.elem_type_kind == TYPE_STRUCT) {
            elem_def2 = get_struct_def(nw.struct_name_ptr, nw.struct_name_len);
        }
        var ti_sl: *TypeInfo = typeinfo_make_slice(out_ptr_depth, nw.elem_type_kind, nw.elem_ptr_depth, nw.struct_name_ptr, nw.struct_name_len, elem_def2);
        ti_sl.elem_typeinfo = nw.elem_typeinfo;
        return ti_sl;
    }
    var ti_p: *TypeInfo = typeinfo_make(nw.type_kind, out_ptr_depth);
    ti_p.is_tagged = nw.is_tagged;
    ti_p.struct_name_ptr = nw.struct_name_ptr;
    ti_p.struct_name_len = nw.struct_name_len;
    ti_p.tag_layout_ptr = nw.tag_layout_ptr;
    ti_p.tag_layout_len = nw.tag_layout_len;
    return ti_p;
}

func typeinfo_from_stack_ctor_expr(sc: *AstStackCtor) -> *TypeInfo {
    if (sc.type_kind == TYPE_STRUCT) {
        var struct_def_sc: *AstStructDef = get_struct_def(sc.struct_name_ptr, sc.struct_name_len);
        var ti_sc: *TypeInfo = typeinfo_make_struct(sc.ptr_depth, sc.struct_name_ptr, sc.struct_name_len, struct_def_sc);
        ti_sc.is_tagged = sc.is_tagged;
        return ti_sc;
    }
    var ti_sc2: *TypeInfo = typeinfo_make(sc.type_kind, sc.ptr_depth);
    ti_sc2.is_tagged = sc.is_tagged;
    ti_sc2.struct_name_ptr = sc.struct_name_ptr;
    ti_sc2.struct_name_len = sc.struct_name_len;
    ti_sc2.tag_layout_ptr = sc.tag_layout_ptr;
    ti_sc2.tag_layout_len = sc.tag_layout_len;
    ti_sc2.elem_type_kind = sc.elem_type_kind;
    ti_sc2.elem_ptr_depth = sc.elem_ptr_depth;
    ti_sc2.array_len = sc.array_len;
    ti_sc2.array_len_is_param = sc.array_len_is_param;
    ti_sc2.array_len_param_ptr = sc.array_len_param_ptr;
    ti_sc2.array_len_param_len = sc.array_len_param_len;
    ti_sc2.elem_typeinfo = sc.elem_typeinfo;
    return ti_sc2;
}

func typeinfo_from_call_ptr_expr(cp: *AstCallPtr) -> *TypeInfo {
    var callee: u64 = cp.callee;
    var name_ptr2: u64 = 0;
    var name_len2: u64 = 0;
    var ck: u64 = ast_kind(callee);
    if (ck == AST_IDENT) {
        var idn: *AstIdent = (*AstIdent)callee;
        name_ptr2 = idn.name_ptr;
        name_len2 = idn.name_len;
    } else if (ck == AST_ADDR_OF) {
        var a: *AstAddrOf = (*AstAddrOf)callee;
        if (ast_kind(a.operand) == AST_IDENT) {
            var idn2: *AstIdent = (*AstIdent)a.operand;
            name_ptr2 = idn2.name_ptr;
            name_len2 = idn2.name_len;
        }
    }
    if (name_ptr2 != 0) {
        var fn_ptr: *AstFunc = typeinfo_find_func(name_ptr2, name_len2);
        if (fn_ptr != 0) { return typeinfo_from_func_ret(fn_ptr, 0); }
    }
    return typeinfo_make(TYPE_I64, 0);
}

func typeinfo_from_ident_expr(ident: *AstIdent, symtab: *Symtab) -> *TypeInfo {
    var name_ptr: u64 = ident.name_ptr;
    var name_len: u64 = ident.name_len;
    var names: *Vec<*NameInfo> = symtab.names_vec;
    var types: *Vec<*TypeInfo> = symtab.types_vec;
    var count: u64 = symtab.count;

    if (count == 0) {
        var resolved_ptr0: u64 = name_ptr;
        var resolved_len0: u64 = name_len;
        var resolved0: *NameInfo = resolve_name(name_ptr, name_len);
        if (resolved0 != 0) {
            resolved_ptr0 = resolved0.ptr;
            resolved_len0 = resolved0.len;
        }
        var ginfo0: *GlobalInfo = compiler_find_global_info(resolved_ptr0, resolved_len0);
        if (ginfo0 == 0 && (resolved_ptr0 != name_ptr || resolved_len0 != name_len)) {
            ginfo0 = compiler_find_global_info(name_ptr, name_len);
        }
        if (ginfo0 != 0 && ginfo0.typeinfo_ptr != 0) { return ginfo0.typeinfo_ptr; }
        return typeinfo_make(TYPE_I64, 0);
    }

    for (var idx: i64 = (i64)count - 1; idx >= 0; idx = idx - 1) {
        var i: u64 = (u64)idx;
        var name_info: *NameInfo = names.get(i);
        if (str_eq(name_info.ptr, name_info.len, name_ptr, name_len)) {
            return types.get(i);
        }
    }

    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    var ginfo: *GlobalInfo = compiler_find_global_info(resolved_ptr, resolved_len);
    if (ginfo == 0 && (resolved_ptr != name_ptr || resolved_len != name_len)) {
        ginfo = compiler_find_global_info(name_ptr, name_len);
    }
    if (ginfo != 0 && ginfo.typeinfo_ptr != 0) { return ginfo.typeinfo_ptr; }

    return typeinfo_make(TYPE_I64, 0);
}

func typeinfo_from_cast_expr(cast_node: *AstCast) -> *TypeInfo {
    if (cast_node.target_type == TYPE_TRAIT) {
        return typeinfo_make_trait(cast_node.target_ptr_depth, cast_node.struct_name_ptr, cast_node.struct_name_len);
    }
    if (cast_node.target_type == TYPE_STRUCT) {
        var struct_def: *AstStructDef = get_struct_def(cast_node.struct_name_ptr, cast_node.struct_name_len);
        var rs: *TypeInfo = typeinfo_make_struct(cast_node.target_ptr_depth, cast_node.struct_name_ptr, cast_node.struct_name_len, struct_def);
        rs.is_tagged = cast_node.target_is_tagged;
        return rs;
    }
    var rb: *TypeInfo = typeinfo_make(cast_node.target_type, cast_node.target_ptr_depth);
    rb.is_tagged = cast_node.target_is_tagged;
    rb.struct_name_ptr = cast_node.struct_name_ptr;
    rb.struct_name_len = cast_node.struct_name_len;
    rb.tag_layout_ptr = cast_node.tag_layout_ptr;
    rb.tag_layout_len = cast_node.tag_layout_len;
    return rb;
}

func typeinfo_from_addr_of_expr(addr_of: *AstAddrOf, symtab: *Symtab) -> *TypeInfo {
    var op_ti: *TypeInfo = get_expr_type_with_symtab(addr_of.operand, symtab);
    if (op_ti == 0) { return 0; }
    return typeinfo_clone_with_depth(op_ti, op_ti.ptr_depth + 1);
}

func typeinfo_from_deref_expr(deref: *AstDeref, symtab: *Symtab) -> *TypeInfo {
    var op_ti: *TypeInfo = get_expr_type_with_symtab(deref.operand, symtab);
    if (op_ti == 0 || op_ti.ptr_depth == 0) { return 0; }
    return typeinfo_clone_with_depth(op_ti, op_ti.ptr_depth - 1);
}

func typeinfo_from_index_expr(index: *AstIndex, symtab: *Symtab) -> *TypeInfo {
    var bt: *TypeInfo = get_expr_type_with_symtab(index.base, symtab);
    if (bt != 0) {
        if (bt.ptr_depth > 0) {
            if (bt.type_kind == TYPE_STRUCT) {
                return typeinfo_make_struct(bt.ptr_depth - 1, bt.struct_name_ptr, bt.struct_name_len, bt.struct_def);
            }
            return typeinfo_make(bt.type_kind, bt.ptr_depth - 1);
        }
        if (bt.type_kind == TYPE_ARRAY || bt.type_kind == TYPE_SLICE) {
            if (bt.elem_typeinfo != 0) {
                return typeinfo_clone(bt.elem_typeinfo);
            }
            if (bt.elem_type_kind == TYPE_STRUCT) {
                return typeinfo_make_struct(bt.elem_ptr_depth, bt.struct_name_ptr, bt.struct_name_len, bt.struct_def);
            }
            return typeinfo_make(bt.elem_type_kind, bt.elem_ptr_depth);
        }
    }
    return typeinfo_make(TYPE_I64, 0);
}

func typeinfo_from_slice_expr(slice: *AstSlice, symtab: *Symtab) -> *TypeInfo {
    var pt: *TypeInfo = get_expr_type_with_symtab(slice.ptr_expr, symtab);
    if (pt != 0 && pt.ptr_depth > 0) {
        if (pt.type_kind == TYPE_STRUCT) {
            return typeinfo_make_slice(0, TYPE_STRUCT, pt.ptr_depth - 1, pt.struct_name_ptr, pt.struct_name_len, pt.struct_def);
        }
        var out: *TypeInfo = typeinfo_make_slice(0, pt.type_kind, pt.ptr_depth - 1, pt.struct_name_ptr, pt.struct_name_len, 0);
        out.elem_typeinfo = pt.elem_typeinfo;
        return out;
    }
    return typeinfo_make_slice(0, TYPE_U8, 0, 0, 0, 0);
}

func typeinfo_from_member_access_expr(member_access: *AstMemberAccess, symtab: *Symtab) -> *TypeInfo {
    var obj_ti: *TypeInfo = get_expr_type_with_symtab(member_access.object, symtab);
    if (ast_kind(member_access.object) == AST_IDENT && member_access.parent_ptr == 0) {
        var scope_id: *AstIdent = (*AstIdent)member_access.object;
        var scoped_const: *ConstResult = (*ConstResult)compiler_find_scoped_const(scope_id.name_ptr, scope_id.name_len, member_access.member_ptr, member_access.member_len);
        if (scoped_const != 0 && scoped_const.found != 0) {
            return typeinfo_make(TYPE_I64, 0);
        }
    }
    if (obj_ti == 0) { return 0; }
    if (obj_ti.ptr_depth > 0 && obj_ti.is_tagged == 1 && obj_ti.tag_layout_ptr != 0) {
        return typeinfo_make(TYPE_U64, 0);
    }
    if (obj_ti.type_kind != TYPE_STRUCT || obj_ti.struct_def == 0) { return 0; }
    var field: *FieldDesc = typeinfo_find_field_desc_scoped(obj_ti.struct_def, member_access.parent_ptr, member_access.parent_len, member_access.member_ptr, member_access.member_len);
    if (field == 0) { return 0; }
    if (compiler_check_field_access(field) == 0) {
        emit_stderr("[ERROR] private field access denied: ");
        emit_stderr_len(obj_ti.struct_def.name_ptr, obj_ti.struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(member_access.member_ptr, member_access.member_len);
        emit_stderr("\n");
        return 0;
    }
    return typeinfo_from_field_desc(field, 0);
}

func typeinfo_from_unary_expr(unary: *AstUnary, symtab: *Symtab) -> *TypeInfo {
    if (unary == 0) { return typeinfo_make(TYPE_I64, 0); }
    if (unary.op == TOKEN_MINUS || unary.op == TOKEN_PLUS) {
        var operand_ti: *TypeInfo = get_expr_type_with_symtab(unary.operand, symtab);
        if (operand_ti != 0 && operand_ti.ptr_depth == 0 && operand_ti.type_kind == TYPE_F64) {
            return typeinfo_make(TYPE_F64, 0);
        }
    }
    return typeinfo_make(TYPE_I64, 0);
}

func typeinfo_from_binary_expr(binary: *AstBinary, symtab: *Symtab) -> *TypeInfo {
    var op: u64 = binary.op;
    var left_ti_f: *TypeInfo = get_expr_type_with_symtab(binary.left, symtab);
    var right_ti_f: *TypeInfo = get_expr_type_with_symtab(binary.right, symtab);
    var left_is_f64: u64 = 0;
    var right_is_f64: u64 = 0;
    if (left_ti_f != 0) { left_is_f64 = (left_ti_f.ptr_depth == 0 && left_ti_f.type_kind == TYPE_F64); }
    if (right_ti_f != 0) { right_is_f64 = (right_ti_f.ptr_depth == 0 && right_ti_f.type_kind == TYPE_F64); }
    if (left_is_f64 != 0 || right_is_f64 != 0) {
        if (op == TOKEN_PLUS || op == TOKEN_MINUS || op == TOKEN_STAR || op == TOKEN_SLASH) {
            return typeinfo_make(TYPE_F64, 0);
        }
    }

    if (op == TOKEN_ANDAND || op == TOKEN_OROR ||
        op == TOKEN_LT || op == TOKEN_GT ||
        op == TOKEN_LTEQ || op == TOKEN_GTEQ ||
        op == TOKEN_EQEQ || op == TOKEN_BANGEQ) {
        return typeinfo_make(TYPE_I64, 0);
    }

    if (op == TOKEN_PLUS || op == TOKEN_MINUS) {
        var left_ti: *TypeInfo = get_expr_type_with_symtab(binary.left, symtab);
        if (left_ti != 0 && left_ti.ptr_depth > 0) {
            return typeinfo_clone_with_depth(left_ti, left_ti.ptr_depth);
        }
        var right_ti: *TypeInfo = get_expr_type_with_symtab(binary.right, symtab);
        if (right_ti != 0 && right_ti.ptr_depth > 0) {
            return typeinfo_clone_with_depth(right_ti, right_ti.ptr_depth);
        }
    }
    return 0;
}

func get_expr_type_with_symtab(node: *AstNode, symtab: *Symtab) -> *TypeInfo {
    if (node == 0) { return typeinfo_make(TYPE_I64, 0); }
    var kind: u64 = ast_kind(node);
    var nref: AstNodeTagRef;
    nref.node = node;

    if (kind == AST_NEW) { return typeinfo_from_new_expr(nref.new_expr); }
    if (kind == AST_STACK_CTOR) { return typeinfo_from_stack_ctor_expr(nref.stack_ctor); }
    if (kind == AST_SIZEOF || kind == AST_SIZEOF_EXPR) { return typeinfo_make(TYPE_U64, 0); }

    if (kind == AST_CALL) {
        var fn_call: *AstFunc = typeinfo_find_func(nref.call.name_ptr, nref.call.name_len);
        if (fn_call != 0) { return typeinfo_from_func_ret(fn_call, 0); }
        return typeinfo_make(TYPE_I64, 0);
    }
    if (kind == AST_CALL_PTR) { return typeinfo_from_call_ptr_expr(nref.call_ptr); }
    if (kind == AST_METHOD_CALL) { return typeinfo_method_call_ret(nref.method_call, symtab, 0); }
    if (kind == AST_SAFE_METHOD_CALL) { return typeinfo_method_call_ret(nref.method_call, symtab, 1); }
    if (kind == AST_IDENT) { return typeinfo_from_ident_expr(nref.ident, symtab); }
    if (kind == AST_STRING) { return typeinfo_make(TYPE_U8, 1); }
    if (kind == AST_CAST) { return typeinfo_from_cast_expr(nref.cast_expr); }
    if (kind == AST_TRY) { return typeinfo_try_value_type(nref.try_expr, symtab); }

    if (kind == AST_ADDR_OF) {
        var addr_res: *TypeInfo = typeinfo_from_addr_of_expr(nref.addr_of, symtab);
        if (addr_res != 0) { return addr_res; }
    }
    if (kind == AST_DEREF) {
        var deref_res: *TypeInfo = typeinfo_from_deref_expr(nref.deref, symtab);
        if (deref_res != 0) { return deref_res; }
    }
    if (kind == AST_DEREF8) { return typeinfo_make(TYPE_U8, 0); }
    if (kind == AST_INDEX) { return typeinfo_from_index_expr(nref.index_expr, symtab); }
    if (kind == AST_SLICE) { return typeinfo_from_slice_expr(nref.slice_expr, symtab); }

    if (kind == AST_MEMBER_ACCESS) {
        var mres: *TypeInfo = typeinfo_from_member_access_expr(nref.member_access, symtab);
        if (mres != 0) { return mres; }
        return 0;
    }
    if (kind == AST_SAFE_MEMBER_ACCESS) { return typeinfo_safe_member_access_type(nref.member_access, symtab); }
    if (kind == AST_STRUCT_LITERAL) {
        return typeinfo_make_struct(0, 0, 0, nref.struct_lit.struct_def);
    }

    if (kind == AST_BINARY) {
        var bres: *TypeInfo = typeinfo_from_binary_expr(nref.binary, symtab);
        if (bres != 0) { return bres; }
    }
    if (kind == AST_UNARY) { return typeinfo_from_unary_expr(nref.unary, symtab); }

    if (kind == AST_LITERAL) { return typeinfo_make(TYPE_I64, 0); }
    if (kind == AST_FLOAT) { return typeinfo_make(TYPE_F64, 0); }
    return typeinfo_make(TYPE_I64, 0);
}
