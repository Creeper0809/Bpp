// types.b - Token and AST type constants for v3.8

// ============================================
// Token Types
// ============================================
const TOKEN_EOF = 0;
const TOKEN_IDENTIFIER = 10;
const TOKEN_NUMBER = 11;
const TOKEN_STRING = 12;
const TOKEN_FLOAT = 13;

// Keywords
const TOKEN_FUNC = 20;
const TOKEN_VAR = 21;
const TOKEN_CONST = 22;
const TOKEN_RETURN = 23;
const TOKEN_IF = 24;
const TOKEN_ELSE = 25;
const TOKEN_WHILE = 26;
const TOKEN_IMPORT = 27;
const TOKEN_FOR = 28;
const TOKEN_SWITCH = 29;
const TOKEN_CASE = 30;
const TOKEN_DEFAULT = 31;
const TOKEN_BREAK = 32;
const TOKEN_CONTINUE = 33;
const TOKEN_ASM = 34;
const TOKEN_TRUE = 35;
const TOKEN_FALSE = 36;
const TOKEN_STRUCT = 37;
const TOKEN_ENUM = 38;
const TOKEN_IMPL = 39;
const TOKEN_TRAIT = 91;
const TOKEN_UNION = 89;
const TOKEN_ABST = 92;
const TOKEN_ASSERT = 93;
const TOKEN_TODO = 94;
const TOKEN_UNREACHABLE = 95;
const TOKEN_PUBLIC = 96;
const TOKEN_PRIVATE = 97;
const TOKEN_PROTECTED = 98;
const TOKEN_SUPER = 99;
const TOKEN_STATIC = 47;

// Compiler macros
const TOKEN_LINE_MACRO = 45;
const TOKEN_SIZEOF = 46;

// Type keywords
const TOKEN_U8 = 40;
const TOKEN_U16 = 41;
const TOKEN_U32 = 42;
const TOKEN_U64 = 43;
const TOKEN_I64 = 44;
const TOKEN_F64 = 90;
const TOKEN_CHAR = 48;
const TOKEN_TAGGED = 49;
const TOKEN_PACKED = 50;
const TOKEN_AS = 51;
const TOKEN_FROM = 52;
const TOKEN_NULL = 53;
const TOKEN_ALIAS = 54;
const TOKEN_DEFER = 55;
const TOKEN_NEW = 56;
const TOKEN_DELETE = 57;
const TOKEN_CONSTRUCTOR = 58;
const TOKEN_DESTRUCTOR = 59;
const TOKEN_BOOL = 114;
const TOKEN_I8 = 115;
const TOKEN_I16 = 116;
const TOKEN_I32 = 117;
const TOKEN_MATCH = 118;
const TOKEN_TRY = 119;
const TOKEN_CATCH = 120;
const TOKEN_FINALLY = 121;
const TOKEN_THROW = 122;
const TOKEN_WHERE = 123;

// Delimiters
const TOKEN_LPAREN = 100;
const TOKEN_RPAREN = 101;
const TOKEN_LBRACE = 102;
const TOKEN_RBRACE = 103;
const TOKEN_LBRACKET = 104;
const TOKEN_RBRACKET = 105;
const TOKEN_SEMICOLON = 106;
const TOKEN_COLON = 107;
const TOKEN_COMMA = 108;
const TOKEN_DOT = 109;
const TOKEN_ARROW = 110;
const TOKEN_DOT_Q = 111;
const TOKEN_QUESTION = 112;
const TOKEN_AT = 113;

// Operators
const TOKEN_PLUS = 60;
const TOKEN_MINUS = 61;
const TOKEN_STAR = 62;
const TOKEN_SLASH = 63;
const TOKEN_PERCENT = 64;
const TOKEN_CARET = 65;
const TOKEN_AMPERSAND = 66;
const TOKEN_BANG = 67;
const TOKEN_EQ = 68;
const TOKEN_EQEQ = 69;
const TOKEN_BANGEQ = 70;
const TOKEN_LT = 71;
const TOKEN_GT = 72;
const TOKEN_LTEQ = 73;
const TOKEN_GTEQ = 74;
const TOKEN_PIPE = 75;
const TOKEN_LSHIFT = 76;
const TOKEN_RSHIFT = 77;
const TOKEN_ANDAND = 78;
const TOKEN_OROR = 79;
const TOKEN_PLUSPLUS = 80;
const TOKEN_MINUSMINUS = 81;
const TOKEN_PLUS_EQ = 82;
const TOKEN_MINUS_EQ = 83;
const TOKEN_STAR_EQ = 84;
const TOKEN_SLASH_EQ = 85;
const TOKEN_PERCENT_EQ = 86;
const TOKEN_TILDE = 87;

// ============================================
// AST Node Types
// ============================================

// Expressions
const AST_LITERAL = 100;
const AST_IDENT = 101;
const AST_BINARY = 102;
const AST_UNARY = 103;
const AST_CALL = 104;
const AST_ADDR_OF = 105;
const AST_DEREF = 106;
const AST_DEREF8 = 107;
const AST_CAST = 108;
const AST_STRING = 109;
const AST_MEMBER_ACCESS = 110;
const AST_STRUCT_LITERAL = 111;
const AST_SIZEOF = 112;
const AST_METHOD_CALL = 113;
const AST_INDEX = 114;
const AST_SLICE = 115;
const AST_CALL_PTR = 116;
const AST_SIZEOF_EXPR = 117;
const AST_GENERIC_CALL = 118;
const AST_SAFE_MEMBER_ACCESS = 119;
const AST_SAFE_METHOD_CALL = 120;
const AST_TRY = 121;
const AST_FLOAT = 122;
const AST_SUPER = 123;
const AST_GENERIC_STRUCT_LITERAL = 124;
const AST_STATIC_GENERIC_CALL = 125;

// Statements
const AST_RETURN = 200;
const AST_VAR_DECL = 201;
const AST_CONST_DECL = 206;
const AST_ASSIGN = 202;
const AST_EXPR_STMT = 203;
const AST_IF = 204;
const AST_WHILE = 205;
const AST_FOR = 207;
const AST_SWITCH = 208;
const AST_CASE = 209;
const AST_BREAK = 211;
const AST_CONTINUE = 212;
const AST_BLOCK = 210;
const AST_ASM = 213;
const AST_ALIAS = 214;
const AST_DEFER = 215;
const AST_NEW = 216;
const AST_DELETE = 217;
const AST_STACK_CTOR = 218;
const AST_MATCH = 219;

// Top-level
const AST_FUNC = 300;
const AST_PROGRAM = 301;
const AST_IMPORT = 302;
const AST_STRUCT_DEF = 303;

// ============================================
// Type Constants
// ============================================
const TYPE_VOID = 0;
const TYPE_U8 = 1;
const TYPE_U16 = 2;
const TYPE_U32 = 3;
const TYPE_U64 = 4;
const TYPE_I64 = 5;
const TYPE_F64 = 6;
const TYPE_BOOL = 7;
const TYPE_I8 = 8;
const TYPE_I16 = 9;
const TYPE_I32 = 11;
const TYPE_PTR = 10;
const TYPE_STRUCT = 20;
const TYPE_ARRAY = 21;
const TYPE_SLICE = 22;
const TYPE_GENERIC = 23;
const TYPE_TRAIT = 24;
const TYPE_FUNC = 25;

// Access modifiers
const ACCESS_PUBLIC = 1;
const ACCESS_PRIVATE = 2;
const ACCESS_PROTECTED = 3;

// Generic param kinds
const GENERIC_KIND_TYPE = 1;
const GENERIC_KIND_VALUE = 2;

// ============================================
// Parser Data Structures
// ============================================

// Parser state
struct Parser {
    public tokens_vec: *Vec<*Token>;
    public cur: u64;
    public pending_gt_active: u64;
    public pending_gt_tok: *Token;
    public peek_cache_valid: u64;
    public peek_cache_pos: u64;
    public peek_cache_tok: *Token;
    public generic_params_ctx: u64;
    public generated_funcs: *Vec<u64>;
    public generated_globals: *Vec<u64>;
    public generated_id_counter: u64;
    public breakable_depth: u64;
    public try_stmt_counter: u64;
    public try_throw_flag_ptr_stack: *Vec<u64>;
    public try_throw_flag_len_stack: *Vec<u64>;
    public try_throw_value_ptr_stack: *Vec<u64>;
    public try_throw_value_len_stack: *Vec<u64>;
    public try_throw_allowed_depth_stack: *Vec<u64>;
    public recovery_enabled: u64;
    public recovering: u64;
    public error_count: u64;
    public max_errors: u64;
}

impl Parser {
    public constructor() {
        self.tokens_vec = 0;
        self.cur = 0;
        self.pending_gt_active = 0;
        self.pending_gt_tok = 0;
        self.peek_cache_valid = 0;
        self.peek_cache_pos = 0;
        self.peek_cache_tok = 0;
        self.generic_params_ctx = 0;
        self.generated_funcs = 0;
        self.generated_globals = 0;
        self.generated_id_counter = 0;
        self.breakable_depth = 0;
        self.try_stmt_counter = 0;
        self.try_throw_flag_ptr_stack = 0;
        self.try_throw_flag_len_stack = 0;
        self.try_throw_value_ptr_stack = 0;
        self.try_throw_value_len_stack = 0;
        self.try_throw_allowed_depth_stack = 0;
        self.recovery_enabled = 0;
        self.recovering = 0;
        self.error_count = 0;
        self.max_errors = 20;
    }
}

// Type information (112 bytes)
struct TypeInfo {
    public type_kind: u64;
    public ptr_depth: u64;
    public is_tagged: u64;
    public struct_name_ptr: u64;
    public struct_name_len: u64;
    public tag_layout_ptr: u64;
    public tag_layout_len: u64;
    public struct_def: *AstStructDef;
    public elem_type_kind: u64;
    public elem_ptr_depth: u64;
    public array_len: u64;
    public array_len_is_param: u64;
    public array_len_param_ptr: u64;
    public array_len_param_len: u64;
    public elem_typeinfo: *TypeInfo;
    public fn_params_vec: *Vec<*TypeInfo>;
    public fn_ret_typeinfo: *TypeInfo;
    public fn_is_variadic: u64;
}

impl TypeInfo {
    public constructor(base_type: u64, ptr_depth: u64) {
        self.type_kind = base_type;
        self.ptr_depth = ptr_depth;
        self.is_tagged = 0;
        self.struct_name_ptr = 0;
        self.struct_name_len = 0;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.struct_def = 0;
        self.elem_type_kind = 0;
        self.elem_ptr_depth = 0;
        self.array_len = 0;
        self.array_len_is_param = 0;
        self.array_len_param_ptr = 0;
        self.array_len_param_len = 0;
        self.elem_typeinfo = 0;
        self.fn_params_vec = 0;
        self.fn_ret_typeinfo = 0;
        self.fn_is_variadic = 0;
    }

    public func set_name_and_tag(self: *TypeInfo, struct_name_ptr: u64, struct_name_len: u64, is_tagged: u64, tag_layout_ptr: u64, tag_layout_len: u64) -> u64 {
        self.is_tagged = is_tagged;
        if (is_tagged == 1 && tag_layout_ptr != 0) {
            self.struct_name_ptr = 0;
            self.struct_name_len = 0;
            self.tag_layout_ptr = tag_layout_ptr;
            self.tag_layout_len = tag_layout_len;
            return 0;
        }
        self.struct_name_ptr = struct_name_ptr;
        self.struct_name_len = struct_name_len;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        return 0;
    }

    public func copy_from(self: *TypeInfo, src: *TypeInfo) -> u64 {
        if (src == 0) { return 0; }
        self.type_kind = src.type_kind;
        self.ptr_depth = src.ptr_depth;
        self.is_tagged = src.is_tagged;
        self.struct_name_ptr = src.struct_name_ptr;
        self.struct_name_len = src.struct_name_len;
        self.tag_layout_ptr = src.tag_layout_ptr;
        self.tag_layout_len = src.tag_layout_len;
        self.struct_def = src.struct_def;
        self.elem_type_kind = src.elem_type_kind;
        self.elem_ptr_depth = src.elem_ptr_depth;
        self.array_len = src.array_len;
        self.array_len_is_param = src.array_len_is_param;
        self.array_len_param_ptr = src.array_len_param_ptr;
        self.array_len_param_len = src.array_len_param_len;
        self.elem_typeinfo = src.elem_typeinfo;
        self.fn_params_vec = src.fn_params_vec;
        self.fn_ret_typeinfo = src.fn_ret_typeinfo;
        self.fn_is_variadic = src.fn_is_variadic;
        return 0;
    }
}

// Struct field descriptor (112 bytes)
struct FieldDesc {
    public name_ptr: u64;
    public name_len: u64;
    public type_kind: u64;
    public struct_name_ptr: u64;
    public struct_name_len: u64;
    public ptr_depth: u64;
    public is_tagged: u64;
    public tag_layout_ptr: u64;
    public tag_layout_len: u64;
    public bit_width: u64;
    public offset: u64;
    public elem_type_kind: u64;
    public elem_ptr_depth: u64;
    public array_len: u64;
    public elem_typeinfo: *TypeInfo;
    public access: u64;
    public owner_struct_ptr: u64;
    public owner_struct_len: u64;
}

// Struct parent descriptor (24 bytes)
struct ParentDesc {
    public name_ptr: u64;
    public name_len: u64;
    public struct_def: *AstStructDef;
}

impl ParentDesc {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.struct_def = 0;
    }
}

// Trait reference in struct inheritance list
struct TraitRef {
    public name_ptr: u64;
    public name_len: u64;
    public trait_def: *TraitDef;
}

impl TraitRef {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.trait_def = 0;
    }
}

impl FieldDesc {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.type_kind = 0;
        self.struct_name_ptr = 0;
        self.struct_name_len = 0;
        self.ptr_depth = 0;
        self.is_tagged = 0;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.bit_width = 0;
        self.offset = 0;
        self.elem_type_kind = 0;
        self.elem_ptr_depth = 0;
        self.array_len = 0;
        self.elem_typeinfo = 0;
        self.access = ACCESS_PUBLIC;
        self.owner_struct_ptr = 0;
        self.owner_struct_len = 0;
    }
}

const GLOBAL_INIT_NONE = 0;
const GLOBAL_INIT_VALUE = 1;
const GLOBAL_INIT_CONST = 2;
const GLOBAL_INIT_EXPR = 3;
const GLOBAL_INIT_RUNTIME = 4;

// Global variable info (64 bytes)
struct GlobalInfo {
    public name_ptr: u64;
    public name_len: u64;
    public typeinfo_ptr: *TypeInfo;
    public init_kind: u64;
    public init_value: u64;
    public init_name_ptr: u64;
    public init_name_len: u64;
    public init_expr: u64;
    public annotations_vec: *Vec<*NameInfo>;
}

// ============================================
// Trait System Data Structures
// ============================================

// Trait method descriptor (32 bytes)
struct TraitMethod {
    public name_ptr: u64;
    public name_len: u64;
    public sig: *AstFunc;
    public index: u64;
}

// Trait definition (24 bytes)
struct TraitDef {
    public name_ptr: u64;
    public name_len: u64;
    public methods_vec: *Vec<*TraitMethod>;
}

// Trait impl method descriptor (24 bytes)
struct TraitImplMethod {
    public name_ptr: u64;
    public name_len: u64;
    public func_def: *AstFunc;
}

// Trait implementation (56 bytes)
struct TraitImpl {
    public trait_ptr: u64;
    public trait_len: u64;
    public struct_ptr: u64;
    public struct_len: u64;
    public methods_vec: *Vec<*TraitImplMethod>;
    public vtable_struct_def: *AstStructDef;
    public vtable_global_ptr: u64;
    public vtable_global_len: u64;
}

impl GlobalInfo {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.typeinfo_ptr = 0;
        self.init_kind = 0;
        self.init_value = 0;
        self.init_name_ptr = 0;
        self.init_name_len = 0;
        self.init_expr = 0;
        self.annotations_vec = 0;
    }
}

// Name info (16 bytes)
struct NameInfo {
    public ptr: u64;
    public len: u64;
}

// Export entry (32 bytes)
struct ExportEntry {
    public name_ptr: u64;
    public name_len: u64;
    public mangled_ptr: u64;
    public mangled_len: u64;
}

// Constant info (24 bytes)
struct ConstInfo {
    public name_ptr: u64;
    public name_len: u64;
    public value: u64;
}

// Constant lookup result (16 bytes)
struct ConstResult {
    public found: u64;
    public value: u64;
}

// String literal entry (24 bytes)
struct StringEntry {
    public str_ptr: u64;
    public str_len: u64;
    public label_id: u64;
}

// Float literal entry (24 bytes)
struct FloatEntry {
    public str_ptr: u64;
    public str_len: u64;
    public label_id: u64;
}

// Symbol table
struct Symtab {
    public names_vec: *Vec<*NameInfo>;
    public offsets_vec: *Vec<u64>;
    public types_vec: *Vec<*TypeInfo>;
    public count: u64;
    public stack_offset: u64;
    public name_to_offset_map: *HashMap<u64, u64>;
    public name_to_type_map: *HashMap<u64, *TypeInfo>;
}

impl Symtab {
    public constructor() {
        self.names_vec = 0;
        self.offsets_vec = 0;
        self.types_vec = 0;
        self.count = 0;
        self.stack_offset = 0;
        self.name_to_offset_map = 0;
        self.name_to_type_map = 0;
    }
}

// ============================================
// Lexer Data Structures
// ============================================

// Token structure (40 bytes)
struct Token {
    public kind: u64;
    public ptr: u64;
    public len: u64;
    public line: u64;
    public col: u64;
}

impl Token {
    public constructor() {
        self.kind = 0;
        self.ptr = 0;
        self.len = 0;
        self.line = 0;
        self.col = 0;
    }
}

// Lexer structure (40 bytes)
struct Lexer {
    public src_ptr: u64;
    public src_len: u64;
    public pos: u64;
    public line: u64;
    public col: u64;
}

impl Lexer {
    public constructor() {
        self.src_ptr = 0;
        self.src_len = 0;
        self.pos = 0;
        self.line = 0;
        self.col = 0;
    }
}

// ============================================
// Parser Data Structures
// ============================================

// Function parameter (120 bytes)
struct Param {
    public name_ptr: u64;
    public name_len: u64;
    public type_kind: u64;
    public ptr_depth: u64;
    public is_tagged: u64;
    public struct_name_ptr: u64;
    public struct_name_len: u64;
    public tag_layout_ptr: u64;
    public tag_layout_len: u64;
    public elem_type_kind: u64;
    public elem_ptr_depth: u64;
    public array_len: u64;
    public array_len_is_param: u64;
    public array_len_param_ptr: u64;
    public array_len_param_len: u64;
    public elem_typeinfo: *TypeInfo;
    public is_variadic: u64;
    public has_default: u64;
    public default_expr: u64;
}

impl Param {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.type_kind = 0;
        self.ptr_depth = 0;
        self.is_tagged = 0;
        self.struct_name_ptr = 0;
        self.struct_name_len = 0;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.elem_type_kind = 0;
        self.elem_ptr_depth = 0;
        self.array_len = 0;
        self.array_len_is_param = 0;
        self.array_len_param_ptr = 0;
        self.array_len_param_len = 0;
        self.elem_typeinfo = 0;
        self.is_variadic = 0;
        self.has_default = 0;
        self.default_expr = 0;
    }

    public func fill_from_typeinfo(self: *Param, ty: *TypeInfo) -> u64 {
        self.type_kind = ty.type_kind;
        self.ptr_depth = ty.ptr_depth;
        self.is_tagged = ty.is_tagged;
        self.struct_name_ptr = ty.struct_name_ptr;
        self.struct_name_len = ty.struct_name_len;
        self.tag_layout_ptr = ty.tag_layout_ptr;
        self.tag_layout_len = ty.tag_layout_len;
        self.elem_type_kind = ty.elem_type_kind;
        self.elem_ptr_depth = ty.elem_ptr_depth;
        self.array_len = ty.array_len;
        self.array_len_is_param = ty.array_len_is_param;
        self.array_len_param_ptr = ty.array_len_param_ptr;
        self.array_len_param_len = ty.array_len_param_len;
        if (ty.type_kind == TYPE_FUNC) {
            if (ty.elem_typeinfo != 0 && ty.elem_typeinfo.type_kind == TYPE_FUNC) {
                self.elem_typeinfo = ty.elem_typeinfo;
            } else {
                self.elem_typeinfo = ty;
            }
        } else {
            self.elem_typeinfo = ty.elem_typeinfo;
        }
        return 0;
    }

    public func copy_from_param(self: *Param, src: *Param) -> u64 {
        if (src == 0) { return 0; }
        self.name_ptr = src.name_ptr;
        self.name_len = src.name_len;
        self.type_kind = src.type_kind;
        self.ptr_depth = src.ptr_depth;
        self.is_tagged = src.is_tagged;
        self.struct_name_ptr = src.struct_name_ptr;
        self.struct_name_len = src.struct_name_len;
        self.tag_layout_ptr = src.tag_layout_ptr;
        self.tag_layout_len = src.tag_layout_len;
        self.elem_type_kind = src.elem_type_kind;
        self.elem_ptr_depth = src.elem_ptr_depth;
        self.array_len = src.array_len;
        self.array_len_is_param = src.array_len_is_param;
        self.array_len_param_ptr = src.array_len_param_ptr;
        self.array_len_param_len = src.array_len_param_len;
        self.elem_typeinfo = src.elem_typeinfo;
        self.is_variadic = src.is_variadic;
        self.has_default = src.has_default;
        self.default_expr = src.default_expr;
        return 0;
    }

    public func apply_to_typeinfo(self: *Param, ti: *TypeInfo) -> u64 {
        if (ti == 0) { return 0; }
        ti.type_kind = self.type_kind;
        ti.ptr_depth = self.ptr_depth;
        ti.is_tagged = self.is_tagged;
        ti.struct_name_ptr = self.struct_name_ptr;
        ti.struct_name_len = self.struct_name_len;
        ti.tag_layout_ptr = self.tag_layout_ptr;
        ti.tag_layout_len = self.tag_layout_len;
        ti.struct_def = 0;
        ti.elem_type_kind = self.elem_type_kind;
        ti.elem_ptr_depth = self.elem_ptr_depth;
        ti.array_len = self.array_len;
        ti.array_len_is_param = self.array_len_is_param;
        ti.array_len_param_ptr = self.array_len_param_ptr;
        ti.array_len_param_len = self.array_len_param_len;
        ti.elem_typeinfo = self.elem_typeinfo;
        return 0;
    }

    public func decay_array_to_ptr(self: *Param) -> u64 {
        if (self.type_kind != TYPE_ARRAY) { return 0; }
        if (self.elem_typeinfo != 0) {
            var inner: *TypeInfo = self.elem_typeinfo;
            self.type_kind = inner.type_kind;
            self.ptr_depth = inner.ptr_depth + 1;
            self.is_tagged = inner.is_tagged;
            self.struct_name_ptr = inner.struct_name_ptr;
            self.struct_name_len = inner.struct_name_len;
            self.tag_layout_ptr = inner.tag_layout_ptr;
            self.tag_layout_len = inner.tag_layout_len;
            self.elem_type_kind = inner.elem_type_kind;
            self.elem_ptr_depth = inner.elem_ptr_depth;
            self.array_len = inner.array_len;
            self.array_len_is_param = inner.array_len_is_param;
            self.array_len_param_ptr = inner.array_len_param_ptr;
            self.array_len_param_len = inner.array_len_param_len;
            self.elem_typeinfo = inner.elem_typeinfo;
            return 0;
        }
        self.type_kind = self.elem_type_kind;
        self.ptr_depth = self.elem_ptr_depth + 1;
        self.is_tagged = 0;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.array_len_is_param = 0;
        self.array_len_param_ptr = 0;
        self.array_len_param_len = 0;
        return 0;
    }

    public func set_as_self_param(self: *Param, struct_name_ptr: u64, struct_name_len: u64) -> u64 {
        self.name_ptr = (u64)"self";
        self.name_len = 4;
        self.type_kind = TYPE_STRUCT;
        self.ptr_depth = 1;
        self.is_tagged = 0;
        self.struct_name_ptr = struct_name_ptr;
        self.struct_name_len = struct_name_len;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.elem_type_kind = 0;
        self.elem_ptr_depth = 0;
        self.array_len = 0;
        self.array_len_is_param = 0;
        self.array_len_param_ptr = 0;
        self.array_len_param_len = 0;
        self.elem_typeinfo = 0;
        self.is_variadic = 0;
        self.has_default = 0;
        self.default_expr = 0;
        return 0;
    }
}

// Generic parameter descriptor (32 bytes)
struct GenericParam {
    public kind: u64;
    public name_ptr: u64;
    public name_len: u64;
    public value_type_kind: u64;
    public bound_trait_ptr: u64;
    public bound_trait_len: u64;
    public assoc_name_ptr: u64;
    public assoc_name_len: u64;
    public assoc_type_ptr: *TypeInfo;
}

impl GenericParam {
    public constructor() {
        self.kind = 0;
        self.name_ptr = 0;
        self.name_len = 0;
        self.value_type_kind = 0;
        self.bound_trait_ptr = 0;
        self.bound_trait_len = 0;
        self.assoc_name_ptr = 0;
        self.assoc_name_len = 0;
        self.assoc_type_ptr = 0;
    }
}

// Generic argument descriptor (24 bytes)
struct GenericArg {
    public kind: u64;
    public type_ptr: *TypeInfo;
    public value: u64;
}

impl GenericArg {
    public constructor() {
        self.kind = 0;
        self.type_ptr = 0;
        self.value = 0;
    }
}
