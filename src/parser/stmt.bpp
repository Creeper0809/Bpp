// parse_stmt.b - Statement parsing
//
// Parses all statement types:
// - Variable declarations
// - Assignments and expression statements
// - Control flow (if, while, for, switch)
// - break, continue, return
// - Inline assembly blocks

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import lexer;
import ast;
import parser.util;
import parser.type;
import parser.expr;

func parse_stmt_internal_name(prefix_ptr: u64, prefix_len: u64, id: u64) -> *NameInfo {
    var id_buf: u64 = heap_alloc(32 * sizeof(u8));
    var id_len: u64 = io_u64_to_ascii(id_buf, id);
    var total_len: u64 = prefix_len + id_len;
    var out_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, total_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, id_buf, id_len);
    out_u8[total_len] = 0;
    return new NameInfo{out_ptr, total_len};
}

func parse_try_context_push(p: *Parser, flag_ptr: u64, flag_len: u64, allowed_depth: u64) -> u64 {
    if (p.try_throw_flag_ptr_stack == 0) {
        p.try_throw_flag_ptr_stack = new Vec<u64>(8);
        p.try_throw_flag_len_stack = new Vec<u64>(8);
        p.try_throw_allowed_depth_stack = new Vec<u64>(8);
    }
    p.try_throw_flag_ptr_stack.push(flag_ptr);
    p.try_throw_flag_len_stack.push(flag_len);
    p.try_throw_allowed_depth_stack.push(allowed_depth);
    return 0;
}

func parse_try_context_pop(p: *Parser) -> u64 {
    if (p.try_throw_flag_ptr_stack == 0 || p.try_throw_flag_ptr_stack.len() == 0) { return 0; }
    p.try_throw_flag_ptr_stack.pop();
    p.try_throw_flag_len_stack.pop();
    p.try_throw_allowed_depth_stack.pop();
    return 0;
}

func parse_try_context_active(p: *Parser) -> u64 {
    if (p.try_throw_flag_ptr_stack == 0) { return 0; }
    if (p.try_throw_flag_ptr_stack.len() == 0) { return 0; }
    return 1;
}

// ============================================
// Variable Declaration
// ============================================

func parse_var_decl(p: *Parser) -> *AstNode {
    var annotations: *Vec<*NameInfo> = parse_take_leading_annotations(p);
    parse_consume(p, TOKEN_VAR);
    
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);
    
    var type_kind: u64 = TYPE_I64;
    var ptr_depth: u64 = 0;
    var is_tagged: u64 = 0;
    var struct_name_ptr: u64 = 0;
    var struct_name_len: u64 = 0;
    var tag_layout_ptr: u64 = 0;
    var tag_layout_len: u64 = 0;
    var elem_type_kind: u64 = 0;
    var elem_ptr_depth: u64 = 0;
    var array_len: u64 = 0;
    var array_len_is_param: u64 = 0;
    var array_len_param_ptr: u64 = 0;
    var array_len_param_len: u64 = 0;
    var elem_typeinfo: *TypeInfo = 0;
    
    if (parse_match(p, TOKEN_COLON)) {
        var ty_info: *TypeInfo = parse_type_ex(p);
        type_kind = ty_info.type_kind;
        ptr_depth = ty_info.ptr_depth;
        is_tagged = ty_info.is_tagged;
        elem_type_kind = ty_info.elem_type_kind;
        elem_ptr_depth = ty_info.elem_ptr_depth;
        array_len = ty_info.array_len;
        array_len_is_param = ty_info.array_len_is_param;
        array_len_param_ptr = ty_info.array_len_param_ptr;
        array_len_param_len = ty_info.array_len_param_len;
        elem_typeinfo = ty_info.elem_typeinfo;
        tag_layout_ptr = ty_info.tag_layout_ptr;
        tag_layout_len = ty_info.tag_layout_len;
        
        // If TYPE_STRUCT/TYPE_GENERIC/TYPE_TRAIT, get struct name from TypeInfo
        if (type_kind == TYPE_STRUCT || type_kind == TYPE_GENERIC || type_kind == TYPE_TRAIT) {
            struct_name_ptr = ty_info.struct_name_ptr;
            struct_name_len = ty_info.struct_name_len;
        }
        // If array/slice of struct pointer, store element struct name
        if (type_kind == TYPE_ARRAY || type_kind == TYPE_SLICE) {
            struct_name_ptr = ty_info.struct_name_ptr;
            struct_name_len = ty_info.struct_name_len;
        }
        // tagged layout name (non-struct base)
        if (is_tagged == 1 && tag_layout_ptr != 0 && type_kind != TYPE_STRUCT && type_kind != TYPE_ARRAY && type_kind != TYPE_SLICE) {
            struct_name_ptr = 0;
            struct_name_len = 0;
        }
    }
    
    var init: *AstNode = 0;
    
    if (parse_match(p, TOKEN_EQ)) {
        init = parse_expr(p);
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    var decl: *AstVarDecl = ast_var_decl(name_tok.ptr, name_tok.len, type_kind, ptr_depth, init);
    decl.is_tagged = is_tagged;
    decl.struct_name_ptr = struct_name_ptr;
    decl.struct_name_len = struct_name_len;
    decl.tag_layout_ptr = tag_layout_ptr;
    decl.tag_layout_len = tag_layout_len;
    decl.elem_type_kind = elem_type_kind;
    decl.elem_ptr_depth = elem_ptr_depth;
    decl.array_len = array_len;
    decl.array_len_is_param = array_len_is_param;
    decl.array_len_param_ptr = array_len_param_ptr;
    decl.array_len_param_len = array_len_param_len;
    decl.elem_typeinfo = elem_typeinfo;
    decl.annotations_vec = annotations;
    return (*AstNode)decl;
}

// ============================================
// Assignment Helpers
// ============================================

func is_assignable_expr(expr: *AstNode) -> u64 {
    var k: u64 = ast_kind(expr);
    switch (k) {
        case AST_IDENT: return true;
        case AST_DEREF: return true;
        case AST_DEREF8: return true;
        default: return false;
    }
}

func make_incdec_rhs(incdec_kind: u64, target: *AstNode) -> *AstNode {
    var one: *AstNode = ast_literal(1);
    switch (incdec_kind) {
        case TOKEN_PLUSPLUS:
            return ast_binary(TOKEN_PLUS, target, one);
        case TOKEN_MINUSMINUS:
            return ast_binary(TOKEN_MINUS, target, one);
        default:
            return ast_binary(TOKEN_MINUS, target, one);
    }
}

func parse_assign_or_postfix_expr(p: *Parser, lhs: *AstNode) -> *AstNode {
    if (parse_match(p, TOKEN_EQ)) {
        var rhs: *AstNode = parse_expr(p);
        return ast_assign(lhs, rhs);
    }
    return parse_postfix_incdec_after_expr(p, lhs);
}

func parse_prefix_incdec_assign(p: *Parser) -> *AstNode {
    var k: u64 = parse_peek_kind(p);
    parse_consume(p, k);
    var target: *AstNode = parse_unary(p);
    if (!is_assignable_expr(target)) {
        emit_stderr("[ERROR] ++/-- requires assignable expression\n");
        parse_panic_here(p, "Syntax error");
    }
    var rhs: *AstNode = make_incdec_rhs(k, target);
    return ast_assign(target, rhs);
}

func parse_postfix_incdec_after_expr(p: *Parser, expr: *AstNode) -> *AstNode {
    var k: u64 = parse_peek_kind(p);
    switch (k) {
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            break;
        default:
            return expr;
    }
    parse_consume(p, k);
    if (!is_assignable_expr(expr)) {
        emit_stderr("[ERROR] ++/-- requires assignable expression\n");
        parse_panic_here(p, "Syntax error");
    }
    var rhs: *AstNode = make_incdec_rhs(k, expr);
    return ast_assign(expr, rhs);
}

func parse_wrap_stmt_in_block(stmt: *AstNode) -> *AstNode {
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    stmts.push(stmt);
    return ast_block(stmts);
}

func parse_stmt_or_block(p: *Parser) -> *AstNode {
    if (parse_peek_kind(p) == TOKEN_LBRACE) {
        return parse_block(p);
    }
    return parse_wrap_stmt_in_block(parse_stmt(p));
}

func parse_assign_or_expr(p: *Parser) -> *AstNode {
    var expr: *AstNode = parse_expr(p);
    
    if (parse_match(p, TOKEN_EQ)) {
        var val: *AstNode = parse_expr(p);
        parse_consume(p, TOKEN_SEMICOLON);
        return ast_assign(expr, val);
    }

    // Compound assignment: x += 5  =>  x = x + 5
    var k: u64 = parse_peek_kind(p);
    var bin_op: u64 = 0;
    switch (k) {
        case TOKEN_PLUS_EQ: bin_op = TOKEN_PLUS; break;
        case TOKEN_MINUS_EQ: bin_op = TOKEN_MINUS; break;
        case TOKEN_STAR_EQ: bin_op = TOKEN_STAR; break;
        case TOKEN_SLASH_EQ: bin_op = TOKEN_SLASH; break;
        case TOKEN_PERCENT_EQ: bin_op = TOKEN_PERCENT; break;
        default: bin_op = 0; break;
    }
    if (bin_op != 0) {
        parse_consume(p, k);
        if (!is_assignable_expr(expr)) {
            emit_stderr("[ERROR] Compound assignment requires assignable expression\n");
            parse_panic_here(p, "Syntax error");
        }
        var rhs: *AstNode = parse_expr(p);
        
        var new_val: *AstNode = ast_binary(bin_op, expr, rhs);
        parse_consume(p, TOKEN_SEMICOLON);
        return ast_assign(expr, new_val);
    }

    // Postfix ++/-- statement sugar: x++; x--;  =>  x = x +/- 1;
    var post_k: u64 = parse_peek_kind(p);
    switch (post_k) {
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            parse_consume(p, post_k);
            if (!is_assignable_expr(expr)) {
                emit_stderr("[ERROR] ++/-- requires assignable expression\n");
                parse_panic_here(p, "Syntax error");
            }
            var rhs: *AstNode = make_incdec_rhs(post_k, expr);
            parse_consume(p, TOKEN_SEMICOLON);
            return ast_assign(expr, rhs);
        default:
            break;
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_expr_stmt(expr);
}

// ============================================
// Control Flow Statements
// ============================================

func parse_if_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_IF);
    parse_consume(p, TOKEN_LPAREN);
    var cond: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    
    var then_blk: *AstNode = parse_stmt_or_block(p);
    
    var else_blk: *AstNode = 0;
    if (parse_match(p, TOKEN_ELSE)) {
        if (parse_peek_kind(p) == TOKEN_IF) {
            else_blk = parse_wrap_stmt_in_block(parse_if_stmt(p));
        } else {
            else_blk = parse_stmt_or_block(p);
        }
    }
    
    return ast_if(cond, then_blk, else_blk);
}

func parse_while_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_WHILE);
    parse_consume(p, TOKEN_LPAREN);
    var cond: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    
    p.breakable_depth = p.breakable_depth + 1;
    var body: *AstNode = parse_stmt_or_block(p);
    p.breakable_depth = p.breakable_depth - 1;
    
    return ast_while(cond, body);
}

func parse_for_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_FOR);
    parse_consume(p, TOKEN_LPAREN);

    var init: *AstNode = 0;
    var k: u64 = parse_peek_kind(p);

    // Parse init clause
    switch (k) {
        case TOKEN_SEMICOLON:
            parse_consume(p, TOKEN_SEMICOLON);
            break;
        case TOKEN_VAR:
            init = parse_var_decl(p);
            break;
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            init = parse_prefix_incdec_assign(p);
            parse_consume(p, TOKEN_SEMICOLON);
            break;
        default:
            var lhs: *AstNode = parse_expr(p);
            init = parse_assign_or_postfix_expr(p, lhs);
            parse_consume(p, TOKEN_SEMICOLON);
            break;
    }

    var cond: *AstNode = 0;
    if (parse_peek_kind(p) != TOKEN_SEMICOLON) {
        cond = parse_expr(p);
    }
    parse_consume(p, TOKEN_SEMICOLON);

    var update: *AstNode = 0;
    k = parse_peek_kind(p);

    // Parse update clause
    switch (k) {
        case TOKEN_RPAREN:
            // No update clause
            break;
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            update = parse_prefix_incdec_assign(p);
            break;
        default:
            var upd_lhs: *AstNode = parse_expr(p);
            update = parse_assign_or_postfix_expr(p, upd_lhs);
            break;
    }

    parse_consume(p, TOKEN_RPAREN);

    p.breakable_depth = p.breakable_depth + 1;
    var body: *AstNode = parse_stmt_or_block(p);
    p.breakable_depth = p.breakable_depth - 1;
    return ast_for(init, cond, update, body);
}

func parse_switch_stmt(p: *Parser) -> *AstNode {
    if (parse_peek_kind(p) == TOKEN_MATCH) {
        parse_consume(p, TOKEN_MATCH);
    } else {
        parse_consume(p, TOKEN_SWITCH);
    }
    parse_consume(p, TOKEN_LPAREN);
    var expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    parse_consume(p, TOKEN_LBRACE);

    var cases: *Vec<*AstNode> = new Vec<*AstNode>(16);
    p.breakable_depth = p.breakable_depth + 1;

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        var is_default: u64 = 0;
        var value: *AstNode = 0;
        var matched: u64 = 0;

        switch (parse_peek_kind(p)) {
            case TOKEN_CASE:
                parse_consume(p, TOKEN_CASE);
                if (parse_peek_kind(p) == TOKEN_IDENTIFIER) {
                    var wc_tok: *Token = parse_peek(p);
                    if (wc_tok.len == 1 && str_eq(wc_tok.ptr, wc_tok.len, "_", 1) != 0) {
                        parse_adv(p);
                        is_default = 1;
                        matched = 1;
                        break;
                    }
                }
                value = parse_expr(p);
                matched = 1;
                break;
            case TOKEN_DEFAULT:
                parse_consume(p, TOKEN_DEFAULT);
                is_default = 1;
                matched = 1;
                break;
            default:
                break;
        }
        if (matched == 0) { break; }

        parse_consume(p, TOKEN_COLON);

        var stmts: *Vec<*AstNode> = new Vec<*AstNode>(8);
        while (parse_peek_kind(p) != TOKEN_CASE) {
            if (parse_peek_kind(p) == TOKEN_DEFAULT) { break; }
            if (parse_peek_kind(p) == TOKEN_RBRACE) { break; }
            if (parse_peek_kind(p) == TOKEN_EOF) { break; }
            stmts.push(parse_stmt(p));
        }

        var case_body: *AstNode = ast_block(stmts);
        cases.push(ast_case(value, case_body, is_default));
    }

    p.breakable_depth = p.breakable_depth - 1;
    parse_consume(p, TOKEN_RBRACE);
    return ast_switch(expr, cases);
}

// ============================================
// Jump Statements
// ============================================

func parse_break_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_BREAK);
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_break();
}

func parse_continue_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_CONTINUE);
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_continue();
}

func parse_return_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_RETURN);
    
    var expr: *AstNode = 0;
    if (parse_peek_kind(p) != TOKEN_SEMICOLON) {
        expr = parse_expr(p);
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_return(expr);
}

func parse_throw_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_THROW);
    if (parse_try_context_active(p) == 0) {
        emit_stderr("[ERROR] throw can only be used inside try { ... }\n");
        parse_panic_here(p, "Syntax error");
    }

    var top_idx: u64 = p.try_throw_flag_ptr_stack.len() - 1;
    var allowed_depth: u64 = p.try_throw_allowed_depth_stack.get(top_idx);
    if (p.breakable_depth != allowed_depth) {
        emit_stderr("[ERROR] throw inside nested loop/switch is not supported\n");
        parse_panic_here(p, "Syntax error");
    }

    var flag_ptr: u64 = p.try_throw_flag_ptr_stack.get(top_idx);
    var flag_len: u64 = p.try_throw_flag_len_stack.get(top_idx);
    var thrown_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_SEMICOLON);

    var throw_stmts: *Vec<*AstNode> = new Vec<*AstNode>(3);
    throw_stmts.push((*AstNode)ast_expr_stmt(thrown_expr));
    throw_stmts.push((*AstNode)ast_assign((*AstNode)ast_ident(flag_ptr, flag_len), (*AstNode)ast_literal(1)));
    throw_stmts.push((*AstNode)ast_break());
    return (*AstNode)ast_block(throw_stmts);
}

func parse_try_stmt_append_block_stmts(dst: *Vec<*AstNode>, block_node: *AstNode) -> u64 {
    if (block_node == 0) { return 0; }
    if (ast_kind(block_node) != AST_BLOCK) {
        dst.push(block_node);
        return 0;
    }
    var blk: *AstBlock = (*AstBlock)block_node;
    if (blk.stmts_vec == 0) { return 0; }
    var n: u64 = blk.stmts_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        dst.push(blk.stmts_vec.get(i));
    }
    return 0;
}

func parse_try_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_TRY);
    p.try_stmt_counter = p.try_stmt_counter + 1;
    var flag_name: *NameInfo = parse_stmt_internal_name("__try_thrown_", 12, p.try_stmt_counter);

    var allowed_depth: u64 = p.breakable_depth;
    parse_try_context_push(p, flag_name.ptr, flag_name.len, allowed_depth);
    var try_block: *AstNode = parse_block(p);
    parse_try_context_pop(p);

    var catch_block: *AstNode = 0;
    var finally_block: *AstNode = 0;
    if (parse_peek_kind(p) == TOKEN_CATCH) {
        parse_consume(p, TOKEN_CATCH);
        catch_block = parse_block(p);
    }
    if (parse_peek_kind(p) == TOKEN_FINALLY) {
        parse_consume(p, TOKEN_FINALLY);
        finally_block = parse_block(p);
    }
    if (catch_block == 0 && finally_block == 0) {
        emit_stderr("[ERROR] try statement requires catch and/or finally block\n");
        parse_panic_here(p, "Syntax error");
    }

    var lowered_stmts: *Vec<*AstNode> = new Vec<*AstNode>(6);
    lowered_stmts.push((*AstNode)ast_var_decl(flag_name.ptr, flag_name.len, TYPE_U64, 0, (*AstNode)ast_literal(0)));

    var while_body_stmts: *Vec<*AstNode> = new Vec<*AstNode>(8);
    parse_try_stmt_append_block_stmts(while_body_stmts, try_block);
    while_body_stmts.push((*AstNode)ast_break());
    var while_body: *AstNode = (*AstNode)ast_block(while_body_stmts);
    lowered_stmts.push((*AstNode)ast_while((*AstNode)ast_literal(1), while_body));

    if (catch_block != 0) {
        var thrown_ident: *AstNode = (*AstNode)ast_ident(flag_name.ptr, flag_name.len);
        var thrown_cond: *AstNode = (*AstNode)ast_binary(TOKEN_BANGEQ, thrown_ident, (*AstNode)ast_literal(0));
        lowered_stmts.push((*AstNode)ast_if(thrown_cond, catch_block, 0));
    }

    if (finally_block != 0) {
        lowered_stmts.push(finally_block);
    }

    return (*AstNode)ast_block(lowered_stmts);
}

// ============================================
// Alias Statement
// ============================================

func parse_alias_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_ALIAS);

    var reg_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_COLON);

    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_SEMICOLON);

    return (*AstNode)ast_alias(reg_tok.ptr, reg_tok.len, name_tok.ptr, name_tok.len);
}

// ============================================
// Defer Statement
// ============================================

func parse_defer_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_DEFER);
    var stmt: *AstNode = parse_stmt(p);
    return (*AstNode)ast_defer(stmt);
}

// ============================================
// Debug Statements (assert/todo/unreachable)
// ============================================

func build_debug_fail_stmt(msg_ptr: u64, msg_len: u64, line: u64) -> *AstNode {
    var args: *Vec<*AstNode> = new Vec<*AstNode>(3);
    args.push((*AstNode)ast_string(msg_ptr, msg_len));
    args.push((*AstNode)ast_literal(msg_len));
    args.push((*AstNode)ast_literal(line));
    var call: *AstCall = ast_call("debug_fail", 10, args);
    return ast_expr_stmt((*AstNode)call);
}

func parse_assert_stmt(p: *Parser) -> *AstNode {
    var tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_ASSERT);
    parse_consume(p, TOKEN_LPAREN);
    var cond: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    parse_consume(p, TOKEN_SEMICOLON);

    var not_cond: *AstNode = (*AstNode)ast_unary(TOKEN_BANG, cond);
    var fail_stmt: *AstNode = build_debug_fail_stmt("assert failed", 13, tok.line);
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    stmts.push(fail_stmt);
    var blk: *AstNode = (*AstNode)ast_block(stmts);
    return (*AstNode)ast_if(not_cond, blk, 0);
}

func parse_todo_stmt(p: *Parser) -> *AstNode {
    var tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_TODO);
    parse_consume(p, TOKEN_SEMICOLON);
    return build_debug_fail_stmt("todo reached", 12, tok.line);
}

func parse_unreachable_stmt(p: *Parser) -> *AstNode {
    var tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_UNREACHABLE);
    parse_consume(p, TOKEN_SEMICOLON);
    return build_debug_fail_stmt("unreachable", 11, tok.line);
}

// ============================================
// Delete Statement
// ============================================

func parse_delete_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_DELETE);
    var expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_SEMICOLON);
    return (*AstNode)ast_delete(expr);
}

// ============================================
// ASM Block
// ============================================

func parse_asm_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_ASM);
    parse_consume(p, TOKEN_LBRACE);
    
    var asm_text: *Vec<u64> = new Vec<u64>(256);
    
    var prev_line: i64 = -1;
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) {
            emit_stderr("[ERROR] Unexpected EOF in asm block\n");
            parse_panic_here(p, "Syntax error");
        }
        
        var tok: *Token = parse_peek(p);
        var cur_line: i64 = (i64)tok.line;
        
        if (prev_line >= 0) {
            if (cur_line > prev_line) {
                asm_text.push(10);
            } else {
                asm_text.push(32);
            }
        }
        prev_line = cur_line;
        
        var ptr: u64 = tok.ptr;
        var len: u64 = tok.len;
        var ptr_u8: *u8 = (*u8)ptr;

        for (var i: u64 = 0; i < len; i++) {
            asm_text.push(ptr_u8[i]);
        }
        parse_adv(p);
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return ast_asm(asm_text);
}

// ============================================
// Block and Generic Statement
// ============================================

func parse_block(p: *Parser) -> *AstNode {
    push_trace("parse_block", "parser/stmt.b", __LINE__);
    defer pop_trace();
    
    parse_consume(p, TOKEN_LBRACE);
    
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(16);
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        stmts.push(parse_stmt(p));
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return ast_block(stmts);
}

func parse_stmt(p: *Parser) -> *AstNode {
    push_trace("parse_stmt", "parser/stmt.b", __LINE__);
    defer pop_trace();
    var k: u64 = parse_peek_kind(p);
    switch (k) {
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            var stmt: *AstNode = parse_prefix_incdec_assign(p);
            parse_consume(p, TOKEN_SEMICOLON);
            return stmt;
        case TOKEN_VAR:
            return parse_var_decl(p);
        case TOKEN_AT:
            var next_k: u64 = parse_peek_kind_after_annotations(p);
            if (next_k == TOKEN_VAR) {
                return parse_var_decl(p);
            }
            emit_stderr("[ERROR] statement annotation target must be variable declaration\n");
            parse_panic_here(p, "Syntax error");
            return parse_assign_or_expr(p);
        case TOKEN_IF:
            return parse_if_stmt(p);
        case TOKEN_WHILE:
            return parse_while_stmt(p);
        case TOKEN_FOR:
            return parse_for_stmt(p);
        case TOKEN_SWITCH:
        case TOKEN_MATCH:
            return parse_switch_stmt(p);
        case TOKEN_BREAK:
            return parse_break_stmt(p);
        case TOKEN_CONTINUE:
            return parse_continue_stmt(p);
        case TOKEN_ASM:
            return parse_asm_stmt(p);
        case TOKEN_ALIAS:
            return parse_alias_stmt(p);
        case TOKEN_DEFER:
            return parse_defer_stmt(p);
        case TOKEN_DELETE:
            return parse_delete_stmt(p);
        case TOKEN_TRY:
            return parse_try_stmt(p);
        case TOKEN_THROW:
            return parse_throw_stmt(p);
        case TOKEN_ASSERT:
            return parse_assert_stmt(p);
        case TOKEN_TODO:
            return parse_todo_stmt(p);
        case TOKEN_UNREACHABLE:
            return parse_unreachable_stmt(p);
        case TOKEN_RETURN:
            return parse_return_stmt(p);
        default:
            return parse_assign_or_expr(p);
    }
}
