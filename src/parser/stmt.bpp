// parse_stmt.b - Statement parsing
//
// Parses all statement types:
// - Variable declarations
// - Assignments and expression statements
// - Control flow (if, while, for, switch)
// - break, continue, return
// - Inline assembly blocks

import std.io;
import std.vec;
import std.util;
import std.str;
import module_utils;
import types;
import lexer;
import ast;
import compiler;
import parser.util;
import parser.type;
import parser.expr;

func parse_stmt_internal_name(prefix_ptr: u64, prefix_len: u64, id: u64) -> *NameInfo {
    var id_buf: u64 = heap_alloc(32 * sizeof(u8));
    var id_len: u64 = io_u64_to_ascii(id_buf, id);
    var total_len: u64 = prefix_len + id_len;
    var out_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, total_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, id_buf, id_len);
    out_u8[total_len] = 0;
    return new NameInfo{out_ptr, total_len};
}

func parse_try_context_push(p: *Parser, flag_ptr: u64, flag_len: u64, value_ptr: u64, value_len: u64, allowed_depth: u64) -> u64 {
    if (p.try_throw_flag_ptr_stack == 0) {
        p.try_throw_flag_ptr_stack = new Vec<u64>(8);
        p.try_throw_flag_len_stack = new Vec<u64>(8);
        p.try_throw_value_ptr_stack = new Vec<u64>(8);
        p.try_throw_value_len_stack = new Vec<u64>(8);
        p.try_throw_allowed_depth_stack = new Vec<u64>(8);
    }
    p.try_throw_flag_ptr_stack.push(flag_ptr);
    p.try_throw_flag_len_stack.push(flag_len);
    p.try_throw_value_ptr_stack.push(value_ptr);
    p.try_throw_value_len_stack.push(value_len);
    p.try_throw_allowed_depth_stack.push(allowed_depth);
    return 0;
}

func parse_try_context_pop(p: *Parser) -> u64 {
    if (p.try_throw_flag_ptr_stack == 0 || p.try_throw_flag_ptr_stack.len() == 0) { return 0; }
    p.try_throw_flag_ptr_stack.pop();
    p.try_throw_flag_len_stack.pop();
    p.try_throw_value_ptr_stack.pop();
    p.try_throw_value_len_stack.pop();
    p.try_throw_allowed_depth_stack.pop();
    return 0;
}

func parse_try_context_active(p: *Parser) -> u64 {
    if (p.try_throw_flag_ptr_stack == 0) { return 0; }
    if (p.try_throw_flag_ptr_stack.len() == 0) { return 0; }
    return 1;
}

func parse_try_context_current_flag_ptr(p: *Parser) -> u64 {
    if (parse_try_context_active(p) == 0) { return 0; }
    var top_idx: u64 = p.try_throw_flag_ptr_stack.len() - 1;
    return p.try_throw_flag_ptr_stack.get(top_idx);
}

func parse_try_context_current_flag_len(p: *Parser) -> u64 {
    if (parse_try_context_active(p) == 0) { return 0; }
    var top_idx: u64 = p.try_throw_flag_len_stack.len() - 1;
    return p.try_throw_flag_len_stack.get(top_idx);
}

func parse_try_context_current_value_ptr(p: *Parser) -> u64 {
    if (parse_try_context_active(p) == 0) { return 0; }
    var top_idx: u64 = p.try_throw_value_ptr_stack.len() - 1;
    return p.try_throw_value_ptr_stack.get(top_idx);
}

func parse_try_context_current_value_len(p: *Parser) -> u64 {
    if (parse_try_context_active(p) == 0) { return 0; }
    var top_idx: u64 = p.try_throw_value_len_stack.len() - 1;
    return p.try_throw_value_len_stack.get(top_idx);
}

func parse_try_build_break_guard(flag_ptr: u64, flag_len: u64) -> *AstNode {
    if (flag_ptr == 0 || flag_len == 0) { return 0; }
    var cond: *AstNode = (*AstNode)ast_binary(TOKEN_BANGEQ, (*AstNode)ast_ident(flag_ptr, flag_len), (*AstNode)ast_literal(0));
    var then_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    then_stmts.push((*AstNode)ast_break());
    return (*AstNode)ast_if(cond, (*AstNode)ast_block(then_stmts), 0);
}

func parse_try_build_not_thrown_cond(flag_ptr: u64, flag_len: u64) -> *AstNode {
    if (flag_ptr == 0 || flag_len == 0) { return (*AstNode)ast_literal(1); }
    return (*AstNode)ast_binary(TOKEN_EQEQ, (*AstNode)ast_ident(flag_ptr, flag_len), (*AstNode)ast_literal(0));
}

func parse_try_wrap_stmt_if_not_thrown(stmt: *AstNode, flag_ptr: u64, flag_len: u64) -> *AstNode {
    if (stmt == 0) { return 0; }
    if (flag_ptr == 0 || flag_len == 0) { return stmt; }
    var then_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    then_stmts.push(stmt);
    return (*AstNode)ast_if(parse_try_build_not_thrown_cond(flag_ptr, flag_len), (*AstNode)ast_block(then_stmts), 0);
}

func parse_try_wrap_loop_body_with_guard(body: *AstNode, flag_ptr: u64, flag_len: u64) -> *AstNode {
    if (body == 0) { return 0; }
    if (flag_ptr == 0 || flag_len == 0) { return body; }

    var wrapped: *Vec<*AstNode> = new Vec<*AstNode>(8);
    if (ast_kind(body) == AST_BLOCK) {
        var blk: *AstBlock = (*AstBlock)body;
        if (blk.stmts_vec != 0) {
            var n: u64 = blk.stmts_vec.len();
            for (var i: u64 = 0; i < n; i++) {
                wrapped.push(blk.stmts_vec.get(i));
                wrapped.push(parse_try_build_break_guard(flag_ptr, flag_len));
            }
        }
    } else {
        wrapped.push(body);
        wrapped.push(parse_try_build_break_guard(flag_ptr, flag_len));
    }
    return (*AstNode)ast_block(wrapped);
}

// ============================================
// Variable Declaration
// ============================================

func parse_var_decl(p: *Parser) -> *AstNode {
    var annotations: *Vec<*NameInfo> = parse_take_leading_annotations(p);
    parse_consume(p, TOKEN_VAR);
    
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);
    
    var type_kind: u64 = TYPE_I64;
    var ptr_depth: u64 = 0;
    var is_tagged: u64 = 0;
    var struct_name_ptr: u64 = 0;
    var struct_name_len: u64 = 0;
    var tag_layout_ptr: u64 = 0;
    var tag_layout_len: u64 = 0;
    var elem_type_kind: u64 = 0;
    var elem_ptr_depth: u64 = 0;
    var array_len: u64 = 0;
    var array_len_is_param: u64 = 0;
    var array_len_param_ptr: u64 = 0;
    var array_len_param_len: u64 = 0;
    var elem_typeinfo: *TypeInfo = 0;
    
    if (parse_match(p, TOKEN_COLON)) {
        var ty_info: *TypeInfo = parse_type_ex(p);
        type_kind = ty_info.type_kind;
        ptr_depth = ty_info.ptr_depth;
        is_tagged = ty_info.is_tagged;
        elem_type_kind = ty_info.elem_type_kind;
        elem_ptr_depth = ty_info.elem_ptr_depth;
        array_len = ty_info.array_len;
        array_len_is_param = ty_info.array_len_is_param;
        array_len_param_ptr = ty_info.array_len_param_ptr;
        array_len_param_len = ty_info.array_len_param_len;
        elem_typeinfo = ty_info.elem_typeinfo;
        tag_layout_ptr = ty_info.tag_layout_ptr;
        tag_layout_len = ty_info.tag_layout_len;
        
        // If TYPE_STRUCT/TYPE_GENERIC/TYPE_TRAIT, get struct name from TypeInfo
        if (type_kind == TYPE_STRUCT || type_kind == TYPE_GENERIC || type_kind == TYPE_TRAIT) {
            struct_name_ptr = ty_info.struct_name_ptr;
            struct_name_len = ty_info.struct_name_len;
        }
        // If array/slice of struct pointer, store element struct name
        if (type_kind == TYPE_ARRAY || type_kind == TYPE_SLICE) {
            struct_name_ptr = ty_info.struct_name_ptr;
            struct_name_len = ty_info.struct_name_len;
        }
        // tagged layout name (non-struct base)
        if (is_tagged == 1 && tag_layout_ptr != 0 && type_kind != TYPE_STRUCT && type_kind != TYPE_ARRAY && type_kind != TYPE_SLICE) {
            struct_name_ptr = 0;
            struct_name_len = 0;
        }
    }
    
    var init: *AstNode = 0;
    
    if (parse_match(p, TOKEN_EQ)) {
        init = parse_expr(p);
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    var decl: *AstVarDecl = ast_var_decl(name_tok.ptr, name_tok.len, type_kind, ptr_depth, init);
    decl.is_tagged = is_tagged;
    decl.struct_name_ptr = struct_name_ptr;
    decl.struct_name_len = struct_name_len;
    decl.tag_layout_ptr = tag_layout_ptr;
    decl.tag_layout_len = tag_layout_len;
    decl.elem_type_kind = elem_type_kind;
    decl.elem_ptr_depth = elem_ptr_depth;
    decl.array_len = array_len;
    decl.array_len_is_param = array_len_is_param;
    decl.array_len_param_ptr = array_len_param_ptr;
    decl.array_len_param_len = array_len_param_len;
    decl.elem_typeinfo = elem_typeinfo;
    decl.annotations_vec = annotations;
    return (*AstNode)decl;
}

// ============================================
// Assignment Helpers
// ============================================

func is_assignable_expr(expr: *AstNode) -> u64 {
    var k: u64 = ast_kind(expr);
    switch (k) {
        case AST_IDENT: return true;
        case AST_DEREF: return true;
        case AST_DEREF8: return true;
        default: return false;
    }
}

func parse_is_enum_member_const_target(target: *AstNode) -> u64 {
    if (target == 0) { return 0; }
    if (ast_kind(target) != AST_MEMBER_ACCESS) { return 0; }

    var ma: *AstMemberAccess = (*AstMemberAccess)target;
    if (ma.parent_ptr != 0) { return 0; }
    if (ma.object == 0 || ast_kind(ma.object) != AST_IDENT) { return 0; }

    var sid: *AstIdent = (*AstIdent)ma.object;
    var scoped_const: *ConstResult = (*ConstResult)compiler_find_scoped_const(sid.name_ptr, sid.name_len, ma.member_ptr, ma.member_len);
    if (scoped_const == 0 || scoped_const.found == 0) { return 0; }
    return 1;
}

func parse_validate_assignment_target_not_enum_const(p: *Parser, target: *AstNode) -> u64 {
    if (parse_is_enum_member_const_target(target) == 0) { return 0; }
    var ma: *AstMemberAccess = (*AstMemberAccess)target;
    var sid: *AstIdent = (*AstIdent)ma.object;
    emit_stderr("[ERROR] Cannot assign to enum member constant: ");
    emit_stderr_len(sid.name_ptr, sid.name_len);
    emit_stderr(".");
    emit_stderr_len(ma.member_ptr, ma.member_len);
    emit_stderr("\n");
    parse_panic_here(p, "Syntax error");
    return 0;
}

func make_incdec_rhs(incdec_kind: u64, target: *AstNode) -> *AstNode {
    var one: *AstNode = ast_literal(1);
    switch (incdec_kind) {
        case TOKEN_PLUSPLUS:
            return ast_binary(TOKEN_PLUS, target, one);
        case TOKEN_MINUSMINUS:
            return ast_binary(TOKEN_MINUS, target, one);
        default:
            return ast_binary(TOKEN_MINUS, target, one);
    }
}

func parse_assign_or_postfix_expr(p: *Parser, lhs: *AstNode) -> *AstNode {
    if (parse_match(p, TOKEN_EQ)) {
        parse_validate_assignment_target_not_enum_const(p, lhs);
        var rhs: *AstNode = parse_expr(p);
        return ast_assign(lhs, rhs);
    }
    return parse_postfix_incdec_after_expr(p, lhs);
}

func parse_prefix_incdec_assign(p: *Parser) -> *AstNode {
    var k: u64 = parse_peek_kind(p);
    parse_consume(p, k);
    var target: *AstNode = parse_unary(p);
    if (!is_assignable_expr(target)) {
        emit_stderr("[ERROR] ++/-- requires assignable expression\n");
        parse_panic_here(p, "Syntax error");
    }
    parse_validate_assignment_target_not_enum_const(p, target);
    var rhs: *AstNode = make_incdec_rhs(k, target);
    return ast_assign(target, rhs);
}

func parse_postfix_incdec_after_expr(p: *Parser, expr: *AstNode) -> *AstNode {
    var k: u64 = parse_peek_kind(p);
    switch (k) {
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            break;
        default:
            return expr;
    }
    parse_consume(p, k);
    if (!is_assignable_expr(expr)) {
        emit_stderr("[ERROR] ++/-- requires assignable expression\n");
        parse_panic_here(p, "Syntax error");
    }
    parse_validate_assignment_target_not_enum_const(p, expr);
    var rhs: *AstNode = make_incdec_rhs(k, expr);
    return ast_assign(expr, rhs);
}

func parse_wrap_stmt_in_block(stmt: *AstNode) -> *AstNode {
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    stmts.push(stmt);
    return ast_block(stmts);
}

func parse_stmt_or_block(p: *Parser) -> *AstNode {
    if (parse_peek_kind(p) == TOKEN_LBRACE) {
        return parse_block(p);
    }
    return parse_wrap_stmt_in_block(parse_stmt(p));
}

func parse_assign_or_expr(p: *Parser) -> *AstNode {
    var expr: *AstNode = parse_expr(p);
    
    if (parse_match(p, TOKEN_EQ)) {
        parse_validate_assignment_target_not_enum_const(p, expr);
        var val: *AstNode = parse_expr(p);
        parse_consume(p, TOKEN_SEMICOLON);
        return ast_assign(expr, val);
    }

    // Compound assignment: x += 5  =>  x = x + 5
    var k: u64 = parse_peek_kind(p);
    var bin_op: u64 = 0;
    switch (k) {
        case TOKEN_PLUS_EQ: bin_op = TOKEN_PLUS; break;
        case TOKEN_MINUS_EQ: bin_op = TOKEN_MINUS; break;
        case TOKEN_STAR_EQ: bin_op = TOKEN_STAR; break;
        case TOKEN_SLASH_EQ: bin_op = TOKEN_SLASH; break;
        case TOKEN_PERCENT_EQ: bin_op = TOKEN_PERCENT; break;
        default: bin_op = 0; break;
    }
    if (bin_op != 0) {
        parse_consume(p, k);
        if (!is_assignable_expr(expr)) {
            emit_stderr("[ERROR] Compound assignment requires assignable expression\n");
            parse_panic_here(p, "Syntax error");
        }
        parse_validate_assignment_target_not_enum_const(p, expr);
        var rhs: *AstNode = parse_expr(p);
        
        var new_val: *AstNode = ast_binary(bin_op, expr, rhs);
        parse_consume(p, TOKEN_SEMICOLON);
        return ast_assign(expr, new_val);
    }

    // Postfix ++/-- statement sugar: x++; x--;  =>  x = x +/- 1;
    var post_k: u64 = parse_peek_kind(p);
    switch (post_k) {
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            parse_consume(p, post_k);
            if (!is_assignable_expr(expr)) {
                emit_stderr("[ERROR] ++/-- requires assignable expression\n");
                parse_panic_here(p, "Syntax error");
            }
            parse_validate_assignment_target_not_enum_const(p, expr);
            var rhs: *AstNode = make_incdec_rhs(post_k, expr);
            parse_consume(p, TOKEN_SEMICOLON);
            return ast_assign(expr, rhs);
        default:
            break;
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_expr_stmt(expr);
}

// ============================================
// Control Flow Statements
// ============================================

func parse_if_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_IF);
    parse_consume(p, TOKEN_LPAREN);
    var cond: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    
    var then_blk: *AstNode = parse_stmt_or_block(p);
    
    var else_blk: *AstNode = 0;
    if (parse_match(p, TOKEN_ELSE)) {
        if (parse_peek_kind(p) == TOKEN_IF) {
            else_blk = parse_wrap_stmt_in_block(parse_if_stmt(p));
        } else {
            else_blk = parse_stmt_or_block(p);
        }
    }
    
    return ast_if(cond, then_blk, else_blk);
}

func parse_while_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_WHILE);
    parse_consume(p, TOKEN_LPAREN);
    var cond: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    
    p.breakable_depth = p.breakable_depth + 1;
    var body: *AstNode = parse_stmt_or_block(p);
    p.breakable_depth = p.breakable_depth - 1;

    if (parse_try_context_active(p) != 0) {
        var flag_ptr: u64 = parse_try_context_current_flag_ptr(p);
        var flag_len: u64 = parse_try_context_current_flag_len(p);
        body = parse_try_wrap_loop_body_with_guard(body, flag_ptr, flag_len);
    }
    
    return ast_while(cond, body);
}

func parse_for_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_FOR);
    parse_consume(p, TOKEN_LPAREN);

    var init: *AstNode = 0;
    var k: u64 = parse_peek_kind(p);

    // Parse init clause
    switch (k) {
        case TOKEN_SEMICOLON:
            parse_consume(p, TOKEN_SEMICOLON);
            break;
        case TOKEN_VAR:
            init = parse_var_decl(p);
            break;
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            init = parse_prefix_incdec_assign(p);
            parse_consume(p, TOKEN_SEMICOLON);
            break;
        default:
            var lhs: *AstNode = parse_expr(p);
            init = parse_assign_or_postfix_expr(p, lhs);
            parse_consume(p, TOKEN_SEMICOLON);
            break;
    }

    var cond: *AstNode = 0;
    if (parse_peek_kind(p) != TOKEN_SEMICOLON) {
        cond = parse_expr(p);
    }
    parse_consume(p, TOKEN_SEMICOLON);

    var update: *AstNode = 0;
    k = parse_peek_kind(p);

    // Parse update clause
    switch (k) {
        case TOKEN_RPAREN:
            // No update clause
            break;
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            update = parse_prefix_incdec_assign(p);
            break;
        default:
            var upd_lhs: *AstNode = parse_expr(p);
            update = parse_assign_or_postfix_expr(p, upd_lhs);
            break;
    }

    parse_consume(p, TOKEN_RPAREN);

    p.breakable_depth = p.breakable_depth + 1;
    var body: *AstNode = parse_stmt_or_block(p);
    p.breakable_depth = p.breakable_depth - 1;
    if (parse_try_context_active(p) != 0) {
        var flag_ptr: u64 = parse_try_context_current_flag_ptr(p);
        var flag_len: u64 = parse_try_context_current_flag_len(p);
        body = parse_try_wrap_loop_body_with_guard(body, flag_ptr, flag_len);
    }
    return ast_for(init, cond, update, body);
}

const PARSE_SWITCH_ARM_SIMPLE = 1;
const PARSE_SWITCH_ARM_VARIANT = 2;
const PARSE_SWITCH_ARM_DEFAULT = 3;

struct ParseSwitchArm {
    public kind: u64;
    public values_vec: *Vec<*AstNode>;
    public enum_ptr: u64;
    public enum_len: u64;
    public variant_ptr: u64;
    public variant_len: u64;
    public bind_names: *Vec<*NameInfo>;
    public body: *AstNode;
}

impl ParseSwitchArm {
    public constructor() {
        self.kind = 0;
        self.values_vec = 0;
        self.enum_ptr = 0;
        self.enum_len = 0;
        self.variant_ptr = 0;
        self.variant_len = 0;
        self.bind_names = 0;
        self.body = 0;
    }
}

func parse_match_build_payload_field_name(idx: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"v";
    var prefix_len: u64 = 1;
    var idx_buf: u64 = heap_alloc(32 * sizeof(u8));
    var idx_len: u64 = io_u64_to_ascii(idx_buf, idx);
    var out_len: u64 = prefix_len + idx_len;
    var out_ptr: u64 = heap_alloc((out_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, out_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, idx_buf, idx_len);
    out_u8[out_len] = 0;
    return new NameInfo{out_ptr, out_len};
}

func parse_switch_parse_variant_case_head(p: *Parser, is_match_stmt: u64) -> *ParseSwitchArm {
    if (is_match_stmt == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) { return 0; }

    var saved: u64 = parser_pos(p);
    var enum_tok: *Token = parse_peek(p);
    parse_adv(p);
    if (parse_match(p, TOKEN_DOT) == 0) {
        parser_set_pos(p, saved);
        return 0;
    }
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
        parser_set_pos(p, saved);
        return 0;
    }
    var variant_tok: *Token = parse_peek(p);
    parse_adv(p);

    var expected_arity: u64 = compiler_get_enum_variant_arity(enum_tok.ptr, enum_tok.len, variant_tok.ptr, variant_tok.len);
    if (expected_arity == 9223372036854775807) {
        parser_set_pos(p, saved);
        return 0;
    }

    var bind_names: *Vec<*NameInfo> = new Vec<*NameInfo>(expected_arity);
    if (parse_match(p, TOKEN_LPAREN)) {
        if (parse_peek_kind(p) != TOKEN_RPAREN) {
            while (1) {
                if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                    emit_stderr("[ERROR] match variant payload binding must be identifier\n");
                    parse_panic_here(p, "Syntax error");
                }
                var bind_tok: *Token = parse_peek(p);
                parse_consume(p, TOKEN_IDENTIFIER);
                bind_names.push(new NameInfo{bind_tok.ptr, bind_tok.len});
                if (parse_match(p, TOKEN_COMMA) == 0) { break; }
            }
        }
        parse_consume(p, TOKEN_RPAREN);
    }

    if (bind_names.len() != expected_arity) {
        emit_stderr("[ERROR] match variant payload arity mismatch: ");
        emit_stderr_len(enum_tok.ptr, enum_tok.len);
        emit_stderr(".");
        emit_stderr_len(variant_tok.ptr, variant_tok.len);
        emit_stderr(" expects ");
        emit_u64_stderr(expected_arity);
        emit_stderr(" binding(s), got ");
        emit_u64_stderr(bind_names.len());
        emit_stderr("\n");
        parse_panic_here(p, "Syntax error");
    }
    if (parse_peek_kind(p) == TOKEN_COMMA) {
        emit_stderr("[ERROR] variant match case cannot be combined with comma-separated values\n");
        parse_panic_here(p, "Syntax error");
    }

    var arm: *ParseSwitchArm = new ParseSwitchArm();
    arm.kind = PARSE_SWITCH_ARM_VARIANT;
    arm.enum_ptr = enum_tok.ptr;
    arm.enum_len = enum_tok.len;
    arm.variant_ptr = variant_tok.ptr;
    arm.variant_len = variant_tok.len;
    arm.bind_names = bind_names;
    return arm;
}

func parse_switch_parse_case_head(p: *Parser, is_match_stmt: u64) -> *ParseSwitchArm {
    var arm: *ParseSwitchArm = new ParseSwitchArm();
    if (parse_peek_kind(p) == TOKEN_DEFAULT) {
        parse_consume(p, TOKEN_DEFAULT);
        arm.kind = PARSE_SWITCH_ARM_DEFAULT;
        return arm;
    }
    if (parse_peek_kind(p) != TOKEN_CASE) {
        return 0;
    }
    parse_consume(p, TOKEN_CASE);

    if (parse_peek_kind(p) == TOKEN_IDENTIFIER) {
        var wc_tok: *Token = parse_peek(p);
        if (wc_tok.len == 1 && str_eq(wc_tok.ptr, wc_tok.len, "_", 1) != 0) {
            parse_adv(p);
            arm.kind = PARSE_SWITCH_ARM_DEFAULT;
            return arm;
        }
    }

    var variant_arm: *ParseSwitchArm = parse_switch_parse_variant_case_head(p, is_match_stmt);
    if (variant_arm != 0) { return variant_arm; }

    arm.kind = PARSE_SWITCH_ARM_SIMPLE;
    arm.values_vec = new Vec<*AstNode>(2);
    arm.values_vec.push(parse_expr(p));
    while (parse_match(p, TOKEN_COMMA)) {
        if (parse_peek_kind(p) == TOKEN_IDENTIFIER) {
            var wc_tok2: *Token = parse_peek(p);
            if (wc_tok2.len == 1 && str_eq(wc_tok2.ptr, wc_tok2.len, "_", 1) != 0) {
                emit_stderr("[ERROR] wildcard '_' cannot be mixed with explicit case values\n");
                parse_panic_here(p, "Syntax error");
            }
        }
        arm.values_vec.push(parse_expr(p));
    }
    return arm;
}

func parse_switch_parse_case_body(p: *Parser) -> *AstNode {
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(8);
    while (parse_peek_kind(p) != TOKEN_CASE) {
        if (parse_peek_kind(p) == TOKEN_DEFAULT) { break; }
        if (parse_peek_kind(p) == TOKEN_RBRACE) { break; }
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        stmts.push(parse_stmt(p));
    }
    return (*AstNode)ast_block(stmts);
}

func parse_switch_build_tag_expr(tmp_name_ptr: u64, tmp_name_len: u64) -> *AstNode {
    return (*AstNode)ast_member_access((*AstNode)ast_ident(tmp_name_ptr, tmp_name_len), "__tag", 5);
}

func parse_switch_build_simple_case_cond(tmp_name_ptr: u64, tmp_name_len: u64, values: *Vec<*AstNode>, enum_mode: u64) -> *AstNode {
    if (values == 0 || values.len() == 0) {
        return (*AstNode)ast_literal(0);
    }
    var lhs_base: *AstNode = (*AstNode)ast_ident(tmp_name_ptr, tmp_name_len);
    if (enum_mode != 0) {
        lhs_base = parse_switch_build_tag_expr(tmp_name_ptr, tmp_name_len);
    }
    var cond: *AstNode = (*AstNode)ast_binary(TOKEN_EQEQ, lhs_base, values.get(0));
    var n: u64 = values.len();
    for (var i: u64 = 1; i < n; i++) {
        var cmp_lhs: *AstNode = (*AstNode)ast_ident(tmp_name_ptr, tmp_name_len);
        if (enum_mode != 0) {
            cmp_lhs = parse_switch_build_tag_expr(tmp_name_ptr, tmp_name_len);
        }
        var cmp: *AstNode = (*AstNode)ast_binary(TOKEN_EQEQ, cmp_lhs, values.get(i));
        cond = (*AstNode)ast_binary(TOKEN_OROR, cond, cmp);
    }
    return cond;
}

func parse_switch_expr_is_enum_variant_const(node: *AstNode, enum_ptr: u64, enum_len: u64, variant_ptr: u64, variant_len: u64) -> u64 {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    if (kind == AST_CAST) {
        return parse_switch_expr_is_enum_variant_const(((*AstCast)node).expr, enum_ptr, enum_len, variant_ptr, variant_len);
    }
    if (kind == AST_MEMBER_ACCESS) {
        var ma: *AstMemberAccess = (*AstMemberAccess)node;
        if (ma.object == 0 || ast_kind(ma.object) != AST_IDENT) { return 0; }
        var obj: *AstIdent = (*AstIdent)ma.object;
        if (str_eq(obj.name_ptr, obj.name_len, enum_ptr, enum_len) == 0) { return 0; }
        if (str_eq(ma.member_ptr, ma.member_len, variant_ptr, variant_len) == 0) { return 0; }
        return 1;
    }
    if (kind == AST_IDENT) {
        var id: *AstIdent = (*AstIdent)node;
        var scoped: *NameInfo = module_util_build_joined_name(enum_ptr, enum_len, variant_ptr, variant_len);
        if (str_eq(id.name_ptr, id.name_len, scoped.ptr, scoped.len) != 0) { return 1; }
    }
    return 0;
}

func parse_switch_arm_covers_variant(arm: *ParseSwitchArm, enum_ptr: u64, enum_len: u64, variant_ptr: u64, variant_len: u64) -> u64 {
    if (arm == 0) { return 0; }
    if (arm.kind == PARSE_SWITCH_ARM_VARIANT) {
        if (str_eq(arm.enum_ptr, arm.enum_len, enum_ptr, enum_len) == 0) { return 0; }
        if (str_eq(arm.variant_ptr, arm.variant_len, variant_ptr, variant_len) == 0) { return 0; }
        return 1;
    }
    if (arm.kind != PARSE_SWITCH_ARM_SIMPLE || arm.values_vec == 0) { return 0; }
    var n: u64 = arm.values_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        if (parse_switch_expr_is_enum_variant_const(arm.values_vec.get(i), enum_ptr, enum_len, variant_ptr, variant_len) != 0) {
            return 1;
        }
    }
    return 0;
}

func parse_switch_has_default_arm(arms: *Vec<*ParseSwitchArm>) -> u64 {
    if (arms == 0) { return 0; }
    var n: u64 = arms.len();
    for (var i: u64 = 0; i < n; i++) {
        var arm: *ParseSwitchArm = arms.get(i);
        if (arm != 0 && arm.kind == PARSE_SWITCH_ARM_DEFAULT) {
            return 1;
        }
    }
    return 0;
}

func parse_switch_validate_variant_exhaustive(p: *Parser, arms: *Vec<*ParseSwitchArm>, enum_ptr: u64, enum_len: u64) -> u64 {
    if (arms == 0 || enum_ptr == 0 || enum_len == 0) { return 0; }
    if (parse_switch_has_default_arm(arms) != 0) { return 0; }
    var variants: *Vec<*NameInfo> = compiler_get_enum_variants(enum_ptr, enum_len);
    if (variants == 0 || variants.len() == 0) { return 0; }

    var vn: u64 = variants.len();
    for (var vi: u64 = 0; vi < vn; vi++) {
        var variant: *NameInfo = variants.get(vi);
        var covered: u64 = 0;
        var an: u64 = arms.len();
        for (var ai: u64 = 0; ai < an; ai++) {
            if (parse_switch_arm_covers_variant(arms.get(ai), enum_ptr, enum_len, variant.ptr, variant.len) != 0) {
                covered = 1;
                break;
            }
        }
        if (covered == 0) {
            emit_stderr("[ERROR] non-exhaustive match: missing case ");
            emit_stderr_len(enum_ptr, enum_len);
            emit_stderr(".");
            emit_stderr_len(variant.ptr, variant.len);
            emit_stderr("\n");
            parse_panic_here(p, "Syntax error");
        }
    }
    return 0;
}

func parse_switch_find_payload_field_desc(struct_def: *AstStructDef, field_ptr: u64, field_len: u64) -> *FieldDesc {
    if (struct_def == 0 || struct_def.fields_vec == 0) { return 0; }
    var n: u64 = struct_def.fields_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var field: *FieldDesc = struct_def.fields_vec.get(i);
        if (str_eq(field.name_ptr, field.name_len, field_ptr, field_len) != 0) {
            return field;
        }
    }
    return 0;
}

func parse_switch_build_binding_decl(name_ptr: u64, name_len: u64, field_expr: *AstNode, field_desc: *FieldDesc) -> *AstVarDecl {
    var decl: *AstVarDecl = ast_var_decl(name_ptr, name_len, TYPE_U64, 0, field_expr);
    if (field_desc == 0) { return decl; }

    decl.type_kind = field_desc.type_kind;
    decl.ptr_depth = field_desc.ptr_depth;
    decl.is_tagged = field_desc.is_tagged;
    decl.struct_name_ptr = field_desc.struct_name_ptr;
    decl.struct_name_len = field_desc.struct_name_len;
    decl.tag_layout_ptr = field_desc.tag_layout_ptr;
    decl.tag_layout_len = field_desc.tag_layout_len;
    decl.elem_type_kind = field_desc.elem_type_kind;
    decl.elem_ptr_depth = field_desc.elem_ptr_depth;
    decl.array_len = field_desc.array_len;
    decl.elem_typeinfo = field_desc.elem_typeinfo;
    return decl;
}

func parse_switch_variant_arm_with_bindings(p: *Parser, tmp_name_ptr: u64, tmp_name_len: u64, arm: *ParseSwitchArm) -> *AstNode {
    var then_stmts: *Vec<*AstNode> = new Vec<*AstNode>(8);
    if (arm.bind_names != 0) {
        var bn: u64 = arm.bind_names.len();
        if (bn != 0) {
            var payload_info: *NameInfo = compiler_get_enum_variant_payload_struct(arm.enum_ptr, arm.enum_len, arm.variant_ptr, arm.variant_len);
            if (payload_info == 0) {
                emit_stderr("[ERROR] enum variant payload metadata is missing for match arm: ");
                emit_stderr_len(arm.enum_ptr, arm.enum_len);
                emit_stderr(".");
                emit_stderr_len(arm.variant_ptr, arm.variant_len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }

            var payload_struct: *AstStructDef = get_struct_def(payload_info.ptr, payload_info.len);
            if (payload_struct == 0) {
                emit_stderr("[ERROR] enum payload struct type not found: ");
                emit_stderr_len(payload_info.ptr, payload_info.len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }

            var payload_tmp: *NameInfo = parse_stmt_internal_name("__match_payload_", 16, parse_next_generated_id(p));
            var payload_slot_expr: *AstNode = (*AstNode)ast_member_access((*AstNode)ast_ident(tmp_name_ptr, tmp_name_len), "__payload", 9);
            var payload_addr_expr: *AstNode = (*AstNode)ast_addr_of(payload_slot_expr);
            var payload_cast: *AstNode = (*AstNode)ast_cast_ex(payload_addr_expr, TYPE_STRUCT, 1, 0, payload_info.ptr, payload_info.len, 0, 0);
            var payload_decl: *AstVarDecl = ast_var_decl(payload_tmp.ptr, payload_tmp.len, TYPE_STRUCT, 1, payload_cast);
            payload_decl.struct_name_ptr = payload_info.ptr;
            payload_decl.struct_name_len = payload_info.len;
            then_stmts.push((*AstNode)payload_decl);

            for (var i: u64 = 0; i < bn; i++) {
                var bind: *NameInfo = arm.bind_names.get(i);
                var field_name: *NameInfo = parse_match_build_payload_field_name(i);
                var field_desc: *FieldDesc = parse_switch_find_payload_field_desc(payload_struct, field_name.ptr, field_name.len);
                var field_expr: *AstNode = (*AstNode)ast_member_access((*AstNode)ast_deref((*AstNode)ast_ident(payload_tmp.ptr, payload_tmp.len)), field_name.ptr, field_name.len);
                then_stmts.push((*AstNode)parse_switch_build_binding_decl(bind.ptr, bind.len, field_expr, field_desc));
            }
        }
    }
    parse_try_stmt_append_block_stmts(then_stmts, arm.body);
    return (*AstNode)ast_block(then_stmts);
}

func parse_switch_lower_pattern_match(p: *Parser, expr: *AstNode, arms: *Vec<*ParseSwitchArm>, is_match_stmt: u64) -> *AstNode {
    if (arms == 0 || arms.len() == 0) {
        return (*AstNode)ast_block(new Vec<*AstNode>(0));
    }

    var enum_ptr: u64 = 0;
    var enum_len: u64 = 0;
    var n: u64 = arms.len();
    for (var i: u64 = 0; i < n; i++) {
        var arm0: *ParseSwitchArm = arms.get(i);
        if (arm0.kind != PARSE_SWITCH_ARM_VARIANT) { continue; }
        if (enum_ptr == 0) {
            enum_ptr = arm0.enum_ptr;
            enum_len = arm0.enum_len;
        } else if (str_eq(enum_ptr, enum_len, arm0.enum_ptr, arm0.enum_len) == 0) {
            emit_stderr("[ERROR] all variant match arms must target the same enum type\n");
            parse_panic_here(p, "Syntax error");
        }
    }

    if (is_match_stmt != 0 && enum_ptr != 0) {
        parse_switch_validate_variant_exhaustive(p, arms, enum_ptr, enum_len);
    }

    var tmp_id: u64 = parse_next_generated_id(p);
    var tmp_name: *NameInfo = parse_stmt_internal_name("__match_tmp_", 12, tmp_id);
    var tmp_decl: *AstVarDecl = ast_var_decl(tmp_name.ptr, tmp_name.len, TYPE_U64, 0, expr);
    if (enum_ptr != 0) {
        tmp_decl.type_kind = TYPE_STRUCT;
        tmp_decl.ptr_depth = 0;
        tmp_decl.struct_name_ptr = enum_ptr;
        tmp_decl.struct_name_len = enum_len;
    }

    var chain: *AstNode = 0;
    for (var ri: i64 = (i64)n - 1; ri >= 0; ri--) {
        var arm: *ParseSwitchArm = arms.get((u64)ri);
        if (arm.kind == PARSE_SWITCH_ARM_DEFAULT) {
            chain = arm.body;
            continue;
        }
        var else_block: *AstNode = chain;
        if (else_block != 0 && ast_kind(else_block) == AST_IF) {
            else_block = parse_wrap_stmt_in_block(else_block);
        }
        if (arm.kind == PARSE_SWITCH_ARM_VARIANT) {
            var tag_const: *NameInfo = module_util_build_joined_name(arm.enum_ptr, arm.enum_len, arm.variant_ptr, arm.variant_len);
            var cond: *AstNode = (*AstNode)ast_binary(TOKEN_EQEQ, parse_switch_build_tag_expr(tmp_name.ptr, tmp_name.len), (*AstNode)ast_ident(tag_const.ptr, tag_const.len));
            var then_block: *AstNode = parse_switch_variant_arm_with_bindings(p, tmp_name.ptr, tmp_name.len, arm);
            chain = (*AstNode)ast_if(cond, then_block, else_block);
            continue;
        }
        var cond2: *AstNode = parse_switch_build_simple_case_cond(tmp_name.ptr, tmp_name.len, arm.values_vec, enum_ptr != 0);
        chain = (*AstNode)ast_if(cond2, arm.body, else_block);
    }

    var lowered_stmts: *Vec<*AstNode> = new Vec<*AstNode>(2);
    lowered_stmts.push((*AstNode)tmp_decl);
    if (chain != 0) {
        lowered_stmts.push(chain);
    } else if (is_match_stmt == 0) {
        // no-op for switch/match without default arm
    }
    return (*AstNode)ast_block(lowered_stmts);
}

func parse_switch_stmt(p: *Parser) -> *AstNode {
    var is_match_stmt: u64 = 0;
    if (parse_peek_kind(p) == TOKEN_MATCH) {
        parse_consume(p, TOKEN_MATCH);
        is_match_stmt = 1;
    } else {
        parse_consume(p, TOKEN_SWITCH);
    }
    parse_consume(p, TOKEN_LPAREN);
    var expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    parse_consume(p, TOKEN_LBRACE);

    var cases: *Vec<*AstNode> = new Vec<*AstNode>(16);
    var arms: *Vec<*ParseSwitchArm> = new Vec<*ParseSwitchArm>(16);
    var has_pattern_arm: u64 = 0;
    p.breakable_depth = p.breakable_depth + 1;

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        var arm: *ParseSwitchArm = parse_switch_parse_case_head(p, is_match_stmt);
        if (arm == 0) { break; }
        parse_consume(p, TOKEN_COLON);
        arm.body = parse_switch_parse_case_body(p);
        if (arm.kind == PARSE_SWITCH_ARM_VARIANT) {
            has_pattern_arm = 1;
        }
        arms.push(arm);

        if (arm.kind == PARSE_SWITCH_ARM_DEFAULT) {
            cases.push(ast_case(0, arm.body, 1));
            continue;
        }
        if (arm.kind == PARSE_SWITCH_ARM_SIMPLE) {
            if (arm.values_vec == 0 || arm.values_vec.len() == 0) {
                emit_stderr("[ERROR] case value is required\n");
                parse_panic_here(p, "Syntax error");
            }
            var cvn: u64 = arm.values_vec.len();
            for (var ci: u64 = 0; ci < cvn; ci++) {
                cases.push(ast_case(arm.values_vec.get(ci), arm.body, 0));
            }
        }
    }

    p.breakable_depth = p.breakable_depth - 1;
    parse_consume(p, TOKEN_RBRACE);
    if (has_pattern_arm != 0) {
        return parse_switch_lower_pattern_match(p, expr, arms, is_match_stmt);
    }
    if (is_match_stmt != 0) {
        return ast_match(expr, cases);
    }
    return ast_switch(expr, cases);
}

// ============================================
// Jump Statements
// ============================================

func parse_break_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_BREAK);
    if (p.breakable_depth == 0) {
        emit_stderr("[ERROR] break can only be used inside loop/switch\n");
        parse_panic_here(p, "Syntax error");
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_break();
}

func parse_continue_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_CONTINUE);
    if (p.breakable_depth == 0) {
        emit_stderr("[ERROR] continue can only be used inside loop\n");
        parse_panic_here(p, "Syntax error");
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_continue();
}

func parse_return_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_RETURN);
    
    var expr: *AstNode = 0;
    if (parse_peek_kind(p) != TOKEN_SEMICOLON) {
        expr = parse_expr(p);
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    return ast_return(expr);
}

func parse_throw_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_THROW);
    if (parse_try_context_active(p) == 0) {
        emit_stderr("[ERROR] throw can only be used inside try { ... }\n");
        parse_panic_here(p, "Syntax error");
    }

    var top_idx: u64 = p.try_throw_flag_ptr_stack.len() - 1;
    var flag_ptr: u64 = p.try_throw_flag_ptr_stack.get(top_idx);
    var flag_len: u64 = p.try_throw_flag_len_stack.get(top_idx);
    var value_ptr: u64 = p.try_throw_value_ptr_stack.get(top_idx);
    var value_len: u64 = p.try_throw_value_len_stack.get(top_idx);
    var thrown_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_SEMICOLON);

    var throw_stmts: *Vec<*AstNode> = new Vec<*AstNode>(2);
    throw_stmts.push((*AstNode)ast_assign((*AstNode)ast_ident(value_ptr, value_len), thrown_expr));
    throw_stmts.push((*AstNode)ast_assign((*AstNode)ast_ident(flag_ptr, flag_len), (*AstNode)ast_literal(1)));
    return (*AstNode)ast_block(throw_stmts);
}

func parse_try_stmt_append_block_stmts(dst: *Vec<*AstNode>, block_node: *AstNode) -> u64 {
    if (block_node == 0) { return 0; }
    if (ast_kind(block_node) != AST_BLOCK) {
        dst.push(block_node);
        return 0;
    }
    var blk: *AstBlock = (*AstBlock)block_node;
    if (blk.stmts_vec == 0) { return 0; }
    var n: u64 = blk.stmts_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        dst.push(blk.stmts_vec.get(i));
    }
    return 0;
}

func parse_try_stmt_append_block_stmts_with_guard(dst: *Vec<*AstNode>, block_node: *AstNode, flag_ptr: u64, flag_len: u64) -> u64 {
    if (block_node == 0) { return 0; }
    if (ast_kind(block_node) != AST_BLOCK) {
        dst.push(parse_try_wrap_stmt_if_not_thrown(block_node, flag_ptr, flag_len));
        return 0;
    }
    var blk: *AstBlock = (*AstBlock)block_node;
    if (blk.stmts_vec == 0) { return 0; }
    var n: u64 = blk.stmts_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        dst.push(parse_try_wrap_stmt_if_not_thrown(blk.stmts_vec.get(i), flag_ptr, flag_len));
    }
    return 0;
}

func parse_try_build_unhandled_throw_stmt() -> *AstNode {
    var args: *Vec<*AstNode> = new Vec<*AstNode>(3);
    args.push((*AstNode)ast_string("unhandled throw", 15));
    args.push((*AstNode)ast_literal(15));
    args.push((*AstNode)ast_literal(0));
    var call: *AstCall = ast_call("debug_fail", 10, args);
    return ast_expr_stmt((*AstNode)call);
}

func parse_try_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_TRY);
    p.try_stmt_counter = p.try_stmt_counter + 1;
    var flag_name: *NameInfo = parse_stmt_internal_name("__try_thrown_", 12, p.try_stmt_counter);
    var value_name: *NameInfo = parse_stmt_internal_name("__try_value_", 11, p.try_stmt_counter);

    var outer_flag_ptr: u64 = 0;
    var outer_flag_len: u64 = 0;
    var outer_value_ptr: u64 = 0;
    var outer_value_len: u64 = 0;
    if (parse_try_context_active(p) != 0) {
        outer_flag_ptr = parse_try_context_current_flag_ptr(p);
        outer_flag_len = parse_try_context_current_flag_len(p);
        outer_value_ptr = parse_try_context_current_value_ptr(p);
        outer_value_len = parse_try_context_current_value_len(p);
    }

    var allowed_depth: u64 = p.breakable_depth;
    parse_try_context_push(p, flag_name.ptr, flag_name.len, value_name.ptr, value_name.len, allowed_depth);
    var try_block: *AstNode = parse_block(p);

    var catch_block: *AstNode = 0;
    var catch_name_ptr: u64 = 0;
    var catch_name_len: u64 = 0;
    var catch_value_type: *TypeInfo = 0;
    var finally_block: *AstNode = 0;
    if (parse_peek_kind(p) == TOKEN_CATCH) {
        parse_consume(p, TOKEN_CATCH);
        if (parse_match(p, TOKEN_LPAREN)) {
            var catch_tok: *Token = parse_peek(p);
            parse_consume(p, TOKEN_IDENTIFIER);
            catch_name_ptr = catch_tok.ptr;
            catch_name_len = catch_tok.len;
            if (parse_match(p, TOKEN_COLON)) {
                catch_value_type = parse_type_ex(p);
            }
            parse_consume(p, TOKEN_RPAREN);
        }
        catch_block = parse_block(p);
    }
    if (parse_peek_kind(p) == TOKEN_FINALLY) {
        parse_consume(p, TOKEN_FINALLY);
        finally_block = parse_block(p);
    }
    parse_try_context_pop(p);

    if (catch_block == 0 && finally_block == 0) {
        emit_stderr("[ERROR] try statement requires catch and/or finally block\n");
        parse_panic_here(p, "Syntax error");
    }

    var lowered_stmts: *Vec<*AstNode> = new Vec<*AstNode>(6);
    lowered_stmts.push((*AstNode)ast_var_decl(flag_name.ptr, flag_name.len, TYPE_U64, 0, (*AstNode)ast_literal(0)));
    var thrown_value_type: *TypeInfo = catch_value_type;
    if (thrown_value_type == 0) {
        thrown_value_type = new TypeInfo(TYPE_U64, 0);
    }
    var value_decl: *AstVarDecl = ast_var_decl(value_name.ptr, value_name.len, thrown_value_type.type_kind, thrown_value_type.ptr_depth, (*AstNode)ast_literal(0));
    value_decl.is_tagged = thrown_value_type.is_tagged;
    value_decl.struct_name_ptr = thrown_value_type.struct_name_ptr;
    value_decl.struct_name_len = thrown_value_type.struct_name_len;
    value_decl.tag_layout_ptr = thrown_value_type.tag_layout_ptr;
    value_decl.tag_layout_len = thrown_value_type.tag_layout_len;
    value_decl.elem_type_kind = thrown_value_type.elem_type_kind;
    value_decl.elem_ptr_depth = thrown_value_type.elem_ptr_depth;
    value_decl.array_len = thrown_value_type.array_len;
    value_decl.array_len_is_param = thrown_value_type.array_len_is_param;
    value_decl.array_len_param_ptr = thrown_value_type.array_len_param_ptr;
    value_decl.array_len_param_len = thrown_value_type.array_len_param_len;
    if (thrown_value_type.type_kind == TYPE_FUNC) {
        value_decl.elem_typeinfo = thrown_value_type;
    } else {
        value_decl.elem_typeinfo = thrown_value_type.elem_typeinfo;
    }
    lowered_stmts.push((*AstNode)value_decl);

    parse_try_stmt_append_block_stmts_with_guard(lowered_stmts, try_block, flag_name.ptr, flag_name.len);

    if (catch_block != 0) {
        var catch_wrapped: *Vec<*AstNode> = new Vec<*AstNode>(8);
        catch_wrapped.push((*AstNode)ast_assign((*AstNode)ast_ident(flag_name.ptr, flag_name.len), (*AstNode)ast_literal(0)));

        if (catch_name_ptr != 0 && catch_name_len != 0) {
            var catch_decl: *AstVarDecl = ast_var_decl(catch_name_ptr, catch_name_len, thrown_value_type.type_kind, thrown_value_type.ptr_depth, (*AstNode)ast_ident(value_name.ptr, value_name.len));
            catch_decl.is_tagged = thrown_value_type.is_tagged;
            catch_decl.struct_name_ptr = thrown_value_type.struct_name_ptr;
            catch_decl.struct_name_len = thrown_value_type.struct_name_len;
            catch_decl.tag_layout_ptr = thrown_value_type.tag_layout_ptr;
            catch_decl.tag_layout_len = thrown_value_type.tag_layout_len;
            catch_decl.elem_type_kind = thrown_value_type.elem_type_kind;
            catch_decl.elem_ptr_depth = thrown_value_type.elem_ptr_depth;
            catch_decl.array_len = thrown_value_type.array_len;
            catch_decl.array_len_is_param = thrown_value_type.array_len_is_param;
            catch_decl.array_len_param_ptr = thrown_value_type.array_len_param_ptr;
            catch_decl.array_len_param_len = thrown_value_type.array_len_param_len;
            if (thrown_value_type.type_kind == TYPE_FUNC) {
                catch_decl.elem_typeinfo = thrown_value_type;
            } else {
                catch_decl.elem_typeinfo = thrown_value_type.elem_typeinfo;
            }
            catch_wrapped.push((*AstNode)catch_decl);
        }
        parse_try_stmt_append_block_stmts_with_guard(catch_wrapped, catch_block, flag_name.ptr, flag_name.len);

        var thrown_cond2: *AstNode = (*AstNode)ast_binary(TOKEN_BANGEQ, (*AstNode)ast_ident(flag_name.ptr, flag_name.len), (*AstNode)ast_literal(0));
        lowered_stmts.push((*AstNode)ast_if(thrown_cond2, (*AstNode)ast_block(catch_wrapped), 0));
    }

    if (finally_block != 0) {
        var pending_name: *NameInfo = parse_stmt_internal_name("__try_pending_", 14, p.try_stmt_counter);
        lowered_stmts.push((*AstNode)ast_var_decl(pending_name.ptr, pending_name.len, TYPE_U64, 0, (*AstNode)ast_ident(flag_name.ptr, flag_name.len)));
        lowered_stmts.push((*AstNode)ast_assign((*AstNode)ast_ident(flag_name.ptr, flag_name.len), (*AstNode)ast_literal(0)));
        parse_try_stmt_append_block_stmts_with_guard(lowered_stmts, finally_block, flag_name.ptr, flag_name.len);

        var restore_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
        restore_stmts.push((*AstNode)ast_assign((*AstNode)ast_ident(flag_name.ptr, flag_name.len), (*AstNode)ast_ident(pending_name.ptr, pending_name.len)));
        var restore_cond: *AstNode = (*AstNode)ast_binary(TOKEN_EQEQ, (*AstNode)ast_ident(flag_name.ptr, flag_name.len), (*AstNode)ast_literal(0));
        lowered_stmts.push((*AstNode)ast_if(restore_cond, (*AstNode)ast_block(restore_stmts), 0));
    }

    var post_throw_cond: *AstNode = (*AstNode)ast_binary(TOKEN_BANGEQ, (*AstNode)ast_ident(flag_name.ptr, flag_name.len), (*AstNode)ast_literal(0));
    if (outer_flag_ptr != 0 && outer_flag_len != 0 && outer_value_ptr != 0 && outer_value_len != 0) {
        var propagate_stmts: *Vec<*AstNode> = new Vec<*AstNode>(3);
        propagate_stmts.push((*AstNode)ast_assign((*AstNode)ast_ident(outer_value_ptr, outer_value_len), (*AstNode)ast_ident(value_name.ptr, value_name.len)));
        propagate_stmts.push((*AstNode)ast_assign((*AstNode)ast_ident(outer_flag_ptr, outer_flag_len), (*AstNode)ast_literal(1)));
        lowered_stmts.push((*AstNode)ast_if(post_throw_cond, (*AstNode)ast_block(propagate_stmts), 0));
    } else {
        var fail_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
        fail_stmts.push(parse_try_build_unhandled_throw_stmt());
        lowered_stmts.push((*AstNode)ast_if(post_throw_cond, (*AstNode)ast_block(fail_stmts), 0));
    }

    return (*AstNode)ast_block(lowered_stmts);
}

// ============================================
// Alias Statement
// ============================================

func parse_alias_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_ALIAS);

    var reg_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_COLON);

    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_SEMICOLON);

    return (*AstNode)ast_alias(reg_tok.ptr, reg_tok.len, name_tok.ptr, name_tok.len);
}

// ============================================
// Defer Statement
// ============================================

func parse_defer_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_DEFER);
    var stmt: *AstNode = parse_stmt(p);
    return (*AstNode)ast_defer(stmt);
}

// ============================================
// Debug Statements (assert/todo/unreachable)
// ============================================

func build_debug_fail_stmt(msg_ptr: u64, msg_len: u64, line: u64) -> *AstNode {
    var args: *Vec<*AstNode> = new Vec<*AstNode>(3);
    args.push((*AstNode)ast_string(msg_ptr, msg_len));
    args.push((*AstNode)ast_literal(msg_len));
    args.push((*AstNode)ast_literal(line));
    var call: *AstCall = ast_call("debug_fail", 10, args);
    return ast_expr_stmt((*AstNode)call);
}

func parse_assert_stmt(p: *Parser) -> *AstNode {
    var tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_ASSERT);
    parse_consume(p, TOKEN_LPAREN);
    var cond: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    parse_consume(p, TOKEN_SEMICOLON);

    var not_cond: *AstNode = (*AstNode)ast_unary(TOKEN_BANG, cond);
    var fail_stmt: *AstNode = build_debug_fail_stmt("assert failed", 13, tok.line);
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    stmts.push(fail_stmt);
    var blk: *AstNode = (*AstNode)ast_block(stmts);
    return (*AstNode)ast_if(not_cond, blk, 0);
}

func parse_todo_stmt(p: *Parser) -> *AstNode {
    var tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_TODO);
    parse_consume(p, TOKEN_SEMICOLON);
    return build_debug_fail_stmt("todo reached", 12, tok.line);
}

func parse_unreachable_stmt(p: *Parser) -> *AstNode {
    var tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_UNREACHABLE);
    parse_consume(p, TOKEN_SEMICOLON);
    return build_debug_fail_stmt("unreachable", 11, tok.line);
}

// ============================================
// Delete Statement
// ============================================

func parse_delete_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_DELETE);
    var expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_SEMICOLON);
    return (*AstNode)ast_delete(expr);
}

// ============================================
// ASM Block
// ============================================

func parse_asm_stmt(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_ASM);
    parse_consume(p, TOKEN_LBRACE);
    
    var asm_text: *Vec<u64> = new Vec<u64>(256);
    
    var prev_line: i64 = -1;
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) {
            emit_stderr("[ERROR] Unexpected EOF in asm block\n");
            parse_panic_here(p, "Syntax error");
        }
        
        var tok: *Token = parse_peek(p);
        var cur_line: i64 = (i64)tok.line;
        
        if (prev_line >= 0) {
            if (cur_line > prev_line) {
                asm_text.push(10);
            } else {
                asm_text.push(32);
            }
        }
        prev_line = cur_line;
        
        var ptr: u64 = tok.ptr;
        var len: u64 = tok.len;
        var ptr_u8: *u8 = (*u8)ptr;

        for (var i: u64 = 0; i < len; i++) {
            asm_text.push(ptr_u8[i]);
        }
        parse_adv(p);
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return ast_asm(asm_text);
}

// ============================================
// Block and Generic Statement
// ============================================

func parse_stmt_is_lambda_closure_decl(stmt: *AstNode) -> u64 {
    if (stmt == 0) { return 0; }
    if (ast_kind(stmt) != AST_VAR_DECL) { return 0; }
    var decl: *AstVarDecl = (*AstVarDecl)stmt;
    if (decl.init_expr == 0) { return 0; }
    if (ast_kind(decl.init_expr) != AST_CALL) { return 0; }
    var call: *AstCall = (*AstCall)decl.init_expr;
    if (call.name_ptr == 0 || call.name_len < 14) { return 0; }
    if (str_eq(call.name_ptr, 14, "__lambda_bind_", 14) == 0) { return 0; }
    return 1;
}

func parse_block_try_append_owned_cleanup(stmts: *Vec<*AstNode>, stmt: *AstNode) -> u64 {
    if (stmts == 0 || parse_stmt_is_lambda_closure_decl(stmt) == 0) { return 0; }
    var decl: *AstVarDecl = (*AstVarDecl)stmt;
    var delete_expr: *AstNode = (*AstNode)ast_ident(decl.name_ptr, decl.name_len);
    var delete_stmt: *AstNode = (*AstNode)ast_delete(delete_expr);
    stmts.push((*AstNode)ast_defer(delete_stmt));
    return 0;
}

func parse_block(p: *Parser) -> *AstNode {
    push_trace("parse_block", "parser/stmt.b", __LINE__);
    defer pop_trace();
    
    parse_consume(p, TOKEN_LBRACE);
    
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(16);
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        var stmt: *AstNode = parse_stmt(p);
        stmts.push(stmt);
        parse_block_try_append_owned_cleanup(stmts, stmt);
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return ast_block(stmts);
}

func parse_stmt(p: *Parser) -> *AstNode {
    push_trace("parse_stmt", "parser/stmt.b", __LINE__);
    defer pop_trace();
    var k: u64 = parse_peek_kind(p);
    switch (k) {
        case TOKEN_PLUSPLUS:
        case TOKEN_MINUSMINUS:
            var stmt: *AstNode = parse_prefix_incdec_assign(p);
            parse_consume(p, TOKEN_SEMICOLON);
            return stmt;
        case TOKEN_VAR:
            return parse_var_decl(p);
        case TOKEN_AT:
            var next_k: u64 = parse_peek_kind_after_annotations(p);
            if (next_k == TOKEN_VAR) {
                return parse_var_decl(p);
            }
            emit_stderr("[ERROR] statement annotation target must be variable declaration\n");
            parse_panic_here(p, "Syntax error");
            return parse_assign_or_expr(p);
        case TOKEN_IF:
            return parse_if_stmt(p);
        case TOKEN_WHILE:
            return parse_while_stmt(p);
        case TOKEN_FOR:
            return parse_for_stmt(p);
        case TOKEN_SWITCH:
        case TOKEN_MATCH:
            return parse_switch_stmt(p);
        case TOKEN_BREAK:
            return parse_break_stmt(p);
        case TOKEN_CONTINUE:
            return parse_continue_stmt(p);
        case TOKEN_ASM:
            return parse_asm_stmt(p);
        case TOKEN_ALIAS:
            return parse_alias_stmt(p);
        case TOKEN_DEFER:
            return parse_defer_stmt(p);
        case TOKEN_DELETE:
            return parse_delete_stmt(p);
        case TOKEN_TRY:
            return parse_try_stmt(p);
        case TOKEN_THROW:
            return parse_throw_stmt(p);
        case TOKEN_ASSERT:
            return parse_assert_stmt(p);
        case TOKEN_TODO:
            return parse_todo_stmt(p);
        case TOKEN_UNREACHABLE:
            return parse_unreachable_stmt(p);
        case TOKEN_RETURN:
            return parse_return_stmt(p);
        default:
            return parse_assign_or_expr(p);
    }
}
