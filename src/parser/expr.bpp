// parse_expr.b - Expression parsing
//
// Pratt parser style with precedence climbing:
// - Primary expressions (literals, identifiers, calls)
// - Postfix expressions (array access, member access)
// - Unary expressions (*, -, !)
// - Binary expressions (arithmetic, comparison, logical)

import std.io;
import std.vec;
import std.util;
import std.str;
import module_utils;
import types;
import lexer;
import ast;
import compiler;
import parser.util;
import parser.type;

// ============================================
// Primary Expression
// ============================================

struct ParseCallArgs {
    public args: *Vec<*AstNode>;
    public arg_names: *Vec<*NameInfo>;
}

func parse_call_named_arg_peek(p: *Parser) -> *Token {
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) { return 0; }
    var saved_pos: u64 = parser_pos(p);
    var name_tok: *Token = parse_peek(p);
    parse_adv(p);
    var is_named: u64 = 0;
    if (parse_peek_kind(p) == TOKEN_COLON) {
        is_named = 1;
    }
    parser_set_pos(p, saved_pos);
    if (is_named == 0) { return 0; }
    return name_tok;
}

func parse_call_args_paren(p: *Parser, allow_named: u64) -> *ParseCallArgs {
    parse_consume(p, TOKEN_LPAREN);

    var args: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var arg_names: *Vec<*NameInfo> = 0;
    var seen_named: u64 = 0;

    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        while (1) {
            var arg_name: *NameInfo = 0;
            var named_tok: *Token = parse_call_named_arg_peek(p);
            if (named_tok != 0) {
                if (allow_named == 0) {
                    emit_stderr("[ERROR] named arguments are not allowed for this call target\n");
                    parse_panic_here(p, "Syntax error");
                }
                parse_consume(p, TOKEN_IDENTIFIER);
                parse_consume(p, TOKEN_COLON);
                arg_name = new NameInfo{named_tok.ptr, named_tok.len};
                seen_named = 1;
            } else if (seen_named != 0) {
                emit_stderr("[ERROR] positional argument cannot follow named arguments\n");
                parse_panic_here(p, "Syntax error");
            }

            args.push(parse_expr(p));
            if (arg_names != 0) {
                arg_names.push(arg_name);
            } else if (arg_name != 0) {
                arg_names = new Vec<*NameInfo>(args.len());
                for (var ai: u64 = 0; ai + 1 < args.len(); ai++) {
                    arg_names.push(0);
                }
                arg_names.push(arg_name);
            }

            if (parse_match(p, TOKEN_COMMA) == 0) { break; }
        }
    }

    parse_consume(p, TOKEN_RPAREN);
    var out: *ParseCallArgs = new ParseCallArgs();
    out.args = args;
    out.arg_names = arg_names;
    return out;
}

func parse_expr_list_paren(p: *Parser) -> *Vec<*AstNode> {
    parse_consume(p, TOKEN_LPAREN);
    var args: *Vec<*AstNode> = new Vec<*AstNode>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        args.push(parse_expr(p));
        while (parse_match(p, TOKEN_COMMA)) {
            args.push(parse_expr(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);
    return args;
}

func parse_expr_list_brace(p: *Parser) -> *Vec<*AstNode> {
    parse_consume(p, TOKEN_LBRACE);
    var values: *Vec<*AstNode> = new Vec<*AstNode>(8);
    if (parse_peek_kind(p) != TOKEN_RBRACE) {
        values.push(parse_expr(p));
        while (parse_match(p, TOKEN_COMMA)) {
            values.push(parse_expr(p));
        }
    }
    parse_consume(p, TOKEN_RBRACE);
    return values;
}

func parse_lambda_param_set_default(param: *Param) -> u64 {
    param.type_kind = TYPE_U64;
    param.ptr_depth = 0;
    param.is_tagged = 0;
    param.struct_name_ptr = 0;
    param.struct_name_len = 0;
    param.tag_layout_ptr = 0;
    param.tag_layout_len = 0;
    param.elem_type_kind = 0;
    param.elem_ptr_depth = 0;
    param.array_len = 0;
    param.array_len_is_param = 0;
    param.array_len_param_ptr = 0;
    param.array_len_param_len = 0;
    param.elem_typeinfo = 0;
    return 0;
}

func parse_lambda_param(p: *Parser) -> *Param {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    var param: *Param = new Param();
    param.name_ptr = name_tok.ptr;
    param.name_len = name_tok.len;

    if (parse_match(p, TOKEN_COLON)) {
        var ty: *TypeInfo = parse_type_ex(p);
        param.fill_from_typeinfo(ty);
        param.decay_array_to_ptr();
        return param;
    }

    parse_lambda_param_set_default(param);
    return param;
}

func parse_lambda_param_exists(params: *Vec<*Param>, name_ptr: u64, name_len: u64) -> u64 {
    if (params == 0) { return 0; }
    var n: u64 = params.len();
    for (var i: u64 = 0; i < n; i++) {
        var p2: *Param = params.get(i);
        if (str_eq(p2.name_ptr, p2.name_len, name_ptr, name_len) != 0) {
            return 1;
        }
    }
    return 0;
}

func parse_lambda_symbol_is_global(name_ptr: u64, name_len: u64) -> u64 {
    if (name_ptr != 0 && name_len >= 5) {
        var suffix_ptr: u64 = name_ptr + (name_len - 5);
        if (str_eq(suffix_ptr, 5, "_ctor", 5) != 0) { return 1; }
    }
    if (compiler_func_exists(name_ptr, name_len) != 0) { return 1; }
    if (compiler_global_exists(name_ptr, name_len) != 0) { return 1; }
    var cres: *ConstResult = (*ConstResult)compiler_find_const(name_ptr, name_len);
    if (cres != 0 && cres.found != 0) { return 1; }

    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        if (compiler_func_exists(resolved.ptr, resolved.len) != 0) { return 1; }
        if (compiler_global_exists(resolved.ptr, resolved.len) != 0) { return 1; }
        var cres2: *ConstResult = (*ConstResult)compiler_find_const(resolved.ptr, resolved.len);
        if (cres2 != 0 && cres2.found != 0) { return 1; }
    }
    return 0;
}

struct LambdaCapture {
    public name_ptr: u64;
    public name_len: u64;
    public slot_ptr: u64;
    public slot_len: u64;
    public mode: u64;
}

const LAMBDA_CAPTURE_BY_VALUE = 1;
const LAMBDA_CAPTURE_BY_REF = 2;

func parse_lambda_capture_find(captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64) -> *LambdaCapture {
    if (captures == 0) { return 0; }
    var n: u64 = captures.len();
    for (var i: u64 = 0; i < n; i++) {
        var c: *LambdaCapture = captures.get(i);
        if (str_eq(c.name_ptr, c.name_len, name_ptr, name_len) != 0) {
            return c;
        }
    }
    return 0;
}

func parse_lambda_parse_capture_list(p: *Parser, params: *Vec<*Param>, captures: *Vec<*LambdaCapture>) -> u64 {
    if (parse_match(p, TOKEN_LBRACKET) == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_RBRACKET) {
        while (1) {
            var mode: u64 = LAMBDA_CAPTURE_BY_VALUE;
            if (parse_match(p, TOKEN_AMPERSAND)) {
                mode = LAMBDA_CAPTURE_BY_REF;
            }
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] lambda capture entry must be identifier or '&identifier'\n");
                parse_panic_here(p, "Syntax error");
            }
            var cap_tok: *Token = parse_peek(p);
            parse_consume(p, TOKEN_IDENTIFIER);

            if (parse_lambda_param_exists(params, cap_tok.ptr, cap_tok.len) != 0) {
                emit_stderr("[ERROR] lambda capture cannot duplicate parameter name: ");
                emit_stderr_len(cap_tok.ptr, cap_tok.len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
            if (parse_lambda_symbol_is_global(cap_tok.ptr, cap_tok.len) != 0) {
                emit_stderr("[ERROR] lambda capture list cannot include global symbol: ");
                emit_stderr_len(cap_tok.ptr, cap_tok.len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
            if (mode == LAMBDA_CAPTURE_BY_REF) {
                if (parser_current_function_has_param_name(p, cap_tok.ptr, cap_tok.len) == 0) {
                    emit_stderr("[ERROR] by-ref capture requires enclosing function parameter (non-parameter locals are not allowed): ");
                    emit_stderr_len(cap_tok.ptr, cap_tok.len);
                    emit_stderr("\n");
                    parse_panic_here(p, "Syntax error");
                }
            }
            parse_lambda_capture_add_with_mode(captures, cap_tok.ptr, cap_tok.len, mode);
            if (parse_match(p, TOKEN_COMMA) == 0) { break; }
        }
    }
    parse_consume(p, TOKEN_RBRACKET);
    return 1;
}

func parse_lambda_capture_add_with_mode(captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64, mode: u64) -> u64 {
    if (captures == 0) { return 0; }
    var ex: *LambdaCapture = parse_lambda_capture_find(captures, name_ptr, name_len);
    if (ex != 0) {
        ex.mode = mode;
        return 0;
    }
    var c: *LambdaCapture = new LambdaCapture();
    c.name_ptr = name_ptr;
    c.name_len = name_len;
    c.slot_ptr = 0;
    c.slot_len = 0;
    if (mode == 0) { mode = LAMBDA_CAPTURE_BY_VALUE; }
    c.mode = mode;
    captures.push(c);
    return 0;
}

func parse_lambda_collect_capture_name(p: *Parser, params: *Vec<*Param>, captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64) -> u64 {
    if (parse_lambda_param_exists(params, name_ptr, name_len) != 0) { return 0; }
    if (parse_lambda_symbol_is_global(name_ptr, name_len) != 0) { return 0; }
    parse_lambda_capture_add_with_mode(captures, name_ptr, name_len, LAMBDA_CAPTURE_BY_VALUE);
    return 0;
}

func parse_lambda_collect_expr_captures(p: *Parser, node: *AstNode, params: *Vec<*Param>, captures: *Vec<*LambdaCapture>) -> u64 {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)node;
            return parse_lambda_collect_capture_name(p, params, captures, id.name_ptr, id.name_len);
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)node;
            parse_lambda_collect_expr_captures(p, bin.left, params, captures);
            parse_lambda_collect_expr_captures(p, bin.right, params, captures);
            return 0;
        case AST_UNARY:
            return parse_lambda_collect_expr_captures(p, ((*AstUnary)node).operand, params, captures);
        case AST_ADDR_OF:
            return parse_lambda_collect_expr_captures(p, ((*AstAddrOf)node).operand, params, captures);
        case AST_DEREF:
            return parse_lambda_collect_expr_captures(p, ((*AstDeref)node).operand, params, captures);
        case AST_DEREF8:
            return parse_lambda_collect_expr_captures(p, ((*AstDeref8)node).operand, params, captures);
        case AST_CAST:
            return parse_lambda_collect_expr_captures(p, ((*AstCast)node).expr, params, captures);
        case AST_TRY:
            return parse_lambda_collect_expr_captures(p, ((*AstTry)node).operand, params, captures);
        case AST_SIZEOF_EXPR:
            return parse_lambda_collect_expr_captures(p, ((*AstSizeofExpr)node).expr, params, captures);
        case AST_INDEX:
            var idx: *AstIndex = (*AstIndex)node;
            parse_lambda_collect_expr_captures(p, idx.base, params, captures);
            parse_lambda_collect_expr_captures(p, idx.index, params, captures);
            return 0;
        case AST_MEMBER_ACCESS:
        case AST_SAFE_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)node;
            if (ma.parent_ptr == 0 && ast_kind(ma.object) == AST_IDENT) {
                var sid: *AstIdent = (*AstIdent)ma.object;
                var scoped_const: *ConstResult = (*ConstResult)compiler_find_scoped_const(sid.name_ptr, sid.name_len, ma.member_ptr, ma.member_len);
                if (scoped_const != 0 && scoped_const.found != 0) {
                    return 0;
                }
            }
            return parse_lambda_collect_expr_captures(p, ma.object, params, captures);
        case AST_METHOD_CALL:
        case AST_SAFE_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)node;
            parse_lambda_collect_expr_captures(p, mc.receiver, params, captures);
            if (mc.args_vec != 0) {
                var an: u64 = mc.args_vec.len();
                for (var ai: u64 = 0; ai < an; ai++) {
                    parse_lambda_collect_expr_captures(p, mc.args_vec.get(ai), params, captures);
                }
            }
            return 0;
        case AST_CALL:
            var call: *AstCall = (*AstCall)node;
            parse_lambda_collect_capture_name(p, params, captures, call.name_ptr, call.name_len);
            if (call.args_vec != 0) {
                var cn: u64 = call.args_vec.len();
                for (var ci: u64 = 0; ci < cn; ci++) {
                    parse_lambda_collect_expr_captures(p, call.args_vec.get(ci), params, captures);
                }
            }
            return 0;
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)node;
            parse_lambda_collect_expr_captures(p, cp.callee, params, captures);
            if (cp.args_vec != 0) {
                var cpn: u64 = cp.args_vec.len();
                for (var cpi: u64 = 0; cpi < cpn; cpi++) {
                    parse_lambda_collect_expr_captures(p, cp.args_vec.get(cpi), params, captures);
                }
            }
            return 0;
        case AST_GENERIC_CALL:
            var gc: *AstGenericCall = (*AstGenericCall)node;
            if (parse_lambda_symbol_is_global(gc.name_ptr, gc.name_len) == 0) {
                emit_stderr("[ERROR] lambda generic call target must be global symbol: ");
                emit_stderr_len(gc.name_ptr, gc.name_len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
            if (gc.args_vec != 0) {
                var gcn: u64 = gc.args_vec.len();
                for (var gci: u64 = 0; gci < gcn; gci++) {
                    parse_lambda_collect_expr_captures(p, gc.args_vec.get(gci), params, captures);
                }
            }
            return 0;
        case AST_STATIC_GENERIC_CALL:
            var sgc: *AstStaticGenericCall = (*AstStaticGenericCall)node;
            if (parse_lambda_symbol_is_global(sgc.struct_name_ptr, sgc.struct_name_len) == 0) {
                emit_stderr("[ERROR] lambda static generic call target must be global symbol: ");
                emit_stderr_len(sgc.struct_name_ptr, sgc.struct_name_len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
            if (sgc.args_vec != 0) {
                var sgn: u64 = sgc.args_vec.len();
                for (var sgi: u64 = 0; sgi < sgn; sgi++) {
                    parse_lambda_collect_expr_captures(p, sgc.args_vec.get(sgi), params, captures);
                }
            }
            return 0;
        case AST_STRUCT_LITERAL:
            var sl: *AstStructLiteral = (*AstStructLiteral)node;
            if (sl.values_vec != 0) {
                var sn: u64 = sl.values_vec.len();
                for (var si: u64 = 0; si < sn; si++) {
                    parse_lambda_collect_expr_captures(p, sl.values_vec.get(si), params, captures);
                }
            }
            return 0;
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)node;
            if (gsl.values_vec != 0) {
                var gsn: u64 = gsl.values_vec.len();
                for (var gsi: u64 = 0; gsi < gsn; gsi++) {
                    parse_lambda_collect_expr_captures(p, gsl.values_vec.get(gsi), params, captures);
                }
            }
            return 0;
        case AST_SLICE:
            var slice_node: *AstSlice = (*AstSlice)node;
            parse_lambda_collect_expr_captures(p, slice_node.ptr_expr, params, captures);
            parse_lambda_collect_expr_captures(p, slice_node.len_expr, params, captures);
            return 0;
        case AST_NEW:
            var nw: *AstNew = (*AstNew)node;
            if (nw.literal_expr != 0) {
                parse_lambda_collect_expr_captures(p, nw.literal_expr, params, captures);
            }
            if (nw.ctor_args_vec != 0) {
                var nn: u64 = nw.ctor_args_vec.len();
                for (var ni: u64 = 0; ni < nn; ni++) {
                    parse_lambda_collect_expr_captures(p, nw.ctor_args_vec.get(ni), params, captures);
                }
            }
            return 0;
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)node;
            if (sc.ctor_args_vec != 0) {
                var sn2: u64 = sc.ctor_args_vec.len();
                for (var si2: u64 = 0; si2 < sn2; si2++) {
                    parse_lambda_collect_expr_captures(p, sc.ctor_args_vec.get(si2), params, captures);
                }
            }
            return 0;
    }
    return 0;
}

func parse_lambda_build_name_with_prefix(prefix_ptr: u64, prefix_len: u64, lambda_id: u64) -> *NameInfo {
    var id_buf: u64 = heap_alloc(32 * sizeof(u8));
    var id_len: u64 = io_u64_to_ascii(id_buf, lambda_id);
    var total_len: u64 = prefix_len + id_len;
    var name_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var name_u8: []u8 = slice(name_ptr, total_len + 1);
    str_copy(name_ptr, prefix_ptr, prefix_len);
    str_copy(name_ptr + prefix_len, id_buf, id_len);
    name_u8[total_len] = 0;
    return new NameInfo{name_ptr, total_len};
}

func parse_lambda_build_capture_slot_name(lambda_id: u64, capture_idx: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__lambda_cap_";
    var prefix_len: u64 = 13;
    var id_buf: u64 = heap_alloc(32 * sizeof(u8));
    var id_len: u64 = io_u64_to_ascii(id_buf, lambda_id);
    var idx_buf: u64 = heap_alloc(32 * sizeof(u8));
    var idx_len: u64 = io_u64_to_ascii(idx_buf, capture_idx);
    var total_len: u64 = prefix_len + id_len + 1 + idx_len;
    var out_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, total_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, id_buf, id_len);
    out_u8[prefix_len + id_len] = 95;
    str_copy(out_ptr + prefix_len + id_len + 1, idx_buf, idx_len);
    out_u8[total_len] = 0;
    return new NameInfo{out_ptr, total_len};
}

func parse_lambda_build_bind_param_name(capture_idx: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__cap_";
    var prefix_len: u64 = 6;
    var idx_buf: u64 = heap_alloc(32 * sizeof(u8));
    var idx_len: u64 = io_u64_to_ascii(idx_buf, capture_idx);
    var total_len: u64 = prefix_len + idx_len;
    var out_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, total_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, idx_buf, idx_len);
    out_u8[total_len] = 0;
    return new NameInfo{out_ptr, total_len};
}

func parse_lambda_param_copy_type(dst: *Param, src: *Param) -> u64 {
    if (dst == 0 || src == 0) { return 0; }
    dst.type_kind = src.type_kind;
    dst.ptr_depth = src.ptr_depth;
    dst.is_tagged = src.is_tagged;
    dst.struct_name_ptr = src.struct_name_ptr;
    dst.struct_name_len = src.struct_name_len;
    dst.tag_layout_ptr = src.tag_layout_ptr;
    dst.tag_layout_len = src.tag_layout_len;
    dst.elem_type_kind = src.elem_type_kind;
    dst.elem_ptr_depth = src.elem_ptr_depth;
    dst.array_len = src.array_len;
    dst.array_len_is_param = src.array_len_is_param;
    dst.array_len_param_ptr = src.array_len_param_ptr;
    dst.array_len_param_len = src.array_len_param_len;
    dst.elem_typeinfo = src.elem_typeinfo;
    dst.is_variadic = 0;
    dst.has_default = 0;
    dst.default_expr = 0;
    return 0;
}

func parse_lambda_make_capture_param(p: *Parser, capture: *LambdaCapture, name_ptr: u64, name_len: u64) -> *Param {
    var out: *Param = new Param();
    out.name_ptr = name_ptr;
    out.name_len = name_len;
    var src_param: *Param = 0;
    if (capture != 0) {
        src_param = parser_current_function_find_param(p, capture.name_ptr, capture.name_len);
    }
    if (src_param != 0) {
        parse_lambda_param_copy_type(out, src_param);
    } else {
        parse_lambda_param_set_default(out);
    }
    if (capture != 0 && capture.mode == LAMBDA_CAPTURE_BY_REF) {
        out.ptr_depth = out.ptr_depth + 1;
    }
    out.is_variadic = 0;
    out.has_default = 0;
    out.default_expr = 0;
    return out;
}

func parse_lambda_make_field_from_param(owner_ptr: u64, owner_len: u64, param: *Param) -> *FieldDesc {
    if (param == 0) { return 0; }
    var f: *FieldDesc = new FieldDesc();
    f.name_ptr = param.name_ptr;
    f.name_len = param.name_len;
    f.type_kind = param.type_kind;
    f.ptr_depth = param.ptr_depth;
    f.is_tagged = param.is_tagged;
    f.struct_name_ptr = param.struct_name_ptr;
    f.struct_name_len = param.struct_name_len;
    f.tag_layout_ptr = param.tag_layout_ptr;
    f.tag_layout_len = param.tag_layout_len;
    f.bit_width = 0;
    f.elem_type_kind = param.elem_type_kind;
    f.elem_ptr_depth = param.elem_ptr_depth;
    f.array_len = param.array_len;
    f.elem_typeinfo = param.elem_typeinfo;
    f.access = ACCESS_PUBLIC;
    f.owner_struct_ptr = owner_ptr;
    f.owner_struct_len = owner_len;
    return f;
}

func parse_lambda_build_env_struct_name(lambda_id: u64) -> *NameInfo {
    return parse_lambda_build_name_with_prefix("__lambda_env_", 13, lambda_id);
}

func parse_lambda_set_capture_field_names(captures: *Vec<*LambdaCapture>) -> u64 {
    if (captures == 0) { return 0; }
    var n: u64 = captures.len();
    for (var i: u64 = 0; i < n; i++) {
        var c: *LambdaCapture = captures.get(i);
        var field_name: *NameInfo = parse_lambda_build_bind_param_name(i);
        c.slot_ptr = field_name.ptr;
        c.slot_len = field_name.len;
    }
    return 0;
}

func parse_lambda_build_env_struct(p: *Parser, captures: *Vec<*LambdaCapture>, lambda_id: u64) -> *AstStructDef {
    if (captures == 0) { return 0; }
    var env_name: *NameInfo = parse_lambda_build_env_struct_name(lambda_id);
    var fields: *Vec<*FieldDesc> = new Vec<*FieldDesc>(captures.len());
    var n: u64 = captures.len();
    for (var i: u64 = 0; i < n; i++) {
        var c: *LambdaCapture = captures.get(i);
        var field_param: *Param = parse_lambda_make_capture_param(p, c, c.slot_ptr, c.slot_len);
        fields.push(parse_lambda_make_field_from_param(env_name.ptr, env_name.len, field_param));
    }
    var env_struct: *AstStructDef = ast_struct_def(env_name.ptr, env_name.len, 0, fields, 0, 0, 0);
    register_struct_type(env_struct);
    return env_struct;
}

func parse_lambda_build_param_typeinfo(src: *Param) -> *TypeInfo {
    if (src == 0) { return 0; }
    var ti: *TypeInfo = new TypeInfo(src.type_kind, src.ptr_depth);
    ti.is_tagged = src.is_tagged;
    ti.struct_name_ptr = src.struct_name_ptr;
    ti.struct_name_len = src.struct_name_len;
    ti.tag_layout_ptr = src.tag_layout_ptr;
    ti.tag_layout_len = src.tag_layout_len;
    ti.elem_type_kind = src.elem_type_kind;
    ti.elem_ptr_depth = src.elem_ptr_depth;
    ti.array_len = src.array_len;
    ti.array_len_is_param = src.array_len_is_param;
    ti.array_len_param_ptr = src.array_len_param_ptr;
    ti.array_len_param_len = src.array_len_param_len;
    ti.elem_typeinfo = src.elem_typeinfo;
    return ti;
}

func parse_lambda_build_func_sig_typeinfo(fn: *AstFunc) -> *TypeInfo {
    if (fn == 0) { return 0; }
    var sig: *TypeInfo = new TypeInfo(TYPE_FUNC, 0);
    var params_sig: *Vec<*TypeInfo> = new Vec<*TypeInfo>(4);
    var variadic: u64 = 0;
    if (fn.params_vec != 0) {
        var n: u64 = fn.params_vec.len();
        for (var i: u64 = 0; i < n; i++) {
            var p: *Param = fn.params_vec.get(i);
            params_sig.push(parse_lambda_build_param_typeinfo(p));
            if (p != 0 && p.is_variadic != 0) { variadic = 1; }
        }
    }
    var ret_ti: *TypeInfo = new TypeInfo(fn.ret_type, fn.ret_ptr_depth);
    ret_ti.is_tagged = fn.ret_is_tagged;
    ret_ti.struct_name_ptr = fn.ret_struct_name_ptr;
    ret_ti.struct_name_len = fn.ret_struct_name_len;
    ret_ti.tag_layout_ptr = fn.ret_tag_layout_ptr;
    ret_ti.tag_layout_len = fn.ret_tag_layout_len;
    sig.fn_params_vec = params_sig;
    sig.fn_ret_typeinfo = ret_ti;
    sig.fn_is_variadic = variadic;
    return sig;
}

func parse_lambda_build_runtime_closure_struct(lambda_id: u64, lambda_fn: *AstFunc, env_struct: *AstStructDef) -> *AstStructDef {
    if (lambda_fn == 0 || env_struct == 0) { return 0; }
    var closure_name: *NameInfo = parse_lambda_build_name_with_prefix("__LambdaClosureObj_", 19, lambda_id);
    var existing: *AstStructDef = get_struct_def(closure_name.ptr, closure_name.len);
    if (existing != 0) { return existing; }

    var fields: *Vec<*FieldDesc> = new Vec<*FieldDesc>(2);

    var fn_field: *FieldDesc = new FieldDesc();
    fn_field.name_ptr = (u64)"fn";
    fn_field.name_len = 2;
    fn_field.type_kind = TYPE_FUNC;
    fn_field.ptr_depth = 1;
    fn_field.is_tagged = 0;
    fn_field.struct_name_ptr = 0;
    fn_field.struct_name_len = 0;
    fn_field.tag_layout_ptr = 0;
    fn_field.tag_layout_len = 0;
    fn_field.bit_width = 0;
    fn_field.offset = 0;
    fn_field.elem_type_kind = 0;
    fn_field.elem_ptr_depth = 0;
    fn_field.array_len = 0;
    fn_field.elem_typeinfo = parse_lambda_build_func_sig_typeinfo(lambda_fn);
    fn_field.access = ACCESS_PUBLIC;
    fn_field.owner_struct_ptr = closure_name.ptr;
    fn_field.owner_struct_len = closure_name.len;
    fields.push(fn_field);

    var env_field: *FieldDesc = new FieldDesc();
    env_field.name_ptr = (u64)"env";
    env_field.name_len = 3;
    env_field.type_kind = TYPE_STRUCT;
    env_field.ptr_depth = 1;
    env_field.is_tagged = 0;
    env_field.struct_name_ptr = env_struct.name_ptr;
    env_field.struct_name_len = env_struct.name_len;
    env_field.tag_layout_ptr = 0;
    env_field.tag_layout_len = 0;
    env_field.bit_width = 0;
    env_field.offset = 0;
    env_field.elem_type_kind = 0;
    env_field.elem_ptr_depth = 0;
    env_field.array_len = 0;
    env_field.elem_typeinfo = 0;
    env_field.access = ACCESS_PUBLIC;
    env_field.owner_struct_ptr = closure_name.ptr;
    env_field.owner_struct_len = closure_name.len;
    fields.push(env_field);

    var closure_struct: *AstStructDef = ast_struct_def(closure_name.ptr, closure_name.len, 0, fields, 0, 0, 0);
    register_struct_type(closure_struct);
    return closure_struct;
}

func parse_lambda_make_env_param(env_struct: *AstStructDef) -> *Param {
    var p: *Param = new Param();
    p.name_ptr = "__env";
    p.name_len = 5;
    p.type_kind = TYPE_STRUCT;
    p.ptr_depth = 1;
    p.is_tagged = 0;
    p.struct_name_ptr = env_struct.name_ptr;
    p.struct_name_len = env_struct.name_len;
    p.tag_layout_ptr = 0;
    p.tag_layout_len = 0;
    p.elem_type_kind = 0;
    p.elem_ptr_depth = 0;
    p.array_len = 0;
    p.array_len_is_param = 0;
    p.array_len_param_ptr = 0;
    p.array_len_param_len = 0;
    p.elem_typeinfo = 0;
    return p;
}

func parse_lambda_capture_field_expr(env_param_ptr: u64, env_param_len: u64, capture: *LambdaCapture) -> *AstNode {
    var env_deref: *AstNode = (*AstNode)ast_deref((*AstNode)ast_ident(env_param_ptr, env_param_len));
    return (*AstNode)ast_member_access(env_deref, capture.slot_ptr, capture.slot_len);
}

func parse_lambda_rewrite_expr_captures_env(p: *Parser, node: *AstNode, captures: *Vec<*LambdaCapture>, env_param_ptr: u64, env_param_len: u64) -> *AstNode {
    if (node == 0 || captures == 0 || captures.len() == 0) { return node; }
    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)node;
            var slot: *LambdaCapture = parse_lambda_capture_slot_for_name(captures, id.name_ptr, id.name_len);
            if (slot == 0) { return node; }
            var field_expr: *AstNode = parse_lambda_capture_field_expr(env_param_ptr, env_param_len, slot);
            if (slot.mode == LAMBDA_CAPTURE_BY_REF) {
                return (*AstNode)ast_deref(field_expr);
            }
            return field_expr;
        case AST_CALL:
            var call: *AstCall = (*AstCall)node;
            var slot2: *LambdaCapture = parse_lambda_capture_slot_for_name(captures, call.name_ptr, call.name_len);
            if (call.args_vec != 0) {
                var cn: u64 = call.args_vec.len();
                for (var ci: u64 = 0; ci < cn; ci++) {
                    call.args_vec.set(ci, parse_lambda_rewrite_expr_captures_env(p, call.args_vec.get(ci), captures, env_param_ptr, env_param_len));
                }
            }
            if (slot2 == 0) { return node; }
            if (slot2.mode == LAMBDA_CAPTURE_BY_REF) {
                emit_stderr("[ERROR] by-ref captured symbol cannot be used as direct call target in lambda\n");
                parse_panic_here(p, "Syntax error");
            }
            return (*AstNode)ast_call_ptr(parse_lambda_capture_field_expr(env_param_ptr, env_param_len, slot2), call.args_vec);
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)node;
            bin.left = parse_lambda_rewrite_expr_captures_env(p, bin.left, captures, env_param_ptr, env_param_len);
            bin.right = parse_lambda_rewrite_expr_captures_env(p, bin.right, captures, env_param_ptr, env_param_len);
            return node;
        case AST_UNARY:
            var un: *AstUnary = (*AstUnary)node;
            un.operand = parse_lambda_rewrite_expr_captures_env(p, un.operand, captures, env_param_ptr, env_param_len);
            return node;
        case AST_ADDR_OF:
            var ao: *AstAddrOf = (*AstAddrOf)node;
            ao.operand = parse_lambda_rewrite_expr_captures_env(p, ao.operand, captures, env_param_ptr, env_param_len);
            return node;
        case AST_DEREF:
            var dr: *AstDeref = (*AstDeref)node;
            dr.operand = parse_lambda_rewrite_expr_captures_env(p, dr.operand, captures, env_param_ptr, env_param_len);
            return node;
        case AST_DEREF8:
            var dr8: *AstDeref8 = (*AstDeref8)node;
            dr8.operand = parse_lambda_rewrite_expr_captures_env(p, dr8.operand, captures, env_param_ptr, env_param_len);
            return node;
        case AST_CAST:
            var cs: *AstCast = (*AstCast)node;
            cs.expr = parse_lambda_rewrite_expr_captures_env(p, cs.expr, captures, env_param_ptr, env_param_len);
            return node;
        case AST_TRY:
            var tr: *AstTry = (*AstTry)node;
            tr.operand = parse_lambda_rewrite_expr_captures_env(p, tr.operand, captures, env_param_ptr, env_param_len);
            return node;
        case AST_SIZEOF_EXPR:
            var se: *AstSizeofExpr = (*AstSizeofExpr)node;
            se.expr = parse_lambda_rewrite_expr_captures_env(p, se.expr, captures, env_param_ptr, env_param_len);
            return node;
        case AST_INDEX:
            var idx: *AstIndex = (*AstIndex)node;
            idx.base = parse_lambda_rewrite_expr_captures_env(p, idx.base, captures, env_param_ptr, env_param_len);
            idx.index = parse_lambda_rewrite_expr_captures_env(p, idx.index, captures, env_param_ptr, env_param_len);
            return node;
        case AST_MEMBER_ACCESS:
        case AST_SAFE_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)node;
            ma.object = parse_lambda_rewrite_expr_captures_env(p, ma.object, captures, env_param_ptr, env_param_len);
            return node;
        case AST_METHOD_CALL:
        case AST_SAFE_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)node;
            mc.receiver = parse_lambda_rewrite_expr_captures_env(p, mc.receiver, captures, env_param_ptr, env_param_len);
            if (mc.args_vec != 0) {
                var an: u64 = mc.args_vec.len();
                for (var ai: u64 = 0; ai < an; ai++) {
                    mc.args_vec.set(ai, parse_lambda_rewrite_expr_captures_env(p, mc.args_vec.get(ai), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)node;
            cp.callee = parse_lambda_rewrite_expr_captures_env(p, cp.callee, captures, env_param_ptr, env_param_len);
            if (cp.args_vec != 0) {
                var cpn: u64 = cp.args_vec.len();
                for (var cpi: u64 = 0; cpi < cpn; cpi++) {
                    cp.args_vec.set(cpi, parse_lambda_rewrite_expr_captures_env(p, cp.args_vec.get(cpi), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
        case AST_GENERIC_CALL:
            var gc: *AstGenericCall = (*AstGenericCall)node;
            if (gc.args_vec != 0) {
                var gcn: u64 = gc.args_vec.len();
                for (var gci: u64 = 0; gci < gcn; gci++) {
                    gc.args_vec.set(gci, parse_lambda_rewrite_expr_captures_env(p, gc.args_vec.get(gci), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
        case AST_STATIC_GENERIC_CALL:
            var sgc: *AstStaticGenericCall = (*AstStaticGenericCall)node;
            if (sgc.args_vec != 0) {
                var sgn: u64 = sgc.args_vec.len();
                for (var sgi: u64 = 0; sgi < sgn; sgi++) {
                    sgc.args_vec.set(sgi, parse_lambda_rewrite_expr_captures_env(p, sgc.args_vec.get(sgi), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
        case AST_STRUCT_LITERAL:
            var sl: *AstStructLiteral = (*AstStructLiteral)node;
            if (sl.values_vec != 0) {
                var sn: u64 = sl.values_vec.len();
                for (var si: u64 = 0; si < sn; si++) {
                    sl.values_vec.set(si, parse_lambda_rewrite_expr_captures_env(p, sl.values_vec.get(si), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)node;
            if (gsl.values_vec != 0) {
                var gsn: u64 = gsl.values_vec.len();
                for (var gsi: u64 = 0; gsi < gsn; gsi++) {
                    gsl.values_vec.set(gsi, parse_lambda_rewrite_expr_captures_env(p, gsl.values_vec.get(gsi), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
        case AST_SLICE:
            var slice_node: *AstSlice = (*AstSlice)node;
            slice_node.ptr_expr = parse_lambda_rewrite_expr_captures_env(p, slice_node.ptr_expr, captures, env_param_ptr, env_param_len);
            slice_node.len_expr = parse_lambda_rewrite_expr_captures_env(p, slice_node.len_expr, captures, env_param_ptr, env_param_len);
            return node;
        case AST_NEW:
            var nw: *AstNew = (*AstNew)node;
            if (nw.literal_expr != 0) {
                nw.literal_expr = parse_lambda_rewrite_expr_captures_env(p, nw.literal_expr, captures, env_param_ptr, env_param_len);
            }
            if (nw.ctor_args_vec != 0) {
                var nn: u64 = nw.ctor_args_vec.len();
                for (var ni: u64 = 0; ni < nn; ni++) {
                    nw.ctor_args_vec.set(ni, parse_lambda_rewrite_expr_captures_env(p, nw.ctor_args_vec.get(ni), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)node;
            if (sc.ctor_args_vec != 0) {
                var sn2: u64 = sc.ctor_args_vec.len();
                for (var si2: u64 = 0; si2 < sn2; si2++) {
                    sc.ctor_args_vec.set(si2, parse_lambda_rewrite_expr_captures_env(p, sc.ctor_args_vec.get(si2), captures, env_param_ptr, env_param_len));
                }
            }
            return node;
    }
    return node;
}

func parse_lambda_emit_capture_globals(p: *Parser, captures: *Vec<*LambdaCapture>, lambda_id: u64) -> u64 {
    if (captures == 0) { return 0; }
    var n: u64 = captures.len();
    for (var i: u64 = 0; i < n; i++) {
        var c: *LambdaCapture = captures.get(i);
        var slot_name: *NameInfo = parse_lambda_build_capture_slot_name(lambda_id, i);
        c.slot_ptr = slot_name.ptr;
        c.slot_len = slot_name.len;

        var ginfo: *GlobalInfo = new GlobalInfo();
        ginfo.name_ptr = slot_name.ptr;
        ginfo.name_len = slot_name.len;
        ginfo.typeinfo_ptr = new TypeInfo(TYPE_U64, 0);
        ginfo.init_kind = GLOBAL_INIT_VALUE;
        ginfo.init_value = 0;
        ginfo.init_name_ptr = 0;
        ginfo.init_name_len = 0;
        ginfo.init_expr = 0;
        ginfo.annotations_vec = 0;
        parse_generated_globals_push(p, (u64)ginfo);
    }
    return 0;
}

func parse_lambda_capture_slot_for_name(captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64) -> *LambdaCapture {
    var c: *LambdaCapture = parse_lambda_capture_find(captures, name_ptr, name_len);
    if (c == 0 || c.slot_ptr == 0 || c.slot_len == 0) { return 0; }
    return c;
}

func parse_lambda_rewrite_expr_captures(p: *Parser, node: *AstNode, captures: *Vec<*LambdaCapture>) -> *AstNode {
    if (node == 0 || captures == 0 || captures.len() == 0) { return node; }
    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)node;
            var slot: *LambdaCapture = parse_lambda_capture_slot_for_name(captures, id.name_ptr, id.name_len);
            if (slot != 0) {
                if (slot.mode == LAMBDA_CAPTURE_BY_REF) {
                    return (*AstNode)ast_deref((*AstNode)ast_ident(slot.slot_ptr, slot.slot_len));
                }
                id.name_ptr = slot.slot_ptr;
                id.name_len = slot.slot_len;
            }
            return node;
        case AST_CALL:
            var call: *AstCall = (*AstCall)node;
            var slot2: *LambdaCapture = parse_lambda_capture_slot_for_name(captures, call.name_ptr, call.name_len);
            if (slot2 != 0) {
                if (slot2.mode == LAMBDA_CAPTURE_BY_REF) {
                    emit_stderr("[ERROR] by-ref captured symbol cannot be used as direct call target in lambda\n");
                    parse_panic_here(p, "Syntax error");
                }
                call.name_ptr = slot2.slot_ptr;
                call.name_len = slot2.slot_len;
            }
            if (call.args_vec != 0) {
                var cn: u64 = call.args_vec.len();
                for (var ci: u64 = 0; ci < cn; ci++) {
                    call.args_vec.set(ci, parse_lambda_rewrite_expr_captures(p, call.args_vec.get(ci), captures));
                }
            }
            return node;
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)node;
            bin.left = parse_lambda_rewrite_expr_captures(p, bin.left, captures);
            bin.right = parse_lambda_rewrite_expr_captures(p, bin.right, captures);
            return node;
        case AST_UNARY:
            var un: *AstUnary = (*AstUnary)node;
            un.operand = parse_lambda_rewrite_expr_captures(p, un.operand, captures);
            return node;
        case AST_ADDR_OF:
            var ao: *AstAddrOf = (*AstAddrOf)node;
            ao.operand = parse_lambda_rewrite_expr_captures(p, ao.operand, captures);
            return node;
        case AST_DEREF:
            var dr: *AstDeref = (*AstDeref)node;
            dr.operand = parse_lambda_rewrite_expr_captures(p, dr.operand, captures);
            return node;
        case AST_DEREF8:
            var dr8: *AstDeref8 = (*AstDeref8)node;
            dr8.operand = parse_lambda_rewrite_expr_captures(p, dr8.operand, captures);
            return node;
        case AST_CAST:
            var cs: *AstCast = (*AstCast)node;
            cs.expr = parse_lambda_rewrite_expr_captures(p, cs.expr, captures);
            return node;
        case AST_TRY:
            var tr: *AstTry = (*AstTry)node;
            tr.operand = parse_lambda_rewrite_expr_captures(p, tr.operand, captures);
            return node;
        case AST_SIZEOF_EXPR:
            var se: *AstSizeofExpr = (*AstSizeofExpr)node;
            se.expr = parse_lambda_rewrite_expr_captures(p, se.expr, captures);
            return node;
        case AST_INDEX:
            var idx: *AstIndex = (*AstIndex)node;
            idx.base = parse_lambda_rewrite_expr_captures(p, idx.base, captures);
            idx.index = parse_lambda_rewrite_expr_captures(p, idx.index, captures);
            return node;
        case AST_MEMBER_ACCESS:
        case AST_SAFE_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)node;
            ma.object = parse_lambda_rewrite_expr_captures(p, ma.object, captures);
            return node;
        case AST_METHOD_CALL:
        case AST_SAFE_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)node;
            mc.receiver = parse_lambda_rewrite_expr_captures(p, mc.receiver, captures);
            if (mc.args_vec != 0) {
                var an: u64 = mc.args_vec.len();
                for (var ai: u64 = 0; ai < an; ai++) {
                    mc.args_vec.set(ai, parse_lambda_rewrite_expr_captures(p, mc.args_vec.get(ai), captures));
                }
            }
            return node;
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)node;
            cp.callee = parse_lambda_rewrite_expr_captures(p, cp.callee, captures);
            if (cp.args_vec != 0) {
                var cpn: u64 = cp.args_vec.len();
                for (var cpi: u64 = 0; cpi < cpn; cpi++) {
                    cp.args_vec.set(cpi, parse_lambda_rewrite_expr_captures(p, cp.args_vec.get(cpi), captures));
                }
            }
            return node;
        case AST_GENERIC_CALL:
            var gc: *AstGenericCall = (*AstGenericCall)node;
            if (gc.args_vec != 0) {
                var gcn: u64 = gc.args_vec.len();
                for (var gci: u64 = 0; gci < gcn; gci++) {
                    gc.args_vec.set(gci, parse_lambda_rewrite_expr_captures(p, gc.args_vec.get(gci), captures));
                }
            }
            return node;
        case AST_STATIC_GENERIC_CALL:
            var sgc: *AstStaticGenericCall = (*AstStaticGenericCall)node;
            if (sgc.args_vec != 0) {
                var sgn: u64 = sgc.args_vec.len();
                for (var sgi: u64 = 0; sgi < sgn; sgi++) {
                    sgc.args_vec.set(sgi, parse_lambda_rewrite_expr_captures(p, sgc.args_vec.get(sgi), captures));
                }
            }
            return node;
        case AST_STRUCT_LITERAL:
            var sl: *AstStructLiteral = (*AstStructLiteral)node;
            if (sl.values_vec != 0) {
                var sn: u64 = sl.values_vec.len();
                for (var si: u64 = 0; si < sn; si++) {
                    sl.values_vec.set(si, parse_lambda_rewrite_expr_captures(p, sl.values_vec.get(si), captures));
                }
            }
            return node;
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)node;
            if (gsl.values_vec != 0) {
                var gsn: u64 = gsl.values_vec.len();
                for (var gsi: u64 = 0; gsi < gsn; gsi++) {
                    gsl.values_vec.set(gsi, parse_lambda_rewrite_expr_captures(p, gsl.values_vec.get(gsi), captures));
                }
            }
            return node;
        case AST_SLICE:
            var slice_node: *AstSlice = (*AstSlice)node;
            slice_node.ptr_expr = parse_lambda_rewrite_expr_captures(p, slice_node.ptr_expr, captures);
            slice_node.len_expr = parse_lambda_rewrite_expr_captures(p, slice_node.len_expr, captures);
            return node;
        case AST_NEW:
            var nw: *AstNew = (*AstNew)node;
            if (nw.literal_expr != 0) {
                nw.literal_expr = parse_lambda_rewrite_expr_captures(p, nw.literal_expr, captures);
            }
            if (nw.ctor_args_vec != 0) {
                var nn: u64 = nw.ctor_args_vec.len();
                for (var ni: u64 = 0; ni < nn; ni++) {
                    nw.ctor_args_vec.set(ni, parse_lambda_rewrite_expr_captures(p, nw.ctor_args_vec.get(ni), captures));
                }
            }
            return node;
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)node;
            if (sc.ctor_args_vec != 0) {
                var sn2: u64 = sc.ctor_args_vec.len();
                for (var si2: u64 = 0; si2 < sn2; si2++) {
                    sc.ctor_args_vec.set(si2, parse_lambda_rewrite_expr_captures(p, sc.ctor_args_vec.get(si2), captures));
                }
            }
            return node;
    }
    return node;
}

func parse_primary_lambda_expr(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_FUNC);
    var captures: *Vec<*LambdaCapture> = new Vec<*LambdaCapture>(4);
    var has_explicit_capture_list: u64 = parse_lambda_parse_capture_list(p, 0, captures);
    parse_consume(p, TOKEN_LPAREN);

    var params: *Vec<*Param> = new Vec<*Param>(4);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_lambda_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_lambda_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_I64;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;
    if (parse_match(p, TOKEN_ARROW)) {
        var ret_ti: *TypeInfo = parse_type_ex(p);
        ret_type = ret_ti.type_kind;
        ret_ptr_depth = ret_ti.ptr_depth;
        ret_is_tagged = ret_ti.is_tagged;
        ret_struct_name_ptr = ret_ti.struct_name_ptr;
        ret_struct_name_len = ret_ti.struct_name_len;
        ret_tag_layout_ptr = ret_ti.tag_layout_ptr;
        ret_tag_layout_len = ret_ti.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ret_ti.elem_type_kind;
            ret_ptr_depth = ret_ti.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ret_ti.struct_name_ptr;
            ret_struct_name_len = ret_ti.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    parse_consume(p, TOKEN_LBRACE);
    if (parse_peek_kind(p) == TOKEN_RBRACE) {
        emit_stderr("[ERROR] lambda body expression is required\n");
        parse_panic_here(p, "Syntax error");
    }
    var body_expr: *AstNode = parse_expr(p);
    parse_match(p, TOKEN_SEMICOLON);
    parse_consume(p, TOKEN_RBRACE);

    var lambda_id: u64 = parse_next_generated_id(p);
    var lambda_body_name: *NameInfo = parse_lambda_build_name_with_prefix("__lambda_body_", 14, lambda_id);

    if (has_explicit_capture_list != 0) {
        var cap_n0: u64 = captures.len();
        for (var ci0: u64 = 0; ci0 < cap_n0; ci0++) {
            var cap0: *LambdaCapture = captures.get(ci0);
            if (parse_lambda_param_exists(params, cap0.name_ptr, cap0.name_len) != 0) {
                emit_stderr("[ERROR] lambda capture cannot duplicate parameter name: ");
                emit_stderr_len(cap0.name_ptr, cap0.name_len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
        }
    } else {
        parse_lambda_collect_expr_captures(p, body_expr, params, captures);
    }

    var lambda_params: *Vec<*Param> = params;
    var has_captures: u64 = 0;
    var env_struct: *AstStructDef = 0;
    if (captures != 0 && captures.len() != 0) {
        has_captures = 1;
        parse_lambda_set_capture_field_names(captures);
        env_struct = parse_lambda_build_env_struct(p, captures, lambda_id);
        body_expr = parse_lambda_rewrite_expr_captures_env(p, body_expr, captures, "__env", 5);

        lambda_params = new Vec<*Param>(params.len() + 1);
        lambda_params.push(parse_lambda_make_env_param(env_struct));
        var pn: u64 = params.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            lambda_params.push(params.get(pi));
        }
    }

    var body_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    body_stmts.push((*AstNode)ast_return(body_expr));
    var body: *AstNode = (*AstNode)ast_block(body_stmts);

    var lambda_fn: *AstFunc = ast_func_ex(lambda_body_name.ptr, lambda_body_name.len, lambda_params,
                                          ret_type, ret_ptr_depth, ret_is_tagged,
                                          ret_struct_name_ptr, ret_struct_name_len,
                                          ret_tag_layout_ptr, ret_tag_layout_len, body);
    parse_generated_funcs_push(p, (u64)lambda_fn);

    if (has_captures == 0) {
        var fn_ident: *AstNode = (*AstNode)ast_ident(lambda_body_name.ptr, lambda_body_name.len);
        return (*AstNode)ast_addr_of(fn_ident);
    }

    var closure_struct: *AstStructDef = parse_lambda_build_runtime_closure_struct(lambda_id, lambda_fn, env_struct);
    var bind_name: *NameInfo = parse_lambda_build_name_with_prefix("__lambda_bind_", 14, lambda_id);
    var bind_params: *Vec<*Param> = new Vec<*Param>(captures.len());
    var bind_body_stmts: *Vec<*AstNode> = new Vec<*AstNode>(captures.len() + 8);
    var bind_call_args: *Vec<*AstNode> = new Vec<*AstNode>(captures.len());

    var env_alloc: *AstNode = (*AstNode)ast_new(TYPE_STRUCT, 0, 0, env_struct.name_ptr, env_struct.name_len,
                                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    var env_decl: *AstVarDecl = ast_var_decl("__env_obj", 9, TYPE_STRUCT, 1, env_alloc);
    env_decl.struct_name_ptr = env_struct.name_ptr;
    env_decl.struct_name_len = env_struct.name_len;
    bind_body_stmts.push((*AstNode)env_decl);

    var cap_n: u64 = captures.len();
    for (var ci: u64 = 0; ci < cap_n; ci++) {
        var cap: *LambdaCapture = captures.get(ci);
        var bind_param_name: *NameInfo = parse_lambda_build_bind_param_name(ci);
        bind_params.push(parse_lambda_make_capture_param(p, cap, bind_param_name.ptr, bind_param_name.len));

        var env_target: *AstNode = (*AstNode)ast_member_access((*AstNode)ast_deref((*AstNode)ast_ident("__env_obj", 9)), cap.slot_ptr, cap.slot_len);
        bind_body_stmts.push((*AstNode)ast_assign(
            env_target,
            (*AstNode)ast_ident(bind_param_name.ptr, bind_param_name.len)
        ));
        if (cap.mode == LAMBDA_CAPTURE_BY_REF) {
            bind_call_args.push((*AstNode)ast_addr_of((*AstNode)ast_ident(cap.name_ptr, cap.name_len)));
        } else {
            bind_call_args.push((*AstNode)ast_ident(cap.name_ptr, cap.name_len));
        }
    }

    var closure_alloc: *AstNode = (*AstNode)ast_new(TYPE_STRUCT, 0, 0, closure_struct.name_ptr, closure_struct.name_len,
                                                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    var closure_decl: *AstVarDecl = ast_var_decl("__clo_obj", 9, TYPE_STRUCT, 1, closure_alloc);
    closure_decl.struct_name_ptr = closure_struct.name_ptr;
    closure_decl.struct_name_len = closure_struct.name_len;
    bind_body_stmts.push((*AstNode)closure_decl);

    bind_body_stmts.push((*AstNode)ast_assign(
        (*AstNode)ast_member_access((*AstNode)ast_deref((*AstNode)ast_ident("__clo_obj", 9)), "fn", 2),
        (*AstNode)ast_addr_of((*AstNode)ast_ident(lambda_body_name.ptr, lambda_body_name.len))
    ));

    bind_body_stmts.push((*AstNode)ast_assign(
        (*AstNode)ast_member_access((*AstNode)ast_deref((*AstNode)ast_ident("__clo_obj", 9)), "env", 3),
        (*AstNode)ast_ident("__env_obj", 9)
    ));
    var clo_as_u64: *AstNode = (*AstNode)ast_cast_ex((*AstNode)ast_ident("__clo_obj", 9), TYPE_U64, 0, 0, 0, 0, 0, 0);
    var clo_tagged: *AstNode = (*AstNode)ast_binary(TOKEN_PIPE, clo_as_u64, (*AstNode)ast_literal(9223372036854775808));
    bind_body_stmts.push((*AstNode)ast_return(clo_tagged));

    var bind_body: *AstNode = (*AstNode)ast_block(bind_body_stmts);
    var bind_fn: *AstFunc = ast_func_ex(bind_name.ptr, bind_name.len, bind_params,
                                        TYPE_U64, 0, 0, 0, 0, 0, 0, bind_body);
    parse_generated_funcs_push(p, (u64)bind_fn);

    return (*AstNode)ast_call_with_origin_named(bind_name.ptr, bind_name.len, bind_call_args, 0, AST_CALL_ORIGIN_DIRECT);
}

const MATCH_EXPR_ARM_SIMPLE = 1;
const MATCH_EXPR_ARM_VARIANT = 2;
const MATCH_EXPR_ARM_DEFAULT = 3;

struct ParseMatchExprArm {
    public kind: u64;
    public values_vec: *Vec<*AstNode>;
    public enum_ptr: u64;
    public enum_len: u64;
    public variant_ptr: u64;
    public variant_len: u64;
    public bind_names: *Vec<*NameInfo>;
    public value_expr: *AstNode;
}

impl ParseMatchExprArm {
    public constructor() {
        self.kind = 0;
        self.values_vec = 0;
        self.enum_ptr = 0;
        self.enum_len = 0;
        self.variant_ptr = 0;
        self.variant_len = 0;
        self.bind_names = 0;
        self.value_expr = 0;
    }
}

func parse_match_expr_make_empty_call(name_ptr: u64, name_len: u64) -> *AstNode {
    var args: *Vec<*AstNode> = new Vec<*AstNode>(0);
    return (*AstNode)ast_call_with_origin_named(name_ptr, name_len, args, 0, AST_CALL_ORIGIN_DIRECT);
}

func parse_match_expr_wrap_stmt_in_block(stmt: *AstNode) -> *AstNode {
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    stmts.push(stmt);
    return (*AstNode)ast_block(stmts);
}

func parse_match_expr_payload_field_name(idx: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"v";
    var prefix_len: u64 = 1;
    var idx_buf: u64 = heap_alloc(32 * sizeof(u8));
    var idx_len: u64 = io_u64_to_ascii(idx_buf, idx);
    var out_len: u64 = prefix_len + idx_len;
    var out_ptr: u64 = heap_alloc((out_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, out_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, idx_buf, idx_len);
    out_u8[out_len] = 0;
    return new NameInfo{out_ptr, out_len};
}

func parse_match_expr_parse_variant_case_head(p: *Parser) -> *ParseMatchExprArm {
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) { return 0; }
    var saved: u64 = parser_pos(p);
    var enum_tok: *Token = parse_peek(p);
    parse_adv(p);
    if (parse_match(p, TOKEN_DOT) == 0) {
        parser_set_pos(p, saved);
        return 0;
    }
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
        parser_set_pos(p, saved);
        return 0;
    }
    var variant_tok: *Token = parse_peek(p);
    parse_adv(p);

    var expected_arity: u64 = compiler_get_enum_variant_arity(enum_tok.ptr, enum_tok.len, variant_tok.ptr, variant_tok.len);
    if (expected_arity == 9223372036854775807) {
        parser_set_pos(p, saved);
        return 0;
    }

    var bind_names: *Vec<*NameInfo> = new Vec<*NameInfo>(expected_arity);
    if (parse_match(p, TOKEN_LPAREN)) {
        if (parse_peek_kind(p) != TOKEN_RPAREN) {
            while (1) {
                if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                    emit_stderr("[ERROR] match expression variant payload binding must be identifier\n");
                    parse_panic_here(p, "Syntax error");
                }
                var bind_tok: *Token = parse_peek(p);
                parse_consume(p, TOKEN_IDENTIFIER);
                bind_names.push(new NameInfo{bind_tok.ptr, bind_tok.len});
                if (parse_match(p, TOKEN_COMMA) == 0) { break; }
            }
        }
        parse_consume(p, TOKEN_RPAREN);
    }

    if (bind_names.len() != expected_arity) {
        emit_stderr("[ERROR] match expression variant payload arity mismatch: ");
        emit_stderr_len(enum_tok.ptr, enum_tok.len);
        emit_stderr(".");
        emit_stderr_len(variant_tok.ptr, variant_tok.len);
        emit_stderr(" expects ");
        emit_u64_stderr(expected_arity);
        emit_stderr(" binding(s), got ");
        emit_u64_stderr(bind_names.len());
        emit_stderr("\n");
        parse_panic_here(p, "Syntax error");
    }
    if (parse_peek_kind(p) == TOKEN_COMMA) {
        emit_stderr("[ERROR] variant match case cannot be combined with comma-separated values in match expression\n");
        parse_panic_here(p, "Syntax error");
    }

    var arm: *ParseMatchExprArm = new ParseMatchExprArm();
    arm.kind = MATCH_EXPR_ARM_VARIANT;
    arm.enum_ptr = enum_tok.ptr;
    arm.enum_len = enum_tok.len;
    arm.variant_ptr = variant_tok.ptr;
    arm.variant_len = variant_tok.len;
    arm.bind_names = bind_names;
    return arm;
}

func parse_match_expr_parse_case_head(p: *Parser) -> *ParseMatchExprArm {
    var arm: *ParseMatchExprArm = new ParseMatchExprArm();
    if (parse_peek_kind(p) == TOKEN_DEFAULT) {
        parse_consume(p, TOKEN_DEFAULT);
        arm.kind = MATCH_EXPR_ARM_DEFAULT;
        return arm;
    }
    if (parse_peek_kind(p) != TOKEN_CASE) { return 0; }
    parse_consume(p, TOKEN_CASE);

    if (parse_peek_kind(p) == TOKEN_IDENTIFIER) {
        var wc_tok: *Token = parse_peek(p);
        if (wc_tok.len == 1 && str_eq(wc_tok.ptr, wc_tok.len, "_", 1) != 0) {
            parse_adv(p);
            arm.kind = MATCH_EXPR_ARM_DEFAULT;
            return arm;
        }
    }

    var variant_arm: *ParseMatchExprArm = parse_match_expr_parse_variant_case_head(p);
    if (variant_arm != 0) { return variant_arm; }

    arm.kind = MATCH_EXPR_ARM_SIMPLE;
    arm.values_vec = new Vec<*AstNode>(2);
    arm.values_vec.push(parse_expr(p));
    while (parse_match(p, TOKEN_COMMA)) {
        if (parse_peek_kind(p) == TOKEN_IDENTIFIER) {
            var wc_tok2: *Token = parse_peek(p);
            if (wc_tok2.len == 1 && str_eq(wc_tok2.ptr, wc_tok2.len, "_", 1) != 0) {
                emit_stderr("[ERROR] wildcard '_' cannot be mixed with explicit case values in match expression\n");
                parse_panic_here(p, "Syntax error");
            }
        }
        arm.values_vec.push(parse_expr(p));
    }
    return arm;
}

func parse_match_expr_build_tag_expr(tmp_name_ptr: u64, tmp_name_len: u64) -> *AstNode {
    return (*AstNode)ast_member_access((*AstNode)ast_ident(tmp_name_ptr, tmp_name_len), "__tag", 5);
}

func parse_match_expr_build_simple_case_cond(tmp_name_ptr: u64, tmp_name_len: u64, values: *Vec<*AstNode>, enum_mode: u64) -> *AstNode {
    if (values == 0 || values.len() == 0) { return (*AstNode)ast_literal(0); }
    var lhs: *AstNode = (*AstNode)ast_ident(tmp_name_ptr, tmp_name_len);
    if (enum_mode != 0) {
        lhs = parse_match_expr_build_tag_expr(tmp_name_ptr, tmp_name_len);
    }
    var cond: *AstNode = (*AstNode)ast_binary(TOKEN_EQEQ, lhs, values.get(0));
    var n: u64 = values.len();
    for (var i: u64 = 1; i < n; i++) {
        var cmp_lhs: *AstNode = (*AstNode)ast_ident(tmp_name_ptr, tmp_name_len);
        if (enum_mode != 0) {
            cmp_lhs = parse_match_expr_build_tag_expr(tmp_name_ptr, tmp_name_len);
        }
        var cmp: *AstNode = (*AstNode)ast_binary(TOKEN_EQEQ, cmp_lhs, values.get(i));
        cond = (*AstNode)ast_binary(TOKEN_OROR, cond, cmp);
    }
    return cond;
}

func parse_match_expr_is_enum_variant_const(node: *AstNode, enum_ptr: u64, enum_len: u64, variant_ptr: u64, variant_len: u64) -> u64 {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    if (kind == AST_CAST) {
        return parse_match_expr_is_enum_variant_const(((*AstCast)node).expr, enum_ptr, enum_len, variant_ptr, variant_len);
    }
    if (kind == AST_MEMBER_ACCESS) {
        var ma: *AstMemberAccess = (*AstMemberAccess)node;
        if (ma.object == 0 || ast_kind(ma.object) != AST_IDENT) { return 0; }
        var obj: *AstIdent = (*AstIdent)ma.object;
        if (str_eq(obj.name_ptr, obj.name_len, enum_ptr, enum_len) == 0) { return 0; }
        if (str_eq(ma.member_ptr, ma.member_len, variant_ptr, variant_len) == 0) { return 0; }
        return 1;
    }
    if (kind == AST_IDENT) {
        var id: *AstIdent = (*AstIdent)node;
        var scoped: *NameInfo = module_util_build_joined_name(enum_ptr, enum_len, variant_ptr, variant_len);
        if (str_eq(id.name_ptr, id.name_len, scoped.ptr, scoped.len) != 0) { return 1; }
    }
    return 0;
}

func parse_match_expr_arm_covers_variant(arm: *ParseMatchExprArm, enum_ptr: u64, enum_len: u64, variant_ptr: u64, variant_len: u64) -> u64 {
    if (arm == 0) { return 0; }
    if (arm.kind == MATCH_EXPR_ARM_VARIANT) {
        if (str_eq(arm.enum_ptr, arm.enum_len, enum_ptr, enum_len) == 0) { return 0; }
        if (str_eq(arm.variant_ptr, arm.variant_len, variant_ptr, variant_len) == 0) { return 0; }
        return 1;
    }
    if (arm.kind != MATCH_EXPR_ARM_SIMPLE || arm.values_vec == 0) { return 0; }
    var n: u64 = arm.values_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        if (parse_match_expr_is_enum_variant_const(arm.values_vec.get(i), enum_ptr, enum_len, variant_ptr, variant_len) != 0) {
            return 1;
        }
    }
    return 0;
}

func parse_match_expr_has_default_arm(arms: *Vec<*ParseMatchExprArm>) -> u64 {
    if (arms == 0) { return 0; }
    var n: u64 = arms.len();
    for (var i: u64 = 0; i < n; i++) {
        var arm: *ParseMatchExprArm = arms.get(i);
        if (arm != 0 && arm.kind == MATCH_EXPR_ARM_DEFAULT) { return 1; }
    }
    return 0;
}

func parse_match_expr_is_exhaustive_enum(arms: *Vec<*ParseMatchExprArm>, enum_ptr: u64, enum_len: u64) -> u64 {
    if (arms == 0 || enum_ptr == 0 || enum_len == 0) { return 0; }
    var variants: *Vec<*NameInfo> = compiler_get_enum_variants(enum_ptr, enum_len);
    if (variants == 0 || variants.len() == 0) { return 0; }

    var vn: u64 = variants.len();
    for (var vi: u64 = 0; vi < vn; vi++) {
        var variant: *NameInfo = variants.get(vi);
        var covered: u64 = 0;
        var an: u64 = arms.len();
        for (var ai: u64 = 0; ai < an; ai++) {
            if (parse_match_expr_arm_covers_variant(arms.get(ai), enum_ptr, enum_len, variant.ptr, variant.len) != 0) {
                covered = 1;
                break;
            }
        }
        if (covered == 0) { return 0; }
    }
    return 1;
}

func parse_match_expr_find_payload_field_desc(struct_def: *AstStructDef, field_ptr: u64, field_len: u64) -> *FieldDesc {
    if (struct_def == 0 || struct_def.fields_vec == 0) { return 0; }
    var n: u64 = struct_def.fields_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var field: *FieldDesc = struct_def.fields_vec.get(i);
        if (str_eq(field.name_ptr, field.name_len, field_ptr, field_len) != 0) {
            return field;
        }
    }
    return 0;
}

func parse_match_expr_build_binding_decl(name_ptr: u64, name_len: u64, field_expr: *AstNode, field_desc: *FieldDesc) -> *AstVarDecl {
    var decl: *AstVarDecl = ast_var_decl(name_ptr, name_len, TYPE_U64, 0, field_expr);
    if (field_desc == 0) { return decl; }
    decl.type_kind = field_desc.type_kind;
    decl.ptr_depth = field_desc.ptr_depth;
    decl.is_tagged = field_desc.is_tagged;
    decl.struct_name_ptr = field_desc.struct_name_ptr;
    decl.struct_name_len = field_desc.struct_name_len;
    decl.tag_layout_ptr = field_desc.tag_layout_ptr;
    decl.tag_layout_len = field_desc.tag_layout_len;
    decl.elem_type_kind = field_desc.elem_type_kind;
    decl.elem_ptr_depth = field_desc.elem_ptr_depth;
    decl.array_len = field_desc.array_len;
    decl.elem_typeinfo = field_desc.elem_typeinfo;
    return decl;
}

func parse_match_expr_variant_then_block(p: *Parser, tmp_name_ptr: u64, tmp_name_len: u64, arm: *ParseMatchExprArm) -> *AstNode {
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(8);
    if (arm.bind_names != 0 && arm.bind_names.len() != 0) {
        var payload_info: *NameInfo = compiler_get_enum_variant_payload_struct(arm.enum_ptr, arm.enum_len, arm.variant_ptr, arm.variant_len);
        if (payload_info == 0) {
            emit_stderr("[ERROR] enum variant payload metadata is missing for match expression arm\n");
            parse_panic_here(p, "Syntax error");
        }
        var payload_struct: *AstStructDef = get_struct_def(payload_info.ptr, payload_info.len);
        if (payload_struct == 0) {
            emit_stderr("[ERROR] enum payload struct type not found: ");
            emit_stderr_len(payload_info.ptr, payload_info.len);
            emit_stderr("\n");
            parse_panic_here(p, "Syntax error");
        }

        var payload_tmp: *NameInfo = parse_lambda_build_name_with_prefix("__match_payload_", 16, parse_next_generated_id(p));
        var payload_slot_expr: *AstNode = (*AstNode)ast_member_access((*AstNode)ast_ident(tmp_name_ptr, tmp_name_len), "__payload", 9);
        var payload_addr_expr: *AstNode = (*AstNode)ast_addr_of(payload_slot_expr);
        var payload_cast: *AstNode = (*AstNode)ast_cast_ex(payload_addr_expr, TYPE_STRUCT, 1, 0, payload_info.ptr, payload_info.len, 0, 0);
        var payload_decl: *AstVarDecl = ast_var_decl(payload_tmp.ptr, payload_tmp.len, TYPE_STRUCT, 1, payload_cast);
        payload_decl.struct_name_ptr = payload_info.ptr;
        payload_decl.struct_name_len = payload_info.len;
        stmts.push((*AstNode)payload_decl);

        var bn: u64 = arm.bind_names.len();
        for (var bi: u64 = 0; bi < bn; bi++) {
            var bind: *NameInfo = arm.bind_names.get(bi);
            var field_name: *NameInfo = parse_match_expr_payload_field_name(bi);
            var field_desc: *FieldDesc = parse_match_expr_find_payload_field_desc(payload_struct, field_name.ptr, field_name.len);
            var field_expr: *AstNode = (*AstNode)ast_member_access((*AstNode)ast_deref((*AstNode)ast_ident(payload_tmp.ptr, payload_tmp.len)), field_name.ptr, field_name.len);
            stmts.push((*AstNode)parse_match_expr_build_binding_decl(bind.ptr, bind.len, field_expr, field_desc));
        }
    }
    stmts.push((*AstNode)ast_return(arm.value_expr));
    return (*AstNode)ast_block(stmts);
}

func parse_match_expr_lower_if_chain(p: *Parser, scrutinee_expr: *AstNode, arms: *Vec<*ParseMatchExprArm>, tmp_name_ptr: u64, tmp_name_len: u64) -> *AstNode {
    if (arms == 0 || arms.len() == 0) { return 0; }
    var enum_ptr: u64 = 0;
    var enum_len: u64 = 0;
    var n: u64 = arms.len();
    for (var i: u64 = 0; i < n; i++) {
        var arm0: *ParseMatchExprArm = arms.get(i);
        if (arm0.kind != MATCH_EXPR_ARM_VARIANT) { continue; }
        if (enum_ptr == 0) {
            enum_ptr = arm0.enum_ptr;
            enum_len = arm0.enum_len;
        } else if (str_eq(enum_ptr, enum_len, arm0.enum_ptr, arm0.enum_len) == 0) {
            emit_stderr("[ERROR] all variant match expression arms must target the same enum type\n");
            parse_panic_here(p, "Syntax error");
        }
    }

    var has_default: u64 = parse_match_expr_has_default_arm(arms);
    var is_exhaustive_enum: u64 = 0;
    if (has_default == 0 && enum_ptr != 0) {
        is_exhaustive_enum = parse_match_expr_is_exhaustive_enum(arms, enum_ptr, enum_len);
        if (is_exhaustive_enum == 0) {
            var variants: *Vec<*NameInfo> = compiler_get_enum_variants(enum_ptr, enum_len);
            if (variants != 0) {
                var vn: u64 = variants.len();
                for (var vi: u64 = 0; vi < vn; vi++) {
                    var variant: *NameInfo = variants.get(vi);
                    if (parse_match_expr_arm_covers_variant(arms.get(0), enum_ptr, enum_len, variant.ptr, variant.len) == 0) {
                        // Find the first uncovered case for diagnostics.
                        var covered: u64 = 0;
                        for (var ai: u64 = 0; ai < n; ai++) {
                            if (parse_match_expr_arm_covers_variant(arms.get(ai), enum_ptr, enum_len, variant.ptr, variant.len) != 0) {
                                covered = 1;
                                break;
                            }
                        }
                        if (covered == 0) {
                            emit_stderr("[ERROR] non-exhaustive match expression: missing case ");
                            emit_stderr_len(enum_ptr, enum_len);
                            emit_stderr(".");
                            emit_stderr_len(variant.ptr, variant.len);
                            emit_stderr("\n");
                            parse_panic_here(p, "Syntax error");
                        }
                    }
                }
            }
        }
    }
    if (has_default == 0 && is_exhaustive_enum == 0) {
        emit_stderr("[ERROR] match expression requires a default arm or exhaustive enum variant arms\n");
        parse_panic_here(p, "Syntax error");
    }

    var tmp_decl: *AstVarDecl = ast_var_decl(tmp_name_ptr, tmp_name_len, TYPE_U64, 0, scrutinee_expr);
    if (enum_ptr != 0) {
        tmp_decl.type_kind = TYPE_STRUCT;
        tmp_decl.ptr_depth = 0;
        tmp_decl.struct_name_ptr = enum_ptr;
        tmp_decl.struct_name_len = enum_len;
    }

    var chain: *AstNode = 0;
    for (var ri: i64 = (i64)n - 1; ri >= 0; ri = ri - 1) {
        var arm: *ParseMatchExprArm = arms.get((u64)ri);
        if (arm.kind == MATCH_EXPR_ARM_DEFAULT) {
            chain = (*AstNode)ast_block(new Vec<*AstNode>(1));
            ((*AstBlock)chain).stmts_vec.push((*AstNode)ast_return(arm.value_expr));
            continue;
        }
        var else_block: *AstNode = chain;
        if (else_block != 0 && ast_kind(else_block) == AST_IF) {
            else_block = parse_match_expr_wrap_stmt_in_block(else_block);
        }
        if (arm.kind == MATCH_EXPR_ARM_VARIANT) {
            var tag_const: *NameInfo = module_util_build_joined_name(arm.enum_ptr, arm.enum_len, arm.variant_ptr, arm.variant_len);
            var cond_v: *AstNode = (*AstNode)ast_binary(TOKEN_EQEQ, parse_match_expr_build_tag_expr(tmp_name_ptr, tmp_name_len), (*AstNode)ast_ident(tag_const.ptr, tag_const.len));
            var then_v: *AstNode = parse_match_expr_variant_then_block(p, tmp_name_ptr, tmp_name_len, arm);
            chain = (*AstNode)ast_if(cond_v, then_v, else_block);
            continue;
        }
        var cond_s: *AstNode = parse_match_expr_build_simple_case_cond(tmp_name_ptr, tmp_name_len, arm.values_vec, enum_ptr != 0);
        var then_s_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
        then_s_stmts.push((*AstNode)ast_return(arm.value_expr));
        chain = (*AstNode)ast_if(cond_s, (*AstNode)ast_block(then_s_stmts), else_block);
    }

    var fn_body_stmts: *Vec<*AstNode> = new Vec<*AstNode>(4);
    fn_body_stmts.push((*AstNode)tmp_decl);
    if (chain != 0) { fn_body_stmts.push(chain); }
    fn_body_stmts.push((*AstNode)ast_return((*AstNode)ast_literal(0)));
    return (*AstNode)ast_block(fn_body_stmts);
}

func parse_match_expr_make_bind_params(bind_names: *Vec<*NameInfo>) -> *Vec<*Param> {
    if (bind_names == 0) { return 0; }
    var params: *Vec<*Param> = new Vec<*Param>(bind_names.len());
    var n: u64 = bind_names.len();
    for (var i: u64 = 0; i < n; i++) {
        var info: *NameInfo = bind_names.get(i);
        var p: *Param = new Param();
        p.name_ptr = info.ptr;
        p.name_len = info.len;
        parse_lambda_param_set_default(p);
        params.push(p);
    }
    return params;
}

func parse_primary_match_expr(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_MATCH);
    parse_consume(p, TOKEN_LPAREN);
    var scrutinee_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    parse_consume(p, TOKEN_LBRACE);

    var lambda_id: u64 = parse_next_generated_id(p);
    var fn_name: *NameInfo = parse_lambda_build_name_with_prefix("__match_expr_", 13, lambda_id);
    var tmp_name: *NameInfo = parse_lambda_build_name_with_prefix("__match_tmp_", 12, lambda_id);

    var captures: *Vec<*LambdaCapture> = new Vec<*LambdaCapture>(4);
    parse_lambda_collect_expr_captures(p, scrutinee_expr, 0, captures);

    var arms: *Vec<*ParseMatchExprArm> = new Vec<*ParseMatchExprArm>(8);
    var case_value_nodes: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var arm_expr_nodes: *Vec<*AstNode> = new Vec<*AstNode>(8);

    while (parse_peek_kind(p) != TOKEN_RBRACE && parse_peek_kind(p) != TOKEN_EOF) {
        var arm: *ParseMatchExprArm = parse_match_expr_parse_case_head(p);
        if (arm == 0) {
            emit_stderr("[ERROR] Expected 'case' or 'default' in match expression\n");
            parse_panic_here(p, "Syntax error");
        }
        parse_consume(p, TOKEN_COLON);

        if (parse_peek_kind(p) == TOKEN_SEMICOLON) {
            emit_stderr("[ERROR] match expression arm value is required\n");
            parse_panic_here(p, "Syntax error");
        }
        arm.value_expr = parse_expr(p);
        parse_consume(p, TOKEN_SEMICOLON);
        arm_expr_nodes.push(arm.value_expr);

        var bind_params: *Vec<*Param> = parse_match_expr_make_bind_params(arm.bind_names);
        parse_lambda_collect_expr_captures(p, arm.value_expr, bind_params, captures);

        if (arm.kind == MATCH_EXPR_ARM_SIMPLE && arm.values_vec != 0) {
            var cvn: u64 = arm.values_vec.len();
            for (var cvi: u64 = 0; cvi < cvn; cvi++) {
                var cexpr: *AstNode = arm.values_vec.get(cvi);
                case_value_nodes.push(cexpr);
                parse_lambda_collect_expr_captures(p, cexpr, 0, captures);
            }
        }
        arms.push(arm);
    }
    parse_consume(p, TOKEN_RBRACE);

    var fn_params: *Vec<*Param> = new Vec<*Param>(0);
    var has_captures: u64 = 0;
    var env_struct: *AstStructDef = 0;
    if (captures != 0 && captures.len() != 0) {
        has_captures = 1;
        parse_lambda_set_capture_field_names(captures);
        env_struct = parse_lambda_build_env_struct(p, captures, lambda_id);
        fn_params.push(parse_lambda_make_env_param(env_struct));

        scrutinee_expr = parse_lambda_rewrite_expr_captures_env(p, scrutinee_expr, captures, "__env", 5);
        var cvn2: u64 = case_value_nodes.len();
        for (var i: u64 = 0; i < cvn2; i++) {
            case_value_nodes.set(i, parse_lambda_rewrite_expr_captures_env(p, case_value_nodes.get(i), captures, "__env", 5));
        }
        var an: u64 = arm_expr_nodes.len();
        for (var ai: u64 = 0; ai < an; ai++) {
            arm_expr_nodes.set(ai, parse_lambda_rewrite_expr_captures_env(p, arm_expr_nodes.get(ai), captures, "__env", 5));
        }
    }

    var fn_body: *AstNode = parse_match_expr_lower_if_chain(p, scrutinee_expr, arms, tmp_name.ptr, tmp_name.len);
    var fn: *AstFunc = ast_func_ex(fn_name.ptr, fn_name.len, fn_params,
                                   TYPE_U64, 0, 0, 0, 0, 0, 0, fn_body);
    parse_generated_funcs_push(p, (u64)fn);

    if (has_captures == 0) {
        return parse_match_expr_make_empty_call(fn_name.ptr, fn_name.len);
    }

    var bind_name: *NameInfo = parse_lambda_build_name_with_prefix("__match_bind_", 13, lambda_id);
    var bind_params: *Vec<*Param> = new Vec<*Param>(captures.len());
    var bind_stmts: *Vec<*AstNode> = new Vec<*AstNode>(captures.len() + 8);
    var bind_call_args: *Vec<*AstNode> = new Vec<*AstNode>(captures.len());

    var env_alloc: *AstNode = (*AstNode)ast_new(TYPE_STRUCT, 0, 0, env_struct.name_ptr, env_struct.name_len,
                                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    var env_decl: *AstVarDecl = ast_var_decl("__env_obj", 9, TYPE_STRUCT, 1, env_alloc);
    env_decl.struct_name_ptr = env_struct.name_ptr;
    env_decl.struct_name_len = env_struct.name_len;
    bind_stmts.push((*AstNode)env_decl);

    var cap_n: u64 = captures.len();
    for (var ci: u64 = 0; ci < cap_n; ci++) {
        var cap: *LambdaCapture = captures.get(ci);
        var bind_param_name: *NameInfo = parse_lambda_build_bind_param_name(ci);
        bind_params.push(parse_lambda_make_capture_param(p, cap, bind_param_name.ptr, bind_param_name.len));

        var env_target: *AstNode = (*AstNode)ast_member_access((*AstNode)ast_deref((*AstNode)ast_ident("__env_obj", 9)), cap.slot_ptr, cap.slot_len);
        bind_stmts.push((*AstNode)ast_assign(
            env_target,
            (*AstNode)ast_ident(bind_param_name.ptr, bind_param_name.len)
        ));

        if (cap.mode == LAMBDA_CAPTURE_BY_REF) {
            bind_call_args.push((*AstNode)ast_addr_of((*AstNode)ast_ident(cap.name_ptr, cap.name_len)));
        } else {
            bind_call_args.push((*AstNode)ast_ident(cap.name_ptr, cap.name_len));
        }
    }

    var call_args: *Vec<*AstNode> = new Vec<*AstNode>(1);
    call_args.push((*AstNode)ast_ident("__env_obj", 9));
    bind_stmts.push((*AstNode)ast_return(
        (*AstNode)ast_call_with_origin_named(fn_name.ptr, fn_name.len, call_args, 0, AST_CALL_ORIGIN_DIRECT)
    ));
    var bind_body: *AstNode = (*AstNode)ast_block(bind_stmts);
    var bind_fn: *AstFunc = ast_func_ex(bind_name.ptr, bind_name.len, bind_params,
                                        TYPE_U64, 0, 0, 0, 0, 0, 0, bind_body);
    parse_generated_funcs_push(p, (u64)bind_fn);
    return (*AstNode)ast_call_with_origin_named(bind_name.ptr, bind_name.len, bind_call_args, 0, AST_CALL_ORIGIN_DIRECT);
}

func parse_resolve_struct_def(name_ptr: u64, name_len: u64) -> *AstStructDef {
    var struct_def: *AstStructDef = get_struct_def(name_ptr, name_len);
    if (struct_def != 0) { return struct_def; }
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved == 0) { return 0; }
    return get_struct_def(resolved.ptr, resolved.len);
}

func parse_try_build_enum_ctor_name(enum_ptr: u64, enum_len: u64, variant_ptr: u64, variant_len: u64) -> *NameInfo {
    if (enum_ptr == 0 || enum_len == 0 || variant_ptr == 0 || variant_len == 0) { return 0; }
    var e_u8: []u8 = slice(enum_ptr, enum_len);
    var v_u8: []u8 = slice(variant_ptr, variant_len);
    if (e_u8[0] < 65 || e_u8[0] > 90) { return 0; }
    if (v_u8[0] < 65 || v_u8[0] > 90) { return 0; }
    var joined: *NameInfo = module_util_build_joined_name(enum_ptr, enum_len, variant_ptr, variant_len);
    var suffix_ptr: u64 = (u64)"_ctor";
    var suffix_len: u64 = 5;
    var out_len: u64 = joined.len + suffix_len;
    var out_ptr: u64 = heap_alloc((out_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, out_len + 1);
    str_copy(out_ptr, joined.ptr, joined.len);
    str_copy(out_ptr + joined.len, suffix_ptr, suffix_len);
    out_u8[out_len] = 0;
    return new NameInfo{out_ptr, out_len};
}

func parse_primary_identifier_generic_call(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_is_generic_call(p) == 0) { return 0; }
    var generic_args: *Vec<*GenericArg> = parse_generic_args(p);
    var parsed_args: *ParseCallArgs = parse_call_args_paren(p, 1);
    return (*AstNode)ast_generic_call_with_origin_named(tok4.ptr, tok4.len, generic_args, parsed_args.args, parsed_args.arg_names, AST_CALL_ORIGIN_DIRECT);
}

func parse_primary_identifier_generic_struct_literal(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_is_generic_struct_literal(p) == 0) { return 0; }
    var generic_args: *Vec<*GenericArg> = parse_generic_args_type(p);
    if (parse_peek_kind(p) != TOKEN_LBRACE) { return 0; }
    var values: *Vec<*AstNode> = parse_expr_list_brace(p);
    return (*AstNode)ast_generic_struct_literal(tok4.ptr, tok4.len, generic_args, values);
}

func parse_primary_identifier_slice_literal(p: *Parser, tok4: *Token) -> *AstNode {
    if (tok4.len != 5) { return 0; }
    if (str_eq(tok4.ptr, tok4.len, "slice", 5) == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_LPAREN) { return 0; }
    parse_adv(p);
    var ptr_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_COMMA);
    var len_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    return ast_slice(ptr_expr, len_expr);
}

func parse_primary_identifier_struct_literal(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_peek_kind(p) != TOKEN_LBRACE) { return 0; }
    var struct_def: *AstStructDef = parse_resolve_struct_def(tok4.ptr, tok4.len);
    if (struct_def == 0) {
        emit_stderr("[ERROR] Unknown struct/union type for literal: ");
        emit_stderr_len(tok4.ptr, tok4.len);
        emit_stderr("\n");
        parse_panic_here(p, "Syntax error");
        return (*AstNode)ast_literal(0);
    }
    var values: *Vec<*AstNode> = parse_expr_list_brace(p);
    if (struct_def.is_union == 1 && values.len() > 1) {
        emit_stderr("[ERROR] union literal accepts at most one initializer\n");
        parse_panic_here(p, "Syntax error");
    }
    return ast_struct_literal(struct_def, values);
}

func parse_primary_identifier_static_method_call(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_peek_kind(p) != TOKEN_DOT) { return 0; }

    var saved_pos: u64 = parser_pos(p);
    parse_adv(p); // consume '.'

    var method_kind: u64 = parse_peek_kind(p);
    if (method_kind != TOKEN_IDENTIFIER && method_kind != TOKEN_NEW && method_kind != TOKEN_DELETE && method_kind != TOKEN_CONSTRUCTOR && method_kind != TOKEN_DESTRUCTOR) {
        parser_set_pos(p, saved_pos);
        return 0;
    }
    var method_tok: *Token = parse_peek(p);
    parse_adv(p);

    var has_generic: u64 = 0;
    var generic_args: *Vec<*GenericArg> = 0;
    if (parse_is_generic_call(p)) {
        generic_args = parse_generic_args(p);
        has_generic = 1;
    }

    // Non-generic static calls (Type.method(...)) are parsed as normal method calls
    // and lowered in compiler pass. Keep this parser fast path only for generic static calls
    // because postfix parser doesn't represent method generic arguments yet.
    if (has_generic == 0) {
        if (parse_peek_kind(p) == TOKEN_LPAREN) {
            var enum_ctor: *NameInfo = compiler_get_enum_variant_ctor(tok4.ptr, tok4.len, method_tok.ptr, method_tok.len);
            if (enum_ctor == 0) {
                enum_ctor = parse_try_build_enum_ctor_name(tok4.ptr, tok4.len, method_tok.ptr, method_tok.len);
            }
            if (enum_ctor != 0) {
                var args2: *ParseCallArgs = parse_call_args_paren(p, 1);
                var expected_arity: u64 = compiler_get_enum_variant_arity(tok4.ptr, tok4.len, method_tok.ptr, method_tok.len);
                var got_arity: u64 = 0;
                if (args2.args != 0) { got_arity = args2.args.len(); }
                if (expected_arity != 9223372036854775807 && expected_arity != got_arity) {
                    emit_stderr("[ERROR] enum variant constructor arity mismatch: ");
                    emit_stderr_len(tok4.ptr, tok4.len);
                    emit_stderr(".");
                    emit_stderr_len(method_tok.ptr, method_tok.len);
                    emit_stderr(" expects ");
                    emit_u64_stderr(expected_arity);
                    emit_stderr(" argument(s), got ");
                    emit_u64_stderr(got_arity);
                    emit_stderr("\n");
                    parse_panic_here(p, "Syntax error");
                }
                return (*AstNode)ast_call_with_origin_named(enum_ctor.ptr, enum_ctor.len, args2.args, args2.arg_names, AST_CALL_ORIGIN_DIRECT);
            }
        }
        parser_set_pos(p, saved_pos);
        return 0;
    }

    if (parse_peek_kind(p) != TOKEN_LPAREN) {
        parser_set_pos(p, saved_pos);
        return 0;
    }

    var args: *ParseCallArgs = parse_call_args_paren(p, 1);
    return (*AstNode)ast_static_generic_call_named(tok4.ptr, tok4.len, method_tok.ptr, method_tok.len, generic_args, args.args, args.arg_names);
}

func parse_primary_identifier_call_or_ctor(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_peek_kind(p) != TOKEN_LPAREN) { return 0; }
    var args: *ParseCallArgs = parse_call_args_paren(p, 1);
    return (*AstNode)ast_call_with_origin_named(tok4.ptr, tok4.len, args.args, args.arg_names, AST_CALL_ORIGIN_DIRECT);
}

func parse_primary_identifier(p: *Parser, tok4: *Token) -> *AstNode {
    var node: *AstNode = parse_primary_identifier_generic_call(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_generic_struct_literal(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_slice_literal(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_struct_literal(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_static_method_call(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_call_or_ctor(p, tok4);
    if (node != 0) { return node; }
    return ast_ident(tok4.ptr, tok4.len);
}

func parse_identifier_is_known_type(p: *Parser, name_ptr: u64, name_len: u64) -> u64 {
    if (compiler_is_trait_name(name_ptr, name_len) != 0) { return 1; }
    if (is_struct_type(name_ptr, name_len) != 0) { return 1; }
    if (type_parser_find_generic_param(p, name_ptr, name_len) != 0) { return 1; }
    if (compiler_impl_has_generic_param(name_ptr, name_len) != 0) { return 1; }

    // Generic type lookahead (syntax-only): Name<...>
    var saved_pos: u64 = parser_pos(p);
    parse_adv(p);
    if (parse_peek_kind(p) == TOKEN_LT) {
        // Require a well-formed generic list followed by ')' for sizeof(type).
        var is_generic_type_syntax: u64 = parse_scan_generic_list_followed_by(p, TOKEN_RPAREN, 1, 1);
        parser_set_pos(p, saved_pos);
        if (is_generic_type_syntax != 0) { return 1; }
        return 0;
    }
    parser_set_pos(p, saved_pos);
    return 0;
}

func parse_primary_sizeof_is_type(p: *Parser) -> u64 {
    var nk: u64 = parse_peek_kind(p);
    var is_type: u64 = 0;
    if (nk == TOKEN_STAR || nk == TOKEN_BOOL || nk == TOKEN_U8 || nk == TOKEN_U16 || nk == TOKEN_U32 || nk == TOKEN_U64 || nk == TOKEN_I8 || nk == TOKEN_I16 || nk == TOKEN_I32 || nk == TOKEN_I64 || nk == TOKEN_F64 || nk == TOKEN_LBRACKET) {
        is_type = 1;
    } else if (nk == TOKEN_IDENTIFIER) {
        var t: *Token = parse_peek(p);
        is_type = parse_identifier_is_known_type(p, t.ptr, t.len);
    }
    return is_type;
}

func parse_primary_sizeof(p: *Parser) -> *AstNode {
    parse_adv(p);
    parse_consume(p, TOKEN_LPAREN);

    if (parse_primary_sizeof_is_type(p) != 0) {
        var ty: *TypeInfo = parse_type_ex(p);
        var type_kind: u64 = ty.type_kind;
        var ptr_depth: u64 = ty.ptr_depth;
        var struct_name_ptr: u64 = ty.struct_name_ptr;
        var struct_name_len: u64 = ty.struct_name_len;
        var elem_type_kind: u64 = ty.elem_type_kind;
        var elem_ptr_depth: u64 = ty.elem_ptr_depth;
        var array_len: u64 = ty.array_len;
        var array_len_is_param: u64 = ty.array_len_is_param;
        var array_len_param_ptr: u64 = ty.array_len_param_ptr;
        var array_len_param_len: u64 = ty.array_len_param_len;
        var elem_typeinfo: *TypeInfo = ty.elem_typeinfo;

        parse_consume(p, TOKEN_RPAREN);
        return ast_sizeof(type_kind, ptr_depth, struct_name_ptr, struct_name_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len, elem_typeinfo);
    }

    var expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    return ast_sizeof_expr(expr);
}

func parse_primary_new_expr(p: *Parser) -> *AstNode {
    parse_adv(p);
    var ty_new: *TypeInfo = parse_type_ex(p);
    var literal_expr: *AstNode = 0;
    var ctor_args_vec: *Vec<*AstNode> = 0;

    if (parse_peek_kind(p) == TOKEN_LBRACE) {
        if (ty_new.type_kind != TYPE_STRUCT) {
            emit_stderr("[ERROR] new { ... } is only supported for struct types\n");
            parse_panic_here(p, "Syntax error");
        }
        var struct_def_new: *AstStructDef = parse_resolve_struct_def(ty_new.struct_name_ptr, ty_new.struct_name_len);
        if (struct_def_new == 0) {
            emit_stderr("[ERROR] Struct definition not found for new literal\n");
            parse_panic_here(p, "Syntax error");
        }
        var values_new: *Vec<*AstNode> = parse_expr_list_brace(p);
        if (struct_def_new.is_union == 1 && values_new.len() > 1) {
            emit_stderr("[ERROR] union literal accepts at most one initializer\n");
            parse_panic_here(p, "Syntax error");
        }
        literal_expr = (*AstNode)ast_struct_literal(struct_def_new, values_new);
    }

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        if (ty_new.type_kind != TYPE_STRUCT) {
            emit_stderr("[ERROR] new(...) constructor call requires struct type\n");
            parse_panic_here(p, "Syntax error");
        }
        ctor_args_vec = parse_expr_list_paren(p);
    }

    return (*AstNode)ast_new(ty_new.type_kind, ty_new.ptr_depth, ty_new.is_tagged, ty_new.struct_name_ptr, ty_new.struct_name_len,
                             ty_new.tag_layout_ptr, ty_new.tag_layout_len, ty_new.elem_type_kind, ty_new.elem_ptr_depth,
                             ty_new.array_len, ty_new.array_len_is_param, ty_new.array_len_param_ptr, ty_new.array_len_param_len, ty_new.elem_typeinfo,
                             literal_expr, ctor_args_vec);
}

func parse_primary_paren_or_cast(p: *Parser) -> *AstNode {
    parse_adv(p);
    var next_k: u64 = parse_peek_kind(p);
    if (next_k == TOKEN_STAR || next_k == TOKEN_BOOL || next_k == TOKEN_U8 || next_k == TOKEN_U16 ||
        next_k == TOKEN_U32 || next_k == TOKEN_U64 || next_k == TOKEN_I8 || next_k == TOKEN_I16 || next_k == TOKEN_I32 || next_k == TOKEN_I64 ||
        next_k == TOKEN_F64 || next_k == TOKEN_CHAR || next_k == TOKEN_LBRACKET) {
        var ty2: *TypeInfo = parse_type_ex(p);
        var type_kind2: u64 = ty2.type_kind;
        var ptr_depth2: u64 = ty2.ptr_depth;
        var is_tagged2: u64 = ty2.is_tagged;
        var struct_name_ptr2: u64 = ty2.struct_name_ptr;
        var struct_name_len2: u64 = ty2.struct_name_len;
        var tag_layout_ptr2: u64 = ty2.tag_layout_ptr;
        var tag_layout_len2: u64 = ty2.tag_layout_len;

        parse_consume(p, TOKEN_RPAREN);
        var operand3: *AstNode = parse_unary(p);
        return ast_cast_ex(operand3, type_kind2, ptr_depth2, is_tagged2, struct_name_ptr2, struct_name_len2, tag_layout_ptr2, tag_layout_len2);
    }

    if (next_k == TOKEN_IDENTIFIER) {
        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok.ptr;
        var name_len: u64 = name_tok.len;
        var is_known_type: u64 = parse_identifier_is_known_type(p, name_ptr, name_len);

        if (is_known_type != 0) {
            var saved_pos: u64 = parser_pos(p);
            var ty_id: *TypeInfo = parse_type_ex(p);
            if (parse_peek_kind(p) == TOKEN_RPAREN) {
                var type_kind3: u64 = ty_id.type_kind;
                var ptr_depth3: u64 = ty_id.ptr_depth;
                var is_tagged3: u64 = ty_id.is_tagged;
                var struct_name_ptr3: u64 = ty_id.struct_name_ptr;
                var struct_name_len3: u64 = ty_id.struct_name_len;
                var tag_layout_ptr3: u64 = ty_id.tag_layout_ptr;
                var tag_layout_len3: u64 = ty_id.tag_layout_len;

                parse_consume(p, TOKEN_RPAREN);
                var operand4: *AstNode = parse_unary(p);
                return ast_cast_ex(operand4, type_kind3, ptr_depth3, is_tagged3, struct_name_ptr3, struct_name_len3, tag_layout_ptr3, tag_layout_len3);
            }
            parser_set_pos(p, saved_pos);
        }
    }

    var expr2: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    return parse_postfix_from(p, expr2);
}

func parse_primary(p: *Parser) -> *AstNode {
    push_trace("parse_primary", "parser/expr.b", __LINE__);
    defer pop_trace();
    var k: u64 = parse_peek_kind(p);
    
    switch (k) {
        case TOKEN_NUMBER:
            var tok: *Token = parse_peek(p);
            parse_adv(p);
                return ast_literal(parse_num_val(tok));
        case TOKEN_FLOAT:
            var ftok: *Token = parse_peek(p);
            parse_adv(p);
                return ast_float(ftok.ptr, ftok.len);
        case TOKEN_LINE_MACRO:
            var tok2: *Token = parse_peek(p);
            parse_adv(p);
            var line: u64 = tok2.line;
                return ast_literal(line);
        case TOKEN_TRUE:
            parse_adv(p);
            var true_lit: *AstNode = (*AstNode)ast_literal(1);
                return (*AstNode)ast_cast_ex(true_lit, TYPE_BOOL, 0, 0, 0, 0, 0, 0);
        case TOKEN_FALSE:
            parse_adv(p);
            var false_lit: *AstNode = (*AstNode)ast_literal(0);
                return (*AstNode)ast_cast_ex(false_lit, TYPE_BOOL, 0, 0, 0, 0, 0, 0);
        case TOKEN_NULL:
            parse_adv(p);
                return ast_literal(0);
        case TOKEN_STRING:
            var tok3: *Token = parse_peek(p);
            parse_adv(p);
                return ast_string(tok3.ptr, tok3.len);
        case TOKEN_CHAR:
            var ctok: *Token = parse_peek(p);
            parse_adv(p);
            if (parse_is_char_literal_token(ctok) == 0) {
                emit_stderr("[ERROR] Invalid char literal\n");
                parse_panic_at_tok(ctok, "Syntax error");
            }
            return ast_literal(parse_char_literal_value(ctok));
        case TOKEN_SIZEOF:
            return parse_primary_sizeof(p);
        case TOKEN_NEW:
            return parse_primary_new_expr(p);
        case TOKEN_FUNC:
            return parse_primary_lambda_expr(p);
        case TOKEN_MATCH:
            return parse_primary_match_expr(p);
        case TOKEN_AMPERSAND:
            parse_adv(p);
            var operand: *AstNode = parse_unary(p);
            if (operand == 0) {
                emit_stderr("[ERROR] Expected expression after &\n");
                return 0;
            }
                return ast_addr_of(operand);
        case TOKEN_STAR:
            parse_adv(p);
            var operand2: *AstNode = parse_unary(p);
                return ast_deref(operand2);
        case TOKEN_LPAREN:
            return parse_primary_paren_or_cast(p);
        case TOKEN_IDENTIFIER:
            var tok4: *Token = parse_peek(p);
            parse_adv(p);
            return parse_primary_identifier(p, tok4);
        case TOKEN_SUPER:
            parse_adv(p);
            return (*AstNode)ast_super();
        default:
            return 0;
    }
}

func parse_is_generic_list_followed_by(p: *Parser, follow_kind: u64) -> u64 {
    return parse_scan_generic_list_followed_by(p, follow_kind, 1, 0);
}

// Lookahead for generic call: <...>(...)
func parse_is_generic_call(p: *Parser) -> u64 {
    return parse_is_generic_list_followed_by(p, TOKEN_LPAREN);
}

// Lookahead for generic struct literal: <...>{...}
func parse_is_generic_struct_literal(p: *Parser) -> u64 {
    return parse_is_generic_list_followed_by(p, TOKEN_LBRACE);
}

// Parse generic argument list: <T, U, 8>
func parse_generic_args(p: *Parser) -> *Vec<*GenericArg> {
    // Keep one implementation in parser/type to avoid drift between
    // expression-position and type-position generic parsing.
    return parse_generic_args_type(p);
}

// ============================================
// Postfix Expression
// ============================================

func parse_postfix_after_dot(p: *Parser, left: *AstNode, is_safe: u64) -> *AstNode {
    if (parse_peek_kind(p) == TOKEN_LT) {
        parse_adv(p);
        var parent_tok: *Token = parse_peek(p);
        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            if (is_safe != 0) {
                emit_stderr("[ERROR] Expected parent struct name after '.?<'\n");
            } else {
                emit_stderr("[ERROR] Expected parent struct name after '.<'\n");
            }
            parse_panic_here(p, "Syntax error");
        }
        parse_adv(p);
        parse_consume_generic_gt(p);
        var scoped_field_tok: *Token = parse_peek(p);
        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected field name after parent scope\n");
            parse_panic_here(p, "Syntax error");
        }
        parse_adv(p);
        if (is_safe != 0) {
            return ast_safe_member_access_scoped(left, parent_tok.ptr, parent_tok.len, scoped_field_tok.ptr, scoped_field_tok.len);
        }
        return ast_member_access_scoped(left, parent_tok.ptr, parent_tok.len, scoped_field_tok.ptr, scoped_field_tok.len);
    }

    var field_tok: *Token = parse_peek(p);
    var field_kind: u64 = parse_peek_kind(p);
    if (field_kind != TOKEN_IDENTIFIER && field_kind != TOKEN_NEW && field_kind != TOKEN_DELETE && field_kind != TOKEN_CONSTRUCTOR && field_kind != TOKEN_DESTRUCTOR) {
        if (is_safe != 0) {
            emit_stderr("[ERROR] Expected identifier after '.?'\n");
        } else {
            emit_stderr("[ERROR] Expected identifier after '.'\n");
        }
        parse_panic_here(p, "Syntax error");
    }
    parse_adv(p);

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        var call_args: *ParseCallArgs = parse_call_args_paren(p, 1);
        if (is_safe != 0) {
            return (*AstNode)ast_safe_method_call_named(left, field_tok.ptr, field_tok.len, call_args.args, call_args.arg_names);
        }
        return (*AstNode)ast_method_call_named(left, field_tok.ptr, field_tok.len, call_args.args, call_args.arg_names);
    }

    if (is_safe != 0) {
        return ast_safe_member_access(left, field_tok.ptr, field_tok.len);
    }
    return ast_member_access(left, field_tok.ptr, field_tok.len);
}

func parse_postfix_from(p: *Parser, left: *AstNode) -> *AstNode {
    while (1) {
        var k: u64 = parse_peek_kind(p);

        switch (k) {
            case TOKEN_LBRACKET:
                parse_adv(p);
                var idx: *AstNode = parse_expr(p);
                parse_consume(p, TOKEN_RBRACKET);
                left = ast_index(left, idx);
                break;
            case TOKEN_LPAREN:
                var ptr_call_args: *ParseCallArgs = parse_call_args_paren(p, 0);
                left = ast_call_ptr(left, ptr_call_args.args);
                break;
            case TOKEN_DOT:
                parse_adv(p);
                left = parse_postfix_after_dot(p, left, 0);
                break;
            case TOKEN_DOT_Q:
                parse_adv(p);
                left = parse_postfix_after_dot(p, left, 1);
                break;
            case TOKEN_QUESTION:
                parse_adv(p);
                left = ast_try(left);
                break;
            default:
                return left;
        }
    }
}

func parse_postfix(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_primary(p);
    if (left != 0 && ast_kind(left) == AST_SUPER) {
        var k: u64 = parse_peek_kind(p);
        if (k != TOKEN_DOT && k != TOKEN_DOT_Q) {
            emit_stderr("[ERROR] 'super' must be followed by '.' and a member name\n");
            parse_panic_here(p, "Syntax error");
        }
    }
    return parse_postfix_from(p, left);
}

// ============================================
// Unary Expression
// ============================================

func parse_unary(p: *Parser) -> *AstNode {
    var k: u64 = parse_peek_kind(p);
    
    switch (k) {
        case TOKEN_STAR:
            parse_adv(p);
            var operand: *AstNode = parse_unary(p);
            return ast_deref(operand);
        case TOKEN_MINUS:
            parse_adv(p);
            var next_k: u64 = parse_peek_kind(p);
            if (next_k == TOKEN_NUMBER) {
                var tok: *Token = parse_peek(p);
                parse_adv(p);
                var val: u64 = parse_num_val(tok);
                var lit: *AstNode = ast_literal(val);
                return ast_unary(TOKEN_MINUS, lit);
            }
            var operand2: *AstNode = parse_unary(p);
            return ast_unary(TOKEN_MINUS, operand2);
        case TOKEN_BANG:
            parse_adv(p);
            var operand3: *AstNode = parse_unary(p);
            return ast_unary(TOKEN_BANG, operand3);
        case TOKEN_TILDE:
            parse_adv(p);
            var operand4: *AstNode = parse_unary(p);
            return ast_unary(TOKEN_TILDE, operand4);
        default:
            return parse_postfix(p);
    }
}

// ============================================
// Binary Expressions (Precedence Climbing)
// ============================================

func parse_mul(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_unary(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_STAR:
                parse_adv(p);
                var right: *AstNode = parse_unary(p);
                left = ast_binary(TOKEN_STAR, left, right);
                break;
            case TOKEN_SLASH:
                parse_adv(p);
                var right2: *AstNode = parse_unary(p);
                left = ast_binary(TOKEN_SLASH, left, right2);
                break;
            case TOKEN_PERCENT:
                parse_adv(p);
                var right3: *AstNode = parse_unary(p);
                left = ast_binary(TOKEN_PERCENT, left, right3);
                break;
            default:
                return left;
        }
    }
}

func parse_add(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_mul(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_PLUS:
                parse_adv(p);
                var right: *AstNode = parse_mul(p);
                left = ast_binary(TOKEN_PLUS, left, right);
                break;
            case TOKEN_MINUS:
                parse_adv(p);
                var right2: *AstNode = parse_mul(p);
                left = ast_binary(TOKEN_MINUS, left, right2);
                break;
            default:
                return left;
        }
    }
}

func parse_shift(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_add(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_LSHIFT:
                parse_adv(p);
                var right: *AstNode = parse_add(p);
                left = ast_binary(TOKEN_LSHIFT, left, right);
                break;
            case TOKEN_RSHIFT:
                parse_adv(p);
                var right2: *AstNode = parse_add(p);
                left = ast_binary(TOKEN_RSHIFT, left, right2);
                break;
            default:
                return left;
        }
    }
}

func parse_rel(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_shift(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_LT:
                parse_adv(p);
                var right: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_LT, left, right);
                break;
            case TOKEN_GT:
                parse_adv(p);
                var right2: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_GT, left, right2);
                break;
            case TOKEN_LTEQ:
                parse_adv(p);
                var right3: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_LTEQ, left, right3);
                break;
            case TOKEN_GTEQ:
                parse_adv(p);
                var right4: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_GTEQ, left, right4);
                break;
            default:
                return left;
        }
    }
}

func parse_eq(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_rel(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_EQEQ:
                parse_adv(p);
                var right: *AstNode = parse_rel(p);
                left = ast_binary(TOKEN_EQEQ, left, right);
                break;
            case TOKEN_BANGEQ:
                parse_adv(p);
                var right2: *AstNode = parse_rel(p);
                left = ast_binary(TOKEN_BANGEQ, left, right2);
                break;
            default:
                return left;
        }
    }
}

func parse_bitand(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_eq(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_AMPERSAND:
                parse_adv(p);
                var right: *AstNode = parse_eq(p);
                left = ast_binary(TOKEN_AMPERSAND, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_bitxor(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_bitand(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_CARET:
                parse_adv(p);
                var right: *AstNode = parse_bitand(p);
                left = ast_binary(TOKEN_CARET, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_bitor(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_bitxor(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_PIPE:
                parse_adv(p);
                var right: *AstNode = parse_bitxor(p);
                left = ast_binary(TOKEN_PIPE, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_logand(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_bitor(p);

    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_ANDAND:
                parse_adv(p);
                var right: *AstNode = parse_bitor(p);
                left = ast_binary(TOKEN_ANDAND, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_logor(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_logand(p);

    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_OROR:
                parse_adv(p);
                var right: *AstNode = parse_logand(p);
                left = ast_binary(TOKEN_OROR, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_expr(p: *Parser) -> *AstNode {
    push_trace("parse_expr", "parser/expr.b", __LINE__);
    defer pop_trace();
    var expr: *AstNode = parse_logor(p);
    if (expr == 0) {
        emit_stderr("[ERROR] Expected expression\n");
        parse_panic_here(p, "Expected expression");
    }
    return expr;
}
