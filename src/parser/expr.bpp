// parse_expr.b - Expression parsing
//
// Pratt parser style with precedence climbing:
// - Primary expressions (literals, identifiers, calls)
// - Postfix expressions (array access, member access)
// - Unary expressions (*, -, !)
// - Binary expressions (arithmetic, comparison, logical)

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import lexer;
import ast;
import compiler;
import parser.util;
import parser.type;

// ============================================
// Primary Expression
// ============================================

struct ParseCallArgs {
    public args: *Vec<*AstNode>;
    public arg_names: *Vec<*NameInfo>;
}

func parse_call_named_arg_peek(p: *Parser) -> *Token {
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) { return 0; }
    var saved_pos: u64 = parser_pos(p);
    var name_tok: *Token = parse_peek(p);
    parse_adv(p);
    var is_named: u64 = 0;
    if (parse_peek_kind(p) == TOKEN_COLON) {
        is_named = 1;
    }
    parser_set_pos(p, saved_pos);
    if (is_named == 0) { return 0; }
    return name_tok;
}

func parse_call_args_paren(p: *Parser, allow_named: u64) -> *ParseCallArgs {
    parse_consume(p, TOKEN_LPAREN);

    var args: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var arg_names: *Vec<*NameInfo> = 0;
    var seen_named: u64 = 0;

    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        while (1) {
            var arg_name: *NameInfo = 0;
            var named_tok: *Token = parse_call_named_arg_peek(p);
            if (named_tok != 0) {
                if (allow_named == 0) {
                    emit_stderr("[ERROR] named arguments are not allowed for this call target\n");
                    parse_panic_here(p, "Syntax error");
                }
                parse_consume(p, TOKEN_IDENTIFIER);
                parse_consume(p, TOKEN_COLON);
                arg_name = new NameInfo{named_tok.ptr, named_tok.len};
                seen_named = 1;
            } else if (seen_named != 0) {
                emit_stderr("[ERROR] positional argument cannot follow named arguments\n");
                parse_panic_here(p, "Syntax error");
            }

            args.push(parse_expr(p));
            if (arg_names != 0) {
                arg_names.push(arg_name);
            } else if (arg_name != 0) {
                arg_names = new Vec<*NameInfo>(args.len());
                for (var ai: u64 = 0; ai + 1 < args.len(); ai++) {
                    arg_names.push(0);
                }
                arg_names.push(arg_name);
            }

            if (parse_match(p, TOKEN_COMMA) == 0) { break; }
        }
    }

    parse_consume(p, TOKEN_RPAREN);
    var out: *ParseCallArgs = new ParseCallArgs();
    out.args = args;
    out.arg_names = arg_names;
    return out;
}

func parse_expr_list_paren(p: *Parser) -> *Vec<*AstNode> {
    parse_consume(p, TOKEN_LPAREN);
    var args: *Vec<*AstNode> = new Vec<*AstNode>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        args.push(parse_expr(p));
        while (parse_match(p, TOKEN_COMMA)) {
            args.push(parse_expr(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);
    return args;
}

func parse_expr_list_brace(p: *Parser) -> *Vec<*AstNode> {
    parse_consume(p, TOKEN_LBRACE);
    var values: *Vec<*AstNode> = new Vec<*AstNode>(8);
    if (parse_peek_kind(p) != TOKEN_RBRACE) {
        values.push(parse_expr(p));
        while (parse_match(p, TOKEN_COMMA)) {
            values.push(parse_expr(p));
        }
    }
    parse_consume(p, TOKEN_RBRACE);
    return values;
}

func parse_lambda_param_set_default(param: *Param) -> u64 {
    param.type_kind = TYPE_U64;
    param.ptr_depth = 0;
    param.is_tagged = 0;
    param.struct_name_ptr = 0;
    param.struct_name_len = 0;
    param.tag_layout_ptr = 0;
    param.tag_layout_len = 0;
    param.elem_type_kind = 0;
    param.elem_ptr_depth = 0;
    param.array_len = 0;
    param.array_len_is_param = 0;
    param.array_len_param_ptr = 0;
    param.array_len_param_len = 0;
    param.elem_typeinfo = 0;
    return 0;
}

func parse_lambda_param(p: *Parser) -> *Param {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    var param: *Param = new Param();
    param.name_ptr = name_tok.ptr;
    param.name_len = name_tok.len;

    if (parse_match(p, TOKEN_COLON)) {
        var ty: *TypeInfo = parse_type_ex(p);
        param.fill_from_typeinfo(ty);
        param.decay_array_to_ptr();
        return param;
    }

    parse_lambda_param_set_default(param);
    return param;
}

func parse_lambda_param_exists(params: *Vec<*Param>, name_ptr: u64, name_len: u64) -> u64 {
    if (params == 0) { return 0; }
    var n: u64 = params.len();
    for (var i: u64 = 0; i < n; i++) {
        var p2: *Param = params.get(i);
        if (str_eq(p2.name_ptr, p2.name_len, name_ptr, name_len) != 0) {
            return 1;
        }
    }
    return 0;
}

func parse_lambda_symbol_is_global(name_ptr: u64, name_len: u64) -> u64 {
    if (compiler_func_exists(name_ptr, name_len) != 0) { return 1; }
    if (compiler_global_exists(name_ptr, name_len) != 0) { return 1; }
    var cres: *ConstResult = (*ConstResult)compiler_find_const(name_ptr, name_len);
    if (cres != 0 && cres.found != 0) { return 1; }

    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        if (compiler_func_exists(resolved.ptr, resolved.len) != 0) { return 1; }
        if (compiler_global_exists(resolved.ptr, resolved.len) != 0) { return 1; }
        var cres2: *ConstResult = (*ConstResult)compiler_find_const(resolved.ptr, resolved.len);
        if (cres2 != 0 && cres2.found != 0) { return 1; }
    }
    return 0;
}

struct LambdaCapture {
    public name_ptr: u64;
    public name_len: u64;
    public slot_ptr: u64;
    public slot_len: u64;
}

func parse_lambda_capture_find(captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64) -> *LambdaCapture {
    if (captures == 0) { return 0; }
    var n: u64 = captures.len();
    for (var i: u64 = 0; i < n; i++) {
        var c: *LambdaCapture = captures.get(i);
        if (str_eq(c.name_ptr, c.name_len, name_ptr, name_len) != 0) {
            return c;
        }
    }
    return 0;
}

func parse_lambda_capture_add(captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64) -> u64 {
    if (captures == 0) { return 0; }
    if (parse_lambda_capture_find(captures, name_ptr, name_len) != 0) { return 0; }
    var c: *LambdaCapture = new LambdaCapture();
    c.name_ptr = name_ptr;
    c.name_len = name_len;
    c.slot_ptr = 0;
    c.slot_len = 0;
    captures.push(c);
    return 0;
}

func parse_lambda_collect_capture_name(p: *Parser, params: *Vec<*Param>, captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64) -> u64 {
    if (parse_lambda_param_exists(params, name_ptr, name_len) != 0) { return 0; }
    if (parse_lambda_symbol_is_global(name_ptr, name_len) != 0) { return 0; }
    parse_lambda_capture_add(captures, name_ptr, name_len);
    return 0;
}

func parse_lambda_collect_expr_captures(p: *Parser, node: *AstNode, params: *Vec<*Param>, captures: *Vec<*LambdaCapture>) -> u64 {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)node;
            return parse_lambda_collect_capture_name(p, params, captures, id.name_ptr, id.name_len);
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)node;
            parse_lambda_collect_expr_captures(p, bin.left, params, captures);
            parse_lambda_collect_expr_captures(p, bin.right, params, captures);
            return 0;
        case AST_UNARY:
            return parse_lambda_collect_expr_captures(p, ((*AstUnary)node).operand, params, captures);
        case AST_ADDR_OF:
            return parse_lambda_collect_expr_captures(p, ((*AstAddrOf)node).operand, params, captures);
        case AST_DEREF:
            return parse_lambda_collect_expr_captures(p, ((*AstDeref)node).operand, params, captures);
        case AST_DEREF8:
            return parse_lambda_collect_expr_captures(p, ((*AstDeref8)node).operand, params, captures);
        case AST_CAST:
            return parse_lambda_collect_expr_captures(p, ((*AstCast)node).expr, params, captures);
        case AST_TRY:
            return parse_lambda_collect_expr_captures(p, ((*AstTry)node).operand, params, captures);
        case AST_SIZEOF_EXPR:
            return parse_lambda_collect_expr_captures(p, ((*AstSizeofExpr)node).expr, params, captures);
        case AST_INDEX:
            var idx: *AstIndex = (*AstIndex)node;
            parse_lambda_collect_expr_captures(p, idx.base, params, captures);
            parse_lambda_collect_expr_captures(p, idx.index, params, captures);
            return 0;
        case AST_MEMBER_ACCESS:
        case AST_SAFE_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)node;
            if (ma.parent_ptr == 0 && ast_kind(ma.object) == AST_IDENT) {
                var sid: *AstIdent = (*AstIdent)ma.object;
                var scoped_const: *ConstResult = (*ConstResult)compiler_find_scoped_const(sid.name_ptr, sid.name_len, ma.member_ptr, ma.member_len);
                if (scoped_const != 0 && scoped_const.found != 0) {
                    return 0;
                }
            }
            return parse_lambda_collect_expr_captures(p, ma.object, params, captures);
        case AST_METHOD_CALL:
        case AST_SAFE_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)node;
            parse_lambda_collect_expr_captures(p, mc.receiver, params, captures);
            if (mc.args_vec != 0) {
                var an: u64 = mc.args_vec.len();
                for (var ai: u64 = 0; ai < an; ai++) {
                    parse_lambda_collect_expr_captures(p, mc.args_vec.get(ai), params, captures);
                }
            }
            return 0;
        case AST_CALL:
            var call: *AstCall = (*AstCall)node;
            parse_lambda_collect_capture_name(p, params, captures, call.name_ptr, call.name_len);
            if (call.args_vec != 0) {
                var cn: u64 = call.args_vec.len();
                for (var ci: u64 = 0; ci < cn; ci++) {
                    parse_lambda_collect_expr_captures(p, call.args_vec.get(ci), params, captures);
                }
            }
            return 0;
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)node;
            parse_lambda_collect_expr_captures(p, cp.callee, params, captures);
            if (cp.args_vec != 0) {
                var cpn: u64 = cp.args_vec.len();
                for (var cpi: u64 = 0; cpi < cpn; cpi++) {
                    parse_lambda_collect_expr_captures(p, cp.args_vec.get(cpi), params, captures);
                }
            }
            return 0;
        case AST_GENERIC_CALL:
            var gc: *AstGenericCall = (*AstGenericCall)node;
            if (parse_lambda_symbol_is_global(gc.name_ptr, gc.name_len) == 0) {
                emit_stderr("[ERROR] lambda generic call target must be global symbol: ");
                emit_stderr_len(gc.name_ptr, gc.name_len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
            if (gc.args_vec != 0) {
                var gcn: u64 = gc.args_vec.len();
                for (var gci: u64 = 0; gci < gcn; gci++) {
                    parse_lambda_collect_expr_captures(p, gc.args_vec.get(gci), params, captures);
                }
            }
            return 0;
        case AST_STATIC_GENERIC_CALL:
            var sgc: *AstStaticGenericCall = (*AstStaticGenericCall)node;
            if (parse_lambda_symbol_is_global(sgc.struct_name_ptr, sgc.struct_name_len) == 0) {
                emit_stderr("[ERROR] lambda static generic call target must be global symbol: ");
                emit_stderr_len(sgc.struct_name_ptr, sgc.struct_name_len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
            if (sgc.args_vec != 0) {
                var sgn: u64 = sgc.args_vec.len();
                for (var sgi: u64 = 0; sgi < sgn; sgi++) {
                    parse_lambda_collect_expr_captures(p, sgc.args_vec.get(sgi), params, captures);
                }
            }
            return 0;
        case AST_STRUCT_LITERAL:
            var sl: *AstStructLiteral = (*AstStructLiteral)node;
            if (sl.values_vec != 0) {
                var sn: u64 = sl.values_vec.len();
                for (var si: u64 = 0; si < sn; si++) {
                    parse_lambda_collect_expr_captures(p, sl.values_vec.get(si), params, captures);
                }
            }
            return 0;
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)node;
            if (gsl.values_vec != 0) {
                var gsn: u64 = gsl.values_vec.len();
                for (var gsi: u64 = 0; gsi < gsn; gsi++) {
                    parse_lambda_collect_expr_captures(p, gsl.values_vec.get(gsi), params, captures);
                }
            }
            return 0;
        case AST_SLICE:
            var slice_node: *AstSlice = (*AstSlice)node;
            parse_lambda_collect_expr_captures(p, slice_node.ptr_expr, params, captures);
            parse_lambda_collect_expr_captures(p, slice_node.len_expr, params, captures);
            return 0;
        case AST_NEW:
            var nw: *AstNew = (*AstNew)node;
            if (nw.literal_expr != 0) {
                parse_lambda_collect_expr_captures(p, nw.literal_expr, params, captures);
            }
            if (nw.ctor_args_vec != 0) {
                var nn: u64 = nw.ctor_args_vec.len();
                for (var ni: u64 = 0; ni < nn; ni++) {
                    parse_lambda_collect_expr_captures(p, nw.ctor_args_vec.get(ni), params, captures);
                }
            }
            return 0;
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)node;
            if (sc.ctor_args_vec != 0) {
                var sn2: u64 = sc.ctor_args_vec.len();
                for (var si2: u64 = 0; si2 < sn2; si2++) {
                    parse_lambda_collect_expr_captures(p, sc.ctor_args_vec.get(si2), params, captures);
                }
            }
            return 0;
    }
    return 0;
}

func parse_lambda_build_name_with_prefix(prefix_ptr: u64, prefix_len: u64, lambda_id: u64) -> *NameInfo {
    var id_buf: u64 = heap_alloc(32 * sizeof(u8));
    var id_len: u64 = io_u64_to_ascii(id_buf, lambda_id);
    var total_len: u64 = prefix_len + id_len;
    var name_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var name_u8: []u8 = slice(name_ptr, total_len + 1);
    str_copy(name_ptr, prefix_ptr, prefix_len);
    str_copy(name_ptr + prefix_len, id_buf, id_len);
    name_u8[total_len] = 0;
    return new NameInfo{name_ptr, total_len};
}

func parse_lambda_build_capture_slot_name(lambda_id: u64, capture_idx: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__lambda_cap_";
    var prefix_len: u64 = 13;
    var id_buf: u64 = heap_alloc(32 * sizeof(u8));
    var id_len: u64 = io_u64_to_ascii(id_buf, lambda_id);
    var idx_buf: u64 = heap_alloc(32 * sizeof(u8));
    var idx_len: u64 = io_u64_to_ascii(idx_buf, capture_idx);
    var total_len: u64 = prefix_len + id_len + 1 + idx_len;
    var out_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, total_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, id_buf, id_len);
    out_u8[prefix_len + id_len] = 95;
    str_copy(out_ptr + prefix_len + id_len + 1, idx_buf, idx_len);
    out_u8[total_len] = 0;
    return new NameInfo{out_ptr, total_len};
}

func parse_lambda_build_bind_param_name(capture_idx: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__cap_";
    var prefix_len: u64 = 6;
    var idx_buf: u64 = heap_alloc(32 * sizeof(u8));
    var idx_len: u64 = io_u64_to_ascii(idx_buf, capture_idx);
    var total_len: u64 = prefix_len + idx_len;
    var out_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, total_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, idx_buf, idx_len);
    out_u8[total_len] = 0;
    return new NameInfo{out_ptr, total_len};
}

func parse_lambda_make_u64_param(name_ptr: u64, name_len: u64) -> *Param {
    var p: *Param = new Param();
    p.name_ptr = name_ptr;
    p.name_len = name_len;
    parse_lambda_param_set_default(p);
    return p;
}

func parse_lambda_emit_capture_globals(p: *Parser, captures: *Vec<*LambdaCapture>, lambda_id: u64) -> u64 {
    if (captures == 0) { return 0; }
    var n: u64 = captures.len();
    for (var i: u64 = 0; i < n; i++) {
        var c: *LambdaCapture = captures.get(i);
        var slot_name: *NameInfo = parse_lambda_build_capture_slot_name(lambda_id, i);
        c.slot_ptr = slot_name.ptr;
        c.slot_len = slot_name.len;

        var ginfo: *GlobalInfo = new GlobalInfo();
        ginfo.name_ptr = slot_name.ptr;
        ginfo.name_len = slot_name.len;
        ginfo.typeinfo_ptr = new TypeInfo(TYPE_U64, 0);
        ginfo.init_kind = GLOBAL_INIT_VALUE;
        ginfo.init_value = 0;
        ginfo.init_name_ptr = 0;
        ginfo.init_name_len = 0;
        ginfo.init_expr = 0;
        ginfo.annotations_vec = 0;
        parse_generated_globals_push(p, (u64)ginfo);
    }
    return 0;
}

func parse_lambda_capture_slot_for_name(captures: *Vec<*LambdaCapture>, name_ptr: u64, name_len: u64) -> *NameInfo {
    var c: *LambdaCapture = parse_lambda_capture_find(captures, name_ptr, name_len);
    if (c == 0 || c.slot_ptr == 0 || c.slot_len == 0) { return 0; }
    return new NameInfo{c.slot_ptr, c.slot_len};
}

func parse_lambda_rewrite_expr_captures(node: *AstNode, captures: *Vec<*LambdaCapture>) -> u64 {
    if (node == 0 || captures == 0 || captures.len() == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)node;
            var slot: *NameInfo = parse_lambda_capture_slot_for_name(captures, id.name_ptr, id.name_len);
            if (slot != 0) {
                id.name_ptr = slot.ptr;
                id.name_len = slot.len;
            }
            return 0;
        case AST_CALL:
            var call: *AstCall = (*AstCall)node;
            var slot2: *NameInfo = parse_lambda_capture_slot_for_name(captures, call.name_ptr, call.name_len);
            if (slot2 != 0) {
                call.name_ptr = slot2.ptr;
                call.name_len = slot2.len;
            }
            if (call.args_vec != 0) {
                var cn: u64 = call.args_vec.len();
                for (var ci: u64 = 0; ci < cn; ci++) {
                    parse_lambda_rewrite_expr_captures(call.args_vec.get(ci), captures);
                }
            }
            return 0;
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)node;
            parse_lambda_rewrite_expr_captures(bin.left, captures);
            parse_lambda_rewrite_expr_captures(bin.right, captures);
            return 0;
        case AST_UNARY:
            return parse_lambda_rewrite_expr_captures(((*AstUnary)node).operand, captures);
        case AST_ADDR_OF:
            return parse_lambda_rewrite_expr_captures(((*AstAddrOf)node).operand, captures);
        case AST_DEREF:
            return parse_lambda_rewrite_expr_captures(((*AstDeref)node).operand, captures);
        case AST_DEREF8:
            return parse_lambda_rewrite_expr_captures(((*AstDeref8)node).operand, captures);
        case AST_CAST:
            return parse_lambda_rewrite_expr_captures(((*AstCast)node).expr, captures);
        case AST_TRY:
            return parse_lambda_rewrite_expr_captures(((*AstTry)node).operand, captures);
        case AST_SIZEOF_EXPR:
            return parse_lambda_rewrite_expr_captures(((*AstSizeofExpr)node).expr, captures);
        case AST_INDEX:
            var idx: *AstIndex = (*AstIndex)node;
            parse_lambda_rewrite_expr_captures(idx.base, captures);
            parse_lambda_rewrite_expr_captures(idx.index, captures);
            return 0;
        case AST_MEMBER_ACCESS:
        case AST_SAFE_MEMBER_ACCESS:
            return parse_lambda_rewrite_expr_captures(((*AstMemberAccess)node).object, captures);
        case AST_METHOD_CALL:
        case AST_SAFE_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)node;
            parse_lambda_rewrite_expr_captures(mc.receiver, captures);
            if (mc.args_vec != 0) {
                var an: u64 = mc.args_vec.len();
                for (var ai: u64 = 0; ai < an; ai++) {
                    parse_lambda_rewrite_expr_captures(mc.args_vec.get(ai), captures);
                }
            }
            return 0;
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)node;
            parse_lambda_rewrite_expr_captures(cp.callee, captures);
            if (cp.args_vec != 0) {
                var cpn: u64 = cp.args_vec.len();
                for (var cpi: u64 = 0; cpi < cpn; cpi++) {
                    parse_lambda_rewrite_expr_captures(cp.args_vec.get(cpi), captures);
                }
            }
            return 0;
        case AST_GENERIC_CALL:
            var gc: *AstGenericCall = (*AstGenericCall)node;
            if (gc.args_vec != 0) {
                var gcn: u64 = gc.args_vec.len();
                for (var gci: u64 = 0; gci < gcn; gci++) {
                    parse_lambda_rewrite_expr_captures(gc.args_vec.get(gci), captures);
                }
            }
            return 0;
        case AST_STATIC_GENERIC_CALL:
            var sgc: *AstStaticGenericCall = (*AstStaticGenericCall)node;
            if (sgc.args_vec != 0) {
                var sgn: u64 = sgc.args_vec.len();
                for (var sgi: u64 = 0; sgi < sgn; sgi++) {
                    parse_lambda_rewrite_expr_captures(sgc.args_vec.get(sgi), captures);
                }
            }
            return 0;
        case AST_STRUCT_LITERAL:
            var sl: *AstStructLiteral = (*AstStructLiteral)node;
            if (sl.values_vec != 0) {
                var sn: u64 = sl.values_vec.len();
                for (var si: u64 = 0; si < sn; si++) {
                    parse_lambda_rewrite_expr_captures(sl.values_vec.get(si), captures);
                }
            }
            return 0;
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)node;
            if (gsl.values_vec != 0) {
                var gsn: u64 = gsl.values_vec.len();
                for (var gsi: u64 = 0; gsi < gsn; gsi++) {
                    parse_lambda_rewrite_expr_captures(gsl.values_vec.get(gsi), captures);
                }
            }
            return 0;
        case AST_SLICE:
            var slice_node: *AstSlice = (*AstSlice)node;
            parse_lambda_rewrite_expr_captures(slice_node.ptr_expr, captures);
            parse_lambda_rewrite_expr_captures(slice_node.len_expr, captures);
            return 0;
        case AST_NEW:
            var nw: *AstNew = (*AstNew)node;
            if (nw.literal_expr != 0) {
                parse_lambda_rewrite_expr_captures(nw.literal_expr, captures);
            }
            if (nw.ctor_args_vec != 0) {
                var nn: u64 = nw.ctor_args_vec.len();
                for (var ni: u64 = 0; ni < nn; ni++) {
                    parse_lambda_rewrite_expr_captures(nw.ctor_args_vec.get(ni), captures);
                }
            }
            return 0;
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)node;
            if (sc.ctor_args_vec != 0) {
                var sn2: u64 = sc.ctor_args_vec.len();
                for (var si2: u64 = 0; si2 < sn2; si2++) {
                    parse_lambda_rewrite_expr_captures(sc.ctor_args_vec.get(si2), captures);
                }
            }
            return 0;
    }
    return 0;
}

func parse_primary_lambda_expr(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_FUNC);
    parse_consume(p, TOKEN_LPAREN);

    var params: *Vec<*Param> = new Vec<*Param>(4);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_lambda_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_lambda_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_I64;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;
    if (parse_match(p, TOKEN_ARROW)) {
        var ret_ti: *TypeInfo = parse_type_ex(p);
        ret_type = ret_ti.type_kind;
        ret_ptr_depth = ret_ti.ptr_depth;
        ret_is_tagged = ret_ti.is_tagged;
        ret_struct_name_ptr = ret_ti.struct_name_ptr;
        ret_struct_name_len = ret_ti.struct_name_len;
        ret_tag_layout_ptr = ret_ti.tag_layout_ptr;
        ret_tag_layout_len = ret_ti.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ret_ti.elem_type_kind;
            ret_ptr_depth = ret_ti.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ret_ti.struct_name_ptr;
            ret_struct_name_len = ret_ti.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    parse_consume(p, TOKEN_LBRACE);
    if (parse_peek_kind(p) == TOKEN_RBRACE) {
        emit_stderr("[ERROR] lambda body expression is required\n");
        parse_panic_here(p, "Syntax error");
    }
    var body_expr: *AstNode = parse_expr(p);
    parse_match(p, TOKEN_SEMICOLON);
    parse_consume(p, TOKEN_RBRACE);

    var lambda_id: u64 = parse_next_generated_id(p);
    var lambda_body_name: *NameInfo = parse_lambda_build_name_with_prefix("__lambda_body_", 14, lambda_id);

    var captures: *Vec<*LambdaCapture> = new Vec<*LambdaCapture>(4);
    parse_lambda_collect_expr_captures(p, body_expr, params, captures);
    parse_lambda_emit_capture_globals(p, captures, lambda_id);
    parse_lambda_rewrite_expr_captures(body_expr, captures);

    var body_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    body_stmts.push((*AstNode)ast_return(body_expr));
    var body: *AstNode = (*AstNode)ast_block(body_stmts);

    var lambda_fn: *AstFunc = ast_func_ex(lambda_body_name.ptr, lambda_body_name.len, params,
                                          ret_type, ret_ptr_depth, ret_is_tagged,
                                          ret_struct_name_ptr, ret_struct_name_len,
                                          ret_tag_layout_ptr, ret_tag_layout_len, body);
    parse_generated_funcs_push(p, (u64)lambda_fn);

    if (captures == 0 || captures.len() == 0) {
        var fn_ident: *AstNode = (*AstNode)ast_ident(lambda_body_name.ptr, lambda_body_name.len);
        return (*AstNode)ast_addr_of(fn_ident);
    }

    var bind_name: *NameInfo = parse_lambda_build_name_with_prefix("__lambda_bind_", 14, lambda_id);
    var bind_params: *Vec<*Param> = new Vec<*Param>(captures.len());
    var bind_body_stmts: *Vec<*AstNode> = new Vec<*AstNode>(captures.len() + 1);
    var bind_call_args: *Vec<*AstNode> = new Vec<*AstNode>(captures.len());

    var cap_n: u64 = captures.len();
    for (var ci: u64 = 0; ci < cap_n; ci++) {
        var cap: *LambdaCapture = captures.get(ci);
        var bind_param_name: *NameInfo = parse_lambda_build_bind_param_name(ci);
        bind_params.push(parse_lambda_make_u64_param(bind_param_name.ptr, bind_param_name.len));

        bind_body_stmts.push((*AstNode)ast_assign(
            (*AstNode)ast_ident(cap.slot_ptr, cap.slot_len),
            (*AstNode)ast_ident(bind_param_name.ptr, bind_param_name.len)
        ));
        bind_call_args.push((*AstNode)ast_ident(cap.name_ptr, cap.name_len));
    }

    bind_body_stmts.push((*AstNode)ast_return(
        (*AstNode)ast_addr_of((*AstNode)ast_ident(lambda_body_name.ptr, lambda_body_name.len))
    ));
    var bind_body: *AstNode = (*AstNode)ast_block(bind_body_stmts);

    var bind_fn: *AstFunc = ast_func_ex(bind_name.ptr, bind_name.len, bind_params,
                                        TYPE_U64, 0, 0, 0, 0, 0, 0, bind_body);
    parse_generated_funcs_push(p, (u64)bind_fn);

    return (*AstNode)ast_call_with_origin_named(bind_name.ptr, bind_name.len, bind_call_args, 0, AST_CALL_ORIGIN_DIRECT);
}

func parse_match_expr_make_case_body(expr: *AstNode) -> *AstNode {
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    stmts.push((*AstNode)ast_return(expr));
    return (*AstNode)ast_block(stmts);
}

func parse_match_expr_make_empty_call(name_ptr: u64, name_len: u64) -> *AstNode {
    var args: *Vec<*AstNode> = new Vec<*AstNode>(0);
    return (*AstNode)ast_call_with_origin_named(name_ptr, name_len, args, 0, AST_CALL_ORIGIN_DIRECT);
}

func parse_primary_match_expr(p: *Parser) -> *AstNode {
    parse_consume(p, TOKEN_MATCH);
    parse_consume(p, TOKEN_LPAREN);
    var scrutinee_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    parse_consume(p, TOKEN_LBRACE);

    var lambda_id: u64 = parse_next_generated_id(p);
    var fn_name: *NameInfo = parse_lambda_build_name_with_prefix("__match_expr_", 13, lambda_id);
    var tmp_name: *NameInfo = parse_lambda_build_name_with_prefix("__match_tmp_", 12, lambda_id);

    var captures: *Vec<*LambdaCapture> = new Vec<*LambdaCapture>(4);
    parse_lambda_collect_expr_captures(p, scrutinee_expr, 0, captures);

    var cases: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var case_value_nodes: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var arm_expr_nodes: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var default_count: u64 = 0;

    while (parse_peek_kind(p) != TOKEN_RBRACE && parse_peek_kind(p) != TOKEN_EOF) {
        var is_default_case: u64 = 0;
        var case_values: *Vec<*AstNode> = new Vec<*AstNode>(2);

        if (parse_peek_kind(p) == TOKEN_CASE) {
            parse_consume(p, TOKEN_CASE);
            while (1) {
                if (parse_peek_kind(p) == TOKEN_IDENTIFIER) {
                    var maybe_wild: *Token = parse_peek(p);
                    if (maybe_wild.len == 1) {
                        var wild_u8: []u8 = slice(maybe_wild.ptr, 1);
                        if (wild_u8[0] == 95) {
                            parse_adv(p);
                            is_default_case = 1;
                            default_count = default_count + 1;
                            if (parse_peek_kind(p) == TOKEN_COMMA) {
                                emit_stderr("[ERROR] wildcard '_' cannot be mixed with other case values in match expression\n");
                                parse_panic_here(p, "Syntax error");
                            }
                            break;
                        }
                    }
                }
                case_values.push(parse_expr(p));
                if (parse_match(p, TOKEN_COMMA) == 0) { break; }
            }
            parse_consume(p, TOKEN_COLON);
        } else if (parse_peek_kind(p) == TOKEN_DEFAULT) {
            parse_consume(p, TOKEN_DEFAULT);
            parse_consume(p, TOKEN_COLON);
            is_default_case = 1;
            default_count = default_count + 1;
        } else {
            emit_stderr("[ERROR] Expected 'case' or 'default' in match expression\n");
            parse_panic_here(p, "Syntax error");
            break;
        }

        if (parse_peek_kind(p) == TOKEN_SEMICOLON) {
            emit_stderr("[ERROR] match expression arm value is required\n");
            parse_panic_here(p, "Syntax error");
        }
        var arm_expr: *AstNode = parse_expr(p);
        parse_consume(p, TOKEN_SEMICOLON);
        arm_expr_nodes.push(arm_expr);
        parse_lambda_collect_expr_captures(p, arm_expr, 0, captures);

        if (is_default_case != 0) {
            cases.push(ast_case((*AstNode)ast_literal(0), parse_match_expr_make_case_body(arm_expr), 1));
        } else {
            if (case_values.len() == 0) {
                emit_stderr("[ERROR] case value is required in match expression\n");
                parse_panic_here(p, "Syntax error");
            }
            var cvn: u64 = case_values.len();
            for (var cvi: u64 = 0; cvi < cvn; cvi++) {
                var cexpr: *AstNode = case_values.get(cvi);
                case_value_nodes.push(cexpr);
                parse_lambda_collect_expr_captures(p, cexpr, 0, captures);
                cases.push(ast_case(cexpr, parse_match_expr_make_case_body(arm_expr), 0));
            }
        }
    }

    parse_consume(p, TOKEN_RBRACE);
    if (default_count == 0) {
        emit_stderr("[ERROR] match expression requires a default arm ('default' or 'case _')\n");
        parse_panic_here(p, "Syntax error");
    }

    parse_lambda_emit_capture_globals(p, captures, lambda_id);
    parse_lambda_rewrite_expr_captures(scrutinee_expr, captures);
    var cvn2: u64 = case_value_nodes.len();
    for (var i: u64 = 0; i < cvn2; i++) {
        parse_lambda_rewrite_expr_captures(case_value_nodes.get(i), captures);
    }
    var an: u64 = arm_expr_nodes.len();
    for (var ai: u64 = 0; ai < an; ai++) {
        parse_lambda_rewrite_expr_captures(arm_expr_nodes.get(ai), captures);
    }

    var fn_body_stmts: *Vec<*AstNode> = new Vec<*AstNode>(4);
    fn_body_stmts.push((*AstNode)ast_var_decl(tmp_name.ptr, tmp_name.len, TYPE_U64, 0, scrutinee_expr));
    fn_body_stmts.push((*AstNode)ast_match((*AstNode)ast_ident(tmp_name.ptr, tmp_name.len), cases));
    fn_body_stmts.push((*AstNode)ast_return((*AstNode)ast_literal(0)));
    var fn_body: *AstNode = (*AstNode)ast_block(fn_body_stmts);

    var fn: *AstFunc = ast_func_ex(fn_name.ptr, fn_name.len, new Vec<*Param>(0),
                                   TYPE_U64, 0, 0, 0, 0, 0, 0, fn_body);
    parse_generated_funcs_push(p, (u64)fn);

    if (captures == 0 || captures.len() == 0) {
        return parse_match_expr_make_empty_call(fn_name.ptr, fn_name.len);
    }

    var bind_name: *NameInfo = parse_lambda_build_name_with_prefix("__match_bind_", 13, lambda_id);
    var bind_params: *Vec<*Param> = new Vec<*Param>(captures.len());
    var bind_stmts: *Vec<*AstNode> = new Vec<*AstNode>(captures.len() + 1);
    var bind_call_args: *Vec<*AstNode> = new Vec<*AstNode>(captures.len());

    var cap_n: u64 = captures.len();
    for (var ci: u64 = 0; ci < cap_n; ci++) {
        var cap: *LambdaCapture = captures.get(ci);
        var bind_param_name: *NameInfo = parse_lambda_build_bind_param_name(ci);
        bind_params.push(parse_lambda_make_u64_param(bind_param_name.ptr, bind_param_name.len));
        bind_stmts.push((*AstNode)ast_assign(
            (*AstNode)ast_ident(cap.slot_ptr, cap.slot_len),
            (*AstNode)ast_ident(bind_param_name.ptr, bind_param_name.len)
        ));
        bind_call_args.push((*AstNode)ast_ident(cap.name_ptr, cap.name_len));
    }
    bind_stmts.push((*AstNode)ast_return(parse_match_expr_make_empty_call(fn_name.ptr, fn_name.len)));
    var bind_body: *AstNode = (*AstNode)ast_block(bind_stmts);
    var bind_fn: *AstFunc = ast_func_ex(bind_name.ptr, bind_name.len, bind_params,
                                        TYPE_U64, 0, 0, 0, 0, 0, 0, bind_body);
    parse_generated_funcs_push(p, (u64)bind_fn);
    return (*AstNode)ast_call_with_origin_named(bind_name.ptr, bind_name.len, bind_call_args, 0, AST_CALL_ORIGIN_DIRECT);
}

func parse_resolve_struct_def(name_ptr: u64, name_len: u64) -> *AstStructDef {
    var struct_def: *AstStructDef = get_struct_def(name_ptr, name_len);
    if (struct_def != 0) { return struct_def; }
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved == 0) { return 0; }
    return get_struct_def(resolved.ptr, resolved.len);
}

func parse_primary_identifier_generic_call(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_is_generic_call(p) == 0) { return 0; }
    var generic_args: *Vec<*GenericArg> = parse_generic_args(p);
    var parsed_args: *ParseCallArgs = parse_call_args_paren(p, 1);
    return (*AstNode)ast_generic_call_with_origin_named(tok4.ptr, tok4.len, generic_args, parsed_args.args, parsed_args.arg_names, AST_CALL_ORIGIN_DIRECT);
}

func parse_primary_identifier_generic_struct_literal(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_is_generic_struct_literal(p) == 0) { return 0; }
    var generic_args: *Vec<*GenericArg> = parse_generic_args_type(p);
    if (parse_peek_kind(p) != TOKEN_LBRACE) { return 0; }
    var values: *Vec<*AstNode> = parse_expr_list_brace(p);
    return (*AstNode)ast_generic_struct_literal(tok4.ptr, tok4.len, generic_args, values);
}

func parse_primary_identifier_slice_literal(p: *Parser, tok4: *Token) -> *AstNode {
    if (tok4.len != 5) { return 0; }
    if (str_eq(tok4.ptr, tok4.len, "slice", 5) == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_LPAREN) { return 0; }
    parse_adv(p);
    var ptr_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_COMMA);
    var len_expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    return ast_slice(ptr_expr, len_expr);
}

func parse_primary_identifier_struct_literal(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_peek_kind(p) != TOKEN_LBRACE) { return 0; }
    var struct_def: *AstStructDef = parse_resolve_struct_def(tok4.ptr, tok4.len);
    if (struct_def == 0) {
        emit_stderr("[ERROR] Unknown struct/union type for literal: ");
        emit_stderr_len(tok4.ptr, tok4.len);
        emit_stderr("\n");
        parse_panic_here(p, "Syntax error");
        return (*AstNode)ast_literal(0);
    }
    var values: *Vec<*AstNode> = parse_expr_list_brace(p);
    if (struct_def.is_union == 1 && values.len() > 1) {
        emit_stderr("[ERROR] union literal accepts at most one initializer\n");
        parse_panic_here(p, "Syntax error");
    }
    return ast_struct_literal(struct_def, values);
}

func parse_primary_identifier_static_method_call(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_peek_kind(p) != TOKEN_DOT) { return 0; }

    var saved_pos: u64 = parser_pos(p);
    parse_adv(p); // consume '.'

    var method_kind: u64 = parse_peek_kind(p);
    if (method_kind != TOKEN_IDENTIFIER && method_kind != TOKEN_NEW && method_kind != TOKEN_DELETE && method_kind != TOKEN_CONSTRUCTOR && method_kind != TOKEN_DESTRUCTOR) {
        parser_set_pos(p, saved_pos);
        return 0;
    }
    var method_tok: *Token = parse_peek(p);
    parse_adv(p);

    var has_generic: u64 = 0;
    var generic_args: *Vec<*GenericArg> = 0;
    if (parse_is_generic_call(p)) {
        generic_args = parse_generic_args(p);
        has_generic = 1;
    }

    // Non-generic static calls (Type.method(...)) are parsed as normal method calls
    // and lowered in compiler pass. Keep this parser fast path only for generic static calls
    // because postfix parser doesn't represent method generic arguments yet.
    if (has_generic == 0) {
        parser_set_pos(p, saved_pos);
        return 0;
    }

    if (parse_peek_kind(p) != TOKEN_LPAREN) {
        parser_set_pos(p, saved_pos);
        return 0;
    }

    var args: *ParseCallArgs = parse_call_args_paren(p, 1);
    return (*AstNode)ast_static_generic_call_named(tok4.ptr, tok4.len, method_tok.ptr, method_tok.len, generic_args, args.args, args.arg_names);
}

func parse_primary_identifier_call_or_ctor(p: *Parser, tok4: *Token) -> *AstNode {
    if (parse_peek_kind(p) != TOKEN_LPAREN) { return 0; }
    var args: *ParseCallArgs = parse_call_args_paren(p, 1);
    return (*AstNode)ast_call_with_origin_named(tok4.ptr, tok4.len, args.args, args.arg_names, AST_CALL_ORIGIN_DIRECT);
}

func parse_primary_identifier(p: *Parser, tok4: *Token) -> *AstNode {
    var node: *AstNode = parse_primary_identifier_generic_call(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_generic_struct_literal(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_slice_literal(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_struct_literal(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_static_method_call(p, tok4);
    if (node != 0) { return node; }
    node = parse_primary_identifier_call_or_ctor(p, tok4);
    if (node != 0) { return node; }
    return ast_ident(tok4.ptr, tok4.len);
}

func parse_identifier_is_known_type(p: *Parser, name_ptr: u64, name_len: u64) -> u64 {
    if (compiler_is_trait_name(name_ptr, name_len) != 0) { return 1; }
    if (is_struct_type(name_ptr, name_len) != 0) { return 1; }
    if (type_parser_find_generic_param(p, name_ptr, name_len) != 0) { return 1; }
    if (compiler_impl_has_generic_param(name_ptr, name_len) != 0) { return 1; }

    // Generic type lookahead (syntax-only): Name<...>
    var saved_pos: u64 = parser_pos(p);
    parse_adv(p);
    if (parse_peek_kind(p) == TOKEN_LT) {
        // Require a well-formed generic list followed by ')' for sizeof(type).
        var is_generic_type_syntax: u64 = parse_scan_generic_list_followed_by(p, TOKEN_RPAREN, 1, 1);
        parser_set_pos(p, saved_pos);
        if (is_generic_type_syntax != 0) { return 1; }
        return 0;
    }
    parser_set_pos(p, saved_pos);
    return 0;
}

func parse_primary_sizeof_is_type(p: *Parser) -> u64 {
    var nk: u64 = parse_peek_kind(p);
    var is_type: u64 = 0;
    if (nk == TOKEN_STAR || nk == TOKEN_BOOL || nk == TOKEN_U8 || nk == TOKEN_U16 || nk == TOKEN_U32 || nk == TOKEN_U64 || nk == TOKEN_I8 || nk == TOKEN_I16 || nk == TOKEN_I32 || nk == TOKEN_I64 || nk == TOKEN_F64 || nk == TOKEN_LBRACKET) {
        is_type = 1;
    } else if (nk == TOKEN_IDENTIFIER) {
        var t: *Token = parse_peek(p);
        is_type = parse_identifier_is_known_type(p, t.ptr, t.len);
    }
    return is_type;
}

func parse_primary_sizeof(p: *Parser) -> *AstNode {
    parse_adv(p);
    parse_consume(p, TOKEN_LPAREN);

    if (parse_primary_sizeof_is_type(p) != 0) {
        var ty: *TypeInfo = parse_type_ex(p);
        var type_kind: u64 = ty.type_kind;
        var ptr_depth: u64 = ty.ptr_depth;
        var struct_name_ptr: u64 = ty.struct_name_ptr;
        var struct_name_len: u64 = ty.struct_name_len;
        var elem_type_kind: u64 = ty.elem_type_kind;
        var elem_ptr_depth: u64 = ty.elem_ptr_depth;
        var array_len: u64 = ty.array_len;
        var array_len_is_param: u64 = ty.array_len_is_param;
        var array_len_param_ptr: u64 = ty.array_len_param_ptr;
        var array_len_param_len: u64 = ty.array_len_param_len;
        var elem_typeinfo: *TypeInfo = ty.elem_typeinfo;

        parse_consume(p, TOKEN_RPAREN);
        return ast_sizeof(type_kind, ptr_depth, struct_name_ptr, struct_name_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len, elem_typeinfo);
    }

    var expr: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    return ast_sizeof_expr(expr);
}

func parse_primary_new_expr(p: *Parser) -> *AstNode {
    parse_adv(p);
    var ty_new: *TypeInfo = parse_type_ex(p);
    var literal_expr: *AstNode = 0;
    var ctor_args_vec: *Vec<*AstNode> = 0;

    if (parse_peek_kind(p) == TOKEN_LBRACE) {
        if (ty_new.type_kind != TYPE_STRUCT) {
            emit_stderr("[ERROR] new { ... } is only supported for struct types\n");
            parse_panic_here(p, "Syntax error");
        }
        var struct_def_new: *AstStructDef = parse_resolve_struct_def(ty_new.struct_name_ptr, ty_new.struct_name_len);
        if (struct_def_new == 0) {
            emit_stderr("[ERROR] Struct definition not found for new literal\n");
            parse_panic_here(p, "Syntax error");
        }
        var values_new: *Vec<*AstNode> = parse_expr_list_brace(p);
        if (struct_def_new.is_union == 1 && values_new.len() > 1) {
            emit_stderr("[ERROR] union literal accepts at most one initializer\n");
            parse_panic_here(p, "Syntax error");
        }
        literal_expr = (*AstNode)ast_struct_literal(struct_def_new, values_new);
    }

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        if (ty_new.type_kind != TYPE_STRUCT) {
            emit_stderr("[ERROR] new(...) constructor call requires struct type\n");
            parse_panic_here(p, "Syntax error");
        }
        ctor_args_vec = parse_expr_list_paren(p);
    }

    return (*AstNode)ast_new(ty_new.type_kind, ty_new.ptr_depth, ty_new.is_tagged, ty_new.struct_name_ptr, ty_new.struct_name_len,
                             ty_new.tag_layout_ptr, ty_new.tag_layout_len, ty_new.elem_type_kind, ty_new.elem_ptr_depth,
                             ty_new.array_len, ty_new.array_len_is_param, ty_new.array_len_param_ptr, ty_new.array_len_param_len, ty_new.elem_typeinfo,
                             literal_expr, ctor_args_vec);
}

func parse_primary_paren_or_cast(p: *Parser) -> *AstNode {
    parse_adv(p);
    var next_k: u64 = parse_peek_kind(p);
    if (next_k == TOKEN_STAR || next_k == TOKEN_BOOL || next_k == TOKEN_U8 || next_k == TOKEN_U16 ||
        next_k == TOKEN_U32 || next_k == TOKEN_U64 || next_k == TOKEN_I8 || next_k == TOKEN_I16 || next_k == TOKEN_I32 || next_k == TOKEN_I64 ||
        next_k == TOKEN_F64 || next_k == TOKEN_CHAR || next_k == TOKEN_LBRACKET) {
        var ty2: *TypeInfo = parse_type_ex(p);
        var type_kind2: u64 = ty2.type_kind;
        var ptr_depth2: u64 = ty2.ptr_depth;
        var is_tagged2: u64 = ty2.is_tagged;
        var struct_name_ptr2: u64 = ty2.struct_name_ptr;
        var struct_name_len2: u64 = ty2.struct_name_len;
        var tag_layout_ptr2: u64 = ty2.tag_layout_ptr;
        var tag_layout_len2: u64 = ty2.tag_layout_len;

        parse_consume(p, TOKEN_RPAREN);
        var operand3: *AstNode = parse_unary(p);
        return ast_cast_ex(operand3, type_kind2, ptr_depth2, is_tagged2, struct_name_ptr2, struct_name_len2, tag_layout_ptr2, tag_layout_len2);
    }

    if (next_k == TOKEN_IDENTIFIER) {
        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok.ptr;
        var name_len: u64 = name_tok.len;
        var is_known_type: u64 = parse_identifier_is_known_type(p, name_ptr, name_len);

        if (is_known_type != 0) {
            var saved_pos: u64 = parser_pos(p);
            var ty_id: *TypeInfo = parse_type_ex(p);
            if (parse_peek_kind(p) == TOKEN_RPAREN) {
                var type_kind3: u64 = ty_id.type_kind;
                var ptr_depth3: u64 = ty_id.ptr_depth;
                var is_tagged3: u64 = ty_id.is_tagged;
                var struct_name_ptr3: u64 = ty_id.struct_name_ptr;
                var struct_name_len3: u64 = ty_id.struct_name_len;
                var tag_layout_ptr3: u64 = ty_id.tag_layout_ptr;
                var tag_layout_len3: u64 = ty_id.tag_layout_len;

                parse_consume(p, TOKEN_RPAREN);
                var operand4: *AstNode = parse_unary(p);
                return ast_cast_ex(operand4, type_kind3, ptr_depth3, is_tagged3, struct_name_ptr3, struct_name_len3, tag_layout_ptr3, tag_layout_len3);
            }
            parser_set_pos(p, saved_pos);
        }
    }

    var expr2: *AstNode = parse_expr(p);
    parse_consume(p, TOKEN_RPAREN);
    return parse_postfix_from(p, expr2);
}

func parse_primary(p: *Parser) -> *AstNode {
    push_trace("parse_primary", "parser/expr.b", __LINE__);
    defer pop_trace();
    var k: u64 = parse_peek_kind(p);
    
    switch (k) {
        case TOKEN_NUMBER:
            var tok: *Token = parse_peek(p);
            parse_adv(p);
                return ast_literal(parse_num_val(tok));
        case TOKEN_FLOAT:
            var ftok: *Token = parse_peek(p);
            parse_adv(p);
                return ast_float(ftok.ptr, ftok.len);
        case TOKEN_LINE_MACRO:
            var tok2: *Token = parse_peek(p);
            parse_adv(p);
            var line: u64 = tok2.line;
                return ast_literal(line);
        case TOKEN_TRUE:
            parse_adv(p);
            var true_lit: *AstNode = (*AstNode)ast_literal(1);
                return (*AstNode)ast_cast_ex(true_lit, TYPE_BOOL, 0, 0, 0, 0, 0, 0);
        case TOKEN_FALSE:
            parse_adv(p);
            var false_lit: *AstNode = (*AstNode)ast_literal(0);
                return (*AstNode)ast_cast_ex(false_lit, TYPE_BOOL, 0, 0, 0, 0, 0, 0);
        case TOKEN_NULL:
            parse_adv(p);
                return ast_literal(0);
        case TOKEN_STRING:
            var tok3: *Token = parse_peek(p);
            parse_adv(p);
                return ast_string(tok3.ptr, tok3.len);
        case TOKEN_CHAR:
            var ctok: *Token = parse_peek(p);
            parse_adv(p);
            if (parse_is_char_literal_token(ctok) == 0) {
                emit_stderr("[ERROR] Invalid char literal\n");
                parse_panic_at_tok(ctok, "Syntax error");
            }
            return ast_literal(parse_char_literal_value(ctok));
        case TOKEN_SIZEOF:
            return parse_primary_sizeof(p);
        case TOKEN_NEW:
            return parse_primary_new_expr(p);
        case TOKEN_FUNC:
            return parse_primary_lambda_expr(p);
        case TOKEN_MATCH:
            return parse_primary_match_expr(p);
        case TOKEN_AMPERSAND:
            parse_adv(p);
            var operand: *AstNode = parse_unary(p);
            if (operand == 0) {
                emit_stderr("[ERROR] Expected expression after &\n");
                return 0;
            }
                return ast_addr_of(operand);
        case TOKEN_STAR:
            parse_adv(p);
            var operand2: *AstNode = parse_unary(p);
                return ast_deref(operand2);
        case TOKEN_LPAREN:
            return parse_primary_paren_or_cast(p);
        case TOKEN_IDENTIFIER:
            var tok4: *Token = parse_peek(p);
            parse_adv(p);
            return parse_primary_identifier(p, tok4);
        case TOKEN_SUPER:
            parse_adv(p);
            return (*AstNode)ast_super();
        default:
            return 0;
    }
}

func parse_is_generic_list_followed_by(p: *Parser, follow_kind: u64) -> u64 {
    return parse_scan_generic_list_followed_by(p, follow_kind, 1, 0);
}

// Lookahead for generic call: <...>(...)
func parse_is_generic_call(p: *Parser) -> u64 {
    return parse_is_generic_list_followed_by(p, TOKEN_LPAREN);
}

// Lookahead for generic struct literal: <...>{...}
func parse_is_generic_struct_literal(p: *Parser) -> u64 {
    return parse_is_generic_list_followed_by(p, TOKEN_LBRACE);
}

// Parse generic argument list: <T, U, 8>
func parse_generic_args(p: *Parser) -> *Vec<*GenericArg> {
    // Keep one implementation in parser/type to avoid drift between
    // expression-position and type-position generic parsing.
    return parse_generic_args_type(p);
}

// ============================================
// Postfix Expression
// ============================================

func parse_postfix_after_dot(p: *Parser, left: *AstNode, is_safe: u64) -> *AstNode {
    if (parse_peek_kind(p) == TOKEN_LT) {
        parse_adv(p);
        var parent_tok: *Token = parse_peek(p);
        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            if (is_safe != 0) {
                emit_stderr("[ERROR] Expected parent struct name after '.?<'\n");
            } else {
                emit_stderr("[ERROR] Expected parent struct name after '.<'\n");
            }
            parse_panic_here(p, "Syntax error");
        }
        parse_adv(p);
        parse_consume_generic_gt(p);
        var scoped_field_tok: *Token = parse_peek(p);
        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected field name after parent scope\n");
            parse_panic_here(p, "Syntax error");
        }
        parse_adv(p);
        if (is_safe != 0) {
            return ast_safe_member_access_scoped(left, parent_tok.ptr, parent_tok.len, scoped_field_tok.ptr, scoped_field_tok.len);
        }
        return ast_member_access_scoped(left, parent_tok.ptr, parent_tok.len, scoped_field_tok.ptr, scoped_field_tok.len);
    }

    var field_tok: *Token = parse_peek(p);
    var field_kind: u64 = parse_peek_kind(p);
    if (field_kind != TOKEN_IDENTIFIER && field_kind != TOKEN_NEW && field_kind != TOKEN_DELETE && field_kind != TOKEN_CONSTRUCTOR && field_kind != TOKEN_DESTRUCTOR) {
        if (is_safe != 0) {
            emit_stderr("[ERROR] Expected identifier after '.?'\n");
        } else {
            emit_stderr("[ERROR] Expected identifier after '.'\n");
        }
        parse_panic_here(p, "Syntax error");
    }
    parse_adv(p);

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        var call_args: *ParseCallArgs = parse_call_args_paren(p, 1);
        if (is_safe != 0) {
            return (*AstNode)ast_safe_method_call_named(left, field_tok.ptr, field_tok.len, call_args.args, call_args.arg_names);
        }
        return (*AstNode)ast_method_call_named(left, field_tok.ptr, field_tok.len, call_args.args, call_args.arg_names);
    }

    if (is_safe != 0) {
        return ast_safe_member_access(left, field_tok.ptr, field_tok.len);
    }
    return ast_member_access(left, field_tok.ptr, field_tok.len);
}

func parse_postfix_from(p: *Parser, left: *AstNode) -> *AstNode {
    while (1) {
        var k: u64 = parse_peek_kind(p);

        switch (k) {
            case TOKEN_LBRACKET:
                parse_adv(p);
                var idx: *AstNode = parse_expr(p);
                parse_consume(p, TOKEN_RBRACKET);
                left = ast_index(left, idx);
                break;
            case TOKEN_LPAREN:
                var ptr_call_args: *ParseCallArgs = parse_call_args_paren(p, 0);
                left = ast_call_ptr(left, ptr_call_args.args);
                break;
            case TOKEN_DOT:
                parse_adv(p);
                left = parse_postfix_after_dot(p, left, 0);
                break;
            case TOKEN_DOT_Q:
                parse_adv(p);
                left = parse_postfix_after_dot(p, left, 1);
                break;
            case TOKEN_QUESTION:
                parse_adv(p);
                left = ast_try(left);
                break;
            default:
                return left;
        }
    }
}

func parse_postfix(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_primary(p);
    if (left != 0 && ast_kind(left) == AST_SUPER) {
        var k: u64 = parse_peek_kind(p);
        if (k != TOKEN_DOT && k != TOKEN_DOT_Q) {
            emit_stderr("[ERROR] 'super' must be followed by '.' and a member name\n");
            parse_panic_here(p, "Syntax error");
        }
    }
    return parse_postfix_from(p, left);
}

// ============================================
// Unary Expression
// ============================================

func parse_unary(p: *Parser) -> *AstNode {
    var k: u64 = parse_peek_kind(p);
    
    switch (k) {
        case TOKEN_STAR:
            parse_adv(p);
            var operand: *AstNode = parse_unary(p);
            return ast_deref(operand);
        case TOKEN_MINUS:
            parse_adv(p);
            var next_k: u64 = parse_peek_kind(p);
            if (next_k == TOKEN_NUMBER) {
                var tok: *Token = parse_peek(p);
                parse_adv(p);
                var val: u64 = parse_num_val(tok);
                var lit: *AstNode = ast_literal(val);
                return ast_unary(TOKEN_MINUS, lit);
            }
            var operand2: *AstNode = parse_unary(p);
            return ast_unary(TOKEN_MINUS, operand2);
        case TOKEN_BANG:
            parse_adv(p);
            var operand3: *AstNode = parse_unary(p);
            return ast_unary(TOKEN_BANG, operand3);
        case TOKEN_TILDE:
            parse_adv(p);
            var operand4: *AstNode = parse_unary(p);
            return ast_unary(TOKEN_TILDE, operand4);
        default:
            return parse_postfix(p);
    }
}

// ============================================
// Binary Expressions (Precedence Climbing)
// ============================================

func parse_mul(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_unary(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_STAR:
                parse_adv(p);
                var right: *AstNode = parse_unary(p);
                left = ast_binary(TOKEN_STAR, left, right);
                break;
            case TOKEN_SLASH:
                parse_adv(p);
                var right2: *AstNode = parse_unary(p);
                left = ast_binary(TOKEN_SLASH, left, right2);
                break;
            case TOKEN_PERCENT:
                parse_adv(p);
                var right3: *AstNode = parse_unary(p);
                left = ast_binary(TOKEN_PERCENT, left, right3);
                break;
            default:
                return left;
        }
    }
}

func parse_add(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_mul(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_PLUS:
                parse_adv(p);
                var right: *AstNode = parse_mul(p);
                left = ast_binary(TOKEN_PLUS, left, right);
                break;
            case TOKEN_MINUS:
                parse_adv(p);
                var right2: *AstNode = parse_mul(p);
                left = ast_binary(TOKEN_MINUS, left, right2);
                break;
            default:
                return left;
        }
    }
}

func parse_shift(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_add(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_LSHIFT:
                parse_adv(p);
                var right: *AstNode = parse_add(p);
                left = ast_binary(TOKEN_LSHIFT, left, right);
                break;
            case TOKEN_RSHIFT:
                parse_adv(p);
                var right2: *AstNode = parse_add(p);
                left = ast_binary(TOKEN_RSHIFT, left, right2);
                break;
            default:
                return left;
        }
    }
}

func parse_rel(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_shift(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_LT:
                parse_adv(p);
                var right: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_LT, left, right);
                break;
            case TOKEN_GT:
                parse_adv(p);
                var right2: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_GT, left, right2);
                break;
            case TOKEN_LTEQ:
                parse_adv(p);
                var right3: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_LTEQ, left, right3);
                break;
            case TOKEN_GTEQ:
                parse_adv(p);
                var right4: *AstNode = parse_shift(p);
                left = ast_binary(TOKEN_GTEQ, left, right4);
                break;
            default:
                return left;
        }
    }
}

func parse_eq(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_rel(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_EQEQ:
                parse_adv(p);
                var right: *AstNode = parse_rel(p);
                left = ast_binary(TOKEN_EQEQ, left, right);
                break;
            case TOKEN_BANGEQ:
                parse_adv(p);
                var right2: *AstNode = parse_rel(p);
                left = ast_binary(TOKEN_BANGEQ, left, right2);
                break;
            default:
                return left;
        }
    }
}

func parse_bitand(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_eq(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_AMPERSAND:
                parse_adv(p);
                var right: *AstNode = parse_eq(p);
                left = ast_binary(TOKEN_AMPERSAND, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_bitxor(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_bitand(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_CARET:
                parse_adv(p);
                var right: *AstNode = parse_bitand(p);
                left = ast_binary(TOKEN_CARET, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_bitor(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_bitxor(p);
    
    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_PIPE:
                parse_adv(p);
                var right: *AstNode = parse_bitxor(p);
                left = ast_binary(TOKEN_PIPE, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_logand(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_bitor(p);

    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_ANDAND:
                parse_adv(p);
                var right: *AstNode = parse_bitor(p);
                left = ast_binary(TOKEN_ANDAND, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_logor(p: *Parser) -> *AstNode {
    var left: *AstNode = parse_logand(p);

    while (1) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_OROR:
                parse_adv(p);
                var right: *AstNode = parse_logand(p);
                left = ast_binary(TOKEN_OROR, left, right);
                break;
            default:
                return left;
        }
    }
}

func parse_expr(p: *Parser) -> *AstNode {
    push_trace("parse_expr", "parser/expr.b", __LINE__);
    defer pop_trace();
    var expr: *AstNode = parse_logor(p);
    if (expr == 0) {
        emit_stderr("[ERROR] Expected expression\n");
        parse_panic_here(p, "Expected expression");
    }
    return expr;
}
