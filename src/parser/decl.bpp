// parse_decl.b - Declaration parsing
//
// Parses top-level declarations:
// - const declarations
// - import declarations
// - function declarations (parameters, return types, body)
// - struct definitions
// - enum definitions
// - impl blocks
// - parse_program (entry point)

import std.io;
import std.vec;
import std.util;
import std.str;
import module_utils;
import types;
import lexer;
import ast;
import compiler;
import parser.util;
import parser.type;
import parser.expr;
import parser.stmt;

// ============================================
// Const Declaration
// ============================================

func parse_const_eval_expr(p: *Parser, node: *AstNode, ok: *u64) -> u64 {
    if (node == 0) {
        *ok = 0;
        return 0;
    }

    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_LITERAL:
            return ((*AstLiteral)node).value;
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)node;
            var cres: *ConstResult = (*ConstResult)compiler_find_const(id.name_ptr, id.name_len);
            if (cres != 0 && cres.found != 0) {
                return cres.value;
            }
            emit_stderr("[ERROR] Unknown const in const expression: ");
            emit_stderr_len(id.name_ptr, id.name_len);
            emit_stderr("\n");
            *ok = 0;
            return 0;
        case AST_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)node;
            if (ma.parent_ptr != 0 || ast_kind(ma.object) != AST_IDENT) {
                emit_stderr("[ERROR] Unsupported member access in const expression\n");
                *ok = 0;
                return 0;
            }
            var sid: *AstIdent = (*AstIdent)ma.object;
            var scoped: *ConstResult = (*ConstResult)compiler_find_scoped_const(sid.name_ptr, sid.name_len, ma.member_ptr, ma.member_len);
            if (scoped != 0 && scoped.found != 0) {
                return scoped.value;
            }
            emit_stderr("[ERROR] Unknown scoped const in const expression: ");
            emit_stderr_len(sid.name_ptr, sid.name_len);
            emit_stderr(".");
            emit_stderr_len(ma.member_ptr, ma.member_len);
            emit_stderr("\n");
            *ok = 0;
            return 0;
        case AST_CAST:
            var cast_node: *AstCast = (*AstCast)node;
            return parse_const_eval_expr(p, cast_node.expr, ok);
        case AST_UNARY:
            var un: *AstUnary = (*AstUnary)node;
            var sub_ok: u64 = 1;
            var val: u64 = parse_const_eval_expr(p, un.operand, &sub_ok);
            if (sub_ok == 0) {
                *ok = 0;
                return 0;
            }
            switch (un.op) {
                case TOKEN_MINUS:
                    return 0 - val;
                case TOKEN_BANG:
                    if (val == 0) { return 1; }
                    return 0;
                case TOKEN_TILDE:
                    return ~val;
                default:
                    emit_stderr("[ERROR] Unsupported unary operator in const expression\n");
                    *ok = 0;
                    return 0;
            }
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)node;
            var left_ok: u64 = 1;
            var right_ok: u64 = 1;
            var left: u64 = parse_const_eval_expr(p, bin.left, &left_ok);
            var right: u64 = parse_const_eval_expr(p, bin.right, &right_ok);
            if (left_ok == 0 || right_ok == 0) {
                *ok = 0;
                return 0;
            }
            switch (bin.op) {
                case TOKEN_PLUS: return left + right;
                case TOKEN_MINUS: return left - right;
                case TOKEN_STAR: return left * right;
                case TOKEN_SLASH:
                    if (right == 0) {
                        emit_stderr("[ERROR] Division by zero in const expression\n");
                        parse_panic_here(p, "Syntax error");
                    }
                    return left / right;
                case TOKEN_PERCENT:
                    if (right == 0) {
                        emit_stderr("[ERROR] Modulo by zero in const expression\n");
                        parse_panic_here(p, "Syntax error");
                    }
                    return left % right;
                case TOKEN_LSHIFT: return left << right;
                case TOKEN_RSHIFT: return left >> right;
                case TOKEN_AMPERSAND: return left & right;
                case TOKEN_PIPE: return left | right;
                case TOKEN_CARET: return left ^ right;
                case TOKEN_EQEQ:
                    if (left == right) { return 1; }
                    return 0;
                case TOKEN_BANGEQ:
                    if (left != right) { return 1; }
                    return 0;
                case TOKEN_LT:
                    if (left < right) { return 1; }
                    return 0;
                case TOKEN_LTEQ:
                    if (left <= right) { return 1; }
                    return 0;
                case TOKEN_GT:
                    if (left > right) { return 1; }
                    return 0;
                case TOKEN_GTEQ:
                    if (left >= right) { return 1; }
                    return 0;
                case TOKEN_ANDAND:
                    if (left != 0 && right != 0) { return 1; }
                    return 0;
                case TOKEN_OROR:
                    if (left != 0 || right != 0) { return 1; }
                    return 0;
                default:
                    emit_stderr("[ERROR] Unsupported binary operator in const expression\n");
                    *ok = 0;
                    return 0;
            }
        default:
            emit_stderr("[ERROR] Const expression must be compile-time evaluable\n");
            *ok = 0;
            return 0;
    }
}

func parse_const_decl(p: *Parser) -> *AstConstDecl {
    parse_consume(p, TOKEN_CONST);
    
    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;

    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_EQ);

    var expr: *AstNode = parse_expr(p);
    
    parse_consume(p, TOKEN_SEMICOLON);

    var ok: u64 = 1;
    var value: u64 = parse_const_eval_expr(p, expr, &ok);
    if (ok == 0) {
        parse_panic_here(p, "Syntax error");
    }
    
    return ast_const_decl(name_ptr, name_len, value);
}

func parse_import_expect_module_token(p: *Parser) -> *Token {
    var tok: *Token = parse_peek(p);
    var kind: u64 = parse_peek_kind(p);
    if (kind == TOKEN_IDENTIFIER) {
        parse_adv(p);
        return tok;
    }
    if (kind == TOKEN_CHAR && parse_is_keyword_char_token(tok) != 0) {
        parse_adv(p);
        return tok;
    }
    emit_stderr("[ERROR] Expected module identifier in import\n");
    parse_panic_here(p, "Syntax error");
    return 0;
}

func parse_import_parse_path_suffix(p: *Parser, path_ptr_in: u64, path_len_in: u64) -> *NameInfo {
    var path_ptr: u64 = path_ptr_in;
    var path_len: u64 = path_len_in;
    while (parse_match(p, TOKEN_DOT)) {
        var next_tok: *Token = parse_import_expect_module_token(p);
        var joined_path: u64 = str_concat(path_ptr, path_len, "/", 1);
        path_ptr = str_concat(joined_path, path_len + 1, next_tok.ptr, next_tok.len);
        path_len = path_len + 1 + next_tok.len;
    }
    return new NameInfo{path_ptr, path_len};
}

// ============================================
// Import Declaration
// ============================================

func parse_import_decl(p: *Parser) -> *AstImport {
    parse_consume(p, TOKEN_IMPORT);

    var first_tok: *Token = parse_import_expect_module_token(p);

    // Selective import: import <symbol> [as <alias>] from <module>
    if (parse_peek_kind(p) == TOKEN_AS || parse_peek_kind(p) == TOKEN_FROM) {
        var symbol_ptr: u64 = first_tok.ptr;
        var symbol_len: u64 = first_tok.len;
        var alias_ptr: u64 = symbol_ptr;
        var alias_len: u64 = symbol_len;

        if (parse_match(p, TOKEN_AS)) {
            var alias_tok: *Token = parse_peek(p);
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] Expected alias identifier in import\n");
                parse_panic_here(p, "Syntax error");
            }
            alias_ptr = alias_tok.ptr;
            alias_len = alias_tok.len;
            parse_consume(p, TOKEN_IDENTIFIER);
        }

        parse_consume(p, TOKEN_FROM);

        var mod_tok: *Token = parse_import_expect_module_token(p);
        var path_info: *NameInfo = parse_import_parse_path_suffix(p, mod_tok.ptr, mod_tok.len);

        parse_consume(p, TOKEN_SEMICOLON);

        return ast_import(path_info.ptr, path_info.len, symbol_ptr, symbol_len, alias_ptr, alias_len);
    }

    // Import module: import <module>;
    var path_info2: *NameInfo = parse_import_parse_path_suffix(p, first_tok.ptr, first_tok.len);
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    return ast_import(path_info2.ptr, path_info2.len, 0, 0, 0, 0);
}

// ============================================
// Function Parsing
// ============================================

// Skip a block without parsing its contents
func parse_skip_block(p: *Parser) -> u64 {
    parse_consume(p, TOKEN_LBRACE);
    var depth: u64 = 1;
    while (depth > 0) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_EOF:
                emit_stderr("[ERROR] Unexpected EOF while skipping block\n");
                parse_panic_here(p, "Syntax error");
                break;
            case TOKEN_LBRACE:
                depth = depth + 1;
                break;
            case TOKEN_RBRACE:
                depth = depth - 1;
            default:
                break;
        }
        parse_adv(p);
    }
    return 0;
}

func parse_is_generic_param_list_impl(p: *Parser, require_follow_lparen: u64) -> u64 {
    return parse_scan_generic_list_followed_by(p, TOKEN_LPAREN, require_follow_lparen, 1);
}

func parse_is_generic_param_list(p: *Parser) -> u64 {
    return parse_is_generic_param_list_impl(p, 1);
}

func parse_is_generic_param_list_any(p: *Parser) -> u64 {
    return parse_is_generic_param_list_impl(p, 0);
}

func parse_is_impl_trait_block(p: *Parser) -> u64 {
    if (parse_peek_kind(p) != TOKEN_IMPL) { return false; }
    var saved: u64 = parser_pos(p);
    parse_adv(p);
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
        parser_set_pos(p, saved);
        return false;
    }
    parse_adv(p);
    var k: u64 = parse_peek_kind(p);
    parser_set_pos(p, saved);
    if (k == TOKEN_FOR) { return true; }
    return false;
}

// Parse generic parameter list: <T, U, const N: u64>
// allow_any:
//   0 => require the list to be directly followed by '(' (function generic params)
//   1 => accept any well-formed generic parameter list
func parse_generic_params_impl(p: *Parser, allow_any: u64) -> *Vec<*GenericParam> {
    var tok: *Token = parse_peek(p);
    if (tok == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_LT) { return 0; }
    if (allow_any != 0) {
        if (parse_is_generic_param_list_any(p) == 0) { return 0; }
    } else {
        if (parse_is_generic_param_list(p) == 0) { return 0; }
    }
    parse_consume(p, TOKEN_LT);

    var params: *Vec<*GenericParam> = new Vec<*GenericParam>(4);
    while (1) {
        var is_value: u64 = 0;
        if (parse_match(p, TOKEN_CONST)) { is_value = 1; }

        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected generic parameter name\n");
            parse_panic_here(p, "Syntax error");
        }

        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok.ptr;
        var name_len: u64 = name_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);

        var value_type_kind: u64 = 0;
        if (parse_match(p, TOKEN_COLON)) {
            value_type_kind = parse_base_type(p);
            if (value_type_kind == TYPE_STRUCT || value_type_kind == TYPE_VOID) {
                emit_stderr("[ERROR] Invalid value generic type\n");
                parse_panic_here(p, "Syntax error");
            }
            if (value_type_kind != TYPE_U64) {
                emit_stderr("[ERROR] Value generic type must be u64\n");
                parse_panic_here(p, "Syntax error");
            }
            is_value = 1;
        } else if (is_value == 1) {
            emit_stderr("[ERROR] const generic requires type annotation\n");
            parse_panic_here(p, "Syntax error");
        }

        var gp: *GenericParam = new GenericParam();
        if (is_value == 1) { gp.kind = GENERIC_KIND_VALUE; }
        else { gp.kind = GENERIC_KIND_TYPE; }
        gp.name_ptr = name_ptr;
        gp.name_len = name_len;
        gp.value_type_kind = value_type_kind;
        params.push(gp);

        if (parse_match(p, TOKEN_COMMA)) { continue; }
        break;
    }

    parse_consume_generic_gt(p);
    return params;
}

// Parse generic parameter list for structs/impls: <T, U, const N: u64>
func parse_generic_params_any(p: *Parser) -> *Vec<*GenericParam> {
    push_trace("parse_generic_params_any", "parser/decl.b", __LINE__);
    defer pop_trace();
    return parse_generic_params_impl(p, 1);
}

func parse_param(p: *Parser) -> *Param {
    var is_variadic: u64 = 0;
    if (parse_match(p, TOKEN_DOT)) {
        parse_consume(p, TOKEN_DOT);
        parse_consume(p, TOKEN_DOT);
        is_variadic = 1;
    }

    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(p, generic_params);
    }

    var param: *Param = new Param();
    param.name_ptr = name_tok.ptr;
    param.name_len = name_tok.len;
    param.is_variadic = is_variadic;
    param.has_default = 0;
    param.default_expr = 0;

    if (parse_match(p, TOKEN_COLON)) {
        var ty: *TypeInfo = parse_type_ex(p);
        param.fill_from_typeinfo(ty);
        param.decay_array_to_ptr();
    } else {
        // Backward-compatible shorthand: untyped parameters default to u64.
        param.type_kind = TYPE_U64;
        param.ptr_depth = 0;
        param.is_tagged = 0;
        param.struct_name_ptr = 0;
        param.struct_name_len = 0;
        param.tag_layout_ptr = 0;
        param.tag_layout_len = 0;
        param.elem_type_kind = 0;
        param.elem_ptr_depth = 0;
        param.array_len = 0;
        param.array_len_is_param = 0;
        param.array_len_param_ptr = 0;
        param.array_len_param_len = 0;
        param.elem_typeinfo = 0;
    }

    if (parse_match(p, TOKEN_EQ)) {
        param.default_expr = (u64)parse_expr(p);
        param.has_default = 1;
    }

    return param;
}

func parse_validate_params(p: *Parser, params: *Vec<*Param>) -> u64 {
    if (params == 0) { return 0; }
    var n: u64 = params.len();
    var seen_default: u64 = 0;
    var seen_variadic: u64 = 0;
    for (var i: u64 = 0; i < n; i++) {
        var param: *Param = params.get(i);
        if (param == 0) { continue; }

        for (var j: u64 = 0; j < i; j++) {
            var prev: *Param = params.get(j);
            if (prev == 0) { continue; }
            if (str_eq(prev.name_ptr, prev.name_len, param.name_ptr, param.name_len) != 0) {
                emit_stderr("[ERROR] duplicate parameter name: ");
                emit_stderr_len(param.name_ptr, param.name_len);
                emit_stderr("\n");
                parse_panic_here(p, "Syntax error");
            }
        }

        if (param.is_variadic != 0) {
            if (seen_variadic != 0) {
                emit_stderr("[ERROR] only one variadic parameter is allowed\n");
                parse_panic_here(p, "Syntax error");
            }
            seen_variadic = 1;
            if (i + 1 != n) {
                emit_stderr("[ERROR] variadic parameter must be the last parameter\n");
                parse_panic_here(p, "Syntax error");
            }
            if (param.has_default != 0) {
                emit_stderr("[ERROR] variadic parameter cannot have default value\n");
                parse_panic_here(p, "Syntax error");
            }
            continue;
        }
        if (param.has_default != 0) {
            seen_default = 1;
        } else if (seen_default != 0) {
            emit_stderr("[ERROR] non-default parameter cannot follow default parameter\n");
            parse_panic_here(p, "Syntax error");
        }
    }
    return 0;
}

struct ParsedFuncHeader {
    public annotations: *Vec<*NameInfo>;
    public name_tok: *Token;
    public generic_params: *Vec<*GenericParam>;
    public params: *Vec<*Param>;
    public ret_type: u64;
    public ret_ptr_depth: u64;
    public ret_is_tagged: u64;
    public ret_struct_name_ptr: u64;
    public ret_struct_name_len: u64;
    public ret_tag_layout_ptr: u64;
    public ret_tag_layout_len: u64;
}

impl ParsedFuncHeader {
    public constructor() {
        self.annotations = 0;
        self.name_tok = 0;
        self.generic_params = 0;
        self.params = 0;
        self.ret_type = TYPE_VOID;
        self.ret_ptr_depth = 0;
        self.ret_is_tagged = 0;
        self.ret_struct_name_ptr = 0;
        self.ret_struct_name_len = 0;
        self.ret_tag_layout_ptr = 0;
        self.ret_tag_layout_len = 0;
    }
}

func parse_func_header(p: *Parser) -> *ParsedFuncHeader {
    var annotations: *Vec<*NameInfo> = parse_take_leading_annotations(p);
    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER && name_kind != TOKEN_NEW && name_kind != TOKEN_DELETE) {
        emit_stderr("[ERROR] Expected function name identifier\n");
        parse_panic_here(p, "Syntax error");
    }
    parse_adv(p);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(p, generic_params);
    }

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);
    parse_validate_params(p, params);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    var parsed: *ParsedFuncHeader = new ParsedFuncHeader();
    parsed.annotations = annotations;
    parsed.name_tok = name_tok;
    parsed.generic_params = generic_params;
    parsed.params = params;
    parsed.ret_type = ret_type;
    parsed.ret_ptr_depth = ret_ptr_depth;
    parsed.ret_is_tagged = ret_is_tagged;
    parsed.ret_struct_name_ptr = ret_struct_name_ptr;
    parsed.ret_struct_name_len = ret_struct_name_len;
    parsed.ret_tag_layout_ptr = ret_tag_layout_ptr;
    parsed.ret_tag_layout_len = ret_tag_layout_len;
    return parsed;
}

func parse_func_from_header(parsed: *ParsedFuncHeader, body: *AstNode) -> *AstFunc {
    var name_tok: *Token = parsed.name_tok;
    var func_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, parsed.params,
                                          parsed.ret_type, parsed.ret_ptr_depth, parsed.ret_is_tagged,
                                          parsed.ret_struct_name_ptr, parsed.ret_struct_name_len,
                                          parsed.ret_tag_layout_ptr, parsed.ret_tag_layout_len, body);
    func_node.annotations_vec = parsed.annotations;
    return func_node;
}

func parse_register_generic_func(p: *Parser, name_tok: *Token, generic_params: *Vec<*GenericParam>, func_node: *AstFunc, is_definition: u64) -> u64 {
    if (generic_params == 0) { return 0; }
    type_parser_clear_generic_params(p);
    if (is_definition != 0) {
        compiler_register_generic_func_def(name_tok.ptr, name_tok.len, generic_params, func_node);
        return 0;
    }
    compiler_register_generic_func_sig(name_tok.ptr, name_tok.len, generic_params, func_node);
    return 0;
}

func parse_func_decl(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl", "parser/decl.b", __LINE__);
    defer pop_trace();

    var parsed: *ParsedFuncHeader = parse_func_header(p);
    var name_tok: *Token = parsed.name_tok;
    var generic_params: *Vec<*GenericParam> = parsed.generic_params;

    var body: *AstNode = parse_block(p);

    var func_node: *AstFunc = parse_func_from_header(parsed, body);
    parse_register_generic_func(p, name_tok, generic_params, func_node, 1);
    return func_node;
}

// Parse function signature only (skip body)
func parse_func_decl_signature(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl_signature", "parser/decl.b", __LINE__);
    defer pop_trace();

    var parsed: *ParsedFuncHeader = parse_func_header(p);
    var name_tok: *Token = parsed.name_tok;
    var generic_params: *Vec<*GenericParam> = parsed.generic_params;
    var is_generic_decl: u64 = 0;
    if (generic_params != 0) { is_generic_decl = 1; }

    if (parse_peek_kind(p) == TOKEN_LBRACE) {
        parse_skip_block(p);
    } else if (parse_match(p, TOKEN_SEMICOLON) == 0) {
        emit_stderr("[ERROR] Function declaration must have a body or end with ';'\n");
        parse_panic_here(p, "Syntax error");
    }

    var func_sig: *AstFunc = parse_func_from_header(parsed, 0);
    parse_register_generic_func(p, name_tok, generic_params, func_sig, 0);
    if (is_generic_decl != 0) { return 0; }
    return func_sig;
}

func parse_func_decl_top_level(p: *Parser) -> *AstFunc {
    var parsed: *ParsedFuncHeader = parse_func_header(p);
    var name_tok: *Token = parsed.name_tok;
    var generic_params: *Vec<*GenericParam> = parsed.generic_params;

    if (parse_match(p, TOKEN_SEMICOLON)) {
        var sig: *AstFunc = parse_func_from_header(parsed, 0);
        parse_register_generic_func(p, name_tok, generic_params, sig, 0);
        return 0;
    }

    var body: *AstNode = parse_block(p);
    var func_node: *AstFunc = parse_func_from_header(parsed, body);
    parse_register_generic_func(p, name_tok, generic_params, func_node, 1);
    return func_node;
}

// Parse abstract function signature (no body, ends with ';')
func parse_func_decl_abst_signature(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl_abst_signature", "parser/decl.b", __LINE__);
    defer pop_trace();

    var parsed: *ParsedFuncHeader = parse_func_header(p);
    var name_tok: *Token = parsed.name_tok;
    var generic_params: *Vec<*GenericParam> = parsed.generic_params;

    parse_consume(p, TOKEN_SEMICOLON);

    var func_sig: *AstFunc = parse_func_from_header(parsed, 0);
    parse_register_generic_func(p, name_tok, generic_params, func_sig, 0);
    return func_sig;
}

// ============================================
// Struct Parsing
// ============================================

func parse_uwidth_from_ident(ptr: u64, len: u64) -> u64 {
    if (len < 2) { return 0; }
    var ptr_u8: *u8 = (*u8)ptr;
    var first: u64 = ptr_u8[0];
    if (first != 117) { return 0; }
    var value: u64 = 0;
    for (var i: u64 = 1; i < len; i++) {
        var c: u64 = ptr_u8[i];
        if (c < 48 || c > 57) { return 0; }
        value = value * 10 + (c - 48);
    }
    return value;
}

struct ParseStructInheritance {
    public parents: *Vec<*ParentDesc>;
    public traits: *Vec<*TraitRef>;
}

func parse_struct_parse_inheritance(p: *Parser, struct_name_ptr: u64, struct_name_len: u64) -> ParseStructInheritance {
    var inheritance: ParseStructInheritance;
    var parents: *Vec<*ParentDesc> = 0;
    var traits: *Vec<*TraitRef> = 0;
    if (parse_match(p, TOKEN_COLON)) {
        parents = new Vec<*ParentDesc>(4);
        while (1) {
            var parent_tok: *Token = parse_peek(p);
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] Expected parent struct name after ':'\n");
                parse_panic_here(p, "Syntax error");
            }
            parse_adv(p);
            if (str_eq(parent_tok.ptr, parent_tok.len, struct_name_ptr, struct_name_len)) {
                emit_stderr("[ERROR] Struct cannot inherit from itself\n");
                parse_panic_here(p, "Syntax error");
            }
            if (compiler_is_trait_name(parent_tok.ptr, parent_tok.len) != 0) {
                if (traits == 0) { traits = new Vec<*TraitRef>(4); }
                var tref: *TraitRef = new TraitRef();
                tref.name_ptr = parent_tok.ptr;
                tref.name_len = parent_tok.len;
                tref.trait_def = compiler_get_trait_def(parent_tok.ptr, parent_tok.len);
                traits.push(tref);
                if (!parse_match(p, TOKEN_COMMA)) { break; }
                continue;
            }
            var parent_desc: *ParentDesc = new ParentDesc();
            parent_desc.name_ptr = parent_tok.ptr;
            parent_desc.name_len = parent_tok.len;
            parents.push(parent_desc);
            if (!parse_match(p, TOKEN_COMMA)) { break; }
        }
    }
    inheritance.parents = parents;
    inheritance.traits = traits;
    return inheritance;
}

func parse_struct_validate_constraints(p: *Parser, is_packed: u64, is_union: u64, parents: *Vec<*ParentDesc>, traits: *Vec<*TraitRef>) -> u64 {
    if (is_union == 1) {
        if (is_packed == 1) {
            emit_stderr("[ERROR] packed union is not supported\n");
            parse_panic_here(p, "Syntax error");
        }
        if (parents != 0 && parents.len() > 0) {
            emit_stderr("[ERROR] union cannot use inheritance\n");
            parse_panic_here(p, "Syntax error");
        }
        if (traits != 0 && traits.len() > 0) {
            emit_stderr("[ERROR] union cannot use trait inheritance\n");
            parse_panic_here(p, "Syntax error");
        }
        return 0;
    }
    if (is_packed == 1 && parents != 0 && parents.len() > 0) {
        emit_stderr("[ERROR] packed struct cannot use inheritance\n");
        parse_panic_here(p, "Syntax error");
    }
    if (is_packed == 1 && traits != 0 && traits.len() > 0) {
        emit_stderr("[ERROR] packed struct cannot use trait inheritance\n");
        parse_panic_here(p, "Syntax error");
    }
    return 0;
}

struct ParsePackedFieldType {
    public type_kind: u64;
    public bit_width: u64;
}

func parse_struct_parse_packed_field_type(p: *Parser) -> ParsePackedFieldType {
    var packed_type: ParsePackedFieldType;
    packed_type.type_kind = 0;
    packed_type.bit_width = 0;
    var k: u64 = parse_peek_kind(p);
    switch (k) {
        case TOKEN_BOOL:
            parse_adv(p);
            packed_type.type_kind = TYPE_BOOL;
            packed_type.bit_width = 8;
            break;
        case TOKEN_U8:
            parse_adv(p);
            packed_type.type_kind = TYPE_U8;
            packed_type.bit_width = 8;
            break;
        case TOKEN_U16:
            parse_adv(p);
            packed_type.type_kind = TYPE_U16;
            packed_type.bit_width = 16;
            break;
        case TOKEN_U32:
            parse_adv(p);
            packed_type.type_kind = TYPE_U32;
            packed_type.bit_width = 32;
            break;
        case TOKEN_U64:
            parse_adv(p);
            packed_type.type_kind = TYPE_U64;
            packed_type.bit_width = 64;
            break;
        case TOKEN_I8:
            parse_adv(p);
            packed_type.type_kind = TYPE_I8;
            packed_type.bit_width = 8;
            break;
        case TOKEN_I16:
            parse_adv(p);
            packed_type.type_kind = TYPE_I16;
            packed_type.bit_width = 16;
            break;
        case TOKEN_I32:
            parse_adv(p);
            packed_type.type_kind = TYPE_I32;
            packed_type.bit_width = 32;
            break;
        case TOKEN_I64:
            parse_adv(p);
            packed_type.type_kind = TYPE_I64;
            packed_type.bit_width = 64;
            break;
        case TOKEN_IDENTIFIER:
            var bw_tok: *Token = parse_peek(p);
            var bw_ptr: u64 = bw_tok.ptr;
            var bw_len: u64 = bw_tok.len;
            parse_adv(p);
            var bw: u64 = parse_uwidth_from_ident(bw_ptr, bw_len);
            if (bw == 0 || bw > 64) {
                emit_stderr("[ERROR] packed field must be integer width type\n");
                parse_panic_here(p, "Syntax error");
            }
            packed_type.type_kind = TYPE_U64;
            packed_type.bit_width = bw;
            break;
        default:
            emit_stderr("[ERROR] packed field must be integer width type\n");
            parse_panic_here(p, "Syntax error");
    }
    return packed_type;
}

func parse_member_access_modifier(p: *Parser, default_access: u64) -> u64 {
    if (parse_peek_kind(p) == TOKEN_PUBLIC) {
        parse_adv(p);
        return ACCESS_PUBLIC;
    }
    if (parse_peek_kind(p) == TOKEN_PRIVATE) {
        parse_adv(p);
        return ACCESS_PRIVATE;
    }
    if (parse_peek_kind(p) == TOKEN_PROTECTED) {
        parse_adv(p);
        return ACCESS_PROTECTED;
    }
    return default_access;
}

func parse_struct_parse_field(p: *Parser, is_packed: u64, struct_name_ptr: u64, struct_name_len: u64) -> *FieldDesc {
    var access: u64 = parse_member_access_modifier(p, ACCESS_PRIVATE);

    var field_name_tok: *Token = parse_peek(p);
    var field_name_ptr: u64 = field_name_tok.ptr;
    var field_name_len: u64 = field_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);
    parse_consume(p, TOKEN_COLON);

    var field_type_kind: u64 = 0;
    var field_ptr_depth: u64 = 0;
    var field_struct_name_ptr: u64 = 0;
    var field_struct_name_len: u64 = 0;
    var field_tag_layout_ptr: u64 = 0;
    var field_tag_layout_len: u64 = 0;
    var field_elem_type_kind: u64 = 0;
    var field_elem_ptr_depth: u64 = 0;
    var field_array_len: u64 = 0;
    var field_elem_typeinfo: *TypeInfo = 0;
    var field_is_tagged: u64 = 0;
    var field_bit_width: u64 = 0;

    if (is_packed == 1) {
        var packed_type: ParsePackedFieldType = parse_struct_parse_packed_field_type(p);
        field_type_kind = packed_type.type_kind;
        field_bit_width = packed_type.bit_width;
    } else {
        var field_type: *TypeInfo = parse_type_ex(p);
        field_type_kind = field_type.type_kind;
        field_struct_name_ptr = field_type.struct_name_ptr;
        field_struct_name_len = field_type.struct_name_len;
        field_tag_layout_ptr = field_type.tag_layout_ptr;
        field_tag_layout_len = field_type.tag_layout_len;
        field_ptr_depth = field_type.ptr_depth;
        field_is_tagged = field_type.is_tagged;
        field_elem_type_kind = field_type.elem_type_kind;
        field_elem_ptr_depth = field_type.elem_ptr_depth;
        field_array_len = field_type.array_len;
        field_elem_typeinfo = field_type.elem_typeinfo;
    }

    parse_consume(p, TOKEN_SEMICOLON);

    var field_desc: *FieldDesc = new FieldDesc();
    field_desc.name_ptr = field_name_ptr;
    field_desc.name_len = field_name_len;
    field_desc.type_kind = field_type_kind;
    field_desc.struct_name_ptr = field_struct_name_ptr;
    field_desc.struct_name_len = field_struct_name_len;
    field_desc.ptr_depth = field_ptr_depth;
    field_desc.is_tagged = field_is_tagged;
    field_desc.tag_layout_ptr = field_tag_layout_ptr;
    field_desc.tag_layout_len = field_tag_layout_len;
    field_desc.bit_width = field_bit_width;
    field_desc.elem_type_kind = field_elem_type_kind;
    field_desc.elem_ptr_depth = field_elem_ptr_depth;
    field_desc.array_len = field_array_len;
    field_desc.elem_typeinfo = field_elem_typeinfo;
    field_desc.access = access;
    field_desc.owner_struct_ptr = struct_name_ptr;
    field_desc.owner_struct_len = struct_name_len;
    return field_desc;
}

func parse_struct_def(p: *Parser) -> *AstStructDef {
    push_trace("parse_struct_def", "parser/decl.b", __LINE__);
    defer pop_trace();
    var is_packed: u64 = 0;
    if (parse_match(p, TOKEN_PACKED)) {
        is_packed = 1;
    }
    var is_union: u64 = 0;
    if (parse_match(p, TOKEN_STRUCT) == 0) {
        if (parse_match(p, TOKEN_UNION) != 0) {
            is_union = 1;
        } else {
            emit_stderr("[ERROR] Expected struct or union declaration\n");
            parse_panic_here(p, "Syntax error");
        }
    }

    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(p, generic_params);
    }

    var parents: *Vec<*ParentDesc> = 0;
    var traits: *Vec<*TraitRef> = 0;
    if (is_union == 0) {
        var inheritance: ParseStructInheritance = parse_struct_parse_inheritance(p, name_ptr, name_len);
        parents = inheritance.parents;
        traits = inheritance.traits;
    } else if (parse_peek_kind(p) == TOKEN_COLON) {
        emit_stderr("[ERROR] union cannot declare inheritance list\n");
        parse_panic_here(p, "Syntax error");
    }
    parse_struct_validate_constraints(p, is_packed, is_union, parents, traits);

    parse_consume(p, TOKEN_LBRACE);
    
    var fields: *Vec<*FieldDesc> = new Vec<*FieldDesc>(8);
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        fields.push(parse_struct_parse_field(p, is_packed, name_ptr, name_len));
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    var struct_def: *AstStructDef = ast_struct_def(name_ptr, name_len, parents, fields, is_packed, traits, is_union);
    if (generic_params != 0) {
        type_parser_clear_generic_params(p);
        compiler_register_generic_struct_def(name_ptr, name_len, generic_params, struct_def);
    }
    return struct_def;
}

// ============================================
// Enum Parsing
// ============================================

func parse_enum_def(p: *Parser) -> *Vec<*AstConstDecl> {
    parse_consume(p, TOKEN_ENUM);
    
    var enum_name_tok: *Token = parse_peek(p);
    var enum_name_ptr: u64 = enum_name_tok.ptr;
    var enum_name_len: u64 = enum_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_LBRACE);
    
    var consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(16);
    var current_value: u64 = 0;
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        
        var member_tok: *Token = parse_peek(p);
        var member_ptr: u64 = member_tok.ptr;
        var member_len: u64 = member_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);
        
        // Check for explicit value
        if (parse_match(p, TOKEN_EQ)) {
            var explicit_expr: *AstNode = parse_expr(p);
            var expr_ok: u64 = 1;
            current_value = parse_const_eval_expr(p, explicit_expr, &expr_ok);
            if (expr_ok == 0) {
                emit_stderr("[ERROR] enum member value must be a compile-time constant expression\n");
                parse_panic_here(p, "Syntax error");
            }
        }
        
        // Create EnumName_MemberName
        var name_info: *NameInfo = module_util_build_joined_name(enum_name_ptr, enum_name_len, member_ptr, member_len);
        var const_node: *AstConstDecl = ast_const_decl(name_info.ptr, name_info.len, current_value);
        consts.push(const_node);
        
        current_value = current_value + 1;
        
        // Optional comma
        if (parse_peek_kind(p) == TOKEN_COMMA) {
            parse_consume(p, TOKEN_COMMA);
        }
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return consts;
}

// ============================================
// Impl Block Parsing
// ============================================

// ============================================
// Trait Parsing
// ============================================

func parse_trait_method_signature(p: *Parser, mode: u64) -> *AstFunc {
    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER) {
        emit_stderr("[ERROR] Expected trait method name identifier\n");
        parse_panic_here(p, "Syntax error");
    }
    parse_adv(p);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);
    parse_validate_params(p, params);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    var body: *AstNode = 0;
    if (parse_peek_kind(p) == TOKEN_SEMICOLON) {
        parse_adv(p);
    } else if (parse_peek_kind(p) == TOKEN_LBRACE) {
        // parse_program full mode is encoded as 0.
        if (mode == 0) {
            body = parse_block(p);
        } else {
            parse_skip_block(p);
        }
    } else {
        emit_stderr("[ERROR] trait method must end with ';' or method body\n");
        parse_panic_here(p, "Syntax error");
    }
    return ast_func_ex(name_tok.ptr, name_tok.len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, body);
}

func parse_trait_def(p: *Parser, mode: u64) -> *TraitDef {
    parse_consume(p, TOKEN_TRAIT);

    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var methods: *Vec<*TraitMethod> = new Vec<*TraitMethod>(8);
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        if (parse_peek_kind(p) != TOKEN_FUNC) {
            emit_stderr("[ERROR] trait block can only contain methods\n");
            parse_panic_here(p, "Syntax error");
        }
        var sig: *AstFunc = parse_trait_method_signature(p, mode);
        var tm: *TraitMethod = new TraitMethod();
        tm.name_ptr = sig.name_ptr;
        tm.name_len = sig.name_len;
        tm.sig = sig;
        tm.index = methods.len();
        methods.push(tm);
    }

    parse_consume(p, TOKEN_RBRACE);

    var td: *TraitDef = new TraitDef();
    td.name_ptr = name_ptr;
    td.name_len = name_len;
    td.methods_vec = methods;
    compiler_register_trait_def(td);
    return td;
}

func _make_self_param(struct_name_ptr: u64, struct_name_len: u64) -> *Param {
    var p: *Param = new Param();
    p.set_as_self_param(struct_name_ptr, struct_name_len);
    return p;
}

func parse_constructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_CONSTRUCTOR);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);
    parse_validate_params(p, params);

    if (parse_peek_kind(p) == TOKEN_ARROW) {
        emit_stderr("[ERROR] constructor cannot specify return type\n");
        parse_panic_here(p, "Syntax error");
    }

    var params_out: *Vec<*Param> = new Vec<*Param>(params.len() + 1);
    params_out.push(_make_self_param(struct_name_ptr, struct_name_len));
    for (var i: u64 = 0; i < params.len(); i++) {
        params_out.push(params.get(i));
    }

    if (sig_only != 0) {
        parse_skip_block(p);
        var sig_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
        compiler_register_generic_func_sig(name_tok.ptr, name_tok.len, 0, sig_node);
        return sig_node;
    }

    var body: *AstNode = parse_block(p);
    var func_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
    compiler_register_generic_func_def(name_tok.ptr, name_tok.len, 0, func_node);
    return func_node;
}

func parse_destructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_DESTRUCTOR);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        parse_adv(p);
        if (parse_peek_kind(p) != TOKEN_RPAREN) {
            emit_stderr("[ERROR] destructor cannot take parameters\n");
            parse_panic_here(p, "Syntax error");
        }
        parse_consume(p, TOKEN_RPAREN);
    }

    var params_out: *Vec<*Param> = new Vec<*Param>(1);
    params_out.push(_make_self_param(struct_name_ptr, struct_name_len));

    if (sig_only != 0) {
        parse_skip_block(p);
        return ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
    }

    var body: *AstNode = parse_block(p);
    return ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
}

func parser_mark_impl_method_metadata(struct_name_ptr: u64, struct_name_len: u64, func_node: *AstFunc, method_access: u64, method_is_override: u64) -> u64 {
    if (func_node == 0) { return 0; }
    func_node.impl_owner_ptr = struct_name_ptr;
    func_node.impl_owner_len = struct_name_len;
    func_node.impl_method_access = method_access;
    func_node.impl_original_name_ptr = func_node.name_ptr;
    func_node.impl_original_name_len = func_node.name_len;
    func_node.impl_name_finalized = 0;
    func_node.impl_is_override = method_is_override;
    return 0;
}

func parse_impl_parse_func_by_mode(p: *Parser, sig_only: u64) -> *AstFunc {
    if (sig_only != 0) {
        return parse_func_decl_signature(p);
    }
    return parse_func_decl(p);
}

struct ParseImplModifiers {
    public is_static: u64;
    public is_abst: u64;
    public is_override: u64;
    public access: u64;
    public annotations: *Vec<*NameInfo>;
}

func parse_impl_consume_override_annotation(p: *Parser, modifiers: *ParseImplModifiers) -> u64 {
    if (parse_peek_kind(p) != TOKEN_AT) { return 0; }

    var group: *Vec<*NameInfo> = parse_consume_annotation_group(p);
    if (group == 0 || group.len() == 0) { return 0; }

    var has_override: u64 = 0;
    var has_other: u64 = 0;
    var n: u64 = group.len();
    for (var i: u64 = 0; i < n; i++) {
        var info: *NameInfo = group.get(i);
        if (str_eq(info.ptr, info.len, "override", 8) != 0) {
            has_override = 1;
        } else {
            has_other = 1;
        }
    }

    if (has_override != 0 && has_other != 0) {
        emit_stderr("[ERROR] @[override] cannot be combined with other annotations in the same group\n");
        parse_panic_here(p, "Syntax error");
    }

    if (has_override != 0) {
        if (modifiers.is_override != 0 || n > 1) {
            emit_stderr("[ERROR] duplicate @[override] annotation\n");
            parse_panic_here(p, "Syntax error");
        }
        modifiers.is_override = 1;
        return 1;
    }

    modifiers.annotations = parse_annotations_append(modifiers.annotations, group);
    return 1;
}

func parse_impl_consume_modifiers(p: *Parser) -> ParseImplModifiers {
    var modifiers: ParseImplModifiers;
    modifiers.is_static = 0;
    modifiers.is_abst = 0;
    modifiers.is_override = 0;
    modifiers.access = ACCESS_PRIVATE;
    modifiers.annotations = 0;

    var seen_access: u64 = 0;
    while (1) {
        var k: u64 = parse_peek_kind(p);
        if (k == TOKEN_AT) {
            parse_impl_consume_override_annotation(p, &modifiers);
            continue;
        }
        if (k == TOKEN_PUBLIC) {
            if (seen_access != 0) {
                emit_stderr("[ERROR] duplicate access modifier\n");
                parse_panic_here(p, "Syntax error");
            }
            modifiers.access = ACCESS_PUBLIC;
            seen_access = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_PRIVATE) {
            if (seen_access != 0) {
                emit_stderr("[ERROR] duplicate access modifier\n");
                parse_panic_here(p, "Syntax error");
            }
            modifiers.access = ACCESS_PRIVATE;
            seen_access = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_PROTECTED) {
            if (seen_access != 0) {
                emit_stderr("[ERROR] duplicate access modifier\n");
                parse_panic_here(p, "Syntax error");
            }
            modifiers.access = ACCESS_PROTECTED;
            seen_access = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_STATIC) {
            if (modifiers.is_static != 0) {
                emit_stderr("[ERROR] duplicate static modifier\n");
                parse_panic_here(p, "Syntax error");
            }
            modifiers.is_static = 1;
            parse_adv(p);
            continue;
        }
        if (k == TOKEN_ABST) {
            if (modifiers.is_abst != 0) {
                emit_stderr("[ERROR] duplicate abstract modifier\n");
                parse_panic_here(p, "Syntax error");
            }
            modifiers.is_abst = 1;
            parse_adv(p);
            continue;
        }
        break;
    }
    if (modifiers.is_static != 0 && modifiers.is_abst != 0) {
        emit_stderr("[ERROR] abstract method cannot be static\n");
        parse_panic_here(p, "Syntax error");
    }
    if (modifiers.is_abst != 0 && modifiers.is_override != 0) {
        emit_stderr("[ERROR] abstract method cannot be @[override]\n");
        parse_panic_here(p, "Syntax error");
    }
    return modifiers;
}

func parse_merge_func_annotations(func_node: *AstFunc, extra: *Vec<*NameInfo>) -> u64 {
    if (func_node == 0 || extra == 0) { return 0; }
    if (func_node.annotations_vec == 0) {
        func_node.annotations_vec = extra;
        return 0;
    }
    func_node.annotations_vec = parse_annotations_append(func_node.annotations_vec, extra);
    return 0;
}

func parse_impl_try_special_method(p: *Parser, sig_only: u64, struct_name_ptr: u64, struct_name_len: u64, is_static: u64, is_abst: u64, is_override: u64, method_access: u64, method_annotations: *Vec<*NameInfo>, funcs: *Vec<*AstFunc>) -> u64 {
    var kind: u64 = parse_peek_kind(p);
    if (kind == TOKEN_CONSTRUCTOR) {
        if (is_static != 0) {
            emit_stderr("[ERROR] constructor cannot be static\n");
            parse_panic_here(p, "Syntax error");
        }
        if (is_abst != 0) {
            emit_stderr("[ERROR] constructor cannot be abstract\n");
            parse_panic_here(p, "Syntax error");
        }
        if (is_override != 0) {
            emit_stderr("[ERROR] constructor cannot be @[override]\n");
            parse_panic_here(p, "Syntax error");
        }
        var ctor_node: *AstFunc = parse_constructor_decl(p, struct_name_ptr, struct_name_len, sig_only);
        parse_merge_func_annotations(ctor_node, method_annotations);
        parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, ctor_node, method_access, 0);
        funcs.push(ctor_node);
        return 1;
    }
    if (kind == TOKEN_DESTRUCTOR) {
        if (is_static != 0) {
            emit_stderr("[ERROR] destructor cannot be static\n");
            parse_panic_here(p, "Syntax error");
        }
        if (is_abst != 0) {
            emit_stderr("[ERROR] destructor cannot be abstract\n");
            parse_panic_here(p, "Syntax error");
        }
        if (is_override != 0) {
            emit_stderr("[ERROR] destructor cannot be @[override]\n");
            parse_panic_here(p, "Syntax error");
        }
        var dtor_node: *AstFunc = parse_destructor_decl(p, struct_name_ptr, struct_name_len, sig_only);
        parse_merge_func_annotations(dtor_node, method_annotations);
        parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, dtor_node, method_access, 0);
        funcs.push(dtor_node);
        return 1;
    }
    return 0;
}

func parse_impl_block_impl(p: *Parser, sig_only: u64) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var struct_name_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_name_tok.ptr;
    var struct_name_len: u64 = struct_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        var modifiers: ParseImplModifiers = parse_impl_consume_modifiers(p);
        var is_static: u64 = modifiers.is_static;
        var is_abst: u64 = modifiers.is_abst;
        var is_override: u64 = modifiers.is_override;
        var method_access: u64 = modifiers.access;
        if (parse_impl_try_special_method(p, sig_only, struct_name_ptr, struct_name_len, is_static, is_abst, is_override, method_access, modifiers.annotations, funcs) != 0) {
            continue;
        }

        if (parse_peek_kind(p) == TOKEN_FUNC) {
            if (is_abst != 0) {
                var abst_sig: *AstFunc = parse_func_decl_abst_signature(p);
                parse_merge_func_annotations(abst_sig, modifiers.annotations);
                compiler_register_abst_method_ex(struct_name_ptr, struct_name_len, abst_sig.name_ptr, abst_sig.name_len, abst_sig, method_access);
                continue;
            }

            var func_node: *AstFunc = parse_impl_parse_func_by_mode(p, sig_only);
            if (func_node == 0) { continue; }
            parse_merge_func_annotations(func_node, modifiers.annotations);

            parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, func_node, method_access, is_override);
            funcs.push(func_node);
            continue;
        }

        emit_stderr("[ERROR] impl block can only contain functions\n");
        break;
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();
    return funcs;
}

func parse_impl_block(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_block_impl(p, 0);
}

// Impl block parsing for signature-only pass
func parse_impl_block_signature(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_block_impl(p, 1);
}

func parse_impl_trait_block_impl(p: *Parser, sig_only: u64, register_trait_impl: u64) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var trait_tok: *Token = parse_peek(p);
    var trait_ptr: u64 = trait_tok.ptr;
    var trait_len: u64 = trait_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_FOR);

    var struct_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_tok.ptr;
    var struct_name_len: u64 = struct_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    var impl_methods: *Vec<*TraitImplMethod> = 0;
    if (register_trait_impl != 0) {
        impl_methods = new Vec<*TraitImplMethod>(8);
    }
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        var modifiers: ParseImplModifiers = parse_impl_consume_modifiers(p);
        var method_access: u64 = modifiers.access;

        if (modifiers.is_static != 0) {
            emit_stderr("[ERROR] trait impl methods cannot be static\n");
            parse_panic_here(p, "Syntax error");
        }

        if (modifiers.is_abst != 0) {
            emit_stderr("[ERROR] trait impl methods cannot be abstract\n");
            parse_panic_here(p, "Syntax error");
        }
        if (modifiers.is_override != 0) {
            emit_stderr("[ERROR] trait impl methods cannot use @[override]\n");
            parse_panic_here(p, "Syntax error");
        }

        if (parse_peek_kind(p) != TOKEN_FUNC) {
            emit_stderr("[ERROR] impl Trait for Type block can only contain functions\n");
            parse_panic_here(p, "Syntax error");
        }

        var func_node: *AstFunc = parse_impl_parse_func_by_mode(p, sig_only);
        if (func_node == 0) { continue; }
        parse_merge_func_annotations(func_node, modifiers.annotations);

        var original_name_ptr: u64 = func_node.name_ptr;
        var original_name_len: u64 = func_node.name_len;
        parser_mark_impl_method_metadata(struct_name_ptr, struct_name_len, func_node, method_access, 0);

        if (register_trait_impl != 0) {
            var impl_method: *TraitImplMethod = new TraitImplMethod();
            impl_method.name_ptr = original_name_ptr;
            impl_method.name_len = original_name_len;
            impl_method.func_def = func_node;
            impl_methods.push(impl_method);
        }

        funcs.push(func_node);
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();

    if (register_trait_impl != 0) {
        var impl_info: *TraitImpl = new TraitImpl();
        impl_info.trait_ptr = trait_ptr;
        impl_info.trait_len = trait_len;
        impl_info.struct_ptr = struct_name_ptr;
        impl_info.struct_len = struct_name_len;
        impl_info.methods_vec = impl_methods;
        impl_info.vtable_struct_def = 0;
        impl_info.vtable_global_ptr = 0;
        impl_info.vtable_global_len = 0;
        compiler_register_trait_impl(impl_info);
    }

    return funcs;
}

func parse_impl_trait_block(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_trait_block_impl(p, 0, 1);
}

func parse_impl_trait_block_signature(p: *Parser) -> *Vec<*AstFunc> {
    return parse_impl_trait_block_impl(p, 1, 0);
}

// ============================================
// Program Parsing (Entry Point)
// ============================================

const PARSE_PROGRAM_MODE_FULL = 0;
const PARSE_PROGRAM_MODE_SIGNATURE = 1;

func parse_report_unexpected_top_level(p: *Parser) -> u64 {
    var err_tok: *Token = parse_peek(p);
    if (err_tok == 0) {
        emit_stderr("[ERROR] Unexpected EOF at top-level declaration\n");
        parse_panic_here(p, "Unexpected token");
        return 0;
    }
    emit_stderr("[ERROR] Unexpected top-level token at line ");
    emit_u64_stderr(err_tok.line);
    emit_stderr(", column ");
    emit_u64_stderr(err_tok.col);
    emit_stderr("\n");
    emit_stderr("  Expected one of: func, const, enum, struct, union, trait, impl, var, import\n");
    emit_stderr("  Got: ");
    emit_stderr_len(token_kind_name(err_tok.kind), token_kind_name_len(err_tok.kind));
    emit_stderr(" (id=");
    emit_u64_stderr(err_tok.kind);
    emit_stderr(")");
    if (err_tok.kind != TOKEN_EOF && err_tok.ptr != 0 && err_tok.len != 0) {
        emit_stderr(" near `");
        emit_stderr_len(err_tok.ptr, err_tok.len);
        emit_stderr("`");
    }
    emit_stderr("\n");
    parse_panic_at_tok(err_tok, "Unexpected token");
    return 0;
}

func parse_skip_until_semicolon(p: *Parser) -> u64 {
    while (parse_peek_kind(p) != TOKEN_SEMICOLON && parse_peek_kind(p) != TOKEN_EOF) {
        parse_adv(p);
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return 0;
}

func parse_skip_const_decl_signature(p: *Parser) -> u64 {
    parse_consume(p, TOKEN_CONST);
    parse_consume(p, TOKEN_IDENTIFIER);
    if (parse_match(p, TOKEN_EQ)) {
        parse_skip_until_semicolon(p);
        return 0;
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return 0;
}

func parse_skip_global_var_decl_signature(p: *Parser) -> u64 {
    parse_take_leading_annotations(p);
    parse_consume(p, TOKEN_VAR);
    parse_consume(p, TOKEN_IDENTIFIER);
    if (parse_match(p, TOKEN_COLON)) {
        parse_type_ex(p);
    }
    if (parse_match(p, TOKEN_EQ)) {
        parse_skip_until_semicolon(p);
        return 0;
    }
    parse_consume(p, TOKEN_SEMICOLON);
    return 0;
}

func parse_append_impl_funcs(dst: *Vec<*AstFunc>, src: *Vec<*AstFunc>, mode: u64) -> u64 {
    var num_impl_funcs: u64 = src.len();
    for (var i: u64 = 0; i < num_impl_funcs; i++) {
        var impl_fn: *AstFunc = src.get(i);
        if (mode == PARSE_PROGRAM_MODE_SIGNATURE && impl_fn == 0) { continue; }
        dst.push(impl_fn);
    }
    return 0;
}

func parse_append_generated_funcs(p: *Parser, funcs: *Vec<*AstFunc>) -> u64 {
    var generated: *Vec<u64> = parse_generated_funcs_take(p);
    if (generated == 0) { return 0; }
    var n: u64 = generated.len();
    for (var i: u64 = 0; i < n; i++) {
        funcs.push((*AstFunc)generated.get(i));
    }
    return 0;
}

func parse_global_var_decl_full(p: *Parser, globals: *Vec<*GlobalInfo>) -> u64 {
    var annotations: *Vec<*NameInfo> = parse_take_leading_annotations(p);
    parse_consume(p, TOKEN_VAR);
    var tok: *Token = parse_peek(p);

    parse_consume(p, TOKEN_IDENTIFIER);
    var gtype: *TypeInfo = 0;
    if (parse_match(p, TOKEN_COLON)) {
        gtype = parse_type_ex(p);
    } else {
        gtype = new TypeInfo(TYPE_U64, 0);
    }

    var init_kind: u64 = GLOBAL_INIT_NONE;
    var init_expr: *AstNode = 0;

    if (parse_match(p, TOKEN_EQ)) {
        init_expr = parse_expr(p);
        if (init_expr == 0) {
            emit_stderr("[ERROR] Global init expression missing\n");
            parse_panic_here(p, "Syntax error");
        }
        init_kind = GLOBAL_INIT_EXPR;
    }

    parse_consume(p, TOKEN_SEMICOLON);

    var ginfo: *GlobalInfo = new GlobalInfo();
    ginfo.name_ptr = tok.ptr;
    ginfo.name_len = tok.len;
    ginfo.typeinfo_ptr = gtype;
    ginfo.init_kind = init_kind;
    ginfo.init_value = 0;
    ginfo.init_name_ptr = 0;
    ginfo.init_name_len = 0;
    ginfo.init_expr = (u64)init_expr;
    ginfo.annotations_vec = annotations;
    globals.push(ginfo);
    return 0;
}

func parse_program_handle_func(p: *Parser, mode: u64, funcs: *Vec<*AstFunc>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        var fn_ptr: *AstFunc = parse_func_decl_top_level(p);
        if (fn_ptr != 0) { funcs.push(fn_ptr); }
        return 0;
    }
    var sig_ptr: *AstFunc = parse_func_decl_signature(p);
    if (sig_ptr != 0) { funcs.push(sig_ptr); }
    return 0;
}

func parse_program_handle_const(p: *Parser, mode: u64, consts: *Vec<*AstConstDecl>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        var cdecl: *AstConstDecl = parse_const_decl(p);
        consts.push(cdecl);
        return 0;
    }
    parse_skip_const_decl_signature(p);
    return 0;
}

func parse_program_handle_enum(p: *Parser, mode: u64, consts: *Vec<*AstConstDecl>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        var enum_consts: *Vec<*AstConstDecl> = parse_enum_def(p);
        var num_enum_consts: u64 = enum_consts.len();
        for (var i: u64 = 0; i < num_enum_consts; i++) {
            var enum_cdecl: *AstConstDecl = enum_consts.get(i);
            consts.push(enum_cdecl);
        }
        return 0;
    }
    parse_consume(p, TOKEN_ENUM);
    parse_consume(p, TOKEN_IDENTIFIER);
    parse_skip_block(p);
    return 0;
}

func parse_program_handle_struct(p: *Parser, mode: u64, structs: *Vec<*AstStructDef>) -> u64 {
    var struct_def: *AstStructDef = parse_struct_def(p);
    if (mode != PARSE_PROGRAM_MODE_FULL) { return 0; }
    if (compiler_is_generic_struct_def(struct_def) == 0) {
        structs.push(struct_def);
    }
    register_struct_type(struct_def);
    return 0;
}

func parse_program_handle_impl(p: *Parser, mode: u64, funcs: *Vec<*AstFunc>) -> u64 {
    var impl_funcs: *Vec<*AstFunc> = 0;
    if (parse_is_impl_trait_block(p) != 0) {
        if (mode == PARSE_PROGRAM_MODE_FULL) {
            impl_funcs = parse_impl_trait_block(p);
        } else {
            impl_funcs = parse_impl_trait_block_signature(p);
        }
    } else {
        if (mode == PARSE_PROGRAM_MODE_FULL) {
            impl_funcs = parse_impl_block(p);
        } else {
            impl_funcs = parse_impl_block_signature(p);
        }
    }
    parse_append_impl_funcs(funcs, impl_funcs, mode);
    return 0;
}

func parse_program_handle_global(p: *Parser, mode: u64, globals: *Vec<*GlobalInfo>) -> u64 {
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        parse_global_var_decl_full(p, globals);
        return 0;
    }
    parse_skip_global_var_decl_signature(p);
    return 0;
}

func parse_program_impl(p: *Parser, mode: u64) -> *AstProgram {
    parse_set_active_parser(p);
    if (mode == PARSE_PROGRAM_MODE_SIGNATURE) {
        parse_set_recovery_mode(p, 1, 40);
    } else {
        parse_set_recovery_mode(p, 1, 40);
    }

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(16);
    var consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(1);
    var imports: *Vec<*AstImport> = new Vec<*AstImport>(16);
    var globals: *Vec<*GlobalInfo> = 0;
    var structs: *Vec<*AstStructDef> = 0;

    if (mode == PARSE_PROGRAM_MODE_FULL) {
        consts = new Vec<*AstConstDecl>(64);
        globals = new Vec<*GlobalInfo>(32);
        structs = new Vec<*AstStructDef>(16);
    }

    parse_generated_funcs_begin(p);
    clear_parsing_context();
    while (parse_peek_kind(p) != TOKEN_EOF) {
        // Prevent stale "last parsed function" from polluting top-level diagnostics.
        clear_parsing_context();
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_FUNC:
                parse_program_handle_func(p, mode, funcs);
                break;
            case TOKEN_CONST:
                parse_program_handle_const(p, mode, consts);
                break;
            case TOKEN_ENUM:
                parse_program_handle_enum(p, mode, consts);
                break;
            case TOKEN_STRUCT:
            case TOKEN_UNION:
            case TOKEN_PACKED:
                parse_program_handle_struct(p, mode, structs);
                break;
            case TOKEN_TRAIT:
                parse_trait_def(p, mode);
                break;
            case TOKEN_IMPL:
                parse_program_handle_impl(p, mode, funcs);
                break;
            case TOKEN_VAR:
                parse_program_handle_global(p, mode, globals);
                break;
            case TOKEN_AT:
                var next_k: u64 = parse_peek_kind_after_annotations(p);
                if (next_k == TOKEN_FUNC) {
                    parse_program_handle_func(p, mode, funcs);
                    break;
                }
                if (next_k == TOKEN_VAR) {
                    parse_program_handle_global(p, mode, globals);
                    break;
                }
                emit_stderr("[ERROR] annotation target must be function or variable declaration\n");
                parse_panic_here(p, "Syntax error");
                break;
            case TOKEN_IMPORT:
                imports.push(parse_import_decl(p));
                break;
            default:
                if (mode == PARSE_PROGRAM_MODE_SIGNATURE) {
                    // Pass1 is structural scanning only; avoid duplicate diagnostics.
                    parse_adv(p);
                } else {
                    parse_report_unexpected_top_level(p);
                }
                break;
        }
    }

    parse_append_generated_funcs(p, funcs);
    clear_parsing_context();

    if (parse_has_errors(p) != 0) {
        emit_stderr("[ERROR] parse failed with ");
        emit_u64_stderr(parse_error_count(p));
        emit_stderr(" error(s)\n");
        parse_set_recovery_mode(p, 0, 0);
        panic("Syntax error");
    }

    var prog: *AstProgram = ast_program(funcs, consts, imports);
    if (mode == PARSE_PROGRAM_MODE_FULL) {
        prog.globals_vec = globals;
        prog.structs_vec = structs;
    }
    parse_set_active_parser(0);
    return prog;
}

func parse_program(p: *Parser) -> *AstProgram {
    push_trace("parse_program", "parser/decl.b", __LINE__);
    defer pop_trace();
    return parse_program_impl(p, PARSE_PROGRAM_MODE_FULL);
}

// ============================================
// Program Parsing (Signature Pass)
// ============================================

func parse_program_pass1(p: *Parser) -> *AstProgram {
    push_trace("parse_program_pass1", "parser/decl.b", __LINE__);
    defer pop_trace();
    return parse_program_impl(p, PARSE_PROGRAM_MODE_SIGNATURE);
}

// ============================================
// Program Parsing (Imports Only)
// ============================================

func parse_program_imports_only(p: *Parser) -> *Vec<*AstImport> {
    push_trace("parse_program_imports_only", "parser/decl.b", __LINE__);
    defer pop_trace();

    var imports: *Vec<*AstImport> = new Vec<*AstImport>(8);
    clear_parsing_context();
    while (parse_peek_kind(p) != TOKEN_EOF) {
        if (parse_peek_kind(p) == TOKEN_IMPORT) {
            imports.push(parse_import_decl(p));
        } else {
            parse_adv(p);
        }
    }

    clear_parsing_context();
    return imports;
}
