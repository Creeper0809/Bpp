// main.b - Main entry point for v3.8 modular compiler

import std.io;
import std.str;
import std.os;
import std.path;
import std.util;
import compiler;
import codegen;
import opt;

// Explicit argv layouts for execve-style argument arrays.
// Each field is a single u64 pointer slot, matching the exact contiguous memory
// layout expected by execve without any manual byte offset calculations.
struct Argv6 { public a0: u64; public a1: u64; public a2: u64; public a3: u64; public a4: u64; public a5: u64; }
struct Argv7 { public a0: u64; public a1: u64; public a2: u64; public a3: u64; public a4: u64; public a5: u64; public a6: u64; }
struct Argv5 { public a0: u64; public a1: u64; public a2: u64; public a3: u64; public a4: u64; }
struct Argv2 { public a0: u64; public a1: u64; }
struct MainCliParseResult { public ok: u64; public filename: u64; }
struct MainOutputPaths { public asm_path: u64; public obj_path: u64; public exe_path: u64; }

impl Argv6 {
    public constructor() {
        self.a0 = 0;
        self.a1 = 0;
        self.a2 = 0;
        self.a3 = 0;
        self.a4 = 0;
        self.a5 = 0;
    }
}

impl Argv7 {
    public constructor() {
        self.a0 = 0;
        self.a1 = 0;
        self.a2 = 0;
        self.a3 = 0;
        self.a4 = 0;
        self.a5 = 0;
        self.a6 = 0;
    }
}

impl Argv5 {
    public constructor() {
        self.a0 = 0;
        self.a1 = 0;
        self.a2 = 0;
        self.a3 = 0;
        self.a4 = 0;
    }
}

impl Argv2 {
    public constructor() {
        self.a0 = 0;
        self.a1 = 0;
    }
}

func main_print_usage() -> u64 {
    emit("Usage: bppc [-O0|-O1] [-dump-ir|-dump-ssa|-asm] <source.bpp>\n");
    return 0;
}

func main_parse_cli(argc: u64, argv_ptr: *u64) -> MainCliParseResult {
    var result: MainCliParseResult;
    result.ok = 0;
    result.filename = 0;

    // Default flags (avoid uninitialized globals affecting codegen)
    opt_init_defaults();

    if (argc < 2) { return result; }

    var filename: u64 = 0;
    for (var i: u64 = 1; i < argc; i++) {
        var arg: u64 = argv_ptr[i];
        var arg_len: u64 = str_len(arg);

        if (str_eq(arg, arg_len, "-O1", 3)) {
            opt_set_level(1);
            continue;
        }
        if (str_eq(arg, arg_len, "-O0", 3)) {
            opt_set_level(0);
            continue;
        }
        if (str_eq(arg, arg_len, "-dump-ir", 8)) {
            opt_set_ir_mode(IR_3ADDR);
            opt_set_output_mode(OUT_IR);
            continue;
        }
        if (str_eq(arg, arg_len, "-dump-ssa", 9)) {
            opt_set_ir_mode(IR_SSA);
            opt_set_output_mode(OUT_IR);
            continue;
        }
        if (str_eq(arg, arg_len, "-asm", 4)) {
            opt_set_output_mode(OUT_ASM);
            continue;
        }

        if (arg_len > 0) {
            var arg_u8: []u8 = slice(arg, arg_len);
            if (arg_u8[0] == 45) { // '-'
                emit_stderr("[ERROR] unknown option: ");
                emit_stderr_len(arg, arg_len);
                emit_stderr("\n");
                return result;
            }
        }

        filename = arg;
    }

    if (filename == 0) { return result; }
    result.ok = 1;
    result.filename = filename;
    return result;
}

const MAIN_PASS_FINALIZE_IMPORT_ALIASES = 1;
const MAIN_PASS_LOWER_PARSE_SUGAR = 2;
const MAIN_PASS_FINALIZE_GLOBAL_INIT_KINDS = 3;
const MAIN_PASS_VALIDATE_DIRECT_IMPL_CALLS = 4;
const MAIN_PASS_INSERT_DEFAULT_CONSTRUCTORS = 5;
const MAIN_PASS_INSERT_AUTO_SUPER_CHAINS = 6;
const MAIN_PASS_INSERT_GLOBAL_INIT_FUNC = 7;
const MAIN_PASS_RESOLVE_SUPER_REFERENCES = 8;
const MAIN_PASS_VALIDATE_IMPL_OVERRIDES = 9;
const MAIN_PASS_MONOMORPHIZE_GENERICS = 10;
const MAIN_PASS_FINALIZE_ABST_METHODS = 11;
const MAIN_PASS_FINALIZE_TRAITS = 12;
const MAIN_PASS_APPLY_ANNOTATIONS = 13;

func main_pipeline_pass_name(pass_id: u64) -> u64 {
    switch (pass_id) {
        case MAIN_PASS_FINALIZE_IMPORT_ALIASES: return "finalize_import_aliases";
        case MAIN_PASS_LOWER_PARSE_SUGAR: return "compiler_lower_parse_sugar";
        case MAIN_PASS_FINALIZE_GLOBAL_INIT_KINDS: return "compiler_finalize_global_init_kinds";
        case MAIN_PASS_VALIDATE_DIRECT_IMPL_CALLS: return "compiler_validate_direct_impl_calls";
        case MAIN_PASS_INSERT_DEFAULT_CONSTRUCTORS: return "compiler_insert_default_constructors";
        case MAIN_PASS_INSERT_AUTO_SUPER_CHAINS: return "compiler_insert_auto_super_constructor_chains";
        case MAIN_PASS_INSERT_GLOBAL_INIT_FUNC: return "compiler_insert_global_init_func";
        case MAIN_PASS_RESOLVE_SUPER_REFERENCES: return "compiler_resolve_super_references";
        case MAIN_PASS_VALIDATE_IMPL_OVERRIDES: return "compiler_validate_impl_overrides";
        case MAIN_PASS_MONOMORPHIZE_GENERICS: return "compiler_monomorphize_generics";
        case MAIN_PASS_FINALIZE_ABST_METHODS: return "compiler_finalize_abst_methods";
        case MAIN_PASS_FINALIZE_TRAITS: return "compiler_finalize_traits";
        case MAIN_PASS_APPLY_ANNOTATIONS: return "compiler_apply_annotations";
    }
    return "unknown_pass";
}

func main_run_pipeline_pass(pass_id: u64) -> u64 {
    switch (pass_id) {
        case MAIN_PASS_FINALIZE_IMPORT_ALIASES:
            finalize_import_aliases();
            return 0;
        case MAIN_PASS_LOWER_PARSE_SUGAR:
            compiler_lower_parse_sugar();
            return 0;
        case MAIN_PASS_FINALIZE_GLOBAL_INIT_KINDS:
            compiler_finalize_global_init_kinds();
            return 0;
        case MAIN_PASS_VALIDATE_DIRECT_IMPL_CALLS:
            compiler_validate_direct_impl_calls();
            return 0;
        case MAIN_PASS_INSERT_DEFAULT_CONSTRUCTORS:
            compiler_insert_default_constructors();
            return 0;
        case MAIN_PASS_INSERT_AUTO_SUPER_CHAINS:
            compiler_insert_auto_super_constructor_chains();
            return 0;
        case MAIN_PASS_INSERT_GLOBAL_INIT_FUNC:
            compiler_insert_global_init_func();
            return 0;
        case MAIN_PASS_RESOLVE_SUPER_REFERENCES:
            compiler_resolve_super_references();
            return 0;
        case MAIN_PASS_VALIDATE_IMPL_OVERRIDES:
            compiler_validate_impl_overrides();
            return 0;
        case MAIN_PASS_MONOMORPHIZE_GENERICS:
            compiler_monomorphize_generics();
            return 0;
        case MAIN_PASS_FINALIZE_ABST_METHODS:
            compiler_finalize_abst_methods();
            return 0;
        case MAIN_PASS_FINALIZE_TRAITS:
            compiler_finalize_traits();
            return 0;
        case MAIN_PASS_APPLY_ANNOTATIONS:
            compiler_apply_annotations();
            return 0;
        default:
            emit_stderr("[ERROR] unknown compiler pipeline pass id: ");
            emit_u64_stderr(pass_id);
            emit_stderr("\n");
            return 1;
    }
}

func main_run_compile_pipeline(filename: u64, filename_len: u64) -> *AstProgram {
    if (!load_std_prelude()) {
        emit_stderr("[ERROR] failed to load std prelude\n");
        return 0;
    }

    if (!load_module(filename, filename_len)) {
        emit_stderr("[ERROR] failed to load module: ");
        emit_stderr_len(filename, filename_len);
        emit_stderr("\n");
        return 0;
    }

    var passes: *Vec<u64> = new Vec<u64>(16);
    passes.push(MAIN_PASS_FINALIZE_IMPORT_ALIASES);
    passes.push(MAIN_PASS_LOWER_PARSE_SUGAR);
    passes.push(MAIN_PASS_FINALIZE_GLOBAL_INIT_KINDS);
    passes.push(MAIN_PASS_VALIDATE_DIRECT_IMPL_CALLS);
    passes.push(MAIN_PASS_INSERT_DEFAULT_CONSTRUCTORS);
    passes.push(MAIN_PASS_INSERT_AUTO_SUPER_CHAINS);
    passes.push(MAIN_PASS_INSERT_GLOBAL_INIT_FUNC);
    passes.push(MAIN_PASS_RESOLVE_SUPER_REFERENCES);
    passes.push(MAIN_PASS_VALIDATE_IMPL_OVERRIDES);
    passes.push(MAIN_PASS_MONOMORPHIZE_GENERICS);
    passes.push(MAIN_PASS_FINALIZE_ABST_METHODS);
    passes.push(MAIN_PASS_FINALIZE_TRAITS);
    passes.push(MAIN_PASS_APPLY_ANNOTATIONS);

    var pass_count: u64 = passes.len();
    for (var i: u64 = 0; i < pass_count; i++) {
        var pass_id: u64 = passes.get(i);
        compiler_diag_reset();
        if (main_run_pipeline_pass(pass_id) != 0) {
            emit_stderr("[ERROR] compiler pipeline failed at pass: ");
            emit_stderr(main_pipeline_pass_name(pass_id));
            emit_stderr("\n");
            return 0;
        }
        if (compiler_diag_has_errors() != 0) {
            emit_stderr("[ERROR] compiler pipeline diagnostics in pass: ");
            emit_stderr(main_pipeline_pass_name(pass_id));
            emit_stderr(" (");
            emit_u64_stderr(compiler_diag_count());
            emit_stderr(" error(s))\n");
            return 0;
        }
    }

    return build_merged_program();
}

func main_build_output_paths(base_name: u64, base_len: u64) -> MainOutputPaths {
    var paths: MainOutputPaths;
    paths.asm_path = str_concat(base_name, base_len, ".s", 2);
    paths.obj_path = str_concat(base_name, base_len, ".o", 2);
    paths.exe_path = str_concat(base_name, base_len, ".out", 4);
    return paths;
}

func main_restore_stdout(saved_fd: u64) -> u64 {
    os_sys_dup2(saved_fd, 1);
    sys_close(saved_fd);
    return 0;
}

func main_emit_asm_file(asm_path: u64, merged_prog: *AstProgram) -> u64 {
    var flags: u64 = OS_O_WRONLY + OS_O_CREAT + OS_O_TRUNC;
    var fd_i: i64 = (i64)sys_open(asm_path, flags, 420);
    if (fd_i < 0) {
        emit_stderr("[ERROR] failed to open asm output: ");
        emit_stderr(asm_path);
        emit_stderr("\n");
        return 1;
    }
    var fd: u64 = (u64)fd_i;

    var saved_fd: u64 = 100;
    var dup_res: i64 = (i64)os_sys_dup2(1, saved_fd);
    if (dup_res < 0) {
        sys_close(fd);
        emit_stderr("[ERROR] failed to dup stdout\n");
        return 1;
    }

    var dup_res2: i64 = (i64)os_sys_dup2(fd, 1);
    if (dup_res2 < 0) {
        sys_close(fd);
        main_restore_stdout(saved_fd);
        emit_stderr("[ERROR] failed to redirect stdout to asm file\n");
        return 1;
    }

    compiler_diag_reset();
    cg_program_with_sigs(merged_prog, get_func_sigs());
    if (compiler_diag_has_errors() != 0 || compiler_diag_should_stop_pass() != 0) {
        sys_close(fd);
        main_restore_stdout(saved_fd);
        emit_stderr("[ERROR] code generation failed while emitting asm (");
        emit_u64_stderr(compiler_diag_count());
        emit_stderr(" error(s))\n");
        return 1;
    }
    sys_close(fd);
    main_restore_stdout(saved_fd);
    return 0;
}

const MAIN_EXEC_NOT_FOUND_STATUS = 32512; // 127 << 8

func main_status_exec_not_found(status: i64) -> u64 {
    if (status == MAIN_EXEC_NOT_FOUND_STATUS) { return 1; }
    return 0;
}

func main_run_nasm(asm_path: u64, obj_path: u64) -> u64 {
    var nasm_argv: *Argv6 = new Argv6();
    nasm_argv.a0 = (u64)"nasm";
    nasm_argv.a1 = (u64)"-felf64";
    nasm_argv.a2 = asm_path;
    nasm_argv.a3 = (u64)"-o";
    nasm_argv.a4 = obj_path;
    nasm_argv.a5 = 0;
    var nasm_status: i64 = 0;

    var nasm_override: u64 = compiler_get_nasm_path();
    if (nasm_override != 0) {
        nasm_argv.a0 = nasm_override;
        nasm_status = os_execute(nasm_override, (u64)nasm_argv);
        if (main_status_exec_not_found(nasm_status) != 0) {
            emit_stderr("[ERROR] assembler not found at nasm_path from bpp.toml: ");
            emit_stderr(nasm_override);
            emit_stderr("\n");
            return 1;
        }
        if (nasm_status != 0) {
            emit_stderr("[ERROR] nasm failed with status ");
            emit_i64_stderr(nasm_status);
            emit_stderr("\n");
            return 1;
        }
        return 0;
    }

    nasm_status = os_execute((u64)"/usr/bin/nasm", (u64)nasm_argv);
    if (main_status_exec_not_found(nasm_status) != 0) {
        nasm_status = os_execute((u64)"/usr/local/bin/nasm", (u64)nasm_argv);
    }
    if (main_status_exec_not_found(nasm_status) != 0) {
        nasm_status = os_execute((u64)"/bin/nasm", (u64)nasm_argv);
    }
    if (main_status_exec_not_found(nasm_status) != 0) {
        var env_argv: *Argv7 = new Argv7();
        env_argv.a0 = (u64)"env";
        env_argv.a1 = (u64)"nasm";
        env_argv.a2 = (u64)"-felf64";
        env_argv.a3 = asm_path;
        env_argv.a4 = (u64)"-o";
        env_argv.a5 = obj_path;
        env_argv.a6 = 0;
        nasm_status = os_execute((u64)"/usr/bin/env", (u64)env_argv);
        if (main_status_exec_not_found(nasm_status) != 0) {
            nasm_status = os_execute((u64)"/bin/env", (u64)env_argv);
        }
    }

    if (main_status_exec_not_found(nasm_status) != 0) {
        emit_stderr("[ERROR] nasm not found. Set nasm_path in bpp.toml or install nasm in PATH.\n");
        return 1;
    }
    if (nasm_status != 0) {
        emit_stderr("[ERROR] nasm failed with status ");
        emit_i64_stderr(nasm_status);
        emit_stderr("\n");
        return 1;
    }
    return 0;
}

func main_run_ld(obj_path: u64, exe_path: u64) -> u64 {
    var ld_argv: *Argv5 = new Argv5();
    ld_argv.a0 = (u64)"ld";
    ld_argv.a1 = obj_path;
    ld_argv.a2 = (u64)"-o";
    ld_argv.a3 = exe_path;
    ld_argv.a4 = 0;
    var ld_status: i64 = 0;

    var ld_override: u64 = compiler_get_ld_path();
    if (ld_override != 0) {
        ld_argv.a0 = ld_override;
        ld_status = os_execute(ld_override, (u64)ld_argv);
        if (main_status_exec_not_found(ld_status) != 0) {
            emit_stderr("[ERROR] linker not found at ld_path from bpp.toml: ");
            emit_stderr(ld_override);
            emit_stderr("\n");
            return 1;
        }
        if (ld_status != 0) {
            emit_stderr("[ERROR] ld failed with status ");
            emit_i64_stderr(ld_status);
            emit_stderr("\n");
            return 1;
        }
        return 0;
    }

    ld_status = os_execute((u64)"/usr/bin/ld", (u64)ld_argv);
    if (main_status_exec_not_found(ld_status) != 0) {
        ld_status = os_execute((u64)"/usr/local/bin/ld", (u64)ld_argv);
    }
    if (main_status_exec_not_found(ld_status) != 0) {
        ld_status = os_execute((u64)"/bin/ld", (u64)ld_argv);
    }
    if (main_status_exec_not_found(ld_status) != 0) {
        var env_ld_argv: *Argv6 = new Argv6();
        env_ld_argv.a0 = (u64)"env";
        env_ld_argv.a1 = (u64)"ld";
        env_ld_argv.a2 = obj_path;
        env_ld_argv.a3 = (u64)"-o";
        env_ld_argv.a4 = exe_path;
        env_ld_argv.a5 = 0;
        ld_status = os_execute((u64)"/usr/bin/env", (u64)env_ld_argv);
        if (main_status_exec_not_found(ld_status) != 0) {
            ld_status = os_execute((u64)"/bin/env", (u64)env_ld_argv);
        }
    }

    if (main_status_exec_not_found(ld_status) != 0) {
        emit_stderr("[ERROR] ld not found. Set ld_path in bpp.toml or install ld in PATH.\n");
        return 1;
    }
    if (ld_status != 0) {
        emit_stderr("[ERROR] ld failed with status ");
        emit_i64_stderr(ld_status);
        emit_stderr("\n");
        return 1;
    }
    return 0;
}

func main_run_output(exe_path: u64) -> u64 {
    var exe_argv: *Argv2 = new Argv2();
    exe_argv.a0 = exe_path;
    exe_argv.a1 = 0;
    var status: i64 = os_execute(exe_path, (u64)exe_argv);
    emit("[RUN] exit=");
    print_i64(status);
    emit("\n");
    if (status != 0) {
        emit_stderr("[ERROR] program exited with non-zero status\n");
        return 1;
    }
    return 0;
}

func main_emit_and_run(base_name: u64, base_len: u64, merged_prog: *AstProgram) -> u64 {
    var paths: MainOutputPaths = main_build_output_paths(base_name, base_len);
    var asm_path: u64 = paths.asm_path;
    var obj_path: u64 = paths.obj_path;
    var exe_path: u64 = paths.exe_path;

    if (main_emit_asm_file(asm_path, merged_prog) != 0) { return 1; }
    if (main_run_nasm(asm_path, obj_path) != 0) { return 1; }
    if (main_run_ld(obj_path, exe_path) != 0) { return 1; }

    emit("[OK] output: ");
    emit(exe_path);
    emit("\n");
    if (main_run_output(exe_path) != 0) { return 1; }
    return 0;
}


func main(argc: u64, argv: u64) -> u64 {
    init_stack_trace();

    var argv_ptr: *u64 = (*u64)argv;

    var cli: MainCliParseResult = main_parse_cli(argc, argv_ptr);
    if (cli.ok == 0) {
        main_print_usage();
        return 1;
    }
    var filename: u64 = cli.filename;

    var filename_len: u64 = str_len(filename);

    setup_paths_with_compiler(filename, filename_len);

    push_trace("main", "main.bpp", __LINE__);
    defer pop_trace();

    var merged_prog: *AstProgram = main_run_compile_pipeline(filename, filename_len);
    if (merged_prog == 0) {
        return 1;
    }

    var out_mode: u64 = opt_get_output_mode();
    var base_name: u64 = path_basename_noext(filename, filename_len);
    var base_len: u64 = str_len(base_name);

    switch (out_mode) {
        case OUT_IR:
            compiler_diag_reset();
            cg_program_with_sigs_ir(merged_prog, get_func_sigs());
            if (compiler_diag_has_errors() != 0 || compiler_diag_should_stop_pass() != 0) {
                emit_stderr("[ERROR] IR generation failed (");
                emit_u64_stderr(compiler_diag_count());
                emit_stderr(" error(s))\n");
                return 1;
            }
            break;
        case OUT_ASM:
            compiler_diag_reset();
            cg_program_with_sigs(merged_prog, get_func_sigs());
            if (compiler_diag_has_errors() != 0 || compiler_diag_should_stop_pass() != 0) {
                emit_stderr("[ERROR] ASM generation failed (");
                emit_u64_stderr(compiler_diag_count());
                emit_stderr(" error(s))\n");
                return 1;
            }
            break;
        default:
            if (main_emit_and_run(base_name, base_len, merged_prog) != 0) {
                return 1;
            }
            break;
    }
    
    return 0;
}
