// compiler.b - Compiler globals and driver helpers

import std.io;
import std.str;
import std.path;
import std.vec;
import std.hashmap;
import std.util;
import types;
import lexer;
import ast;
import parser.util;
import parser.decl;
import module_utils;

const GENERIC_DEBUG = 0;
const TRAIT_LOOKUP_DEBUG = 0;
const TRAIT_LOOKUP_LEGACY_M_PREFIX = 1;
const COMPILER_NOT_FOUND_U64 = 9223372036854775807;
const COMPILER_TRY_KIND_INVALID = 0;
const COMPILER_TRY_KIND_OPTION = 1;
const COMPILER_TRY_KIND_RESULT = 2;
const COMPILER_SAFE_RECV_INVALID = 0;
const COMPILER_SAFE_RECV_STRUCT_PTR = 1;
const COMPILER_SAFE_RECV_TRAIT_PTR = 2;
const COMPILER_INHERIT_DIST_NOT_FOUND = 9223372036854775807;

struct CompilerCtx {
    // Module and symbol tables
    public loaded_modules: *HashMap<u64, u64>;
    public loaded_modules_pass1: *HashMap<u64, u64>;
    public module_imports_pass1: *HashMap<u64, *Vec<*AstImport>>;
    public module_imports_pass2: *HashMap<u64, *Vec<*AstImport>>;
    public loaded_modules_vec: *Vec<*NameInfo>;
    public all_funcs: *Vec<*AstFunc>;
    public all_func_sigs: *Vec<*AstFunc>;
    public all_consts: *Vec<*AstConstDecl>;
    public all_globals: *Vec<*GlobalInfo>;
    public all_funcs_map: *HashMap<u64, *AstFunc>;
    public all_funcs_map_src: *Vec<*AstFunc>;
    public all_funcs_map_src_len: u64;
    public all_consts_map2: *HashMap<u64, *AstConstDecl>;
    public all_consts_map2_src: *Vec<*AstConstDecl>;
    public all_consts_map2_src_len: u64;
    public all_globals_map2: *HashMap<u64, *GlobalInfo>;
    public all_globals_map2_src: *Vec<*GlobalInfo>;
    public all_globals_map2_src_len: u64;
    public all_structs: *HashMap<u64, *AstStructDef>;
    public all_structs_vec: *Vec<*AstStructDef>;
    public all_traits: *HashMap<u64, *TraitDef>;
    public all_traits_vec: *Vec<*TraitDef>;
    public all_trait_impls_vec: *Vec<*TraitImpl>;
    public abst_methods: *HashMap<u64, *Vec<*NameInfo>>;
    public base_dir: u64;
    public base_dir_len: u64;
    public project_dir: u64;
    public project_dir_len: u64;
    public lib_dir: u64;
    public lib_dir_len: u64;
    public tool_nasm_path: u64;
    public tool_ld_path: u64;
    public entry_func_ptr: u64;
    public entry_func_len: u64;

    // Generic templates and instantiations
    public generic_funcs: *HashMap<u64, *GenericFuncTemplate>;
    public generic_funcs_mangled: *HashMap<u64, *GenericFuncTemplate>;
    public generic_func_ptrs: *Vec<*GenericFuncTemplate>;
    public generic_instantiations: *HashMap<u64, u64>;
    public generic_structs: *HashMap<u64, *GenericStructTemplate>;
    public generic_struct_ptrs: *Vec<*GenericStructTemplate>;
    public generic_struct_instantiations: *HashMap<u64, *AstStructDef>;
    public generic_struct_bindings: *HashMap<u64, *Vec<*GenericBinding>>;

    // Source/module caches
    public file_ptr: u64;
    public file_len: u64;
    public module_source_cache: *HashMap<u64, *NameInfo>;
    public module_tokens_cache: *HashMap<u64, *Vec<*Token>>;
    public resolved_module_path_cache: *HashMap<u64, *NameInfo>;
    public module_aliases: *HashMap<u64, *HashMap<u64, *NameInfo>>;
    public prelude_aliases: *HashMap<u64, *NameInfo>;
    public prelude_miss_cache: *HashMap<u64, u64>;
    public prelude_loaded: u64;
    public module_exports: *HashMap<u64, *Vec<*ExportEntry>>;
    public module_export_maps: *HashMap<u64, *HashMap<u64, *NameInfo>>;
    public func_module_map: *HashMap<u64, *NameInfo>;
    public global_module_map: *HashMap<u64, *NameInfo>;

    // Impl and name-resolution helpers
    public impl_methods: *HashMap<u64, u64>;
    public impl_method_access: *HashMap<u64, u64>;
    public impl_method_owner: *HashMap<u64, *NameInfo>;
    public impl_method_funcs: *HashMap<u64, *AstFunc>;
    public abst_methods_access: *HashMap<u64, *HashMap<u64, u64>>;
    public abst_methods_sigs: *HashMap<u64, *HashMap<u64, *AstFunc>>;
    public virtual_dispatch_traits: *HashMap<u64, *HashMap<u64, *NameInfo>>;
    public resolve_name_hits: *HashMap<u64, *HashMap<u64, *NameInfo>>;
    public resolve_name_misses: *HashMap<u64, *HashMap<u64, u64>>;
    public reg_aliases: *HashMap<u64, *NameInfo>;
    public const_lookup_result_ptr: *ConstResult;

    // Parse/codegen transient context
    public current_module_ptr: u64;
    public current_module_len: u64;
    public impl_prefix_ptr: u64;
    public impl_prefix_len: u64;
    public current_access_struct_ptr: u64;
    public current_access_struct_len: u64;
}

impl CompilerCtx {
    public constructor() {
        self.loaded_modules = 0;
        self.loaded_modules_pass1 = 0;
        self.module_imports_pass1 = 0;
        self.module_imports_pass2 = 0;
        self.loaded_modules_vec = 0;
        self.all_funcs = 0;
        self.all_func_sigs = 0;
        self.all_consts = 0;
        self.all_globals = 0;
        self.all_funcs_map = 0;
        self.all_funcs_map_src = 0;
        self.all_funcs_map_src_len = 0;
        self.all_consts_map2 = 0;
        self.all_consts_map2_src = 0;
        self.all_consts_map2_src_len = 0;
        self.all_globals_map2 = 0;
        self.all_globals_map2_src = 0;
        self.all_globals_map2_src_len = 0;
        self.all_structs = 0;
        self.all_structs_vec = 0;
        self.all_traits = 0;
        self.all_traits_vec = 0;
        self.all_trait_impls_vec = 0;
        self.abst_methods = 0;
        self.base_dir = 0;
        self.base_dir_len = 0;
        self.project_dir = 0;
        self.project_dir_len = 0;
        self.lib_dir = 0;
        self.lib_dir_len = 0;
        self.tool_nasm_path = 0;
        self.tool_ld_path = 0;
        self.entry_func_ptr = 0;
        self.entry_func_len = 0;
        self.generic_funcs = 0;
        self.generic_funcs_mangled = 0;
        self.generic_func_ptrs = 0;
        self.generic_instantiations = 0;
        self.generic_structs = 0;
        self.generic_struct_ptrs = 0;
        self.generic_struct_instantiations = 0;
        self.generic_struct_bindings = 0;
        self.file_ptr = 0;
        self.file_len = 0;
        self.module_source_cache = 0;
        self.module_tokens_cache = 0;
        self.resolved_module_path_cache = 0;
        self.module_aliases = 0;
        self.prelude_aliases = 0;
        self.prelude_miss_cache = 0;
        self.prelude_loaded = 0;
        self.module_exports = 0;
        self.module_export_maps = 0;
        self.func_module_map = 0;
        self.global_module_map = 0;
        self.impl_methods = 0;
        self.impl_method_access = 0;
        self.impl_method_owner = 0;
        self.impl_method_funcs = 0;
        self.abst_methods_access = 0;
        self.abst_methods_sigs = 0;
        self.virtual_dispatch_traits = 0;
        self.resolve_name_hits = 0;
        self.resolve_name_misses = 0;
        self.reg_aliases = 0;
        self.const_lookup_result_ptr = 0;
        self.current_module_ptr = 0;
        self.current_module_len = 0;
        self.impl_prefix_ptr = 0;
        self.impl_prefix_len = 0;
        self.current_access_struct_ptr = 0;
        self.current_access_struct_len = 0;
    }
}

var g_compiler_ctx: CompilerCtx;

func compiler_ctx_reset_state() -> u64 {
    // Module and symbol tables
    g_compiler_ctx.loaded_modules = new HashMap<u64, u64>(64);
    g_compiler_ctx.loaded_modules_pass1 = new HashMap<u64, u64>(64);
    g_compiler_ctx.module_imports_pass1 = new HashMap<u64, *Vec<*AstImport>>(64);
    g_compiler_ctx.module_imports_pass2 = new HashMap<u64, *Vec<*AstImport>>(64);
    g_compiler_ctx.loaded_modules_vec = new Vec<*NameInfo>(64);
    g_compiler_ctx.all_funcs = new Vec<*AstFunc>(64);
    g_compiler_ctx.all_func_sigs = new Vec<*AstFunc>(64);
    g_compiler_ctx.all_consts = new Vec<*AstConstDecl>(128);
    g_compiler_ctx.all_globals = new Vec<*GlobalInfo>(64);
    g_compiler_ctx.all_funcs_map = 0;
    g_compiler_ctx.all_funcs_map_src = 0;
    g_compiler_ctx.all_funcs_map_src_len = 0;
    g_compiler_ctx.all_consts_map2 = 0;
    g_compiler_ctx.all_consts_map2_src = 0;
    g_compiler_ctx.all_consts_map2_src_len = 0;
    g_compiler_ctx.all_globals_map2 = 0;
    g_compiler_ctx.all_globals_map2_src = 0;
    g_compiler_ctx.all_globals_map2_src_len = 0;
    g_compiler_ctx.all_structs = new HashMap<u64, *AstStructDef>(64);
    g_compiler_ctx.all_structs_vec = new Vec<*AstStructDef>(16);
    g_compiler_ctx.all_traits = new HashMap<u64, *TraitDef>(64);
    g_compiler_ctx.all_traits_vec = new Vec<*TraitDef>(16);
    g_compiler_ctx.all_trait_impls_vec = new Vec<*TraitImpl>(32);
    g_compiler_ctx.abst_methods = 0;

    // Path/tool state
    g_compiler_ctx.base_dir = 0;
    g_compiler_ctx.base_dir_len = 0;
    g_compiler_ctx.project_dir = 0;
    g_compiler_ctx.project_dir_len = 0;
    g_compiler_ctx.lib_dir = 0;
    g_compiler_ctx.lib_dir_len = 0;
    g_compiler_ctx.tool_nasm_path = 0;
    g_compiler_ctx.tool_ld_path = 0;
    g_compiler_ctx.entry_func_ptr = 0;
    g_compiler_ctx.entry_func_len = 0;

    // Generic templates and instantiations
    g_compiler_ctx.generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64);
    g_compiler_ctx.generic_funcs_mangled = new HashMap<u64, *GenericFuncTemplate>(64);
    g_compiler_ctx.generic_func_ptrs = new Vec<*GenericFuncTemplate>(16);
    g_compiler_ctx.generic_instantiations = new HashMap<u64, u64>(64);
    g_compiler_ctx.generic_structs = new HashMap<u64, *GenericStructTemplate>(64);
    g_compiler_ctx.generic_struct_ptrs = new Vec<*GenericStructTemplate>(16);
    g_compiler_ctx.generic_struct_instantiations = new HashMap<u64, *AstStructDef>(64);
    g_compiler_ctx.generic_struct_bindings = new HashMap<u64, *Vec<*GenericBinding>>(64);

    // Source/module caches
    g_compiler_ctx.file_ptr = 0;
    g_compiler_ctx.file_len = 0;
    g_compiler_ctx.module_source_cache = new HashMap<u64, *NameInfo>(64);
    g_compiler_ctx.module_tokens_cache = new HashMap<u64, *Vec<*Token>>(64);
    g_compiler_ctx.resolved_module_path_cache = new HashMap<u64, *NameInfo>(256);
    g_compiler_ctx.module_aliases = new HashMap<u64, *HashMap<u64, *NameInfo>>(128);
    g_compiler_ctx.prelude_aliases = new HashMap<u64, *NameInfo>(128);
    g_compiler_ctx.prelude_miss_cache = new HashMap<u64, u64>(256);
    g_compiler_ctx.prelude_loaded = 0;
    g_compiler_ctx.module_exports = new HashMap<u64, *Vec<*ExportEntry>>(64);
    g_compiler_ctx.module_export_maps = new HashMap<u64, *HashMap<u64, *NameInfo>>(64);
    g_compiler_ctx.func_module_map = new HashMap<u64, *NameInfo>(128);
    g_compiler_ctx.global_module_map = new HashMap<u64, *NameInfo>(128);

    // Impl and resolve helpers
    g_compiler_ctx.impl_methods = new HashMap<u64, u64>(64);
    g_compiler_ctx.impl_method_access = new HashMap<u64, u64>(64);
    g_compiler_ctx.impl_method_owner = new HashMap<u64, *NameInfo>(64);
    g_compiler_ctx.impl_method_funcs = new HashMap<u64, *AstFunc>(64);
    g_compiler_ctx.abst_methods_access = 0;
    g_compiler_ctx.abst_methods_sigs = 0;
    g_compiler_ctx.virtual_dispatch_traits = 0;
    g_compiler_ctx.resolve_name_hits = 0;
    g_compiler_ctx.resolve_name_misses = 0;
    g_compiler_ctx.reg_aliases = new HashMap<u64, *NameInfo>(64);
    g_compiler_ctx.const_lookup_result_ptr = 0;

    // Parse/codegen transient context
    g_compiler_ctx.current_module_ptr = 0;
    g_compiler_ctx.current_module_len = 0;
    g_compiler_ctx.impl_prefix_ptr = 0;
    g_compiler_ctx.impl_prefix_len = 0;
    g_compiler_ctx.current_access_struct_ptr = 0;
    g_compiler_ctx.current_access_struct_len = 0;
    return 0;
}

const PRELUDE_MODULE_COUNT = 7;

// Generic function template (48 bytes)
struct GenericFuncTemplate {
    public name_ptr: u64;
    public name_len: u64;
    public mangled_ptr: u64;
    public mangled_len: u64;
    public params_vec: *Vec<*GenericParam>;
    public func_sig: *AstFunc;
    public func_def: *AstFunc;
}

impl GenericFuncTemplate {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.mangled_ptr = 0;
        self.mangled_len = 0;
        self.params_vec = 0;
        self.func_sig = 0;
        self.func_def = 0;
    }
}

// Generic struct template (24 bytes)
struct GenericStructTemplate {
    public name_ptr: u64;
    public name_len: u64;
    public params_vec: *Vec<*GenericParam>;
    public struct_def: *AstStructDef;
}

impl GenericStructTemplate {
    public constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.params_vec = 0;
        self.struct_def = 0;
    }
}

// Generic binding (40 bytes)
struct GenericBinding {
    public kind: u64;
    public name_ptr: u64;
    public name_len: u64;
    public type: *TypeInfo;
    public value: u64;
}

impl GenericBinding {
    public constructor() {
        self.kind = 0;
        self.name_ptr = 0;
        self.name_len = 0;
        self.type = 0;
        self.value = 0;
    }
}

struct Stat {
    public pad0: u64;
    public pad1: u64;
    public pad2: u64;
    public pad3: u64;
    public pad4: u64;
    public pad5: u64;
    public size: u64;
}

struct CompilerDeclLookup {
    public found: u64;
    public owner_ptr: u64;
    public owner_len: u64;
    public access: u64;
    public sig: *AstFunc;
}

struct CompilerModuleIdentity {
    public module_ptr: u64;
    public module_len: u64;
    public prefix_ptr: u64;
    public prefix_len: u64;
}

struct CompilerTryFieldNames {
    public found: u64;
    public check_ptr: u64;
    public check_len: u64;
    public value_ptr: u64;
    public value_len: u64;
}

struct CompilerResolvedStructName {
    public found: u64;
    public resolved_ptr: u64;
    public resolved_len: u64;
    public struct_def: *AstStructDef;
}

struct CompilerResolvedParent {
    public parent_ptr: u64;
    public parent_len: u64;
    public parent_def: *AstStructDef;
}

struct CompilerImplTraitStruct {
    public trait_def: *TraitDef;
    public struct_def: *AstStructDef;
}

struct CompilerVtableStructInfo {
    public vtable_struct_def: *AstStructDef;
    public vtable_name_ptr: u64;
    public vtable_name_len: u64;
}

struct CompilerMethodResolveResult {
    public found: u64;
    public fn: *AstFunc;
    public owner_ptr: u64;
    public owner_len: u64;
    public access: u64;
}

struct CompilerDowncastCheckInfo {
    public found: u64;
    public src_vptr_offset: u64;
    public trait_ptr: u64;
    public trait_len: u64;
    public expected_vtable_ptr: u64;
    public expected_vtable_len: u64;
}

impl CompilerDeclLookup {
    public func reset_none(self: *CompilerDeclLookup, default_access: u64) -> u64 {
        self.found = 0;
        self.owner_ptr = 0;
        self.owner_len = 0;
        self.access = default_access;
        self.sig = 0;
        return 0;
    }
}

impl CompilerTryFieldNames {
    public func reset_none(self: *CompilerTryFieldNames) -> u64 {
        self.found = 0;
        self.check_ptr = 0;
        self.check_len = 0;
        self.value_ptr = 0;
        self.value_len = 0;
        return 0;
    }
}

impl CompilerMethodResolveResult {
    public func reset_none(self: *CompilerMethodResolveResult) -> u64 {
        self.found = 0;
        self.fn = 0;
        self.owner_ptr = 0;
        self.owner_len = 0;
        self.access = ACCESS_PUBLIC;
        return 0;
    }
}

impl CompilerDowncastCheckInfo {
    public func reset_none(self: *CompilerDowncastCheckInfo) -> u64 {
        self.found = 0;
        self.src_vptr_offset = 0;
        self.trait_ptr = 0;
        self.trait_len = 0;
        self.expected_vtable_ptr = 0;
        self.expected_vtable_len = 0;
        return 0;
    }
}

func compiler_decl_lookup_none(default_access: u64) -> CompilerDeclLookup {
    var lookup: CompilerDeclLookup;
    lookup.found = 0;
    lookup.owner_ptr = 0;
    lookup.owner_len = 0;
    lookup.access = default_access;
    lookup.sig = 0;
    return lookup;
}

// ============================================
// File Reading
// ============================================

func read_entire_file(path: u64) -> u64 {
    var fd_i: i64 = (i64)sys_open(path, 0, 0);
    if (fd_i < 0) { return 0; }
    var fd: u64 = (u64)fd_i;

    var statbuf_raw: u64 = heap_alloc(144 * sizeof(u8));
    var statbuf: *Stat = (*Stat)statbuf_raw;
    var st_res: i64 = (i64)sys_fstat(fd, statbuf_raw);
    if (st_res < 0) {
        sys_close(fd);
        return 0;
    }
    var size: u64 = statbuf.size;

    var buf: u64 = heap_alloc((size + 1) * sizeof(u8));

    var total: u64 = 0;
    for (; total < size; ) {
        var n: i64 = (i64)sys_read(fd, buf + total, size - total);
        if (n < 0) {
            sys_close(fd);
            return 0;
        }
        if (n == 0) { break; }
        total = total + (u64)n;
    }

    var buf_u8: []u8 = slice(buf, size + 1);
    buf_u8[total] = 0;

    sys_close(fd);

    g_compiler_ctx.file_ptr = buf;
    g_compiler_ctx.file_len = total;

    return buf;
}

func compiler_report_module_open_error(file_path: u64, file_path_len: u64) -> u64 {
    emit_stderr("[ERROR] Cannot open module: ");
    var file_path_u8: []u8 = slice(file_path, file_path_len);
    for (var i: u64 = 0; i < file_path_len; i++) {
        emit_char(file_path_u8[i]);
    }
    emit_nl();
    return 0;
}

func compiler_get_cached_module_source(file_path: u64, file_path_len: u64) -> *NameInfo {
    if (g_compiler_ctx.module_source_cache == 0) {
        g_compiler_ctx.module_source_cache = new HashMap<u64, *NameInfo>(64);
    }
    var cached: *NameInfo = g_compiler_ctx.module_source_cache.get(file_path, file_path_len);
    if (cached != 0) {
        g_compiler_ctx.file_ptr = cached.ptr;
        g_compiler_ctx.file_len = cached.len;
        return cached;
    }

    var content: u64 = read_entire_file(file_path);
    if (content == 0) { return 0; }

    var source_info: *NameInfo = new NameInfo{g_compiler_ctx.file_ptr, g_compiler_ctx.file_len};
    g_compiler_ctx.module_source_cache.put(file_path, file_path_len, source_info);
    return source_info;
}

func compiler_set_current_source(file_path: u64, file_path_len: u64) -> u64 {
    var source_info: *NameInfo = compiler_get_cached_module_source(file_path, file_path_len);
    if (source_info == 0) { return false; }
    return true;
}

func compiler_get_cached_module_tokens(file_path: u64, file_path_len: u64) -> *Vec<*Token> {
    if (g_compiler_ctx.module_tokens_cache == 0) {
        g_compiler_ctx.module_tokens_cache = new HashMap<u64, *Vec<*Token>>(64);
    }

    var tokens_cached: *Vec<*Token> = g_compiler_ctx.module_tokens_cache.get(file_path, file_path_len);
    if (tokens_cached != 0) { return tokens_cached; }

    var source_info: *NameInfo = compiler_get_cached_module_source(file_path, file_path_len);
    if (source_info == 0) { return 0; }
    var lex_ptr: u64 = source_info.ptr;
    var lex_len: u64 = source_info.len;
    var preprocessed: *NameInfo = lex_preprocess_source(lex_ptr, lex_len);
    if (preprocessed != 0) {
        lex_ptr = preprocessed.ptr;
        lex_len = preprocessed.len;
    }

    var tokens: *Vec<*Token> = lex_all(lex_ptr, lex_len);
    if (lex_error_count() != 0) {
        emit_stderr("[ERROR] lexing failed for module: ");
        emit_stderr_len(file_path, file_path_len);
        emit_stderr(" (");
        emit_u64_stderr(lex_error_count());
        emit_stderr(" error(s))\n");
        return 0;
    }
    g_compiler_ctx.module_tokens_cache.put(file_path, file_path_len, tokens);
    return tokens;
}

// ============================================
// Manifest + Path Parsing
// ============================================

func compiler_trim_ascii_space(raw: u64) -> u64 {
    if (raw == 0) { return 0; }
    var raw_len: u64 = str_len(raw);
    if (raw_len == 0) { return raw; }

    var s_u8: []u8 = slice(raw, raw_len);
    var start: u64 = 0;
    var end: u64 = raw_len;

    while (start < end) {
        var c0: u64 = s_u8[start];
        if (c0 != 32 && c0 != 9 && c0 != 10 && c0 != 13) { break; }
        start = start + 1;
    }
    while (end > start) {
        var c1: u64 = s_u8[end - 1];
        if (c1 != 32 && c1 != 9 && c1 != 10 && c1 != 13) { break; }
        end = end - 1;
    }

    var out_len: u64 = end - start;
    var out: u64 = heap_alloc((out_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out, out_len + 1);
    for (var i: u64 = 0; i < out_len; i++) {
        out_u8[i] = s_u8[start + i];
    }
    out_u8[out_len] = 0;
    return out;
}

func compiler_strip_wrapped_quotes(raw: u64) -> u64 {
    if (raw == 0) { return 0; }
    var raw_len: u64 = str_len(raw);
    if (raw_len < 2) { return raw; }
    var s_u8: []u8 = slice(raw, raw_len);
    if (s_u8[0] != 34 || s_u8[raw_len - 1] != 34) { return raw; }

    var out_len: u64 = raw_len - 2;
    var out: u64 = heap_alloc((out_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out, out_len + 1);
    for (var i: u64 = 0; i < out_len; i++) {
        out_u8[i] = s_u8[i + 1];
    }
    out_u8[out_len] = 0;
    return out;
}

func compiler_clean_manifest_value(raw: u64) -> u64 {
    if (raw == 0) { return 0; }
    var trimmed: u64 = compiler_trim_ascii_space(raw);
    return compiler_strip_wrapped_quotes(trimmed);
}

func read_manifest_value(manifest_path: u64, key_prefix: u64, key_prefix_len: u64) -> u64 {
    var content: u64 = read_entire_file(manifest_path);
    if (content == 0) { return 0; }
    var raw: u64 = module_util_find_line_starting_with(content, g_compiler_ctx.file_len, key_prefix, key_prefix_len);
    return compiler_clean_manifest_value(raw);
}

func compiler_manifest_resolve_path(manifest_dir: u64, manifest_dir_len: u64, value_path: u64) -> u64 {
    if (value_path == 0) { return 0; }
    var val_len: u64 = str_len(value_path);
    if (val_len == 0) { return 0; }
    var val_u8: []u8 = slice(value_path, val_len);
    if (val_u8[0] == 47) { return value_path; }
    return str_concat3(manifest_dir, manifest_dir_len, "/", 1, value_path, val_len);
}

func compiler_try_set_lib_dir_candidate(candidate_dir: u64) -> u64 {
    if (candidate_dir == 0) { return 0; }
    var candidate_len: u64 = str_len(candidate_dir);
    if (candidate_len == 0) { return 0; }

    var std_candidate: u64 = str_concat(candidate_dir, candidate_len, "/std", 4);
    if (module_util_file_exists(std_candidate) == 0) { return 0; }

    g_compiler_ctx.lib_dir = candidate_dir;
    g_compiler_ctx.lib_dir_len = candidate_len;
    return 1;
}

func compiler_try_autodetect_lib_dir(start_dir: u64, start_dir_len: u64) -> u64 {
    var cur: u64 = start_dir;
    var cur_len: u64 = start_dir_len;

    for (var depth: u64 = 0; depth < 64; depth++) {
        if (compiler_try_set_lib_dir_candidate(cur) != 0) { return 1; }

        var src_candidate: u64 = str_concat(cur, cur_len, "/src", 4);
        if (compiler_try_set_lib_dir_candidate(src_candidate) != 0) { return 1; }

        if (cur_len == 0) { break; }
        var parent: u64 = path_dirname(cur, cur_len);
        var parent_len: u64 = str_len(parent);
        if (parent_len == cur_len) {
            if (str_eq(parent, parent_len, cur, cur_len) != 0) { break; }
        }
        cur = parent;
        cur_len = parent_len;
    }

    return 0;
}

func compiler_find_manifest_path(start_dir: u64, start_dir_len: u64) -> u64 {
    var cur: u64 = start_dir;
    var cur_len: u64 = start_dir_len;

    for (var depth: u64 = 0; depth < 64; depth++) {
        var candidate: u64 = str_concat3(cur, cur_len, "/", 1, "bpp.toml", 8);
        if (module_util_file_exists(candidate) != 0) { return candidate; }

        if (cur_len == 0) { break; }
        var parent: u64 = path_dirname(cur, cur_len);
        var parent_len: u64 = str_len(parent);
        if (parent_len == cur_len) {
            if (str_eq(parent, parent_len, cur, cur_len) != 0) { break; }
        }
        cur = parent;
        cur_len = parent_len;
    }

    return 0;
}

// ============================================
// Module Id + Mangling Helpers
// ============================================

// Returns [ptr,len] struct (16 bytes)
func module_id_from_path(path: u64, path_len: u64) -> *NameInfo {
    return module_util_module_id_from_path(path, path_len, g_compiler_ctx.lib_dir, g_compiler_ctx.lib_dir_len, g_compiler_ctx.base_dir, g_compiler_ctx.base_dir_len);
}

// ============================================
// Module Loading
// ============================================

func compiler_resolve_parent_def(parent_desc: *ParentDesc, panic_context: u64) -> *AstStructDef {
    if (parent_desc == 0) { return 0; }
    if (parent_desc.struct_def != 0) { return parent_desc.struct_def; }
    var parent_def: *AstStructDef = get_struct_def(parent_desc.name_ptr, parent_desc.name_len);
    if (parent_def == 0) {
        emit_stderr("[ERROR] Parent struct not found: ");
        emit_stderr_len(parent_desc.name_ptr, parent_desc.name_len);
        emit_stderr("\n");
        panic(panic_context);
    }
    parent_desc.struct_def = parent_def;
    return parent_def;
}

func compiler_is_not_found_u64(value: u64) -> u64 {
    if (value == COMPILER_NOT_FOUND_U64) { return 1; }
    return 0;
}

func compiler_panic(msg: u64) -> u64 {
    var panic_msg: u64 = msg;
    if (panic_msg == 0) { panic_msg = "Compilation failed"; }

    begin_error_capture();
    set_error_context(panic_msg, str_len(panic_msg));
    if (str_eq(panic_msg, str_len(panic_msg), "Compilation failed", 18) != 0) {
        emit_stderr("[ERROR] compilation aborted (see diagnostics above for the root cause)");
        emit_stderr_nl();
    } else {
        emit_stderr("[ERROR] compilation aborted: ");
        emit_stderr_len(panic_msg, str_len(panic_msg));
        emit_stderr_nl();
    }
    if (g_compiler_ctx.current_module_ptr != 0 && g_compiler_ctx.current_module_len != 0) {
        emit_stderr("[ERROR] while compiling module: ");
        emit_stderr_len(g_compiler_ctx.current_module_ptr, g_compiler_ctx.current_module_len);
        emit_stderr_nl();
    }
    panic(panic_msg);
    return 0;
}

func compiler_panic_callsite(msg: u64, call_name_ptr: u64, call_name_len: u64) -> u64 {
    emit_stderr("[ERROR] ");
    emit_stderr(msg);
    if (call_name_ptr != 0 && call_name_len != 0) {
        emit_stderr(": ");
        emit_stderr_len(call_name_ptr, call_name_len);
    }
    emit_stderr("\n");
    panic("Compiler error");
    return 0;
}

func resolve_module_path_cache_put(module_path: u64, module_len: u64, resolved_path: u64) -> u64 {
    g_compiler_ctx.resolved_module_path_cache.put(module_path, module_len, new NameInfo{resolved_path, str_len(resolved_path)});
    return resolved_path;
}

func resolve_module_path_try_cache(module_path: u64, module_len: u64, candidate: u64) -> u64 {
    if (module_util_file_exists(candidate) == 0) { return 0; }
    return resolve_module_path_cache_put(module_path, module_len, candidate);
}

func resolve_module_path_join_root(root_ptr: u64, root_len: u64, rel_ptr: u64, rel_len: u64) -> u64 {
    return str_concat3(root_ptr, root_len, "/", 1, rel_ptr, rel_len);
}

func resolve_module_path_panic_not_found(module_path: u64, module_len: u64, last_candidate: u64) -> u64 {
    emit_stderr("[ERROR] Cannot resolve module path: ");
    emit_stderr_len(module_path, module_len);
    emit_stderr("\n");
    if (last_candidate != 0) {
        emit_stderr("[ERROR] Last tried path: ");
        emit_stderr(last_candidate);
        emit_stderr("\n");
    }
    compiler_panic("Compilation failed");
    return 0;
}

func resolve_module_path(module_path: u64, module_len: u64) -> u64 {
    if (g_compiler_ctx.resolved_module_path_cache == 0) {
        g_compiler_ctx.resolved_module_path_cache = new HashMap<u64, *NameInfo>(256);
    }
    var cached_info: *NameInfo = g_compiler_ctx.resolved_module_path_cache.get(module_path, module_len);
    if (cached_info != 0) { return cached_info.ptr; }

    var eff_path: u64 = module_path;
    var eff_len: u64 = module_len;

    var prefer_lib: u64 = 0;

    if (module_util_is_std_alias(module_path, module_len)) {
        eff_path = module_util_std_alias_to_module_path(module_path, module_len);
        eff_len = str_len(eff_path);
        prefer_lib = 1;
    }

    if (module_util_is_std_path(eff_path, eff_len)) {
        prefer_lib = 1;
    }

    var with_ext: u64 = str_concat(eff_path, eff_len, ".b", 2);
    var with_ext_len: u64 = eff_len + 2;

    var with_ext_bpp: u64 = str_concat(eff_path, eff_len, ".bpp", 4);
    var with_ext_bpp_len: u64 = eff_len + 4;

    var full: u64 = 0;
    var fallback: u64 = 0;
    if (prefer_lib) {
        full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.lib_dir, g_compiler_ctx.lib_dir_len, with_ext_bpp, with_ext_bpp_len));
        if (full != 0) { return full; }
        full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.base_dir, g_compiler_ctx.base_dir_len, with_ext_bpp, with_ext_bpp_len));
        if (full != 0) { return full; }
        if (g_compiler_ctx.project_dir != 0 && g_compiler_ctx.project_dir_len != 0) {
            full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.project_dir, g_compiler_ctx.project_dir_len, with_ext_bpp, with_ext_bpp_len));
            if (full != 0) { return full; }
        }
        full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.lib_dir, g_compiler_ctx.lib_dir_len, with_ext, with_ext_len));
        if (full != 0) { return full; }
        fallback = resolve_module_path_join_root(g_compiler_ctx.base_dir, g_compiler_ctx.base_dir_len, with_ext, with_ext_len);
        full = resolve_module_path_try_cache(module_path, module_len, fallback);
        if (full != 0) { return full; }
        if (g_compiler_ctx.project_dir != 0 && g_compiler_ctx.project_dir_len != 0) {
            fallback = resolve_module_path_join_root(g_compiler_ctx.project_dir, g_compiler_ctx.project_dir_len, with_ext, with_ext_len);
            full = resolve_module_path_try_cache(module_path, module_len, fallback);
            if (full != 0) { return full; }
        }
        return resolve_module_path_panic_not_found(module_path, module_len, fallback);
    }

    full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.base_dir, g_compiler_ctx.base_dir_len, with_ext_bpp, with_ext_bpp_len));
    if (full != 0) { return full; }
    if (g_compiler_ctx.project_dir != 0 && g_compiler_ctx.project_dir_len != 0) {
        full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.project_dir, g_compiler_ctx.project_dir_len, with_ext_bpp, with_ext_bpp_len));
        if (full != 0) { return full; }
    }
    full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.lib_dir, g_compiler_ctx.lib_dir_len, with_ext_bpp, with_ext_bpp_len));
    if (full != 0) { return full; }
    full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.base_dir, g_compiler_ctx.base_dir_len, with_ext, with_ext_len));
    if (full != 0) { return full; }
    if (g_compiler_ctx.project_dir != 0 && g_compiler_ctx.project_dir_len != 0) {
        full = resolve_module_path_try_cache(module_path, module_len, resolve_module_path_join_root(g_compiler_ctx.project_dir, g_compiler_ctx.project_dir_len, with_ext, with_ext_len));
        if (full != 0) { return full; }
    }
    fallback = resolve_module_path_join_root(g_compiler_ctx.lib_dir, g_compiler_ctx.lib_dir_len, with_ext, with_ext_len);
    full = resolve_module_path_try_cache(module_path, module_len, fallback);
    if (full != 0) { return full; }
    return resolve_module_path_panic_not_found(module_path, module_len, fallback);
}

// ============================================
// Import Alias + Export Table
// ============================================

// Export entry: [name_ptr, name_len, mangled_ptr, mangled_len] = 32 bytes
func module_exports_get(module_ptr: u64, module_len: u64) -> *Vec<*ExportEntry> {
    return g_compiler_ctx.module_exports.?get(module_ptr, module_len);
}

func module_export_map_get(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    return g_compiler_ctx.module_export_maps.?get(module_ptr, module_len);
}

func module_export_map_ensure(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    if (g_compiler_ctx.module_export_maps == 0) {
        g_compiler_ctx.module_export_maps = new HashMap<u64, *HashMap<u64, *NameInfo>>(64);
    }
    var existing: *HashMap<u64, *NameInfo> = g_compiler_ctx.module_export_maps.get(module_ptr, module_len);
    if (existing != 0) { return existing; }
    var map: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(128);
    g_compiler_ctx.module_export_maps.put(module_ptr, module_len, map);
    return map;
}

func module_exports_ensure(module_ptr: u64, module_len: u64) -> *Vec<*ExportEntry> {
    if (g_compiler_ctx.module_exports == 0) {
        g_compiler_ctx.module_exports = new HashMap<u64, *Vec<*ExportEntry>>(64);
    }
    var existing: *Vec<*ExportEntry> = g_compiler_ctx.module_exports.get(module_ptr, module_len);
    if (existing != 0) { return existing; }
    var vec: *Vec<*ExportEntry> = new Vec<*ExportEntry>(32);
    g_compiler_ctx.module_exports.put(module_ptr, module_len, vec);
    return vec;
}

func add_module_export(module_ptr: u64, module_len: u64, name_ptr: u64, name_len: u64, mangled_ptr: u64, mangled_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_ensure(module_ptr, module_len);
    var entry: *ExportEntry = new ExportEntry{name_ptr, name_len, mangled_ptr, mangled_len};
    exports.push(entry);
    var export_map: *HashMap<u64, *NameInfo> = module_export_map_ensure(module_ptr, module_len);
    if (export_map.has(name_ptr, name_len) == 0) {
        var info: *NameInfo = new NameInfo{mangled_ptr, mangled_len};
        export_map.put(name_ptr, name_len, info);
    }
    compiler_invalidate_resolve_name_cache();
    return 0;
}

func module_aliases_get(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    return g_compiler_ctx.module_aliases.?get(module_ptr, module_len);
}

func module_aliases_ensure(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    if (g_compiler_ctx.module_aliases == 0) {
        g_compiler_ctx.module_aliases = new HashMap<u64, *HashMap<u64, *NameInfo>>(128);
    }
    var existing: *HashMap<u64, *NameInfo> = g_compiler_ctx.module_aliases.get(module_ptr, module_len);
    if (existing != 0) { return existing; }
    var map: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(128);
    g_compiler_ctx.module_aliases.put(module_ptr, module_len, map);
    return map;
}

func add_import_alias(module_ptr: u64, module_len: u64, alias_ptr: u64, alias_len: u64, mangled_ptr: u64, mangled_len: u64) -> u64 {
    var alias_map: *HashMap<u64, *NameInfo> = module_aliases_ensure(module_ptr, module_len);
    var existing: *NameInfo = alias_map.get(alias_ptr, alias_len);
    if (existing != 0) {
        var ex_ptr: u64 = existing.ptr;
        var ex_len: u64 = existing.len;
        if (ex_ptr == mangled_ptr && ex_len == mangled_len) {
            return 0;
        }
        emit_stderr("[ERROR] import alias conflict: ");
        emit_stderr_len(alias_ptr, alias_len);
        emit_stderr_nl();
        compiler_panic("Compilation failed");
    }
    var info: *NameInfo = new NameInfo{mangled_ptr, mangled_len};
    alias_map.put(alias_ptr, alias_len, info);
    compiler_invalidate_resolve_name_cache();
    return 0;
}

func add_prelude_alias(alias_ptr: u64, alias_len: u64, mangled_ptr: u64, mangled_len: u64) -> u64 {
    if (g_compiler_ctx.prelude_aliases == 0) {
        g_compiler_ctx.prelude_aliases = new HashMap<u64, *NameInfo>(128);
    }
    var existing: *NameInfo = g_compiler_ctx.prelude_aliases.get(alias_ptr, alias_len);
    if (existing != 0) {
        var ex_ptr: u64 = existing.ptr;
        var ex_len: u64 = existing.len;
        if (ex_ptr == mangled_ptr && ex_len == mangled_len) {
            return 0;
        }
        emit_stderr("[ERROR] prelude alias conflict: ");
        emit_stderr_len(alias_ptr, alias_len);
        emit_stderr_nl();
        compiler_panic("Compilation failed");
    }
    var info: *NameInfo = new NameInfo{mangled_ptr, mangled_len};
    g_compiler_ctx.prelude_aliases.put(alias_ptr, alias_len, info);
    // Clear any previous negative-cache mark for this symbol.
    if (g_compiler_ctx.prelude_miss_cache != 0) {
        g_compiler_ctx.prelude_miss_cache.put(alias_ptr, alias_len, 0);
    }
    compiler_invalidate_resolve_name_cache();
    return 0;
}

func resolve_import_alias(module_ptr: u64, module_len: u64, name_ptr: u64, name_len: u64) -> *NameInfo {
    var alias_map: *HashMap<u64, *NameInfo> = module_aliases_get(module_ptr, module_len);
    return alias_map.?get(name_ptr, name_len);
}

func resolve_prelude_alias(name_ptr: u64, name_len: u64) -> *NameInfo {
    return g_compiler_ctx.prelude_aliases.?get(name_ptr, name_len);
}

func compiler_invalidate_resolve_name_cache() -> u64 {
    g_compiler_ctx.resolve_name_hits = 0;
    g_compiler_ctx.resolve_name_misses = 0;
    return 0;
}

func resolve_name_hits_bucket_get(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    if (g_compiler_ctx.resolve_name_hits == 0) { return 0; }
    return g_compiler_ctx.resolve_name_hits.get(module_ptr, module_len);
}

func resolve_name_hits_bucket_ensure(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    if (g_compiler_ctx.resolve_name_hits == 0) {
        g_compiler_ctx.resolve_name_hits = new HashMap<u64, *HashMap<u64, *NameInfo>>(64);
    }
    var bucket: *HashMap<u64, *NameInfo> = g_compiler_ctx.resolve_name_hits.get(module_ptr, module_len);
    if (bucket != 0) { return bucket; }
    var out: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(128);
    g_compiler_ctx.resolve_name_hits.put(module_ptr, module_len, out);
    return out;
}

func resolve_name_misses_bucket_get(module_ptr: u64, module_len: u64) -> *HashMap<u64, u64> {
    if (g_compiler_ctx.resolve_name_misses == 0) { return 0; }
    return g_compiler_ctx.resolve_name_misses.get(module_ptr, module_len);
}

func resolve_name_misses_bucket_ensure(module_ptr: u64, module_len: u64) -> *HashMap<u64, u64> {
    if (g_compiler_ctx.resolve_name_misses == 0) {
        g_compiler_ctx.resolve_name_misses = new HashMap<u64, *HashMap<u64, u64>>(64);
    }
    var bucket: *HashMap<u64, u64> = g_compiler_ctx.resolve_name_misses.get(module_ptr, module_len);
    if (bucket != 0) { return bucket; }
    var out: *HashMap<u64, u64> = new HashMap<u64, u64>(128);
    g_compiler_ctx.resolve_name_misses.put(module_ptr, module_len, out);
    return out;
}

func compiler_rebuild_func_lookup() -> u64 {
    if (g_compiler_ctx.all_funcs == 0) {
        g_compiler_ctx.all_funcs_map = new HashMap<u64, *AstFunc>(16);
        g_compiler_ctx.all_funcs_map_src = 0;
        g_compiler_ctx.all_funcs_map_src_len = 0;
        return 0;
    }
    var n: u64 = g_compiler_ctx.all_funcs.len();
    var cap: u64 = 16;
    if (n > 0) {
        cap = n * 2;
        if (cap < 16) { cap = 16; }
    }
    g_compiler_ctx.all_funcs_map = new HashMap<u64, *AstFunc>(cap);
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
        if (fn == 0) { continue; }
        if (g_compiler_ctx.all_funcs_map.has(fn.name_ptr, fn.name_len) != 0) { continue; }
        g_compiler_ctx.all_funcs_map.put(fn.name_ptr, fn.name_len, fn);
    }
    g_compiler_ctx.all_funcs_map_src = g_compiler_ctx.all_funcs;
    g_compiler_ctx.all_funcs_map_src_len = n;
    return 0;
}

func compiler_extend_func_lookup(from_idx: u64, to_idx: u64) -> u64 {
    if (g_compiler_ctx.all_funcs_map == 0 || g_compiler_ctx.all_funcs == 0) { return 0; }
    for (var i: u64 = from_idx; i < to_idx; i++) {
        var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
        if (fn == 0) { continue; }
        if (g_compiler_ctx.all_funcs_map.has(fn.name_ptr, fn.name_len) != 0) { continue; }
        g_compiler_ctx.all_funcs_map.put(fn.name_ptr, fn.name_len, fn);
    }
    return 0;
}

func compiler_ensure_func_lookup() -> u64 {
    if (g_compiler_ctx.all_funcs == 0) {
        if (g_compiler_ctx.all_funcs_map == 0 || g_compiler_ctx.all_funcs_map_src != 0 || g_compiler_ctx.all_funcs_map_src_len != 0) {
            compiler_rebuild_func_lookup();
        }
        return 0;
    }
    var n: u64 = g_compiler_ctx.all_funcs.len();
    if (g_compiler_ctx.all_funcs_map == 0 || g_compiler_ctx.all_funcs_map_src != g_compiler_ctx.all_funcs || g_compiler_ctx.all_funcs_map_src_len > n) {
        compiler_rebuild_func_lookup();
        return 0;
    }
    if (g_compiler_ctx.all_funcs_map_src_len < n) {
        compiler_extend_func_lookup(g_compiler_ctx.all_funcs_map_src_len, n);
        g_compiler_ctx.all_funcs_map_src_len = n;
    }
    return 0;
}

func compiler_rebuild_const_lookup() -> u64 {
    if (g_compiler_ctx.all_consts == 0) {
        g_compiler_ctx.all_consts_map2 = new HashMap<u64, *AstConstDecl>(16);
        g_compiler_ctx.all_consts_map2_src = 0;
        g_compiler_ctx.all_consts_map2_src_len = 0;
        return 0;
    }
    var n: u64 = g_compiler_ctx.all_consts.len();
    var cap: u64 = 16;
    if (n > 0) {
        cap = n * 2;
        if (cap < 16) { cap = 16; }
    }
    g_compiler_ctx.all_consts_map2 = new HashMap<u64, *AstConstDecl>(cap);
    for (var i: u64 = 0; i < n; i++) {
        var c: *AstConstDecl = g_compiler_ctx.all_consts.get(i);
        if (c == 0) { continue; }
        if (g_compiler_ctx.all_consts_map2.has(c.name_ptr, c.name_len) != 0) { continue; }
        g_compiler_ctx.all_consts_map2.put(c.name_ptr, c.name_len, c);
    }
    g_compiler_ctx.all_consts_map2_src = g_compiler_ctx.all_consts;
    g_compiler_ctx.all_consts_map2_src_len = n;
    return 0;
}

func compiler_extend_const_lookup(from_idx: u64, to_idx: u64) -> u64 {
    if (g_compiler_ctx.all_consts_map2 == 0 || g_compiler_ctx.all_consts == 0) { return 0; }
    for (var i: u64 = from_idx; i < to_idx; i++) {
        var c: *AstConstDecl = g_compiler_ctx.all_consts.get(i);
        if (c == 0) { continue; }
        if (g_compiler_ctx.all_consts_map2.has(c.name_ptr, c.name_len) != 0) { continue; }
        g_compiler_ctx.all_consts_map2.put(c.name_ptr, c.name_len, c);
    }
    return 0;
}

func compiler_ensure_const_lookup() -> u64 {
    if (g_compiler_ctx.all_consts == 0) {
        if (g_compiler_ctx.all_consts_map2 == 0 || g_compiler_ctx.all_consts_map2_src != 0 || g_compiler_ctx.all_consts_map2_src_len != 0) {
            compiler_rebuild_const_lookup();
        }
        return 0;
    }
    var n: u64 = g_compiler_ctx.all_consts.len();
    if (g_compiler_ctx.all_consts_map2 == 0 || g_compiler_ctx.all_consts_map2_src != g_compiler_ctx.all_consts || g_compiler_ctx.all_consts_map2_src_len > n) {
        compiler_rebuild_const_lookup();
        return 0;
    }
    if (g_compiler_ctx.all_consts_map2_src_len < n) {
        compiler_extend_const_lookup(g_compiler_ctx.all_consts_map2_src_len, n);
        g_compiler_ctx.all_consts_map2_src_len = n;
    }
    return 0;
}

func compiler_rebuild_global_lookup() -> u64 {
    if (g_compiler_ctx.all_globals == 0) {
        g_compiler_ctx.all_globals_map2 = new HashMap<u64, *GlobalInfo>(16);
        g_compiler_ctx.all_globals_map2_src = 0;
        g_compiler_ctx.all_globals_map2_src_len = 0;
        return 0;
    }
    var n: u64 = g_compiler_ctx.all_globals.len();
    var cap: u64 = 16;
    if (n > 0) {
        cap = n * 2;
        if (cap < 16) { cap = 16; }
    }
    g_compiler_ctx.all_globals_map2 = new HashMap<u64, *GlobalInfo>(cap);
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(i);
        if (ginfo == 0) { continue; }
        if (g_compiler_ctx.all_globals_map2.has(ginfo.name_ptr, ginfo.name_len) != 0) { continue; }
        g_compiler_ctx.all_globals_map2.put(ginfo.name_ptr, ginfo.name_len, ginfo);
    }
    g_compiler_ctx.all_globals_map2_src = g_compiler_ctx.all_globals;
    g_compiler_ctx.all_globals_map2_src_len = n;
    return 0;
}

func compiler_extend_global_lookup(from_idx: u64, to_idx: u64) -> u64 {
    if (g_compiler_ctx.all_globals_map2 == 0 || g_compiler_ctx.all_globals == 0) { return 0; }
    for (var i: u64 = from_idx; i < to_idx; i++) {
        var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(i);
        if (ginfo == 0) { continue; }
        if (g_compiler_ctx.all_globals_map2.has(ginfo.name_ptr, ginfo.name_len) != 0) { continue; }
        g_compiler_ctx.all_globals_map2.put(ginfo.name_ptr, ginfo.name_len, ginfo);
    }
    return 0;
}

func compiler_ensure_global_lookup() -> u64 {
    if (g_compiler_ctx.all_globals == 0) {
        if (g_compiler_ctx.all_globals_map2 == 0 || g_compiler_ctx.all_globals_map2_src != 0 || g_compiler_ctx.all_globals_map2_src_len != 0) {
            compiler_rebuild_global_lookup();
        }
        return 0;
    }
    var n: u64 = g_compiler_ctx.all_globals.len();
    if (g_compiler_ctx.all_globals_map2 == 0 || g_compiler_ctx.all_globals_map2_src != g_compiler_ctx.all_globals || g_compiler_ctx.all_globals_map2_src_len > n) {
        compiler_rebuild_global_lookup();
        return 0;
    }
    if (g_compiler_ctx.all_globals_map2_src_len < n) {
        compiler_extend_global_lookup(g_compiler_ctx.all_globals_map2_src_len, n);
        g_compiler_ctx.all_globals_map2_src_len = n;
    }
    return 0;
}

func compiler_invalidate_func_lookup() -> u64 {
    g_compiler_ctx.all_funcs_map_src = 0;
    g_compiler_ctx.all_funcs_map_src_len = 0;
    return 0;
}

func compiler_invalidate_const_lookup() -> u64 {
    g_compiler_ctx.all_consts_map2_src = 0;
    g_compiler_ctx.all_consts_map2_src_len = 0;
    return 0;
}

func compiler_invalidate_global_lookup() -> u64 {
    g_compiler_ctx.all_globals_map2_src = 0;
    g_compiler_ctx.all_globals_map2_src_len = 0;
    return 0;
}

func compiler_func_exists(name_ptr: u64, name_len: u64) -> u64 {
    if (g_compiler_ctx.all_funcs == 0) { return false; }
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    compiler_ensure_func_lookup();
    if (g_compiler_ctx.all_funcs_map != 0 && g_compiler_ctx.all_funcs_map.has(resolved_ptr, resolved_len) != 0) {
        return true;
    }
    return false;
}

func compiler_get_func(name_ptr: u64, name_len: u64) -> *AstFunc {
    if (g_compiler_ctx.all_funcs == 0) { return 0; }
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    compiler_ensure_func_lookup();
    return g_compiler_ctx.all_funcs_map.?get(resolved_ptr, resolved_len);
}

func compiler_global_exists(name_ptr: u64, name_len: u64) -> u64 {
    compiler_ensure_global_lookup();
    if (g_compiler_ctx.all_globals_map2 != 0 && g_compiler_ctx.all_globals_map2.has(name_ptr, name_len) != 0) {
        return true;
    }
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0 && g_compiler_ctx.all_globals_map2 != 0) {
        if (g_compiler_ctx.all_globals_map2.has(resolved.ptr, resolved.len) != 0) { return true; }
    }
    return false;
}

func compiler_find_global_info(name_ptr: u64, name_len: u64) -> *GlobalInfo {
    compiler_ensure_global_lookup();
    var ginfo: *GlobalInfo = g_compiler_ctx.all_globals_map2.?get(name_ptr, name_len);
    if (ginfo != 0) { return ginfo; }
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        return g_compiler_ctx.all_globals_map2.?get(resolved.ptr, resolved.len);
    }
    return 0;
}

func compiler_set_all_globals(globals: *Vec<*GlobalInfo>) -> u64 {
    g_compiler_ctx.all_globals = globals;
    compiler_invalidate_global_lookup();
    return 0;
}

func prelude_try_symbol(module_path: u64, module_len: u64, name_ptr: u64, name_len: u64) -> *NameInfo {
    var mod_id: *NameInfo = module_util_module_id_from_import(module_path, module_len);
    if (mod_id == 0) { return 0; }
    var mod_ptr: u64 = mod_id.ptr;
    var mod_len: u64 = mod_id.len;

    var export_map: *HashMap<u64, *NameInfo> = module_export_map_get(mod_ptr, mod_len);
    if (export_map != 0) {
        var mapped: *NameInfo = export_map.get(name_ptr, name_len);
        if (mapped != 0) {
            add_prelude_alias(name_ptr, name_len, mapped.ptr, mapped.len);
            return mapped;
        }
    }

    var exports: *Vec<*ExportEntry> = module_exports_get(mod_ptr, mod_len);
    if (exports == 0) { return 0; }

    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var sym_ptr: u64 = e.name_ptr;
        var sym_len: u64 = e.name_len;
        if (str_eq(sym_ptr, sym_len, name_ptr, name_len) != 0) {
            var mangled_ptr: u64 = e.mangled_ptr;
            var mangled_len: u64 = e.mangled_len;
            add_prelude_alias(name_ptr, name_len, mangled_ptr, mangled_len);
            var info: *NameInfo = new NameInfo{mangled_ptr, mangled_len};
            return info;
        }
    }
    return 0;
}

func resolve_prelude_alias_lazy(name_ptr: u64, name_len: u64) -> *NameInfo {
    // Fast path: most prelude symbols are already preloaded via load_std_prelude().
    var cached: *NameInfo = resolve_prelude_alias(name_ptr, name_len);
    if (cached != 0) { return cached; }

    // Miss cache avoids repeated export scans for non-prelude identifiers.
    if (g_compiler_ctx.prelude_miss_cache != 0) {
        var miss: u64 = g_compiler_ctx.prelude_miss_cache.get(name_ptr, name_len);
        if (miss == 1) { return 0; }
    }

    // Once prelude is fully loaded, a cache miss means definitive miss.
    if (g_compiler_ctx.prelude_loaded != 0) {
        if (g_compiler_ctx.prelude_miss_cache == 0) {
            g_compiler_ctx.prelude_miss_cache = new HashMap<u64, u64>(256);
        }
        g_compiler_ctx.prelude_miss_cache.put(name_ptr, name_len, 1);
        return 0;
    }

    for (var i: u64 = 0; i < PRELUDE_MODULE_COUNT; i++) {
        var prelude_info: ModulePreludeInfo = module_util_prelude_module_info(i);
        if (prelude_info.found == 0) { continue; }
        var info: *NameInfo = prelude_try_symbol(prelude_info.ptr, prelude_info.len, name_ptr, name_len);
        if (info != 0) { return info; }
    }
    if (g_compiler_ctx.prelude_miss_cache == 0) {
        g_compiler_ctx.prelude_miss_cache = new HashMap<u64, u64>(256);
    }
    g_compiler_ctx.prelude_miss_cache.put(name_ptr, name_len, 1);
    return 0;
}

func resolve_name(name_ptr: u64, name_len: u64) -> *NameInfo {
    var module_ptr: u64 = 0;
    var module_len: u64 = 0;
    if (g_compiler_ctx.current_module_ptr != 0 && g_compiler_ctx.current_module_len != 0) {
        module_ptr = g_compiler_ctx.current_module_ptr;
        module_len = g_compiler_ctx.current_module_len;
    }

    var hit_bucket: *HashMap<u64, *NameInfo> = resolve_name_hits_bucket_get(module_ptr, module_len);
    if (hit_bucket != 0) {
        var cached: *NameInfo = hit_bucket.get(name_ptr, name_len);
        if (cached != 0) { return cached; }
    }

    var miss_bucket: *HashMap<u64, u64> = resolve_name_misses_bucket_get(module_ptr, module_len);
    if (miss_bucket != 0) {
        if (miss_bucket.get(name_ptr, name_len) == 1) { return 0; }
    }

    var result: *NameInfo = 0;
    var suffix_idx: u64 = compiler_find_generic_suffix_index(name_ptr, name_len);
    if (suffix_idx < name_len) {
        var base_ptr: u64 = name_ptr;
        var base_len: u64 = suffix_idx;
        var resolved_base: *NameInfo = resolve_name(base_ptr, base_len);
        if (resolved_base != 0) {
            var suffix_len: u64 = name_len - suffix_idx;
            var combined_len: u64 = resolved_base.len + suffix_len;
            var combined_ptr: u64 = heap_alloc((combined_len + 1) * sizeof(u8));
            str_copy(combined_ptr, resolved_base.ptr, resolved_base.len);
            str_copy(combined_ptr + resolved_base.len, name_ptr + suffix_idx, suffix_len);
            var combined_u8: []u8 = slice(combined_ptr, combined_len + 1);
            combined_u8[combined_len] = 0;
            result = new NameInfo{combined_ptr, combined_len};
        }
    }
    if (result == 0 && g_compiler_ctx.current_module_ptr != 0 && g_compiler_ctx.current_module_len != 0) {
        var import_alias: *NameInfo = resolve_import_alias(g_compiler_ctx.current_module_ptr, g_compiler_ctx.current_module_len, name_ptr, name_len);
        if (import_alias != 0) { result = import_alias; }
    }

    if (result == 0 && g_compiler_ctx.current_module_ptr != 0 && g_compiler_ctx.current_module_len != 0) {
        var export_map: *HashMap<u64, *NameInfo> = module_export_map_get(g_compiler_ctx.current_module_ptr, g_compiler_ctx.current_module_len);
        if (export_map != 0) {
            var mapped: *NameInfo = export_map.get(name_ptr, name_len);
            if (mapped != 0) { result = mapped; }
        }
        if (result == 0 && export_map == 0) {
            var exports: *Vec<*ExportEntry> = module_exports_get(g_compiler_ctx.current_module_ptr, g_compiler_ctx.current_module_len);
            if (exports != 0 && exports.len() != 0) {
                emit_stderr("[ERROR] module export map missing for loaded module\n");
                panic("Compiler state error");
            }
        }
    }

    if (result == 0) {
        var prelude_info: *NameInfo = resolve_prelude_alias_lazy(name_ptr, name_len);
        if (prelude_info != 0) { result = prelude_info; }
    }

    if (result != 0) {
        var hit_bucket_w: *HashMap<u64, *NameInfo> = resolve_name_hits_bucket_ensure(module_ptr, module_len);
        hit_bucket_w.put(name_ptr, name_len, result);
        var miss_bucket_w: *HashMap<u64, u64> = resolve_name_misses_bucket_get(module_ptr, module_len);
        if (miss_bucket_w != 0) {
            miss_bucket_w.put(name_ptr, name_len, 0);
        }
        return result;
    }

    var miss_bucket_new: *HashMap<u64, u64> = resolve_name_misses_bucket_ensure(module_ptr, module_len);
    miss_bucket_new.put(name_ptr, name_len, 1);
    return 0;
}

// ============================================
// ASM Register Alias
// ============================================

func compiler_reg_alias_reset() -> u64 {
    g_compiler_ctx.reg_aliases = new HashMap<u64, *NameInfo>(64);
    return 0;
}

func compiler_reg_alias_set(reg_ptr: u64, reg_len: u64, alias_ptr: u64, alias_len: u64) -> u64 {
    if (g_compiler_ctx.reg_aliases == 0) { g_compiler_ctx.reg_aliases = new HashMap<u64, *NameInfo>(64); }
    var info: *NameInfo = new NameInfo{reg_ptr, reg_len};
    g_compiler_ctx.reg_aliases.put(alias_ptr, alias_len, info);
    return 0;
}

func compiler_reg_alias_get(alias_ptr: u64, alias_len: u64) -> *NameInfo {
    return g_compiler_ctx.reg_aliases.?get(alias_ptr, alias_len);
}

// ============================================
// Const Lookup (SSA/Codegen Shared)
// ============================================

func compiler_const_lookup_result() -> *ConstResult {
    if (g_compiler_ctx.const_lookup_result_ptr == 0) {
        g_compiler_ctx.const_lookup_result_ptr = new ConstResult{0, 0};
    }
    return g_compiler_ctx.const_lookup_result_ptr;
}

func compiler_find_const(name_ptr: u64, name_len: u64) -> u64 {
    var res: *ConstResult = compiler_const_lookup_result();
    res.found = 0;
    res.value = 0;
    var result: u64 = (u64)res;

    if (g_compiler_ctx.all_consts == 0) { return result; }
    compiler_ensure_const_lookup();

    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }

    var c: *AstConstDecl = g_compiler_ctx.all_consts_map2.?get(resolved_ptr, resolved_len);
    if (c != 0) {
        res.found = 1;
        res.value = c.value;
    }
    return result;
}

func compiler_find_scoped_const(scope_ptr: u64, scope_len: u64, member_ptr: u64, member_len: u64) -> u64 {
    var res: *ConstResult = compiler_const_lookup_result();
    res.found = 0;
    res.value = 0;
    var result: u64 = (u64)res;

    if (scope_ptr == 0 || scope_len == 0 || member_ptr == 0 || member_len == 0) { return result; }

    var resolved_scope_ptr: u64 = scope_ptr;
    var resolved_scope_len: u64 = scope_len;
    var resolved_scope: *NameInfo = resolve_name(scope_ptr, scope_len);
    if (resolved_scope != 0) {
        resolved_scope_ptr = resolved_scope.ptr;
        resolved_scope_len = resolved_scope.len;
    }

    var scoped_name_resolved: *NameInfo = module_util_build_joined_name(resolved_scope_ptr, resolved_scope_len, member_ptr, member_len);
    var resolved_const: *ConstResult = (*ConstResult)compiler_find_const(scoped_name_resolved.ptr, scoped_name_resolved.len);
    if (resolved_const != 0 && resolved_const.found != 0) { return result; }

    if (resolved_scope_ptr != scope_ptr || resolved_scope_len != scope_len) {
        var scoped_name_raw: *NameInfo = module_util_build_joined_name(scope_ptr, scope_len, member_ptr, member_len);
        var raw_const: *ConstResult = (*ConstResult)compiler_find_const(scoped_name_raw.ptr, scoped_name_raw.len);
        if (raw_const != 0 && raw_const.found != 0) { return result; }
    }
    return result;
}

func import_all_from_module(importer_ptr: u64, importer_len: u64, module_ptr: u64, module_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_get(module_ptr, module_len);
    if (exports == 0) { return false; }
    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var name_ptr: u64 = e.name_ptr;
        var name_len: u64 = e.name_len;
        var mangled_ptr: u64 = e.mangled_ptr;
        var mangled_len: u64 = e.mangled_len;
        add_import_alias(importer_ptr, importer_len, name_ptr, name_len, mangled_ptr, mangled_len);
    }
    return true;
}

func import_symbol_from_module(importer_ptr: u64, importer_len: u64, module_ptr: u64, module_len: u64, symbol_ptr: u64, symbol_len: u64, alias_ptr: u64, alias_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_get(module_ptr, module_len);
    if (exports == 0) { return false; }
    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var name_ptr: u64 = e.name_ptr;
        var name_len: u64 = e.name_len;
        if (str_eq(name_ptr, name_len, symbol_ptr, symbol_len)) {
            var mangled_ptr: u64 = e.mangled_ptr;
            var mangled_len: u64 = e.mangled_len;
            add_import_alias(importer_ptr, importer_len, alias_ptr, alias_len, mangled_ptr, mangled_len);
            return true;
        }
    }
    emit_stderr("[ERROR] import symbol not found: ");
    emit_stderr_len(symbol_ptr, symbol_len);
    emit_stderr_nl();
    compiler_panic("Compilation failed");
    return false;
}

func prelude_import_all_from_module(module_ptr: u64, module_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_get(module_ptr, module_len);
    if (exports == 0) { return false; }
    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var name_ptr: u64 = e.name_ptr;
        var name_len: u64 = e.name_len;
        var mangled_ptr: u64 = e.mangled_ptr;
        var mangled_len: u64 = e.mangled_len;
        add_prelude_alias(name_ptr, name_len, mangled_ptr, mangled_len);
    }
    return true;
}

// After all modules are loaded, resolve import aliases using stored import lists.
func finalize_import_aliases() -> u64 {
    if (g_compiler_ctx.loaded_modules_vec == 0) { return false; }
    var n: u64 = g_compiler_ctx.loaded_modules_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var info: *NameInfo = g_compiler_ctx.loaded_modules_vec.get(i);
        var module_path: u64 = info.ptr;
        var module_path_len: u64 = info.len;
        var module_id: *NameInfo = module_id_from_path(module_path, module_path_len);
        var module_ptr: u64 = module_id.ptr;
        var module_len: u64 = module_id.len;

        var imports: *Vec<*AstImport> = g_compiler_ctx.module_imports_pass2.get(module_path, module_path_len);
        if (imports == 0) { continue; }
        var num_imports: u64 = imports.len();
        for (var ii: u64 = 0; ii < num_imports; ii++) {
            var imp: *AstImport = imports.get(ii);
            var imp_path: u64 = imp.path_ptr;
            var imp_len: u64 = imp.path_len;
            var imp_sym_ptr: u64 = imp.symbol_ptr;
            var imp_sym_len: u64 = imp.symbol_len;
            var imp_alias_ptr: u64 = imp.alias_ptr;
            var imp_alias_len: u64 = imp.alias_len;

            var imp_mod_id: *NameInfo = module_util_module_id_from_import(imp_path, imp_len);
            var imp_mod_ptr: u64 = imp_mod_id.ptr;
            var imp_mod_len: u64 = imp_mod_id.len;

            if (imp_sym_ptr == 0) {
                import_all_from_module(module_ptr, module_len, imp_mod_ptr, imp_mod_len);
            } else {
                import_symbol_from_module(module_ptr, module_len, imp_mod_ptr, imp_mod_len, imp_sym_ptr, imp_sym_len, imp_alias_ptr, imp_alias_len);
            }
        }
    }
    return true;
}

func set_current_module_for_func(func_ptr: u64, func_len: u64) -> u64 {
    g_compiler_ctx.current_module_ptr = 0;
    g_compiler_ctx.current_module_len = 0;
    if (g_compiler_ctx.func_module_map == 0) { return 0; }
    var info: *NameInfo = g_compiler_ctx.func_module_map.get(func_ptr, func_len);
    if (info != 0) {
        g_compiler_ctx.current_module_ptr = info.ptr;
        g_compiler_ctx.current_module_len = info.len;
    }
    return 0;
}

func set_current_module_for_global(name_ptr: u64, name_len: u64) -> u64 {
    g_compiler_ctx.current_module_ptr = 0;
    g_compiler_ctx.current_module_len = 0;
    if (g_compiler_ctx.global_module_map == 0) { return 0; }
    var info: *NameInfo = g_compiler_ctx.global_module_map.get(name_ptr, name_len);
    if (info != 0) {
        g_compiler_ctx.current_module_ptr = info.ptr;
        g_compiler_ctx.current_module_len = info.len;
    }
    return 0;
}

// ============================================
// Export Registration + Mangling
// ============================================

func compiler_mangle_symbol_name(orig_ptr: u64, orig_len: u64, prefix_ptr: u64, prefix_len: u64, preserve_main: u64) -> *NameInfo {
    if (prefix_len == 0) { return new NameInfo{orig_ptr, orig_len}; }
    if (preserve_main != 0 && orig_len == 4 && str_eq(orig_ptr, orig_len, "main", 4)) {
        return new NameInfo{orig_ptr, orig_len};
    }
    return module_util_mangle_name(prefix_ptr, prefix_len, orig_ptr, orig_len);
}

func compiler_ensure_func_module_map() -> *HashMap<u64, *NameInfo> {
    if (g_compiler_ctx.func_module_map == 0) {
        g_compiler_ctx.func_module_map = new HashMap<u64, *NameInfo>(128);
    }
    return g_compiler_ctx.func_module_map;
}

func compiler_ensure_global_module_map() -> *HashMap<u64, *NameInfo> {
    if (g_compiler_ctx.global_module_map == 0) {
        g_compiler_ctx.global_module_map = new HashMap<u64, *NameInfo>(128);
    }
    return g_compiler_ctx.global_module_map;
}

func compiler_copy_impl_method_metadata_if_needed(orig_ptr: u64, orig_len: u64, mangled_ptr: u64, mangled_len: u64) -> u64 {
    if (compiler_is_impl_method(orig_ptr, orig_len) == 0) { return 0; }
    var access: u64 = compiler_get_impl_method_access(orig_ptr, orig_len);
    var owner: *NameInfo = compiler_get_impl_method_owner(orig_ptr, orig_len);
    var fn: *AstFunc = compiler_get_impl_method_func(orig_ptr, orig_len);
    if (owner != 0) {
        compiler_register_impl_method_ex(mangled_ptr, mangled_len, owner.ptr, owner.len, access);
    } else {
        compiler_register_impl_method_ex(mangled_ptr, mangled_len, 0, 0, access);
    }
    if (fn != 0) {
        compiler_register_impl_method_func(mangled_ptr, mangled_len, fn);
    }
    return 0;
}

func compiler_register_module_exports_funcs(funcs: *Vec<*AstFunc>, module_ptr: u64, module_len: u64, prefix_ptr: u64, prefix_len: u64, module_info: *NameInfo) -> u64 {
    if (funcs == 0) { return 0; }
    var func_map: *HashMap<u64, *NameInfo> = compiler_ensure_func_module_map();
    var num_funcs: u64 = funcs.len();
    for (var i: u64 = 0; i < num_funcs; i++) {
        var fn: *AstFunc = funcs.get(i);
        compiler_finalize_impl_method_name_if_needed(fn);
        compiler_register_finalized_impl_method(fn);

        var orig_ptr: u64 = fn.name_ptr;
        var orig_len: u64 = fn.name_len;
        var mangled_info: *NameInfo = compiler_mangle_symbol_name(orig_ptr, orig_len, prefix_ptr, prefix_len, 1);
        fn.name_ptr = mangled_info.ptr;
        fn.name_len = mangled_info.len;
        compiler_copy_impl_method_metadata_if_needed(orig_ptr, orig_len, mangled_info.ptr, mangled_info.len);

        add_module_export(module_ptr, module_len, orig_ptr, orig_len, mangled_info.ptr, mangled_info.len);

        if (compiler_is_generic_template(fn) != 0) {
            var tpl: *GenericFuncTemplate = compiler_find_generic_template_by_func_ptr(fn);
            if (tpl != 0) {
                tpl.mangled_ptr = mangled_info.ptr;
                tpl.mangled_len = mangled_info.len;
                if (g_compiler_ctx.generic_funcs == 0) { g_compiler_ctx.generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64); }
                g_compiler_ctx.generic_funcs.put(mangled_info.ptr, mangled_info.len, tpl);
            }
        }

        func_map.put(mangled_info.ptr, mangled_info.len, module_info);
    }
    return 0;
}

func compiler_register_module_exports_consts(consts: *Vec<*AstConstDecl>, module_ptr: u64, module_len: u64, prefix_ptr: u64, prefix_len: u64) -> u64 {
    if (consts == 0) { return 0; }
    var num_consts: u64 = consts.len();
    for (var ci: u64 = 0; ci < num_consts; ci++) {
        var c: *AstConstDecl = consts.get(ci);
        var orig_ptr: u64 = c.name_ptr;
        var orig_len: u64 = c.name_len;
        var mangled_info: *NameInfo = compiler_mangle_symbol_name(orig_ptr, orig_len, prefix_ptr, prefix_len, 0);
        c.name_ptr = mangled_info.ptr;
        c.name_len = mangled_info.len;
        add_module_export(module_ptr, module_len, orig_ptr, orig_len, mangled_info.ptr, mangled_info.len);
    }
    return 0;
}

func compiler_register_module_exports_globals(globals: *Vec<*GlobalInfo>, module_ptr: u64, module_len: u64, prefix_ptr: u64, prefix_len: u64, module_info: *NameInfo) -> u64 {
    if (globals == 0) { return 0; }
    var global_map: *HashMap<u64, *NameInfo> = compiler_ensure_global_module_map();
    var num_globals: u64 = globals.len();
    for (var gi: u64 = 0; gi < num_globals; gi++) {
        var ginfo: *GlobalInfo = globals.get(gi);
        var orig_ptr: u64 = ginfo.name_ptr;
        var orig_len: u64 = ginfo.name_len;
        var mangled_info: *NameInfo = compiler_mangle_symbol_name(orig_ptr, orig_len, prefix_ptr, prefix_len, 0);
        ginfo.name_ptr = mangled_info.ptr;
        ginfo.name_len = mangled_info.len;
        add_module_export(module_ptr, module_len, orig_ptr, orig_len, mangled_info.ptr, mangled_info.len);
        global_map.put(mangled_info.ptr, mangled_info.len, module_info);
    }
    return 0;
}

func register_module_exports(prog: u64, module_ptr: u64, module_len: u64, prefix_ptr: u64, prefix_len: u64) -> u64 {
    var prog_info: *AstProgram = (*AstProgram)prog;
    var module_info: *NameInfo = new NameInfo{module_ptr, module_len};
    compiler_register_module_exports_funcs(prog_info.funcs_vec, module_ptr, module_len, prefix_ptr, prefix_len, module_info);
    compiler_register_module_exports_consts(prog_info.consts_vec, module_ptr, module_len, prefix_ptr, prefix_len);
    compiler_register_module_exports_globals(prog_info.globals_vec, module_ptr, module_len, prefix_ptr, prefix_len, module_info);
    return 0;
}

func load_module_by_name(module_path: u64, module_len: u64) -> u64 {
    var resolved: u64 = resolve_module_path(module_path, module_len);
    var resolved_len: u64 = str_len(resolved);
    return load_module(resolved, resolved_len);
}

func compiler_import_panic_missing_module() -> u64 {
    emit_stderr("[ERROR] Expected module identifier in import\n");
    compiler_panic("Compilation failed");
    return 0;
}

func compiler_import_is_module_ident_tok(tok: *Token) -> u64 {
    if (tok == 0) { return 0; }
    if (tok.kind == TOKEN_IDENTIFIER) { return 1; }
    if (tok.kind == TOKEN_CHAR && str_eq(tok.ptr, tok.len, "char", 4) != 0) {
        return 1;
    }
    return 0;
}

func compiler_import_expect_module_tok(tokens: *Vec<*Token>, idx: *u64, n: u64) -> *Token {
    if (*idx >= n) {
        compiler_import_panic_missing_module();
    }
    var tok: *Token = tokens.get(*idx);
    if (compiler_import_is_module_ident_tok(tok) == 0) {
        compiler_import_panic_missing_module();
    }
    *idx = *idx + 1;
    return tok;
}

func compiler_import_parse_path_suffix(tokens: *Vec<*Token>, idx: *u64, n: u64, start_tok: *Token) -> *NameInfo {
    var path_ptr: u64 = start_tok.ptr;
    var path_len: u64 = start_tok.len;
    while (*idx < n && tokens.get(*idx).kind == TOKEN_DOT) {
        *idx = *idx + 1;
        var next_tok: *Token = compiler_import_expect_module_tok(tokens, idx, n);
        var joined_path: u64 = str_concat(path_ptr, path_len, "/", 1);
        path_ptr = str_concat(joined_path, path_len + 1, next_tok.ptr, next_tok.len);
        path_len = path_len + 1 + next_tok.len;
    }
    return new NameInfo{path_ptr, path_len};
}

func compiler_import_expect_semicolon(tokens: *Vec<*Token>, idx: *u64, n: u64) -> u64 {
    if (*idx >= n || tokens.get(*idx).kind != TOKEN_SEMICOLON) {
        emit_stderr("[ERROR] Expected ';' after import\n");
        compiler_panic("Compilation failed");
    }
    *idx = *idx + 1;
    return 0;
}

func compiler_scan_imports_from_tokens(tokens: *Vec<*Token>) -> *Vec<*AstImport> {
    var imports: *Vec<*AstImport> = new Vec<*AstImport>(4);
    if (tokens == 0) { return imports; }

    var n: u64 = tokens.len();
    var i: u64 = 0;
    while (i < n) {
        var tok: *Token = tokens.get(i);
        if (tok.kind != TOKEN_IMPORT) {
            i = i + 1;
            continue;
        }
        i = i + 1;
        if (i >= n) { break; }

        var first_tok: *Token = compiler_import_expect_module_tok(tokens, &i, n);

        if (i < n && (tokens.get(i).kind == TOKEN_AS || tokens.get(i).kind == TOKEN_FROM)) {
            var symbol_ptr: u64 = first_tok.ptr;
            var symbol_len: u64 = first_tok.len;
            var alias_ptr: u64 = symbol_ptr;
            var alias_len: u64 = symbol_len;

            if (tokens.get(i).kind == TOKEN_AS) {
                i = i + 1;
                if (i >= n || tokens.get(i).kind != TOKEN_IDENTIFIER) {
                    emit_stderr("[ERROR] Expected alias identifier in import\n");
                    compiler_panic("Compilation failed");
                }
                var alias_tok: *Token = tokens.get(i);
                alias_ptr = alias_tok.ptr;
                alias_len = alias_tok.len;
                i = i + 1;
            }

            if (i >= n || tokens.get(i).kind != TOKEN_FROM) {
                emit_stderr("[ERROR] Expected 'from' in import\n");
                compiler_panic("Compilation failed");
            }
            i = i + 1;

            var mod_tok: *Token = compiler_import_expect_module_tok(tokens, &i, n);
            var path_info: *NameInfo = compiler_import_parse_path_suffix(tokens, &i, n, mod_tok);
            compiler_import_expect_semicolon(tokens, &i, n);

            imports.push(ast_import(path_info.ptr, path_info.len, symbol_ptr, symbol_len, alias_ptr, alias_len));
            continue;
        }

        var path_info2: *NameInfo = compiler_import_parse_path_suffix(tokens, &i, n, first_tok);
        compiler_import_expect_semicolon(tokens, &i, n);
        imports.push(ast_import(path_info2.ptr, path_info2.len, 0, 0, 0, 0));
    }

    return imports;
}

func compiler_pass1_load_imports_recursive(imports_copy: *Vec<*AstImport>) -> u64 {
    if (imports_copy == 0) { return true; }
    var num_imports: u64 = imports_copy.len();
    for (var i: u64 = 0; i < num_imports; i++) {
        var imp: *AstImport = imports_copy.get(i);
        var resolved: u64 = resolve_module_path(imp.path_ptr, imp.path_len);
        var resolved_len: u64 = str_len(resolved);
        if (!load_module_pass1(resolved, resolved_len)) {
            return false;
        }
    }
    return true;
}

func compiler_pass1_register_func_sigs(prog_sig: *AstProgram) -> u64 {
    if (prog_sig == 0) { return 0; }
    var sig_funcs: *Vec<*AstFunc> = prog_sig.funcs_vec;
    var num_sig_funcs: u64 = sig_funcs.len();
    for (var i: u64 = 0; i < num_sig_funcs; i++) {
        var sig_fn: *AstFunc = sig_funcs.get(i);
        g_compiler_ctx.all_func_sigs.push(sig_fn);
    }
    return 0;
}

// Pass1: scan signatures and register generic templates before full parse.
func load_module_pass1(file_path: u64, file_path_len: u64) -> u64 {
    if (g_compiler_ctx.loaded_modules_pass1.has(file_path, file_path_len)) {
        return true;
    }
    g_compiler_ctx.loaded_modules_pass1.put(file_path, file_path_len, 1);

    var tokens: *Vec<*Token> = compiler_get_cached_module_tokens(file_path, file_path_len);
    if (tokens == 0) {
        compiler_report_module_open_error(file_path, file_path_len);
        return false;
    }

    // Pre-scan imports from token stream without parser round-trip.
    var imports_copy: *Vec<*AstImport> = compiler_scan_imports_from_tokens(tokens);
    g_compiler_ctx.module_imports_pass1.put(file_path, file_path_len, imports_copy);

    if (!compiler_pass1_load_imports_recursive(imports_copy)) { return false; }

    if (compiler_set_current_source(file_path, file_path_len) == 0) {
        compiler_report_module_open_error(file_path, file_path_len);
        return false;
    }
    var p1: *Parser = parse_new(tokens);
    var prog_sig: *AstProgram = parse_program_pass1(p1);
    if (prog_sig == 0 || parse_has_errors(p1) != 0) {
        return false;
    }
    compiler_pass1_register_func_sigs(prog_sig);
    return true;
}

func load_std_prelude() -> u64 {
    g_compiler_ctx.prelude_loaded = 0;
    g_compiler_ctx.prelude_miss_cache = new HashMap<u64, u64>(256);
    compiler_invalidate_resolve_name_cache();

    for (var i: u64 = 0; i < PRELUDE_MODULE_COUNT; i++) {
        var prelude_info: ModulePreludeInfo = module_util_prelude_module_info(i);
        if (prelude_info.found == 0) { continue; }
        if (!load_module_by_name(prelude_info.ptr, prelude_info.len)) { return false; }
        var module_id: *NameInfo = module_util_module_id_from_import(prelude_info.ptr, prelude_info.len);
        prelude_import_all_from_module(module_id.ptr, module_id.len);
    }
    g_compiler_ctx.prelude_loaded = 1;
    return true;
}

func compiler_mark_module_loaded(file_path: u64, file_path_len: u64) -> u64 {
    g_compiler_ctx.loaded_modules.put(file_path, file_path_len, 1);
    var path_info: *NameInfo = module_util_clone_name_info(file_path, file_path_len);
    g_compiler_ctx.loaded_modules_vec.push(path_info);
    return 0;
}

func compiler_load_module_import_deps_pass1(file_path: u64, file_path_len: u64) -> u64 {
    if (g_compiler_ctx.module_imports_pass1 == 0) { return true; }
    var imports_p1: *Vec<*AstImport> = g_compiler_ctx.module_imports_pass1.get(file_path, file_path_len);
    if (imports_p1 == 0) { return true; }

    var num_imports_p1: u64 = imports_p1.len();
    for (var pi: u64 = 0; pi < num_imports_p1; pi++) {
        var imp_p1: *AstImport = imports_p1.get(pi);
        var resolved_p1: u64 = resolve_module_path(imp_p1.path_ptr, imp_p1.path_len);
        var resolved_len_p1: u64 = str_len(resolved_p1);
        if (!load_module(resolved_p1, resolved_len_p1)) {
            return false;
        }
    }
    return true;
}

func compiler_module_identity(file_path: u64, file_path_len: u64) -> CompilerModuleIdentity {
    var identity: CompilerModuleIdentity;
    var module_id: *NameInfo = module_id_from_path(file_path, file_path_len);
    var module_prefix: *NameInfo = module_util_module_prefix_from_id(module_id.ptr, module_id.len);
    identity.module_ptr = module_id.ptr;
    identity.module_len = module_id.len;
    identity.prefix_ptr = module_prefix.ptr;
    identity.prefix_len = module_prefix.len;
    return identity;
}

func compiler_merge_program_consts(prog: *AstProgram) -> u64 {
    var consts: *Vec<*AstConstDecl> = prog.consts_vec;
    var num_consts: u64 = consts.len();
    for (var ci: u64 = 0; ci < num_consts; ci++) {
        g_compiler_ctx.all_consts.push(consts.get(ci));
    }
    if (num_consts != 0) { compiler_invalidate_const_lookup(); }
    return 0;
}

func compiler_merge_program_funcs(prog: *AstProgram) -> u64 {
    var funcs: *Vec<*AstFunc> = prog.funcs_vec;
    var num_funcs: u64 = funcs.len();
    for (var fi: u64 = 0; fi < num_funcs; fi++) {
        g_compiler_ctx.all_funcs.push(funcs.get(fi));
    }
    if (num_funcs != 0) { compiler_invalidate_func_lookup(); }
    return 0;
}

func compiler_merge_program_globals(prog: *AstProgram) -> u64 {
    var globals: *Vec<*GlobalInfo> = prog.globals_vec;
    if (globals == 0) { return 0; }

    var num_globals: u64 = globals.len();
    for (var gi: u64 = 0; gi < num_globals; gi++) {
        g_compiler_ctx.all_globals.push(globals.get(gi));
    }
    if (num_globals != 0) { compiler_invalidate_global_lookup(); }
    return 0;
}

func compiler_register_program_structs(prog: *AstProgram) -> u64 {
    var structs: *Vec<*AstStructDef> = prog.structs_vec;
    if (structs == 0) { return 0; }

    var num_structs: u64 = structs.len();
    for (var si: u64 = 0; si < num_structs; si++) {
        var struct_info: *AstStructDef = structs.get(si);
        g_compiler_ctx.all_structs.put(struct_info.name_ptr, struct_info.name_len, struct_info);
    }
    return 0;
}

func compiler_merge_module_program(file_path: u64, file_path_len: u64, prog: *AstProgram, module_ptr: u64, module_len: u64, prefix_ptr: u64, prefix_len: u64) -> u64 {
    register_module_exports(prog, module_ptr, module_len, prefix_ptr, prefix_len);
    compiler_generic_update_mangled_names(prog);

    g_compiler_ctx.module_imports_pass2.put(file_path, file_path_len, prog.imports_vec);
    compiler_merge_program_consts(prog);
    compiler_merge_program_funcs(prog);
    compiler_merge_program_globals(prog);
    compiler_register_program_structs(prog);
    return 0;
}

func load_module(file_path: u64, file_path_len: u64) -> u64 {
    if (g_compiler_ctx.loaded_modules.has(file_path, file_path_len)) {
        return true;
    }

    if (!load_module_pass1(file_path, file_path_len)) {
        return false;
    }

    compiler_mark_module_loaded(file_path, file_path_len);
    if (!compiler_load_module_import_deps_pass1(file_path, file_path_len)) { return false; }

    var tokens: *Vec<*Token> = compiler_get_cached_module_tokens(file_path, file_path_len);
    if (tokens == 0) {
        compiler_report_module_open_error(file_path, file_path_len);
        return false;
    }
    if (compiler_set_current_source(file_path, file_path_len) == 0) {
        compiler_report_module_open_error(file_path, file_path_len);
        return false;
    }
    
    // Module identity for mangling
    var module_identity: CompilerModuleIdentity = compiler_module_identity(file_path, file_path_len);
    
    // Pass 2: full parse with bodies
    var p: *Parser = parse_new(tokens);
    var prog: *AstProgram = parse_program(p);
    if (prog == 0 || parse_has_errors(p) != 0) {
        return false;
    }
    compiler_merge_module_program(file_path, file_path_len, prog, module_identity.module_ptr, module_identity.module_len, module_identity.prefix_ptr, module_identity.prefix_len);

    return true;
}

// ============================================
// Helper functions for parser
// ============================================

// Check if a name is a registered struct type
func is_struct_type(name_ptr: u64, name_len: u64) -> u64 {
    var struct_def: *AstStructDef = g_compiler_ctx.all_structs.?get(name_ptr, name_len);
    if (struct_def == 0) { return false; }
    return true;
}

// Get struct definition by name
func get_struct_def(name_ptr: u64, name_len: u64) -> *AstStructDef {
    return g_compiler_ctx.all_structs.?get(name_ptr, name_len);
}

// Register a struct type during parsing
func register_struct_type(struct_def: *AstStructDef) -> u64 {
    if (g_compiler_ctx.all_structs == 0) {
        g_compiler_ctx.all_structs = new HashMap<u64, *AstStructDef>(64);
    }
    if (g_compiler_ctx.all_structs_vec == 0) {
        g_compiler_ctx.all_structs_vec = new Vec<*AstStructDef>(16);
    }
    var struct_info: *AstStructDef = struct_def;
    var struct_name_ptr: u64 = struct_info.name_ptr;
    var struct_name_len: u64 = struct_info.name_len;
    if (compiler_is_trait_name(struct_name_ptr, struct_name_len) != 0) {
        emit_stderr("[ERROR] Struct name conflicts with trait: ");
        emit_stderr_len(struct_name_ptr, struct_name_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }
    g_compiler_ctx.all_structs.put(struct_name_ptr, struct_name_len, struct_info);
    g_compiler_ctx.all_structs_vec.push(struct_info);
}

// ============================================
// Trait Registry
// ============================================

func compiler_register_trait_def(trait_def: *TraitDef) -> u64 {
    if (trait_def == 0) { return 0; }
    if (g_compiler_ctx.all_traits == 0) {
        g_compiler_ctx.all_traits = new HashMap<u64, *TraitDef>(64);
    }
    if (g_compiler_ctx.all_traits_vec == 0) {
        g_compiler_ctx.all_traits_vec = new Vec<*TraitDef>(16);
    }
    var name_ptr: u64 = trait_def.name_ptr;
    var name_len: u64 = trait_def.name_len;
    var existing: *TraitDef = g_compiler_ctx.all_traits.get(name_ptr, name_len);
    if (existing != 0) {
        existing.name_ptr = name_ptr;
        existing.name_len = name_len;
        existing.methods_vec = trait_def.methods_vec;
        return 0;
    }
    if (g_compiler_ctx.all_structs != 0) {
        var struct_def: *AstStructDef = g_compiler_ctx.all_structs.?get(name_ptr, name_len);
        if (struct_def != 0) {
            emit_stderr("[ERROR] Trait name conflicts with struct: ");
            emit_stderr_len(name_ptr, name_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
    }
    g_compiler_ctx.all_traits.put(name_ptr, name_len, trait_def);
    g_compiler_ctx.all_traits_vec.push(trait_def);
    return 0;
}

func compiler_get_trait_def(name_ptr: u64, name_len: u64) -> *TraitDef {
    if (g_compiler_ctx.all_traits == 0) { return 0; }
    return g_compiler_ctx.all_traits.?get(name_ptr, name_len);
}

func compiler_is_trait_name(name_ptr: u64, name_len: u64) -> u64 {
    var td: *TraitDef = compiler_get_trait_def(name_ptr, name_len);
    if (td == 0) { return false; }
    return true;
}

func compiler_register_trait_impl(trait_impl: *TraitImpl) -> u64 {
    if (trait_impl == 0) { return 0; }
    if (g_compiler_ctx.all_trait_impls_vec == 0) {
        g_compiler_ctx.all_trait_impls_vec = new Vec<*TraitImpl>(32);
    }
    var existing: *TraitImpl = compiler_find_trait_impl(trait_impl.trait_ptr, trait_impl.trait_len, trait_impl.struct_ptr, trait_impl.struct_len);
    if (existing != 0) {
        if (trait_impl.methods_vec != 0) {
            if (existing.methods_vec == 0) {
                existing.methods_vec = trait_impl.methods_vec;
            } else {
                var n: u64 = trait_impl.methods_vec.len();
                for (var i: u64 = 0; i < n; i++) {
                    var m: *TraitImplMethod = trait_impl.methods_vec.get(i);
                    if (compiler_find_trait_impl_method(existing, m.name_ptr, m.name_len) == 0) {
                        existing.methods_vec.push(m);
                    }
                }
            }
        }
        return 0;
    }
    g_compiler_ctx.all_trait_impls_vec.push(trait_impl);
    return 0;
}

func compiler_get_trait_impls() -> *Vec<*TraitImpl> {
    return g_compiler_ctx.all_trait_impls_vec;
}

// ============================================
// Generic Template Registry
// ============================================

func compiler_get_or_create_generic_template(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>) -> *GenericFuncTemplate {
    if (g_compiler_ctx.generic_funcs == 0) { g_compiler_ctx.generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64); }
    var existing: *GenericFuncTemplate = g_compiler_ctx.generic_funcs.get(name_ptr, name_len);
    if (existing != 0) { return existing; }

    var tpl: *GenericFuncTemplate = new GenericFuncTemplate();
    tpl.name_ptr = name_ptr;
    tpl.name_len = name_len;
    tpl.mangled_ptr = 0;
    tpl.mangled_len = 0;
    tpl.params_vec = params_vec;
    tpl.func_sig = 0;
    tpl.func_def = 0;
    g_compiler_ctx.generic_funcs.put(name_ptr, name_len, tpl);
    return tpl;
}

func compiler_get_or_create_generic_struct_template(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>) -> *GenericStructTemplate {
    if (g_compiler_ctx.generic_structs == 0) { g_compiler_ctx.generic_structs = new HashMap<u64, *GenericStructTemplate>(64); }
    var existing: *GenericStructTemplate = g_compiler_ctx.generic_structs.get(name_ptr, name_len);
    if (existing != 0) { return existing; }

    var tpl: *GenericStructTemplate = new GenericStructTemplate();
    tpl.name_ptr = name_ptr;
    tpl.name_len = name_len;
    tpl.params_vec = params_vec;
    tpl.struct_def = 0;
    g_compiler_ctx.generic_structs.put(name_ptr, name_len, tpl);
    return tpl;
}

func compiler_register_generic_struct_def(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>, struct_def: *AstStructDef) -> u64 {
    if (params_vec == 0 || params_vec.len() == 0) { return 0; }
    var tpl: *GenericStructTemplate = compiler_get_or_create_generic_struct_template(name_ptr, name_len, params_vec);
    tpl.params_vec = params_vec;
    tpl.struct_def = struct_def;
    if (g_compiler_ctx.generic_struct_ptrs == 0) { g_compiler_ctx.generic_struct_ptrs = new Vec<*GenericStructTemplate>(16); }
    g_compiler_ctx.generic_struct_ptrs.push(tpl);
    if (GENERIC_DEBUG != 0) {
        emit_stderr("[DEBUG] generic struct template: ");
        emit_stderr_len(name_ptr, name_len);
        emit_stderr("\n");
    }
    return 0;
}

func compiler_find_generic_struct_template_by_name(name_ptr: u64, name_len: u64) -> *GenericStructTemplate {
    return g_compiler_ctx.generic_structs.?get(name_ptr, name_len);
}

func compiler_is_generic_struct_def(struct_def: *AstStructDef) -> u64 {
    if (g_compiler_ctx.generic_struct_ptrs == 0) { return false; }
    var n: u64 = g_compiler_ctx.generic_struct_ptrs.len();
    for (var i: u64 = 0; i < n; i++) {
        var tpl: *GenericStructTemplate = g_compiler_ctx.generic_struct_ptrs.get(i);
        if (tpl.struct_def == struct_def) { return true; }
    }
    return false;
}

func compiler_register_generic_struct_bindings(inst_ptr: u64, inst_len: u64, bindings: *Vec<*GenericBinding>) -> u64 {
    if (inst_ptr == 0 || inst_len == 0 || bindings == 0) { return 0; }
    if (g_compiler_ctx.generic_struct_bindings == 0) { g_compiler_ctx.generic_struct_bindings = new HashMap<u64, *Vec<*GenericBinding>>(64); }
    if (g_compiler_ctx.generic_struct_bindings.has(inst_ptr, inst_len) != 0) { return 0; }
    g_compiler_ctx.generic_struct_bindings.put(inst_ptr, inst_len, bindings);
    return 0;
}

func compiler_get_generic_struct_bindings(inst_ptr: u64, inst_len: u64) -> *Vec<*GenericBinding> {
    if (g_compiler_ctx.generic_struct_bindings == 0) { return 0; }
    return g_compiler_ctx.generic_struct_bindings.get(inst_ptr, inst_len);
}

func compiler_find_generic_suffix_index(name_ptr: u64, name_len: u64) -> u64 {
    if (name_ptr == 0 || name_len < 5) { return name_len; }
    for (var i: u64 = 0; i + 5 <= name_len; i++) {
        if (str_eq(name_ptr + i, 5, "__G__", 5)) { return i; }
    }
    return name_len;
}

func compiler_try_kind_from_typeinfo(ti: *TypeInfo) -> u64 {
    if (ti == 0) { return COMPILER_TRY_KIND_INVALID; }
    if (ti.type_kind != TYPE_STRUCT || ti.ptr_depth != 0) { return COMPILER_TRY_KIND_INVALID; }
    var base_len: u64 = compiler_find_generic_suffix_index(ti.struct_name_ptr, ti.struct_name_len);
    if (str_eq(ti.struct_name_ptr, base_len, "Option", 6)) { return COMPILER_TRY_KIND_OPTION; }
    if (str_eq(ti.struct_name_ptr, base_len, "Result", 6)) { return COMPILER_TRY_KIND_RESULT; }
    return COMPILER_TRY_KIND_INVALID;
}

func compiler_try_field_names(kind: u64) -> CompilerTryFieldNames {
    var names: CompilerTryFieldNames;
    names.found = 0;
    names.check_ptr = 0;
    names.check_len = 0;
    names.value_ptr = 0;
    names.value_len = 0;
    if (kind == COMPILER_TRY_KIND_OPTION) {
        names.found = 1;
        names.check_ptr = (u64)"is_some";
        names.check_len = 7;
        names.value_ptr = (u64)"value";
        names.value_len = 5;
        return names;
    }
    if (kind == COMPILER_TRY_KIND_RESULT) {
        names.found = 1;
        names.check_ptr = (u64)"is_ok";
        names.check_len = 5;
        names.value_ptr = (u64)"ok";
        names.value_len = 2;
        return names;
    }
    return names;
}

func compiler_try_return_matches_type(value_ti: *TypeInfo, ret_type: u64, ret_ptr_depth: u64, ret_struct_name_ptr: u64, ret_struct_name_len: u64) -> u64 {
    if (compiler_try_kind_from_typeinfo(value_ti) == COMPILER_TRY_KIND_INVALID) { return false; }
    if (ret_type != TYPE_STRUCT || ret_ptr_depth != 0) { return false; }
    if (str_eq(ret_struct_name_ptr, ret_struct_name_len, value_ti.struct_name_ptr, value_ti.struct_name_len) == 0) { return false; }
    return true;
}

func compiler_try_resolve_struct_def(value_ti: *TypeInfo) -> *AstStructDef {
    if (value_ti == 0) { return 0; }
    var struct_def: *AstStructDef = value_ti.struct_def;
    if (struct_def == 0) {
        struct_def = get_struct_def(value_ti.struct_name_ptr, value_ti.struct_name_len);
    }
    return struct_def;
}

func compiler_safe_receiver_mode(recv_ti: *TypeInfo) -> u64 {
    if (recv_ti == 0) { return COMPILER_SAFE_RECV_INVALID; }
    if (recv_ti.ptr_depth == 0) { return COMPILER_SAFE_RECV_INVALID; }
    if (recv_ti.type_kind == TYPE_TRAIT || compiler_is_trait_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len) != 0) {
        return COMPILER_SAFE_RECV_TRAIT_PTR;
    }
    if (recv_ti.type_kind == TYPE_STRUCT) { return COMPILER_SAFE_RECV_STRUCT_PTR; }
    return COMPILER_SAFE_RECV_INVALID;
}

func compiler_generic_adopt_impl_params(params_vec: *Vec<*GenericParam>, name_ptr: u64, name_len: u64, is_def: u64) -> *Vec<*GenericParam> {
    if (params_vec != 0 && params_vec.len() != 0) { return params_vec; }
    if (compiler_is_impl_context() == 0) { return params_vec; }

    var tpl: *GenericStructTemplate = compiler_find_generic_struct_template_by_name(g_compiler_ctx.impl_prefix_ptr, g_compiler_ctx.impl_prefix_len);
    if (tpl == 0 || tpl.params_vec == 0 || tpl.params_vec.len() == 0) { return params_vec; }

    if (GENERIC_DEBUG != 0) {
        if (is_def != 0) {
            emit_stderr("[DEBUG] impl generic params adopted for func def: ");
        } else {
            emit_stderr("[DEBUG] impl generic params adopted for func sig: ");
        }
        emit_stderr_len(name_ptr, name_len);
        emit_stderr("\n");
    }
    return tpl.params_vec;
}

func compiler_generic_register_name(name_ptr: u64, name_len: u64) -> *NameInfo {
    if (g_compiler_ctx.impl_prefix_ptr == 0 || g_compiler_ctx.impl_prefix_len == 0) {
        return new NameInfo{name_ptr, name_len};
    }
    return module_util_build_joined_name(g_compiler_ctx.impl_prefix_ptr, g_compiler_ctx.impl_prefix_len, name_ptr, name_len);
}

func compiler_register_generic_func_sig(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>, func_sig: *AstFunc) -> u64 {
    params_vec = compiler_generic_adopt_impl_params(params_vec, name_ptr, name_len, 0);
    if (params_vec == 0 || params_vec.len() == 0) { return 0; }
    var reg_name: *NameInfo = compiler_generic_register_name(name_ptr, name_len);
    var tpl: *GenericFuncTemplate = compiler_get_or_create_generic_template(reg_name.ptr, reg_name.len, params_vec);
    tpl.params_vec = params_vec;
    tpl.func_sig = func_sig;
    return 0;
}

func compiler_register_generic_func_def(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>, func_def: *AstFunc) -> u64 {
    params_vec = compiler_generic_adopt_impl_params(params_vec, name_ptr, name_len, 1);
    if (params_vec == 0 || params_vec.len() == 0) { return 0; }
    var reg_name: *NameInfo = compiler_generic_register_name(name_ptr, name_len);
    var tpl: *GenericFuncTemplate = compiler_get_or_create_generic_template(reg_name.ptr, reg_name.len, params_vec);
    tpl.params_vec = params_vec;
    tpl.func_def = func_def;
    if (g_compiler_ctx.generic_func_ptrs == 0) { g_compiler_ctx.generic_func_ptrs = new Vec<*GenericFuncTemplate>(16); }
    g_compiler_ctx.generic_func_ptrs.push(tpl);
    if (GENERIC_DEBUG != 0) {
        emit_stderr("[DEBUG] generic template: ");
        emit_stderr_len(name_ptr, name_len);
        emit_stderr("\n");
    }
    return 0;
}

func compiler_set_impl_prefix(prefix_ptr: u64, prefix_len: u64) -> u64 {
    g_compiler_ctx.impl_prefix_ptr = prefix_ptr;
    g_compiler_ctx.impl_prefix_len = prefix_len;
    return 0;
}

func compiler_clear_impl_prefix() -> u64 {
    g_compiler_ctx.impl_prefix_ptr = 0;
    g_compiler_ctx.impl_prefix_len = 0;
    return 0;
}

func compiler_is_impl_context() -> u64 {
    if (g_compiler_ctx.impl_prefix_ptr != 0 && g_compiler_ctx.impl_prefix_len != 0) { return true; }
    return false;
}

func compiler_impl_has_generic_param(name_ptr: u64, name_len: u64) -> u64 {
    if (compiler_is_impl_context() == 0) { return false; }
    var tpl: *GenericStructTemplate = compiler_find_generic_struct_template_by_name(g_compiler_ctx.impl_prefix_ptr, g_compiler_ctx.impl_prefix_len);
    if (tpl == 0 || tpl.params_vec == 0) { return false; }
    var n: u64 = tpl.params_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var gp: *GenericParam = tpl.params_vec.get(i);
        if (str_eq(gp.name_ptr, gp.name_len, name_ptr, name_len) != 0) {
            return true;
        }
    }
    return false;
}

func compiler_set_current_access_struct(struct_ptr: u64, struct_len: u64) -> u64 {
    g_compiler_ctx.current_access_struct_ptr = struct_ptr;
    g_compiler_ctx.current_access_struct_len = struct_len;
    return 0;
}

func compiler_clear_current_access_struct() -> u64 {
    g_compiler_ctx.current_access_struct_ptr = 0;
    g_compiler_ctx.current_access_struct_len = 0;
    return 0;
}

func compiler_set_current_access_struct_from_func(func_ptr: u64, func_len: u64) -> u64 {
    compiler_clear_current_access_struct();
    if (g_compiler_ctx.impl_method_owner == 0) { return 0; }
    var owner: *NameInfo = g_compiler_ctx.impl_method_owner.get(func_ptr, func_len);
    if (owner == 0) { return 0; }
    compiler_set_current_access_struct(owner.ptr, owner.len);
    return 0;
}

func compiler_register_impl_method_ex(name_ptr: u64, name_len: u64, owner_struct_ptr: u64, owner_struct_len: u64, access: u64) -> u64 {
    if (name_ptr == 0 || name_len == 0) { return 0; }
    if (g_compiler_ctx.impl_methods == 0) { g_compiler_ctx.impl_methods = new HashMap<u64, u64>(64); }
    if (g_compiler_ctx.impl_method_access == 0) { g_compiler_ctx.impl_method_access = new HashMap<u64, u64>(64); }
    if (g_compiler_ctx.impl_method_owner == 0) { g_compiler_ctx.impl_method_owner = new HashMap<u64, *NameInfo>(64); }
    g_compiler_ctx.impl_methods.put(name_ptr, name_len, 1);
    g_compiler_ctx.impl_method_access.put(name_ptr, name_len, access);
    if (owner_struct_ptr != 0 && owner_struct_len != 0) {
        g_compiler_ctx.impl_method_owner.put(name_ptr, name_len, new NameInfo{owner_struct_ptr, owner_struct_len});
    }
    return 0;
}

func compiler_register_impl_method_func(name_ptr: u64, name_len: u64, fn: *AstFunc) -> u64 {
    if (name_ptr == 0 || name_len == 0 || fn == 0) { return 0; }
    if (g_compiler_ctx.impl_method_funcs == 0) { g_compiler_ctx.impl_method_funcs = new HashMap<u64, *AstFunc>(64); }
    g_compiler_ctx.impl_method_funcs.put(name_ptr, name_len, fn);
    return 0;
}

func compiler_is_constructor_name(name_ptr: u64, name_len: u64) -> u64 {
    if (str_eq(name_ptr, name_len, "constructor", 11) != 0) { return 1; }
    return 0;
}

func compiler_is_destructor_name(name_ptr: u64, name_len: u64) -> u64 {
    if (str_eq(name_ptr, name_len, "destructor", 10) != 0) { return 1; }
    return 0;
}

func compiler_is_self_param(param: *Param) -> u64 {
    if (param == 0) { return 0; }
    if (param.type_kind != TYPE_STRUCT) { return 0; }
    if (param.ptr_depth == 0) { return 0; }
    if (param.name_ptr == 0 || param.name_len == 0) { return 0; }
    if (str_eq(param.name_ptr, param.name_len, "self", 4) == 0) { return 0; }
    return 1;
}

func compiler_method_param_start_index(fn: *AstFunc) -> u64 {
    if (fn == 0 || fn.params_vec == 0 || fn.params_vec.len() == 0) { return 0; }
    if (compiler_is_self_param(fn.params_vec.get(0)) != 0) { return 1; }
    return 0;
}

func compiler_overload_hex_digit(v: u64) -> u64 {
    if (v < 10) { return 48 + v; }
    return 97 + (v - 10);
}

func compiler_overload_append_hex16(buf: u64, pos_ptr: *u64, value: u64) -> u64 {
    var out: *u8 = (*u8)buf;
    for (var i: u64 = 0; i < 16; i++) {
        var shift: u64 = (15 - i) * 4;
        var d: u64 = (value >> shift) & 15;
        out[*pos_ptr] = compiler_overload_hex_digit(d);
        *pos_ptr = *pos_ptr + 1;
    }
    return 0;
}

func compiler_method_overload_suffix_from_func(fn: *AstFunc) -> *NameInfo {
    if (fn == 0 || fn.params_vec == 0) { return new NameInfo{0, 0}; }
    var start_idx: u64 = compiler_method_param_start_index(fn);
    var params_len: u64 = fn.params_vec.len();
    if (start_idx > params_len) { start_idx = params_len; }

    var total_len: u64 = 4; // "__OL"
    for (var i: u64 = start_idx; i < params_len; i++) {
        var p: *Param = fn.params_vec.get(i);
        var sn_len: u64 = 0;
        var arr_param_len: u64 = 0;
        if (p != 0) {
            sn_len = p.struct_name_len;
            arr_param_len = p.array_len_param_len;
        }
        total_len = total_len + 1 + (16 * 9) + 2 + sn_len + arr_param_len;
    }

    var buf: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out: *u8 = (*u8)buf;
    var pos: u64 = 0;
    out[pos] = 95; pos = pos + 1; // _
    out[pos] = 95; pos = pos + 1; // _
    out[pos] = 79; pos = pos + 1; // O
    out[pos] = 76; pos = pos + 1; // L

    for (var j: u64 = start_idx; j < params_len; j++) {
        var p2: *Param = fn.params_vec.get(j);
        out[pos] = 95; pos = pos + 1; // _

        compiler_overload_append_hex16(buf, &pos, p2.type_kind);
        compiler_overload_append_hex16(buf, &pos, p2.ptr_depth);
        compiler_overload_append_hex16(buf, &pos, p2.is_tagged);
        compiler_overload_append_hex16(buf, &pos, p2.struct_name_len);
        if (p2.struct_name_len > 0 && p2.struct_name_ptr != 0) {
            str_copy(buf + pos, p2.struct_name_ptr, p2.struct_name_len);
            pos = pos + p2.struct_name_len;
        }
        out[pos] = 95; pos = pos + 1; // _
        compiler_overload_append_hex16(buf, &pos, p2.elem_type_kind);
        compiler_overload_append_hex16(buf, &pos, p2.elem_ptr_depth);
        compiler_overload_append_hex16(buf, &pos, p2.array_len);
        compiler_overload_append_hex16(buf, &pos, p2.array_len_is_param);
        compiler_overload_append_hex16(buf, &pos, p2.array_len_param_len);
        if (p2.array_len_param_len > 0 && p2.array_len_param_ptr != 0) {
            str_copy(buf + pos, p2.array_len_param_ptr, p2.array_len_param_len);
            pos = pos + p2.array_len_param_len;
        }
        out[pos] = 95; pos = pos + 1; // _
    }

    out[pos] = 0;
    return new NameInfo{buf, pos};
}

func compiler_method_overload_variant_count(owner_ptr: u64, owner_len: u64, method_ptr: u64, method_len: u64) -> u64 {
    if (owner_ptr == 0 || owner_len == 0 || method_ptr == 0 || method_len == 0) { return 0; }
    var src: *Vec<*AstFunc> = g_compiler_ctx.all_func_sigs;
    if (src == 0 || src.len() == 0) { src = g_compiler_ctx.all_funcs; }
    if (src == 0) { return 0; }

    var seen: *HashMap<u64, u64> = new HashMap<u64, u64>(8);
    var count: u64 = 0;
    var n: u64 = src.len();
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = src.get(i);
        if (fn == 0) { continue; }
        if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { continue; }
        if (str_eq(fn.impl_owner_ptr, fn.impl_owner_len, owner_ptr, owner_len) == 0) { continue; }

        var cand_ptr: u64 = fn.impl_original_name_ptr;
        var cand_len: u64 = fn.impl_original_name_len;
        if (cand_ptr == 0 || cand_len == 0) {
            cand_ptr = fn.name_ptr;
            cand_len = fn.name_len;
        }
        if (str_eq(cand_ptr, cand_len, method_ptr, method_len) == 0) { continue; }

        var sig: *NameInfo = compiler_method_overload_suffix_from_func(fn);
        if (seen.has(sig.ptr, sig.len) == 0) {
            seen.put(sig.ptr, sig.len, 1);
            count = count + 1;
        }
    }
    return count;
}

func compiler_method_is_overloadable(fn: *AstFunc, original_name_ptr: u64, original_name_len: u64) -> u64 {
    if (fn == 0) { return 0; }
    if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { return 0; }
    if (compiler_is_destructor_name(original_name_ptr, original_name_len) != 0) { return 0; }
    if (fn.params_vec == 0 || fn.params_vec.len() == 0) { return 0; }
    if (compiler_is_self_param(fn.params_vec.get(0)) == 0) { return 0; } // static methods are excluded
    if (compiler_method_overload_variant_count(fn.impl_owner_ptr, fn.impl_owner_len, original_name_ptr, original_name_len) > 1) {
        return 1;
    }
    return 0;
}

func compiler_build_method_name_with_overload_suffix(struct_name_ptr: u64, struct_name_len: u64, method_ptr: u64, method_len: u64, overload_ptr: u64, overload_len: u64) -> *NameInfo {
    var base_name: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, method_ptr, method_len);
    if (overload_ptr == 0 || overload_len == 0) { return base_name; }
    var full_ptr: u64 = str_concat(base_name.ptr, base_name.len, overload_ptr, overload_len);
    return new NameInfo{full_ptr, base_name.len + overload_len};
}

func _compiler_struct_distance_to_ancestor(struct_def: *AstStructDef, ancestor_ptr: u64, ancestor_len: u64, depth: u64) -> u64 {
    if (struct_def == 0) { return COMPILER_INHERIT_DIST_NOT_FOUND; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }
    if (str_eq(struct_def.name_ptr, struct_def.name_len, ancestor_ptr, ancestor_len) != 0) {
        return 0;
    }
    if (struct_def.parents_vec == 0 || struct_def.parents_vec.len() == 0) {
        return COMPILER_INHERIT_DIST_NOT_FOUND;
    }
    var best: u64 = COMPILER_INHERIT_DIST_NOT_FOUND;
    var pn: u64 = struct_def.parents_vec.len();
    for (var i: u64 = 0; i < pn; i++) {
        var pd: *ParentDesc = struct_def.parents_vec.get(i);
        var pdef: *AstStructDef = compiler_resolve_parent_def(pd, "Compiler error");
        var d: u64 = _compiler_struct_distance_to_ancestor(pdef, ancestor_ptr, ancestor_len, depth + 1);
        if (d == COMPILER_INHERIT_DIST_NOT_FOUND) { continue; }
        var cand: u64 = d + 1;
        if (best == COMPILER_INHERIT_DIST_NOT_FOUND || cand < best) {
            best = cand;
        }
    }
    return best;
}

func compiler_struct_distance_to_ancestor(child_ptr: u64, child_len: u64, ancestor_ptr: u64, ancestor_len: u64) -> u64 {
    var child_def: *AstStructDef = get_struct_def(child_ptr, child_len);
    if (child_def == 0) { return COMPILER_INHERIT_DIST_NOT_FOUND; }
    return _compiler_struct_distance_to_ancestor(child_def, ancestor_ptr, ancestor_len, 0);
}

func compiler_method_param_match_score(expected: *Param, arg_ti: *TypeInfo) -> u64 {
    if (expected == 0 || arg_ti == 0) { return 0; }

    if (expected.type_kind == TYPE_STRUCT) {
        if (arg_ti.type_kind != TYPE_STRUCT) { return 0; }
        if (expected.ptr_depth != arg_ti.ptr_depth) { return 0; }
        if (expected.struct_name_ptr == 0 || expected.struct_name_len == 0) { return 0; }
        if (arg_ti.struct_name_ptr == 0 || arg_ti.struct_name_len == 0) { return 0; }
        if (str_eq(expected.struct_name_ptr, expected.struct_name_len, arg_ti.struct_name_ptr, arg_ti.struct_name_len) != 0) {
            return 6;
        }
        if (expected.ptr_depth > 0 &&
            compiler_struct_is_same_or_descendant(arg_ti.struct_name_ptr, arg_ti.struct_name_len, expected.struct_name_ptr, expected.struct_name_len) != 0) {
            return 3;
        }
        return 0;
    }

    if (expected.type_kind == TYPE_ARRAY || expected.type_kind == TYPE_SLICE) {
        if (expected.type_kind != arg_ti.type_kind) { return 0; }
        if (expected.ptr_depth != arg_ti.ptr_depth) { return 0; }
        if (expected.type_kind == TYPE_ARRAY && expected.array_len != arg_ti.array_len) { return 0; }
        if (expected.elem_typeinfo != 0 || arg_ti.elem_typeinfo != 0) {
            if (expected.elem_typeinfo == 0 || arg_ti.elem_typeinfo == 0) { return 0; }
            if (!generic_type_equal(expected.elem_typeinfo, arg_ti.elem_typeinfo)) { return 0; }
        } else {
            if (expected.elem_type_kind != arg_ti.elem_type_kind) { return 0; }
            if (expected.elem_ptr_depth != arg_ti.elem_ptr_depth) { return 0; }
            if (expected.elem_type_kind == TYPE_STRUCT) {
                if (str_eq(expected.struct_name_ptr, expected.struct_name_len, arg_ti.struct_name_ptr, arg_ti.struct_name_len) == 0) {
                    return 0;
                }
            }
        }
        return 4;
    }

    if (expected.type_kind == TYPE_TRAIT) {
        if (arg_ti.type_kind != TYPE_TRAIT) { return 0; }
        if (expected.ptr_depth != arg_ti.ptr_depth) { return 0; }
        if (str_eq(expected.struct_name_ptr, expected.struct_name_len, arg_ti.struct_name_ptr, arg_ti.struct_name_len) == 0) {
            return 0;
        }
        return 5;
    }

    if (expected.type_kind != arg_ti.type_kind) { return 0; }
    if (expected.ptr_depth != arg_ti.ptr_depth) { return 0; }
    return 5;
}

func compiler_method_match_score(fn: *AstFunc, arg_types: *Vec<*TypeInfo>, arg_count_hint: u64) -> u64 {
    if (fn == 0 || fn.params_vec == 0) { return 0; }
    var start_idx: u64 = compiler_method_param_start_index(fn);
    var expected_arg_count: u64 = fn.params_vec.len() - start_idx;
    if (arg_types == 0) {
        if (expected_arg_count != arg_count_hint) { return 0; }
        return 1;
    }
    if (arg_types.len() != expected_arg_count) { return 0; }
    var total: u64 = 0;
    for (var i: u64 = 0; i < expected_arg_count; i++) {
        var expected: *Param = fn.params_vec.get(start_idx + i);
        var actual: *TypeInfo = arg_types.get(i);
        var score: u64 = compiler_method_param_match_score(expected, actual);
        if (score == 0) { return 0; }
        total = total + score;
    }
    return total;
}

func compiler_method_resolve_none() -> CompilerMethodResolveResult {
    var result: CompilerMethodResolveResult;
    result.found = 0;
    result.fn = 0;
    result.owner_ptr = 0;
    result.owner_len = 0;
    result.access = ACCESS_PUBLIC;
    return result;
}

func compiler_resolve_method_overload(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64, arg_types: *Vec<*TypeInfo>, arg_count_hint: u64) -> CompilerMethodResolveResult {
    var result: CompilerMethodResolveResult = compiler_method_resolve_none();
    if (struct_ptr == 0 || struct_len == 0 || method_ptr == 0 || method_len == 0) { return result; }
    if (g_compiler_ctx.all_funcs == 0) { return result; }

    var best_score: u64 = 0;
    var best_fn: *AstFunc = 0;
    var ambiguous: u64 = 0;
    var n: u64 = g_compiler_ctx.all_funcs.len();
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
        if (fn == 0) { continue; }
        if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { continue; }

        var cand_ptr: u64 = fn.impl_original_name_ptr;
        var cand_len: u64 = fn.impl_original_name_len;
        if (cand_ptr == 0 || cand_len == 0) {
            cand_ptr = fn.name_ptr;
            cand_len = fn.name_len;
        }
        if (str_eq(cand_ptr, cand_len, method_ptr, method_len) == 0) { continue; }

        var dist: u64 = compiler_struct_distance_to_ancestor(struct_ptr, struct_len, fn.impl_owner_ptr, fn.impl_owner_len);
        if (dist == COMPILER_INHERIT_DIST_NOT_FOUND) { continue; }

        var match_score: u64 = compiler_method_match_score(fn, arg_types, arg_count_hint);
        if (match_score == 0) { continue; }

        var depth_bonus: u64 = 0;
        if (dist < 1024) { depth_bonus = 1024 - dist; }
        var total_score: u64 = match_score * 2048 + depth_bonus;

        if (best_fn == 0 || total_score > best_score) {
            best_score = total_score;
            best_fn = fn;
            ambiguous = 0;
            continue;
        }
        if (total_score == best_score && best_fn != fn) {
            ambiguous = 1;
        }
    }

    if (ambiguous != 0) {
        emit_stderr("[ERROR] ambiguous overloaded method resolution: ");
        emit_stderr_len(struct_ptr, struct_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    if (best_fn == 0) { return result; }

    result.found = 1;
    result.fn = best_fn;
    result.owner_ptr = best_fn.impl_owner_ptr;
    result.owner_len = best_fn.impl_owner_len;
    result.access = best_fn.impl_method_access;
    return result;
}

func compiler_resolve_method_overload_with_count_fallback(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64, arg_types: *Vec<*TypeInfo>, arg_count_hint: u64) -> CompilerMethodResolveResult {
    var result: CompilerMethodResolveResult = compiler_resolve_method_overload(struct_ptr, struct_len, method_ptr, method_len, arg_types, arg_count_hint);
    if (result.found == 0 && arg_types != 0) {
        result = compiler_resolve_method_overload(struct_ptr, struct_len, method_ptr, method_len, 0, arg_count_hint);
    }
    return result;
}

func compiler_resolve_constructor_overload(struct_ptr: u64, struct_len: u64, arg_types: *Vec<*TypeInfo>, arg_count_hint: u64) -> CompilerMethodResolveResult {
    var result: CompilerMethodResolveResult = compiler_resolve_method_overload_with_count_fallback(struct_ptr, struct_len, "constructor", 11, arg_types, arg_count_hint);
    return result;
}

func compiler_method_arg_types_from_params(fn: *AstFunc) -> *Vec<*TypeInfo> {
    if (fn == 0 || fn.params_vec == 0) { return 0; }
    var start_idx: u64 = compiler_method_param_start_index(fn);
    var n: u64 = fn.params_vec.len();
    if (n < start_idx) { n = start_idx; }
    var out: *Vec<*TypeInfo> = new Vec<*TypeInfo>(n - start_idx);
    for (var i: u64 = start_idx; i < n; i++) {
        var p: *Param = fn.params_vec.get(i);
        var ti: *TypeInfo = new TypeInfo(p.type_kind, p.ptr_depth);
        p.apply_to_typeinfo(ti);
        if (ti.type_kind == TYPE_STRUCT && ti.struct_def == 0 && ti.struct_name_ptr != 0) {
            ti.struct_def = get_struct_def(ti.struct_name_ptr, ti.struct_name_len);
        }
        out.push(ti);
    }
    return out;
}

func compiler_finalize_impl_method_name_if_needed(fn: *AstFunc) -> u64 {
    if (fn == 0) { return 0; }
    if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { return 0; }
    if (fn.impl_name_finalized != 0) { return 0; }

    var original_name_ptr: u64 = fn.impl_original_name_ptr;
    var original_name_len: u64 = fn.impl_original_name_len;
    if (original_name_ptr == 0 || original_name_len == 0) {
        original_name_ptr = fn.name_ptr;
        original_name_len = fn.name_len;
        fn.impl_original_name_ptr = original_name_ptr;
        fn.impl_original_name_len = original_name_len;
    }

    var name_info: *NameInfo = 0;
    if (compiler_method_is_overloadable(fn, original_name_ptr, original_name_len) != 0) {
        var overload_suffix: *NameInfo = compiler_method_overload_suffix_from_func(fn);
        name_info = compiler_build_method_name_with_overload_suffix(fn.impl_owner_ptr, fn.impl_owner_len, original_name_ptr, original_name_len, overload_suffix.ptr, overload_suffix.len);
    } else {
        name_info = compiler_build_method_name(fn.impl_owner_ptr, fn.impl_owner_len, original_name_ptr, original_name_len);
    }
    fn.name_ptr = name_info.ptr;
    fn.name_len = name_info.len;
    fn.impl_name_finalized = 1;
    return 0;
}

func compiler_register_finalized_impl_method(fn: *AstFunc) -> u64 {
    if (fn == 0) { return 0; }
    if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { return 0; }
    var prev: *AstFunc = compiler_get_impl_method_func(fn.name_ptr, fn.name_len);
    if (prev != 0 && prev != fn) {
        var same_owner: u64 = str_eq(prev.impl_owner_ptr, prev.impl_owner_len, fn.impl_owner_ptr, fn.impl_owner_len);
        var prev_method_ptr: u64 = prev.impl_original_name_ptr;
        var prev_method_len: u64 = prev.impl_original_name_len;
        if (prev_method_ptr == 0 || prev_method_len == 0) {
            prev_method_ptr = prev.name_ptr;
            prev_method_len = prev.name_len;
        }
        var fn_method_ptr: u64 = fn.impl_original_name_ptr;
        var fn_method_len: u64 = fn.impl_original_name_len;
        if (fn_method_ptr == 0 || fn_method_len == 0) {
            fn_method_ptr = fn.name_ptr;
            fn_method_len = fn.name_len;
        }
        var same_method: u64 = str_eq(prev_method_ptr, prev_method_len, fn_method_ptr, fn_method_len);
        var same_signature: u64 = 0;
        if (same_owner != 0 && same_method != 0) {
            var prev_sig: *NameInfo = compiler_method_overload_suffix_from_func(prev);
            var fn_sig: *NameInfo = compiler_method_overload_suffix_from_func(fn);
            if (prev_sig.len == fn_sig.len) {
                if (prev_sig.len == 0 || str_eq(prev_sig.ptr, prev_sig.len, fn_sig.ptr, fn_sig.len) != 0) {
                    same_signature = 1;
                }
            }
        }
        if (same_signature != 0) {
            var prev_has_body: u64 = 0;
            var fn_has_body: u64 = 0;
            if (prev.body != 0) { prev_has_body = 1; }
            if (fn.body != 0) { fn_has_body = 1; }

            if (prev_has_body != 0 && fn_has_body != 0) {
                emit_stderr("[ERROR] duplicate method signature in impl: ");
                emit_stderr_len(fn.impl_owner_ptr, fn.impl_owner_len);
                emit_stderr(".");
                emit_stderr_len(fn_method_ptr, fn_method_len);
                emit_stderr("\n");
                compiler_panic("Compilation failed");
            }

            // Prefer keeping the definition node over a signature-only placeholder.
            if (prev_has_body != 0 && fn_has_body == 0) {
                return 0;
            }
        } else {
            emit_stderr("[ERROR] duplicate method signature in impl: ");
            emit_stderr_len(fn.impl_owner_ptr, fn.impl_owner_len);
            emit_stderr(".");
            emit_stderr_len(fn_method_ptr, fn_method_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
    }
    compiler_register_impl_method_ex(fn.name_ptr, fn.name_len, fn.impl_owner_ptr, fn.impl_owner_len, fn.impl_method_access);
    compiler_register_impl_method_func(fn.name_ptr, fn.name_len, fn);
    compiler_alias_generic_template_by_func_ptr(fn, fn.name_ptr, fn.name_len);

    var resolved_method: *NameInfo = resolve_name(fn.name_ptr, fn.name_len);
    if (resolved_method != 0) {
        compiler_alias_generic_template_by_func_ptr(fn, resolved_method.ptr, resolved_method.len);
    }
    return 0;
}

func compiler_get_impl_method_access(name_ptr: u64, name_len: u64) -> u64 {
    if (g_compiler_ctx.impl_method_access == 0) { return ACCESS_PUBLIC; }
    if (g_compiler_ctx.impl_method_access.has(name_ptr, name_len) == 0) { return ACCESS_PUBLIC; }
    return g_compiler_ctx.impl_method_access.get(name_ptr, name_len);
}

func compiler_get_impl_method_owner(name_ptr: u64, name_len: u64) -> *NameInfo {
    if (g_compiler_ctx.impl_method_owner == 0) { return 0; }
    return g_compiler_ctx.impl_method_owner.get(name_ptr, name_len);
}

func compiler_get_impl_method_func(name_ptr: u64, name_len: u64) -> *AstFunc {
    if (g_compiler_ctx.impl_method_funcs == 0) { return 0; }
    return g_compiler_ctx.impl_method_funcs.get(name_ptr, name_len);
}

func compiler_abst_method_access_map_ensure(struct_ptr: u64, struct_len: u64) -> *HashMap<u64, u64> {
    if (g_compiler_ctx.abst_methods_access == 0) {
        g_compiler_ctx.abst_methods_access = new HashMap<u64, *HashMap<u64, u64>>(32);
    }
    var m: *HashMap<u64, u64> = g_compiler_ctx.abst_methods_access.get(struct_ptr, struct_len);
    if (m != 0) { return m; }
    var out: *HashMap<u64, u64> = new HashMap<u64, u64>(16);
    g_compiler_ctx.abst_methods_access.put(struct_ptr, struct_len, out);
    return out;
}

func compiler_abst_method_sigs_map_ensure(struct_ptr: u64, struct_len: u64) -> *HashMap<u64, *AstFunc> {
    if (g_compiler_ctx.abst_methods_sigs == 0) {
        g_compiler_ctx.abst_methods_sigs = new HashMap<u64, *HashMap<u64, *AstFunc>>(32);
    }
    var m: *HashMap<u64, *AstFunc> = g_compiler_ctx.abst_methods_sigs.get(struct_ptr, struct_len);
    if (m != 0) { return m; }
    var out: *HashMap<u64, *AstFunc> = new HashMap<u64, *AstFunc>(16);
    g_compiler_ctx.abst_methods_sigs.put(struct_ptr, struct_len, out);
    return out;
}

func compiler_register_abst_method_ex(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64, sig: *AstFunc, access: u64) -> u64 {
    if (struct_ptr == 0 || struct_len == 0 || method_ptr == 0 || method_len == 0) { return 0; }
    if (g_compiler_ctx.abst_methods == 0) { g_compiler_ctx.abst_methods = new HashMap<u64, *Vec<*NameInfo>>(32); }
    var list: *Vec<*NameInfo> = g_compiler_ctx.abst_methods.get(struct_ptr, struct_len);
    if (list == 0) {
        list = new Vec<*NameInfo>(4);
        g_compiler_ctx.abst_methods.put(struct_ptr, struct_len, list);
    }
    var n: u64 = list.len();
    for (var i: u64 = 0; i < n; i++) {
        var ni: *NameInfo = list.get(i);
        if (str_eq(ni.ptr, ni.len, method_ptr, method_len)) { return 0; }
    }
    var name_info: *NameInfo = new NameInfo{method_ptr, method_len};
    list.push(name_info);

    var access_map: *HashMap<u64, u64> = compiler_abst_method_access_map_ensure(struct_ptr, struct_len);
    access_map.put(method_ptr, method_len, access);

    if (sig != 0) {
        var sig_map: *HashMap<u64, *AstFunc> = compiler_abst_method_sigs_map_ensure(struct_ptr, struct_len);
        sig_map.put(method_ptr, method_len, sig);
    }
    return 0;
}

func compiler_get_abst_methods(struct_ptr: u64, struct_len: u64) -> *Vec<*NameInfo> {
    if (g_compiler_ctx.abst_methods == 0) { return 0; }
    return g_compiler_ctx.abst_methods.get(struct_ptr, struct_len);
}

func compiler_get_abst_method_access(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> u64 {
    if (g_compiler_ctx.abst_methods_access == 0) { return ACCESS_PRIVATE; }
    var access_map: *HashMap<u64, u64> = g_compiler_ctx.abst_methods_access.get(struct_ptr, struct_len);
    if (access_map == 0) { return ACCESS_PRIVATE; }
    if (access_map.has(method_ptr, method_len) == 0) { return ACCESS_PRIVATE; }
    return access_map.get(method_ptr, method_len);
}

func compiler_get_abst_method_sig(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> *AstFunc {
    if (g_compiler_ctx.abst_methods_sigs == 0) { return 0; }
    var sig_map: *HashMap<u64, *AstFunc> = g_compiler_ctx.abst_methods_sigs.get(struct_ptr, struct_len);
    if (sig_map == 0) { return 0; }
    return sig_map.get(method_ptr, method_len);
}

func compiler_is_abst_method(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> u64 {
    var list: *Vec<*NameInfo> = compiler_get_abst_methods(struct_ptr, struct_len);
    if (list == 0) { return false; }
    var n: u64 = list.len();
    for (var i: u64 = 0; i < n; i++) {
        var ni: *NameInfo = list.get(i);
        if (str_eq(ni.ptr, ni.len, method_ptr, method_len)) { return true; }
    }
    return false;
}

func compiler_is_impl_method(name_ptr: u64, name_len: u64) -> u64 {
    return g_compiler_ctx.impl_methods.?has(name_ptr, name_len);
}

func compiler_can_access_private_member_from(caller_struct_ptr: u64, caller_struct_len: u64, owner_struct_ptr: u64, owner_struct_len: u64) -> u64 {
    if (owner_struct_ptr == 0 || owner_struct_len == 0) { return false; }
    if (caller_struct_ptr == 0 || caller_struct_len == 0) { return false; }
    if (str_eq(owner_struct_ptr, owner_struct_len, caller_struct_ptr, caller_struct_len) != 0) { return true; }

    // Treat generic template and instantiated names as the same owner.
    // Example: Vec <-> Vec__G__T_u64
    var owner_base_len: u64 = compiler_find_generic_suffix_index(owner_struct_ptr, owner_struct_len);
    var caller_base_len: u64 = compiler_find_generic_suffix_index(caller_struct_ptr, caller_struct_len);
    if (str_eq(owner_struct_ptr, owner_base_len, caller_struct_ptr, caller_base_len) != 0) { return true; }
    return false;
}

func compiler_can_access_protected_member_from(caller_struct_ptr: u64, caller_struct_len: u64, owner_struct_ptr: u64, owner_struct_len: u64) -> u64 {
    if (compiler_can_access_private_member_from(caller_struct_ptr, caller_struct_len, owner_struct_ptr, owner_struct_len) != 0) {
        return true;
    }

    if (compiler_struct_is_same_or_descendant(caller_struct_ptr, caller_struct_len, owner_struct_ptr, owner_struct_len) != 0) {
        return true;
    }

    var owner_base_len: u64 = compiler_find_generic_suffix_index(owner_struct_ptr, owner_struct_len);
    var caller_base_len: u64 = compiler_find_generic_suffix_index(caller_struct_ptr, caller_struct_len);
    if (compiler_struct_is_same_or_descendant(caller_struct_ptr, caller_struct_len, owner_struct_ptr, owner_base_len) != 0) {
        return true;
    }
    if (compiler_struct_is_same_or_descendant(caller_struct_ptr, caller_base_len, owner_struct_ptr, owner_struct_len) != 0) {
        return true;
    }
    if (compiler_struct_is_same_or_descendant(caller_struct_ptr, caller_base_len, owner_struct_ptr, owner_base_len) != 0) {
        return true;
    }
    return false;
}

func compiler_can_access_member_from(caller_struct_ptr: u64, caller_struct_len: u64, owner_struct_ptr: u64, owner_struct_len: u64, access: u64) -> u64 {
    if (access == ACCESS_PUBLIC) { return true; }
    if (access == ACCESS_PRIVATE) {
        return compiler_can_access_private_member_from(caller_struct_ptr, caller_struct_len, owner_struct_ptr, owner_struct_len);
    }
    if (access == ACCESS_PROTECTED) {
        return compiler_can_access_protected_member_from(caller_struct_ptr, caller_struct_len, owner_struct_ptr, owner_struct_len);
    }
    return false;
}

func compiler_can_access_member(owner_struct_ptr: u64, owner_struct_len: u64, access: u64) -> u64 {
    return compiler_can_access_member_from(g_compiler_ctx.current_access_struct_ptr, g_compiler_ctx.current_access_struct_len, owner_struct_ptr, owner_struct_len, access);
}

func compiler_is_generic_func_ptr(fn: *AstFunc) -> u64 {
    if (fn == 0) { return false; }
    var n: u64 = g_compiler_ctx.generic_func_ptrs.?len();
    if (n == 0) { return false; }
    for (var i: u64 = 0; i < n; i++) {
        var tpl: *GenericFuncTemplate = g_compiler_ctx.generic_func_ptrs.get(i);
        if (tpl.func_def == fn) { return true; }
    }
    return false;
}

func compiler_find_generic_template_by_name(name_ptr: u64, name_len: u64) -> *GenericFuncTemplate {
    return g_compiler_ctx.generic_funcs.?get(name_ptr, name_len);
}

func compiler_find_generic_template_by_mangled(name_ptr: u64, name_len: u64) -> *GenericFuncTemplate {
    return g_compiler_ctx.generic_funcs_mangled.?get(name_ptr, name_len);
}

func compiler_find_generic_template_by_func_ptr(fn_ptr: *AstFunc) -> *GenericFuncTemplate {
    var n: u64 = g_compiler_ctx.generic_func_ptrs.?len();
    if (n == 0) { return 0; }
    for (var i: u64 = 0; i < n; i++) {
        var tpl: *GenericFuncTemplate = g_compiler_ctx.generic_func_ptrs.get(i);
        if (tpl.func_def == fn_ptr) { return tpl; }
        if (tpl.func_sig == fn_ptr) { return tpl; }
    }
    return 0;
}

func compiler_alias_generic_template_by_func_ptr(fn_ptr: *AstFunc, new_name_ptr: u64, new_name_len: u64) -> u64 {
    var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_func_ptr(fn_ptr);
    if (tpl_ptr == 0) { return 0; }
    if (g_compiler_ctx.generic_funcs == 0) { g_compiler_ctx.generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64); }
    var tpl: *GenericFuncTemplate = tpl_ptr;
    g_compiler_ctx.generic_funcs.put(new_name_ptr, new_name_len, tpl);
    return 0;
}

func compiler_generic_update_mangled_names(prog: *AstProgram) -> u64 {
    if (g_compiler_ctx.generic_func_ptrs == 0) { return 0; }
    var funcs: *Vec<*AstFunc> = prog.funcs_vec;
    var n: u64 = funcs.?len();
    if (n == 0) { return 0; }
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = funcs.get(i);
        var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_func_ptr(fn);
        if (tpl_ptr == 0) { continue; }
        var tpl: *GenericFuncTemplate = tpl_ptr;
        tpl.mangled_ptr = fn.name_ptr;
        tpl.mangled_len = fn.name_len;
        if (g_compiler_ctx.generic_funcs_mangled == 0) { g_compiler_ctx.generic_funcs_mangled = new HashMap<u64, *GenericFuncTemplate>(64); }
        g_compiler_ctx.generic_funcs_mangled.put(tpl.mangled_ptr, tpl.mangled_len, tpl);
    }
    return 0;
}

// ============================================
// Generic Monomorphization
// ============================================

// Append a string to a vec<u8>
func generic_vec_append_str(v: *Vec<u64>, s_ptr: u64, s_len: u64) -> u64 {
    var s_u8: []u8 = slice(s_ptr, s_len);
    for (var i: u64 = 0; i < s_len; i++) {
        v.push(s_u8[i]);
    }
    return 0;
}

// Append unsigned integer to vec as decimal
func generic_vec_append_u64(v: *Vec<u64>, value: u64) -> u64 {
    if (value == 0) {
        v.push(48);
        return 0;
    }
    var buf: u64 = heap_alloc(32 * sizeof(u8));
    var buf_u8: []u8 = slice(buf, 32);
    var idx: u64 = 0;
    var x: u64 = value;
    while (x > 0) {
        var digit: u64 = x % 10;
        buf_u8[idx] = 48 + digit;
        idx = idx + 1;
        x = x / 10;
    }
    for (var i: u64 = 0; i < idx; i++) {
        v.push(buf_u8[idx - 1 - i]);
    }
    return 0;
}

func generic_type_equal(ta: *TypeInfo, tb: *TypeInfo) -> u64 {
    if (ta.type_kind != tb.type_kind) { return false; }
    if (ta.ptr_depth != tb.ptr_depth) { return false; }
    if (ta.type_kind == TYPE_STRUCT) {
        if (!str_eq(ta.struct_name_ptr, ta.struct_name_len, tb.struct_name_ptr, tb.struct_name_len)) { return false; }
    }
    if (ta.type_kind == TYPE_ARRAY || ta.type_kind == TYPE_SLICE) {
        if (ta.type_kind == TYPE_ARRAY && ta.array_len != tb.array_len) { return false; }
        if (ta.elem_typeinfo != 0 || tb.elem_typeinfo != 0) {
            if (ta.elem_typeinfo == 0 || tb.elem_typeinfo == 0) { return false; }
            if (!generic_type_equal(ta.elem_typeinfo, tb.elem_typeinfo)) { return false; }
        } else {
            if (ta.elem_type_kind != tb.elem_type_kind) { return false; }
            if (ta.elem_ptr_depth != tb.elem_ptr_depth) { return false; }
            if (!str_eq(ta.struct_name_ptr, ta.struct_name_len, tb.struct_name_ptr, tb.struct_name_len)) { return false; }
        }
    }
    return true;
}

func generic_find_binding(bindings: *Vec<*GenericBinding>, kind: u64, name_ptr: u64, name_len: u64) -> *GenericBinding {
    if (bindings == 0) { return 0; }
    var n: u64 = bindings.len();
    for (var i: u64 = 0; i < n; i++) {
        var b: *GenericBinding = bindings.get(i);
        if (b.kind == kind && str_eq(b.name_ptr, b.name_len, name_ptr, name_len)) {
            return b;
        }
    }
    return 0;
}

func generic_bind_type(bindings: *Vec<*GenericBinding>, name_ptr: u64, name_len: u64, type_ptr: *TypeInfo) -> u64 {
    var existing: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, name_ptr, name_len);
    if (existing != 0) {
        if (!generic_type_equal(existing.type, type_ptr)) {
            return true;
        }
        return false;
    }
    var nb: *GenericBinding = new GenericBinding();
    nb.kind = GENERIC_KIND_TYPE;
    nb.name_ptr = name_ptr;
    nb.name_len = name_len;
    nb.type = type_ptr;
    nb.value = 0;
    bindings.push(nb);
    return false;
}

func generic_bind_value(bindings: *Vec<*GenericBinding>, name_ptr: u64, name_len: u64, value: u64) -> u64 {
    var existing: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_VALUE, name_ptr, name_len);
    if (existing != 0) {
        if (existing.value != value) {
            return true;
        }
        return false;
    }
    var nb: *GenericBinding = new GenericBinding();
    nb.kind = GENERIC_KIND_VALUE;
    nb.name_ptr = name_ptr;
    nb.name_len = name_len;
    nb.type = 0;
    nb.value = value;
    bindings.push(nb);
    return false;
}

func generic_make_typeinfo_from_fields(type_kind: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64, elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64) -> *TypeInfo {
    var ti: *TypeInfo = new TypeInfo(type_kind, ptr_depth);
    ti.is_tagged = is_tagged;
    ti.struct_name_ptr = struct_name_ptr;
    ti.struct_name_len = struct_name_len;
    ti.tag_layout_ptr = tag_layout_ptr;
    ti.tag_layout_len = tag_layout_len;
    ti.struct_def = 0;
    ti.elem_type_kind = elem_type_kind;
    ti.elem_ptr_depth = elem_ptr_depth;
    ti.array_len = array_len;
    ti.array_len_is_param = array_len_is_param;
    ti.array_len_param_ptr = array_len_param_ptr;
    ti.array_len_param_len = array_len_param_len;
    return ti;
}

func generic_subst_typeinfo(type_kind: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64, elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64, bindings: *Vec<*GenericBinding>) -> *TypeInfo {
    if (type_kind == TYPE_GENERIC) {
        if (struct_name_ptr == 0 || struct_name_len == 0) {
            return generic_make_typeinfo_from_fields(TYPE_GENERIC, ptr_depth, is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len);
        }
        var b_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, struct_name_ptr, struct_name_len);
        if (b_ptr == 0) {
            emit_stderr("[ERROR] Missing generic type binding: ");
            emit_stderr_len(struct_name_ptr, struct_name_len);
            emit_stderr(" len=");
            print_u64(struct_name_len);
            emit_stderr(" ptr=");
            print_u64(struct_name_ptr);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        var bt: *TypeInfo = b_ptr.type;
        var merged_ptr_depth: u64 = bt.ptr_depth + ptr_depth;
        return generic_make_typeinfo_from_fields(bt.type_kind, merged_ptr_depth, bt.is_tagged, bt.struct_name_ptr, bt.struct_name_len, bt.tag_layout_ptr, bt.tag_layout_len, bt.elem_type_kind, bt.elem_ptr_depth, bt.array_len, bt.array_len_is_param, bt.array_len_param_ptr, bt.array_len_param_len);
    }

    if (bindings != 0 && type_kind == TYPE_STRUCT && struct_name_ptr != 0 && struct_name_len != 0) {
        var b_ptr2: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, struct_name_ptr, struct_name_len);
        if (b_ptr2 != 0) {
            var bt2: *TypeInfo = b_ptr2.type;
            var merged_ptr_depth2: u64 = bt2.ptr_depth + ptr_depth;
            return generic_make_typeinfo_from_fields(bt2.type_kind, merged_ptr_depth2, bt2.is_tagged, bt2.struct_name_ptr, bt2.struct_name_len, bt2.tag_layout_ptr, bt2.tag_layout_len, bt2.elem_type_kind, bt2.elem_ptr_depth, bt2.array_len, bt2.array_len_is_param, bt2.array_len_param_ptr, bt2.array_len_param_len);
        }
    }

    if (type_kind == TYPE_STRUCT && bindings != 0) {
        var base_len: u64 = compiler_find_generic_suffix_index(struct_name_ptr, struct_name_len);
        if (base_len < struct_name_len) {
            var tpl_ptr: *GenericStructTemplate = compiler_find_generic_struct_template_by_name(struct_name_ptr, base_len);
            if (tpl_ptr != 0) {
                var name_info: *NameInfo = generic_struct_get_or_create_instance(tpl_ptr, bindings);
                return generic_make_typeinfo_from_fields(type_kind, ptr_depth, is_tagged, name_info.ptr, name_info.len, tag_layout_ptr, tag_layout_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len);
            }
        }
    }

    if (type_kind == TYPE_ARRAY || type_kind == TYPE_SLICE) {
        var new_array_len: u64 = array_len;
        var new_array_len_is_param: u64 = array_len_is_param;
        var new_array_param_ptr: u64 = array_len_param_ptr;
        var new_array_param_len: u64 = array_len_param_len;
        if (array_len_is_param != 0) {
            var vb_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_VALUE, array_len_param_ptr, array_len_param_len);
            if (vb_ptr == 0) {
                emit_stderr("[ERROR] Missing generic value binding\n");
                compiler_panic("Compilation failed");
            }
            new_array_len = vb_ptr.value;
            new_array_len_is_param = 0;
            new_array_param_ptr = 0;
            new_array_param_len = 0;
        }

        var et: *TypeInfo = generic_subst_typeinfo(elem_type_kind, elem_ptr_depth, 0, struct_name_ptr, struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0, bindings);
        return generic_make_typeinfo_from_fields(type_kind, ptr_depth, is_tagged, et.struct_name_ptr, et.struct_name_len, tag_layout_ptr, tag_layout_len, et.type_kind, et.ptr_depth, new_array_len, new_array_len_is_param, new_array_param_ptr, new_array_param_len);
    }

    return generic_make_typeinfo_from_fields(type_kind, ptr_depth, is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len);
}

func generic_append_type_repr(v: *Vec<u64>, ti: *TypeInfo) -> u64 {
    if (ti.ptr_depth > 0) {
        v.push(112); // 'p'
        generic_vec_append_u64(v, ti.ptr_depth);
        v.push(95); // '_'
        var base: *TypeInfo = generic_make_typeinfo_from_fields(ti.type_kind, 0, ti.is_tagged, ti.struct_name_ptr, ti.struct_name_len, ti.tag_layout_ptr, ti.tag_layout_len, ti.elem_type_kind, ti.elem_ptr_depth, ti.array_len, ti.array_len_is_param, ti.array_len_param_ptr, ti.array_len_param_len);
        return generic_append_type_repr(v, base);
    }

    switch (ti.type_kind) {
        case TYPE_BOOL: generic_vec_append_str(v, "bool", 4); break;
        case TYPE_U8: generic_vec_append_str(v, "u8", 2); break;
        case TYPE_U16: generic_vec_append_str(v, "u16", 3); break;
        case TYPE_U32: generic_vec_append_str(v, "u32", 3); break;
        case TYPE_U64: generic_vec_append_str(v, "u64", 3); break;
        case TYPE_I8: generic_vec_append_str(v, "i8", 2); break;
        case TYPE_I16: generic_vec_append_str(v, "i16", 3); break;
        case TYPE_I32: generic_vec_append_str(v, "i32", 3); break;
        case TYPE_I64: generic_vec_append_str(v, "i64", 3); break;
        case TYPE_STRUCT:
            v.push(83); // 'S'
            var struct_name_u8: []u8 = slice(ti.struct_name_ptr, ti.struct_name_len);
            for (var i: u64 = 0; i < ti.struct_name_len; i++) {
                var c: u64 = struct_name_u8[i];
                if (c == 47 || c == 46) { c = 95; }
                v.push(c);
            }
            break;
        case TYPE_ARRAY:
            v.push(97); // 'a'
            generic_vec_append_u64(v, ti.array_len);
            v.push(95);
            var elem: *TypeInfo = generic_make_typeinfo_from_fields(ti.elem_type_kind, ti.elem_ptr_depth, 0, ti.struct_name_ptr, ti.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
            generic_append_type_repr(v, elem);
            break;
        case TYPE_SLICE:
            v.push(115); // 's'
            v.push(95);
            var elem2: *TypeInfo = generic_make_typeinfo_from_fields(ti.elem_type_kind, ti.elem_ptr_depth, 0, ti.struct_name_ptr, ti.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
            generic_append_type_repr(v, elem2);
            break;
        default:
            generic_vec_append_str(v, "t", 1);
            break;
    }
    return 0;
}

func generic_mangle_name(base_ptr: u64, base_len: u64, params_vec: *Vec<*GenericParam>, bindings: *Vec<*GenericBinding>) -> *NameInfo {
    var v: *Vec<u64> = new Vec<u64>(base_len + 32);
    generic_vec_append_str(v, base_ptr, base_len);
    generic_vec_append_str(v, "__G__", 5);
    var n: u64 = params_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var gp: *GenericParam = params_vec.get(i);
        if (gp.kind == GENERIC_KIND_TYPE) {
            v.push(84); // 'T'
            v.push(95);
            var b_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, gp.name_ptr, gp.name_len);
            if (b_ptr == 0) {
                emit_stderr("[ERROR] Missing generic type binding\n");
                compiler_panic("Compilation failed");
            }
            generic_append_type_repr(v, b_ptr.type);
        } else {
            v.push(86); // 'V'
            v.push(95);
            var b2_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_VALUE, gp.name_ptr, gp.name_len);
            if (b2_ptr == 0) {
                emit_stderr("[ERROR] Missing generic value binding\n");
                compiler_panic("Compilation failed");
            }
            generic_vec_append_u64(v, b2_ptr.value);
        }

        if (i + 1 < n) { v.push(95); }
    }

    var out_len: u64 = v.len();
    var out_ptr: u64 = heap_alloc((out_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, out_len + 1);
    for (var i2: u64 = 0; i2 < out_len; i2++) {
        out_u8[i2] = v.get(i2);
    }
    out_u8[out_len] = 0;
    var info: *NameInfo = new NameInfo{out_ptr, out_len};
    return info;
}

func generic_make_typeinfo_from_param(param: *Param) -> *TypeInfo {
    var ti: *TypeInfo = generic_make_typeinfo_from_fields(param.type_kind, param.ptr_depth, param.is_tagged, param.struct_name_ptr, param.struct_name_len, param.tag_layout_ptr, param.tag_layout_len, param.elem_type_kind, param.elem_ptr_depth, param.array_len, param.array_len_is_param, param.array_len_param_ptr, param.array_len_param_len);
    ti.elem_typeinfo = param.elem_typeinfo;
    return ti;
}

func generic_make_typeinfo_from_vardecl(decl: *AstVarDecl) -> *TypeInfo {
    var ti: *TypeInfo = generic_make_typeinfo_from_fields(decl.type_kind, decl.ptr_depth, decl.is_tagged, decl.struct_name_ptr, decl.struct_name_len, decl.tag_layout_ptr, decl.tag_layout_len, decl.elem_type_kind, decl.elem_ptr_depth, decl.array_len, decl.array_len_is_param, decl.array_len_param_ptr, decl.array_len_param_len);
    ti.elem_typeinfo = decl.elem_typeinfo;
    return ti;
}

func generic_infer_from_typeinfo(tk: u64, pd: u64, sn_ptr: u64, sn_len: u64, elem_k: u64, elem_pd: u64, array_len: u64, array_len_is_param: u64, array_param_ptr: u64, array_param_len: u64, arg_ti: *TypeInfo, bindings: *Vec<*GenericBinding>) -> u64 {
    if (arg_ti == 0) { return true; }
    if (arg_ti.type_kind == TYPE_VOID && arg_ti.ptr_depth == 0 && arg_ti.struct_name_ptr == 0 && arg_ti.struct_name_len == 0 &&
        arg_ti.elem_type_kind == 0 && arg_ti.elem_ptr_depth == 0 && arg_ti.array_len == 0) {
        return true;
    }

    if (tk == TYPE_GENERIC) {
        if (arg_ti.ptr_depth < pd) {
            return true;
        }
        var adj_ptr_depth: u64 = arg_ti.ptr_depth - pd;
        var bound: *TypeInfo = generic_make_typeinfo_from_fields(arg_ti.type_kind, adj_ptr_depth, arg_ti.is_tagged, arg_ti.struct_name_ptr, arg_ti.struct_name_len, arg_ti.tag_layout_ptr, arg_ti.tag_layout_len, arg_ti.elem_type_kind, arg_ti.elem_ptr_depth, arg_ti.array_len, arg_ti.array_len_is_param, arg_ti.array_len_param_ptr, arg_ti.array_len_param_len);
        bound.elem_typeinfo = arg_ti.elem_typeinfo;
        if (generic_bind_type(bindings, sn_ptr, sn_len, bound) != 0) { return true; }
        return false;
    }

    if (tk == TYPE_ARRAY || tk == TYPE_SLICE) {
        if (arg_ti.type_kind != tk) {
            return true;
        }
        if (array_len_is_param != 0) {
            if (generic_bind_value(bindings, array_param_ptr, array_param_len, arg_ti.array_len) != 0) { return true; }
        } else if (tk == TYPE_ARRAY && array_len != arg_ti.array_len) {
            return true;
        }

        var arg_elem_ti: *TypeInfo = arg_ti.elem_typeinfo;
        if (arg_elem_ti == 0) {
            arg_elem_ti = generic_make_typeinfo_from_fields(arg_ti.elem_type_kind, arg_ti.elem_ptr_depth, 0, arg_ti.struct_name_ptr, arg_ti.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        return generic_infer_from_typeinfo(elem_k, elem_pd, sn_ptr, sn_len, 0, 0, 0, 0, 0, 0, arg_elem_ti, bindings);
    }

    if (tk != arg_ti.type_kind || pd != arg_ti.ptr_depth) {
        return true;
    }
    if (tk == TYPE_STRUCT && !str_eq(sn_ptr, sn_len, arg_ti.struct_name_ptr, arg_ti.struct_name_len)) {
        return true;
    }
    return false;
}

func _compiler_find_parent_def(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, depth: u64) -> *AstStructDef {
    if (struct_def == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }
    if (str_eq(struct_def.name_ptr, struct_def.name_len, parent_ptr, parent_len)) { return struct_def; }
    if (struct_def.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var found: *AstStructDef = _compiler_find_parent_def(parent_def, parent_ptr, parent_len, depth + 1);
        if (found != 0) { return found; }
    }
    return 0;
}

func compiler_virtual_dispatch_bucket_ensure(struct_ptr: u64, struct_len: u64) -> *HashMap<u64, *NameInfo> {
    if (g_compiler_ctx.virtual_dispatch_traits == 0) {
        g_compiler_ctx.virtual_dispatch_traits = new HashMap<u64, *HashMap<u64, *NameInfo>>(32);
    }
    var bucket: *HashMap<u64, *NameInfo> = g_compiler_ctx.virtual_dispatch_traits.get(struct_ptr, struct_len);
    if (bucket != 0) { return bucket; }
    var out: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(16);
    g_compiler_ctx.virtual_dispatch_traits.put(struct_ptr, struct_len, out);
    return out;
}

func compiler_register_virtual_dispatch_trait(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64, trait_ptr: u64, trait_len: u64) -> u64 {
    if (struct_ptr == 0 || struct_len == 0 || method_ptr == 0 || method_len == 0 || trait_ptr == 0 || trait_len == 0) { return 0; }
    var bucket: *HashMap<u64, *NameInfo> = compiler_virtual_dispatch_bucket_ensure(struct_ptr, struct_len);
    bucket.put(method_ptr, method_len, new NameInfo{trait_ptr, trait_len});
    return 0;
}

func _compiler_find_virtual_dispatch_trait_in_struct(struct_def: *AstStructDef, method_ptr: u64, method_len: u64, depth: u64) -> *NameInfo {
    if (struct_def == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }

    if (g_compiler_ctx.virtual_dispatch_traits != 0) {
        var bucket: *HashMap<u64, *NameInfo> = g_compiler_ctx.virtual_dispatch_traits.get(struct_def.name_ptr, struct_def.name_len);
        if (bucket != 0) {
            var found: *NameInfo = bucket.get(method_ptr, method_len);
            if (found != 0) { return found; }
        }
    }

    if (struct_def.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var found_parent: *NameInfo = _compiler_find_virtual_dispatch_trait_in_struct(parent_def, method_ptr, method_len, depth + 1);
        if (found_parent != 0) { return found_parent; }
    }
    return 0;
}

func compiler_find_virtual_dispatch_trait(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> *NameInfo {
    var sd: *AstStructDef = get_struct_def(struct_ptr, struct_len);
    if (sd == 0) { return 0; }
    return _compiler_find_virtual_dispatch_trait_in_struct(sd, method_ptr, method_len, 0);
}

func compiler_find_unique_impl_method_in_struct(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> *AstFunc {
    if (g_compiler_ctx.all_funcs == 0) { return 0; }
    var found: *AstFunc = 0;
    var found_count: u64 = 0;
    var n: u64 = g_compiler_ctx.all_funcs.len();
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
        if (fn == 0) { continue; }
        if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { continue; }
        if (str_eq(fn.impl_owner_ptr, fn.impl_owner_len, struct_ptr, struct_len) == 0) { continue; }
        var mptr: u64 = fn.impl_original_name_ptr;
        var mlen: u64 = fn.impl_original_name_len;
        if (mptr == 0 || mlen == 0) {
            mptr = fn.name_ptr;
            mlen = fn.name_len;
        }
        if (str_eq(mptr, mlen, method_ptr, method_len) == 0) { continue; }
        found_count = found_count + 1;
        if (found_count == 1) { found = fn; }
    }
    if (found_count > 1) {
        emit_stderr("[ERROR] overloaded method requires argument type resolution: ");
        emit_stderr_len(struct_ptr, struct_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    return found;
}

func compiler_find_unique_impl_method_decl_in_struct(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> CompilerDeclLookup {
    var lookup: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
    var fn: *AstFunc = compiler_find_unique_impl_method_in_struct(struct_ptr, struct_len, method_ptr, method_len);
    if (fn == 0) { return lookup; }
    lookup.found = 1;
    lookup.owner_ptr = struct_ptr;
    lookup.owner_len = struct_len;
    lookup.access = fn.impl_method_access;
    lookup.sig = fn;
    return lookup;
}

func _compiler_find_method_func_in_hierarchy(struct_def: *AstStructDef, method_ptr: u64, method_len: u64, depth: u64) -> *AstFunc {
    if (struct_def == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }

    var method_name: *NameInfo = compiler_build_method_name(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
    var fn: *AstFunc = compiler_get_impl_method_func(method_name.ptr, method_name.len);
    if (fn == 0) {
        fn = compiler_get_func(method_name.ptr, method_name.len);
    }
    if (fn == 0) {
        fn = compiler_find_unique_impl_method_in_struct(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
    }
    if (fn != 0) { return fn; }

    if (struct_def.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    var found_fn: *AstFunc = 0;
    var found_count: u64 = 0;
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var cand: *AstFunc = _compiler_find_method_func_in_hierarchy(parent_def, method_ptr, method_len, depth + 1);
        if (cand != 0) {
            found_count = found_count + 1;
            if (found_count == 1) { found_fn = cand; }
        }
    }
    if (found_count > 1) {
        emit_stderr("[ERROR] Ambiguous method resolution in inheritance: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    return found_fn;
}

func compiler_find_method_func_in_hierarchy(struct_def: *AstStructDef, method_ptr: u64, method_len: u64) -> *AstFunc {
    return _compiler_find_method_func_in_hierarchy(struct_def, method_ptr, method_len, 0);
}

func compiler_struct_is_same_or_descendant(child_ptr: u64, child_len: u64, ancestor_ptr: u64, ancestor_len: u64) -> u64 {
    if (str_eq(child_ptr, child_len, ancestor_ptr, ancestor_len) != 0) { return true; }
    var child_def: *AstStructDef = get_struct_def(child_ptr, child_len);
    if (child_def == 0) { return false; }
    var found: *AstStructDef = _compiler_find_parent_def(child_def, ancestor_ptr, ancestor_len, 0);
    if (found != 0) { return true; }
    return false;
}

func _compiler_find_method_decl_in_hierarchy(struct_def: *AstStructDef, method_ptr: u64, method_len: u64, depth: u64) -> CompilerDeclLookup {
    var lookup: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
    if (struct_def == 0) { return lookup; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }

    var method_name: *NameInfo = compiler_build_method_name(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
    if (compiler_is_impl_method(method_name.ptr, method_name.len) != 0) {
        lookup.found = 1;
        lookup.owner_ptr = struct_def.name_ptr;
        lookup.owner_len = struct_def.name_len;
        lookup.access = compiler_get_impl_method_access(method_name.ptr, method_name.len);
        lookup.sig = compiler_get_func(method_name.ptr, method_name.len);
        return lookup;
    }

    var overload_lookup: CompilerDeclLookup = compiler_find_unique_impl_method_decl_in_struct(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
    if (overload_lookup.found != 0) { return overload_lookup; }

    if (compiler_is_abst_method(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len) != 0) {
        lookup.found = 1;
        lookup.owner_ptr = struct_def.name_ptr;
        lookup.owner_len = struct_def.name_len;
        lookup.access = compiler_get_abst_method_access(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
        lookup.sig = compiler_get_abst_method_sig(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
        return lookup;
    }

    if (struct_def.parents_vec == 0) { return lookup; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    var found: u64 = 0;
    var first_hit: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var child_lookup: CompilerDeclLookup = _compiler_find_method_decl_in_hierarchy(parent_def, method_ptr, method_len, depth + 1);
        if (child_lookup.found != 0) {
            found = found + 1;
            if (found == 1) { first_hit = child_lookup; }
        }
    }
    if (found > 1) {
        emit_stderr("[ERROR] Ambiguous method declaration in inheritance: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    if (found == 0) { return lookup; }
    return first_hit;
}

func compiler_find_method_decl_in_hierarchy(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> CompilerDeclLookup {
    var lookup: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
    var sd: *AstStructDef = get_struct_def(struct_ptr, struct_len);
    if (sd == 0) { return lookup; }
    return _compiler_find_method_decl_in_hierarchy(sd, method_ptr, method_len, 0);
}

func compiler_find_method_decl_in_hierarchy_overload(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64, arg_types: *Vec<*TypeInfo>, arg_count_hint: u64) -> CompilerDeclLookup {
    var resolved: CompilerMethodResolveResult = compiler_resolve_method_overload(struct_ptr, struct_len, method_ptr, method_len, arg_types, arg_count_hint);
    if (resolved.found != 0 && resolved.fn != 0) {
        var hit: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
        hit.found = 1;
        hit.owner_ptr = resolved.owner_ptr;
        hit.owner_len = resolved.owner_len;
        hit.access = resolved.access;
        hit.sig = resolved.fn;
        return hit;
    }
    return compiler_find_method_decl_in_hierarchy(struct_ptr, struct_len, method_ptr, method_len);
}

func compiler_check_field_access(field_desc: *FieldDesc) -> u64 {
    if (field_desc == 0) { return 0; }
    return compiler_can_access_member(field_desc.owner_struct_ptr, field_desc.owner_struct_len, field_desc.access);
}

func compiler_check_method_access(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> u64 {
    var lookup: CompilerDeclLookup = compiler_find_method_decl_in_hierarchy(struct_ptr, struct_len, method_ptr, method_len);
    if (lookup.found == 0) {
        return 1;
    }
    return compiler_can_access_member(lookup.owner_ptr, lookup.owner_len, lookup.access);
}

func compiler_check_method_access_overload(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64, arg_types: *Vec<*TypeInfo>, arg_count_hint: u64) -> u64 {
    var lookup: CompilerDeclLookup = compiler_find_method_decl_in_hierarchy_overload(struct_ptr, struct_len, method_ptr, method_len, arg_types, arg_count_hint);
    if (lookup.found == 0) { return 1; }
    return compiler_can_access_member(lookup.owner_ptr, lookup.owner_len, lookup.access);
}

func compiler_is_virtual_trait_name(name_ptr: u64, name_len: u64) -> u64 {
    if (name_len < 7) { return false; }
    if (str_eq(name_ptr, 7, "__Virt_", 7) != 0) { return true; }
    return false;
}

func _compiler_find_field_desc_unscoped(struct_def: *AstStructDef, member_ptr: u64, member_len: u64, depth: u64) -> *FieldDesc {
    if (struct_def == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }
    if (struct_def.is_union == 1) {
        var ufields: *Vec<*FieldDesc> = struct_def.fields_vec;
        var un: u64 = ufields.len();
        for (var ui: u64 = 0; ui < un; ui++) {
            var uf: *FieldDesc = ufields.get(ui);
            if (str_eq(uf.name_ptr, uf.name_len, member_ptr, member_len)) { return uf; }
        }
        return 0;
    }
    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var n: u64 = fields.len();
    for (var i: u64 = 0; i < n; i++) {
        var f: *FieldDesc = fields.get(i);
        if (str_eq(f.name_ptr, f.name_len, member_ptr, member_len)) { return f; }
    }
    if (struct_def.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    var match_desc: *FieldDesc = 0;
    var match_count: u64 = 0;
    for (var j: u64 = 0; j < pn; j++) {
        var parent_desc: *ParentDesc = parents.get(j);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var cand: *FieldDesc = _compiler_find_field_desc_unscoped(parent_def, member_ptr, member_len, depth + 1);
        if (cand != 0) {
            match_count = match_count + 1;
            if (match_count == 1) { match_desc = cand; }
        }
    }
    if (match_count > 1) {
        emit_stderr("[ERROR] Ambiguous field access: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(member_ptr, member_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    return match_desc;
}

func compiler_find_struct_field_desc_scoped(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> *FieldDesc {
    if (struct_def == 0) { return 0; }
    if (struct_def.is_union == 1) {
        if (parent_ptr != 0) {
            emit_stderr("[ERROR] union cannot use parent scope\n");
            panic("Compiler error");
        }
        return _compiler_find_field_desc_unscoped(struct_def, member_ptr, member_len, 0);
    }
    if (parent_ptr != 0) {
        var parent_def: *AstStructDef = _compiler_find_parent_def(struct_def, parent_ptr, parent_len, 0);
        if (parent_def == 0) {
            emit_stderr("[ERROR] Parent scope not found: ");
            emit_stderr_len(parent_ptr, parent_len);
            emit_stderr("\n");
            panic("Compiler error");
        }
        var desc: *FieldDesc = _compiler_find_field_desc_unscoped(parent_def, member_ptr, member_len, 0);
        if (desc == 0) {
            emit_stderr("[ERROR] Field not found in parent scope: ");
            emit_stderr_len(parent_ptr, parent_len);
            emit_stderr(".");
            emit_stderr_len(member_ptr, member_len);
            emit_stderr("\n");
            panic("Compiler error");
        }
        return desc;
    }
    return _compiler_find_field_desc_unscoped(struct_def, member_ptr, member_len, 0);
}

func generic_find_struct_field_type(struct_name_ptr: u64, struct_name_len: u64, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> *TypeInfo {
    if (struct_name_ptr == 0 || struct_name_len == 0) { return 0; }
    var sd: *AstStructDef = get_struct_def(struct_name_ptr, struct_name_len);
    if (sd == 0) {
        if (GENERIC_DEBUG != 0) {
            emit_stderr("[DEBUG] Missing struct def for member access: ");
            emit_stderr_len(struct_name_ptr, struct_name_len);
            emit_stderr("\n");
        }
        return 0;
    }
    var field_desc: *FieldDesc = compiler_find_struct_field_desc_scoped(sd, parent_ptr, parent_len, member_ptr, member_len);
    if (field_desc != 0) {
        var f: *FieldDesc = field_desc;
        return generic_make_typeinfo_from_fields(f.type_kind, f.ptr_depth, f.is_tagged, f.struct_name_ptr, f.struct_name_len, f.tag_layout_ptr, f.tag_layout_len, f.elem_type_kind, f.elem_ptr_depth, f.array_len, 0, 0, 0);
    }

    if (GENERIC_DEBUG != 0) {
        emit_stderr("[DEBUG] Missing struct field: ");
        emit_stderr_len(struct_name_ptr, struct_name_len);
        emit_stderr(".");
        emit_stderr_len(member_ptr, member_len);
        emit_stderr("\n");
    }
    return 0;
}

func generic_type_u64() -> *TypeInfo {
    return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

func generic_type_unknown() -> *TypeInfo {
    return generic_make_typeinfo_from_fields(TYPE_VOID, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

func generic_type_u8_ptr() -> *TypeInfo {
    return generic_make_typeinfo_from_fields(TYPE_U8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

func generic_type_f64() -> *TypeInfo {
    return generic_make_typeinfo_from_fields(TYPE_F64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

func generic_infer_member_access_type(member: *AstMemberAccess, symtab: *HashMap<u64, *TypeInfo>) -> *TypeInfo {
    var obj_ti: *TypeInfo = generic_infer_expr_type(member.object, symtab);
    if (ast_kind(member.object) == AST_IDENT && member.parent_ptr == 0) {
        var scope_id: *AstIdent = (*AstIdent)member.object;
        var scoped_const: *ConstResult = (*ConstResult)compiler_find_scoped_const(scope_id.name_ptr, scope_id.name_len, member.member_ptr, member.member_len);
        if (scoped_const != 0 && scoped_const.found != 0) {
            return generic_type_u64();
        }
    }
    if (obj_ti == 0 || obj_ti.type_kind != TYPE_STRUCT) { return generic_type_u64(); }
    var field_ti: *TypeInfo = generic_find_struct_field_type(obj_ti.struct_name_ptr, obj_ti.struct_name_len, member.parent_ptr, member.parent_len, member.member_ptr, member.member_len);
    if (field_ti != 0) { return field_ti; }
    return generic_type_u64();
}

func generic_infer_try_type(tr: *AstTry, symtab: *HashMap<u64, *TypeInfo>) -> *TypeInfo {
    var opt_ti: *TypeInfo = generic_infer_expr_type(tr.operand, symtab);
    if (opt_ti == 0) { return generic_type_u64(); }
    if (opt_ti.type_kind != TYPE_STRUCT || opt_ti.ptr_depth != 0) { return generic_type_u64(); }
    var base_len: u64 = compiler_find_generic_suffix_index(opt_ti.struct_name_ptr, opt_ti.struct_name_len);
    if (str_eq(opt_ti.struct_name_ptr, base_len, "Option", 6)) {
        var vt: *TypeInfo = generic_find_struct_field_type(opt_ti.struct_name_ptr, opt_ti.struct_name_len, 0, 0, (u64)"value", 5);
        if (vt != 0) { return vt; }
    }
    if (str_eq(opt_ti.struct_name_ptr, base_len, "Result", 6)) {
        var ok_t: *TypeInfo = generic_find_struct_field_type(opt_ti.struct_name_ptr, opt_ti.struct_name_len, 0, 0, (u64)"ok", 2);
        if (ok_t != 0) { return ok_t; }
    }
    return generic_type_u64();
}

func generic_infer_call_return_type(call: *AstCall) -> *TypeInfo {
    var resolved_ptr: u64 = call.name_ptr;
    var resolved_len: u64 = call.name_len;
    var resolved: *NameInfo = resolve_name(call.name_ptr, call.name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    if (g_compiler_ctx.all_func_sigs != 0) {
        var n: u64 = g_compiler_ctx.all_func_sigs.len();
        for (var i: u64 = 0; i < n; i++) {
            var fn: *AstFunc = g_compiler_ctx.all_func_sigs.get(i);
            if (str_eq(fn.name_ptr, fn.name_len, resolved_ptr, resolved_len)) {
                return generic_make_typeinfo_from_fields(fn.ret_type, fn.ret_ptr_depth, fn.ret_is_tagged, fn.ret_struct_name_ptr, fn.ret_struct_name_len, fn.ret_tag_layout_ptr, fn.ret_tag_layout_len, 0, 0, 0, 0, 0, 0);
            }
        }
    }
    return generic_type_u64();
}

func generic_infer_expr_type(expr: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> *TypeInfo {
    var kind: u64 = ast_kind(expr);
    switch (kind) {
        case AST_LITERAL:
            return generic_type_u64();
        case AST_STRING:
            return generic_type_u8_ptr();
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)expr;
            var t_ptr: *TypeInfo = 0;
            if (symtab != 0) {
                t_ptr = symtab.get(id.name_ptr, id.name_len);
            }
            if (t_ptr != 0) { return t_ptr; }
            var ginfo: *GlobalInfo = compiler_find_global_info(id.name_ptr, id.name_len);
            if (ginfo == 0) {
                var resolved: *NameInfo = resolve_name(id.name_ptr, id.name_len);
                if (resolved != 0) {
                    ginfo = compiler_find_global_info(resolved.ptr, resolved.len);
                }
            }
            if (ginfo != 0) {
                if (ginfo.typeinfo_ptr != 0) { return ginfo.typeinfo_ptr; }
            }
            var const_res: *ConstResult = (*ConstResult)compiler_find_const(id.name_ptr, id.name_len);
            if (const_res != 0 && const_res.found != 0) {
                return generic_type_u64();
            }
            if (compiler_func_exists(id.name_ptr, id.name_len) != 0) {
                return generic_type_u8_ptr();
            }
            return generic_type_unknown();
        case AST_SUPER:
            return generic_type_u64();
        case AST_ADDR_OF:
            var a: *AstAddrOf = (*AstAddrOf)expr;
            var base_t: *TypeInfo = generic_infer_expr_type(a.operand, symtab);
            return generic_make_typeinfo_from_fields(base_t.type_kind, base_t.ptr_depth + 1, base_t.is_tagged, base_t.struct_name_ptr, base_t.struct_name_len, base_t.tag_layout_ptr, base_t.tag_layout_len, base_t.elem_type_kind, base_t.elem_ptr_depth, base_t.array_len, base_t.array_len_is_param, base_t.array_len_param_ptr, base_t.array_len_param_len);
        case AST_DEREF:
            var d: *AstDeref = (*AstDeref)expr;
            var dt: *TypeInfo = generic_infer_expr_type(d.operand, symtab);
            if (dt.ptr_depth == 0) { return generic_type_u64(); }
            return generic_make_typeinfo_from_fields(dt.type_kind, dt.ptr_depth - 1, dt.is_tagged, dt.struct_name_ptr, dt.struct_name_len, dt.tag_layout_ptr, dt.tag_layout_len, dt.elem_type_kind, dt.elem_ptr_depth, dt.array_len, dt.array_len_is_param, dt.array_len_param_ptr, dt.array_len_param_len);
        case AST_CAST:
            var c: *AstCast = (*AstCast)expr;
            return generic_make_typeinfo_from_fields(c.target_type, c.target_ptr_depth, c.target_is_tagged, c.struct_name_ptr, c.struct_name_len, c.tag_layout_ptr, c.tag_layout_len, 0, 0, 0, 0, 0, 0);
        case AST_INDEX:
            var ix: *AstIndex = (*AstIndex)expr;
            var bt: *TypeInfo = generic_infer_expr_type(ix.base, symtab);
            if (bt.type_kind == TYPE_ARRAY || bt.type_kind == TYPE_SLICE) {
                return generic_make_typeinfo_from_fields(bt.elem_type_kind, bt.elem_ptr_depth, 0, bt.struct_name_ptr, bt.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            if (bt.ptr_depth > 0) {
                return generic_make_typeinfo_from_fields(bt.type_kind, bt.ptr_depth - 1, bt.is_tagged, bt.struct_name_ptr, bt.struct_name_len, bt.tag_layout_ptr, bt.tag_layout_len, bt.elem_type_kind, bt.elem_ptr_depth, bt.array_len, bt.array_len_is_param, bt.array_len_param_ptr, bt.array_len_param_len);
            }
            return generic_type_u64();
        case AST_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)expr;
            return generic_infer_member_access_type(ma, symtab);
        case AST_SAFE_MEMBER_ACCESS:
            var sma: *AstMemberAccess = (*AstMemberAccess)expr;
            return generic_infer_member_access_type(sma, symtab);
        case AST_TRY:
            var tr: *AstTry = (*AstTry)expr;
            return generic_infer_try_type(tr, symtab);
        case AST_FLOAT:
            return generic_type_f64();
        case AST_STACK_CTOR:
            var sc3: *AstStackCtor = (*AstStackCtor)expr;
            return generic_make_typeinfo_from_fields(sc3.type_kind, sc3.ptr_depth, sc3.is_tagged, sc3.struct_name_ptr, sc3.struct_name_len, sc3.tag_layout_ptr, sc3.tag_layout_len,
                                                     sc3.elem_type_kind, sc3.elem_ptr_depth, sc3.array_len, sc3.array_len_is_param, sc3.array_len_param_ptr, sc3.array_len_param_len);
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)expr;
            var tpl: *GenericStructTemplate = compiler_try_resolve_generic_struct_template(gsl.name_ptr, gsl.name_len);
            if (tpl == 0) {
                return generic_type_u64();
            }
            var bindings_gsl: *Vec<*GenericBinding> = generic_build_bindings_for_struct(tpl, gsl.generic_args_vec);
            var inst_name: *NameInfo = generic_struct_get_or_create_instance(tpl, bindings_gsl);
            return generic_make_typeinfo_from_fields(TYPE_STRUCT, 0, 0, inst_name.ptr, inst_name.len, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_CALL:
            return generic_infer_call_return_type((*AstCall)expr);
        default:
            return generic_type_u64();
    }
}

func generic_collect_var_decls(stmt: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> u64 {
    var kind: u64 = ast_kind(stmt);
    switch (kind) {
        case AST_VAR_DECL:
            var vd: *AstVarDecl = (*AstVarDecl)stmt;
            var t_ptr: *TypeInfo = generic_make_typeinfo_from_vardecl(vd);
            symtab.put(vd.name_ptr, vd.name_len, t_ptr);
            break;
        case AST_BLOCK:
            var blk: *AstBlock = (*AstBlock)stmt;
            var stmts: *Vec<*AstNode> = blk.stmts_vec;
            var n: u64 = stmts.len();
            for (var i: u64 = 0; i < n; i++) {
                generic_collect_var_decls(stmts.get(i), symtab);
            }
            break;
        case AST_IF:
            var ifs: *AstIf = (*AstIf)stmt;
            if (ifs.then_block != 0) { generic_collect_var_decls(ifs.then_block, symtab); }
            if (ifs.else_block != 0) { generic_collect_var_decls(ifs.else_block, symtab); }
            break;
        case AST_WHILE:
            var wl: *AstWhile = (*AstWhile)stmt;
            if (wl.body != 0) { generic_collect_var_decls(wl.body, symtab); }
            break;
        case AST_FOR:
            var fr: *AstFor = (*AstFor)stmt;
            if (fr.init != 0) { generic_collect_var_decls(fr.init, symtab); }
            if (fr.body != 0) { generic_collect_var_decls(fr.body, symtab); }
            break;
        case AST_SWITCH:
        case AST_MATCH:
            var sw: *AstSwitch = (*AstSwitch)stmt;
            var cases: *Vec<*AstNode> = sw.cases_vec;
            var cn: u64 = cases.len();
            for (var j: u64 = 0; j < cn; j++) {
                generic_collect_var_decls(cases.get(j), symtab);
            }
            break;
        case AST_CASE:
            var cs: *AstCase = (*AstCase)stmt;
            if (cs.body != 0) { generic_collect_var_decls(cs.body, symtab); }
            break;
        default:
            break;
    }
    return 0;
}

func generic_build_symtab_for_func(fn: *AstFunc) -> *HashMap<u64, *TypeInfo> {
    var symtab: *HashMap<u64, *TypeInfo> = new HashMap<u64, *TypeInfo>(64);
    var params: *Vec<*Param> = fn.params_vec;
    if (params != 0) {
        var n: u64 = params.len();
        for (var i: u64 = 0; i < n; i++) {
            var p: *Param = params.get(i);
            var t_ptr: *TypeInfo = generic_make_typeinfo_from_param(p);
            symtab.put(p.name_ptr, p.name_len, t_ptr);
        }
    }
    if (fn.body != 0) {
        generic_collect_var_decls(fn.body, symtab);
    }
    return symtab;
}

func generic_clone_args_vec(args: *Vec<*AstNode>, bindings: *Vec<*GenericBinding>) -> *Vec<*AstNode> {
    if (args == 0) { return 0; }
    var out: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var n: u64 = args.len();
    for (var i: u64 = 0; i < n; i++) {
        var expr: *AstNode = args.get(i);
        out.push(generic_clone_expr(expr, bindings));
    }
    return out;
}

func generic_clone_arg_names(arg_names: *Vec<*NameInfo>) -> *Vec<*NameInfo> {
    if (arg_names == 0) { return 0; }
    var n: u64 = arg_names.len();
    var out: *Vec<*NameInfo> = new Vec<*NameInfo>(n);
    for (var i: u64 = 0; i < n; i++) {
        var nm: *NameInfo = arg_names.get(i);
        if (nm == 0) {
            out.push(0);
        } else {
            out.push(new NameInfo{nm.ptr, nm.len});
        }
    }
    return out;
}

func generic_clone_maybe_instantiate_ctor_template(struct_name_ptr: u64, struct_name_len: u64, args_vec: *Vec<*AstNode>) -> u64 {
    if (args_vec == 0) { return 0; }
    var struct_base_len: u64 = compiler_find_generic_suffix_index(struct_name_ptr, struct_name_len);
    var ctor_name: *NameInfo = _compiler_build_constructor_name(struct_name_ptr, struct_base_len);
    var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_name(ctor_name.ptr, ctor_name.len);
    if (tpl_ptr != 0 && tpl_ptr.params_vec != 0 && tpl_ptr.params_vec.len() > 0) {
        var ctor_bindings: *Vec<*GenericBinding> = compiler_get_generic_struct_bindings(struct_name_ptr, struct_name_len);
        if (ctor_bindings != 0) {
            generic_get_or_create_instance(tpl_ptr, ctor_bindings);
        }
    }
    return 0;
}

func generic_clone_expr_generic_call(gc: *AstGenericCall, bindings: *Vec<*GenericBinding>) -> *AstNode {
    var gargs: *Vec<*GenericArg> = new Vec<*GenericArg>(4);
    var gn: u64 = gc.generic_args_vec.len();
    for (var i: u64 = 0; i < gn; i++) {
        var ga: *GenericArg = gc.generic_args_vec.get(i);
        var ng: *GenericArg = new GenericArg();
        ng.kind = ga.kind;
        ng.value = ga.value;
        if (ga.kind == GENERIC_KIND_TYPE) {
            var ti: *TypeInfo = ga.type_ptr;
            if (ti.type_kind == TYPE_GENERIC) {
                var chk: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, ti.struct_name_ptr, ti.struct_name_len);
                if (chk == 0 && GENERIC_DEBUG != 0) {
                    emit_stderr("[DEBUG] Missing binding for generic arg in call: ");
                    emit_stderr_len(gc.name_ptr, gc.name_len);
                    emit_stderr(" arg=");
                    emit_stderr_len(ti.struct_name_ptr, ti.struct_name_len);
                    emit_stderr("\n");
                }
            }
            ng.type_ptr = generic_subst_typeinfo(ti.type_kind, ti.ptr_depth, ti.is_tagged, ti.struct_name_ptr, ti.struct_name_len, ti.tag_layout_ptr, ti.tag_layout_len, ti.elem_type_kind, ti.elem_ptr_depth, ti.array_len, ti.array_len_is_param, ti.array_len_param_ptr, ti.array_len_param_len, bindings);
        } else {
            ng.type_ptr = 0;
        }
        gargs.push(ng);
    }
    var args_g: *Vec<*AstNode> = generic_clone_args_vec(gc.args_vec, bindings);
    var arg_names: *Vec<*NameInfo> = generic_clone_arg_names(gc.arg_names_vec);
    return (*AstNode)ast_generic_call_with_origin_named(gc.name_ptr, gc.name_len, gargs, args_g, arg_names, gc.origin);
}

func generic_clone_expr_new(nw: *AstNew, bindings: *Vec<*GenericBinding>) -> *AstNode {
    var sub3: *TypeInfo = generic_subst_typeinfo(nw.type_kind, nw.ptr_depth, nw.is_tagged, nw.struct_name_ptr, nw.struct_name_len, nw.tag_layout_ptr, nw.tag_layout_len,
                                                nw.elem_type_kind, nw.elem_ptr_depth, nw.array_len, nw.array_len_is_param, nw.array_len_param_ptr, nw.array_len_param_len, bindings);
    if (sub3.elem_typeinfo == 0) {
        sub3.elem_typeinfo = nw.elem_typeinfo;
    }
    var lit2: *AstNode = generic_clone_expr(nw.literal_expr, bindings);
    var args4: *Vec<*AstNode> = generic_clone_args_vec(nw.ctor_args_vec, bindings);
    if (sub3.type_kind == TYPE_STRUCT) {
        generic_clone_maybe_instantiate_ctor_template(sub3.struct_name_ptr, sub3.struct_name_len, args4);
    }
    return (*AstNode)ast_new(sub3.type_kind, sub3.ptr_depth, sub3.is_tagged, sub3.struct_name_ptr, sub3.struct_name_len, sub3.tag_layout_ptr, sub3.tag_layout_len,
                             sub3.elem_type_kind, sub3.elem_ptr_depth, sub3.array_len, sub3.array_len_is_param, sub3.array_len_param_ptr, sub3.array_len_param_len,
                             sub3.elem_typeinfo, lit2, args4);
}

func generic_clone_expr_stack_ctor(sc: *AstStackCtor, bindings: *Vec<*GenericBinding>) -> *AstNode {
    var sub_sc: *TypeInfo = generic_subst_typeinfo(sc.type_kind, sc.ptr_depth, sc.is_tagged, sc.struct_name_ptr, sc.struct_name_len, sc.tag_layout_ptr, sc.tag_layout_len,
                                                  sc.elem_type_kind, sc.elem_ptr_depth, sc.array_len, sc.array_len_is_param, sc.array_len_param_ptr, sc.array_len_param_len, bindings);
    if (sub_sc.elem_typeinfo == 0) {
        sub_sc.elem_typeinfo = sc.elem_typeinfo;
    }
    var args_sc: *Vec<*AstNode> = generic_clone_args_vec(sc.ctor_args_vec, bindings);
    if (sub_sc.type_kind == TYPE_STRUCT) {
        generic_clone_maybe_instantiate_ctor_template(sub_sc.struct_name_ptr, sub_sc.struct_name_len, args_sc);
    }
    return (*AstNode)ast_stack_ctor(sub_sc.type_kind, sub_sc.ptr_depth, sub_sc.is_tagged, sub_sc.struct_name_ptr, sub_sc.struct_name_len, sub_sc.tag_layout_ptr, sub_sc.tag_layout_len,
                                    sub_sc.elem_type_kind, sub_sc.elem_ptr_depth, sub_sc.array_len, sub_sc.array_len_is_param, sub_sc.array_len_param_ptr, sub_sc.array_len_param_len,
                                    sub_sc.elem_typeinfo, args_sc);
}

func generic_clone_expr(node: *AstNode, bindings: *Vec<*GenericBinding>) -> *AstNode {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    var nref: AstNodeTagRef;
    nref.node = node;
    switch (kind) {
        case AST_LITERAL:
            return ast_literal(nref.literal.value);
        case AST_FLOAT:
            return ast_float(nref.float_lit.str_ptr, nref.float_lit.str_len);
        case AST_IDENT:
            return ast_ident(nref.ident.name_ptr, nref.ident.name_len);
        case AST_SUPER:
            return (*AstNode)ast_super();
        case AST_STRING:
            return ast_string(nref.string_lit.str_ptr, nref.string_lit.str_len);
        case AST_BINARY:
            return ast_binary(
                nref.binary.op,
                generic_clone_expr(nref.binary.left, bindings),
                generic_clone_expr(nref.binary.right, bindings)
            );
        case AST_UNARY:
            return ast_unary(nref.unary.op, generic_clone_expr(nref.unary.operand, bindings));
        case AST_CALL:
            var args: *Vec<*AstNode> = generic_clone_args_vec(nref.call.args_vec, bindings);
            var arg_names: *Vec<*NameInfo> = generic_clone_arg_names(nref.call.arg_names_vec);
            return (*AstNode)ast_call_with_origin_named(nref.call.name_ptr, nref.call.name_len, args, arg_names, nref.call.origin);
        case AST_GENERIC_CALL:
            return generic_clone_expr_generic_call(nref.generic_call, bindings);
        case AST_GENERIC_STRUCT_LITERAL:
            var gargs2: *Vec<*GenericArg> = new Vec<*GenericArg>(4);
            var gn2: u64 = nref.generic_struct_lit.generic_args_vec.len();
            for (var gi: u64 = 0; gi < gn2; gi++) {
                var ga2: *GenericArg = nref.generic_struct_lit.generic_args_vec.get(gi);
                var ng2: *GenericArg = new GenericArg();
                ng2.kind = ga2.kind;
                ng2.value = ga2.value;
                if (ga2.kind == GENERIC_KIND_TYPE) {
                    var ti3: *TypeInfo = ga2.type_ptr;
                    ng2.type_ptr = generic_subst_typeinfo(ti3.type_kind, ti3.ptr_depth, ti3.is_tagged, ti3.struct_name_ptr, ti3.struct_name_len, ti3.tag_layout_ptr, ti3.tag_layout_len, ti3.elem_type_kind, ti3.elem_ptr_depth, ti3.array_len, ti3.array_len_is_param, ti3.array_len_param_ptr, ti3.array_len_param_len, bindings);
                } else {
                    ng2.type_ptr = 0;
                }
                gargs2.push(ng2);
            }
            var vals2: *Vec<*AstNode> = generic_clone_args_vec(nref.generic_struct_lit.values_vec, bindings);
            return (*AstNode)ast_generic_struct_literal(nref.generic_struct_lit.name_ptr, nref.generic_struct_lit.name_len, gargs2, vals2);
        case AST_STATIC_GENERIC_CALL:
            var sg_gargs: *Vec<*GenericArg> = new Vec<*GenericArg>(4);
            var sg_n: u64 = nref.static_generic_call.generic_args_vec.len();
            for (var sg_i: u64 = 0; sg_i < sg_n; sg_i++) {
                var sg_ga: *GenericArg = nref.static_generic_call.generic_args_vec.get(sg_i);
                var sg_ng: *GenericArg = new GenericArg();
                sg_ng.kind = sg_ga.kind;
                sg_ng.value = sg_ga.value;
                if (sg_ga.kind == GENERIC_KIND_TYPE) {
                    var sg_ti: *TypeInfo = sg_ga.type_ptr;
                    sg_ng.type_ptr = generic_subst_typeinfo(sg_ti.type_kind, sg_ti.ptr_depth, sg_ti.is_tagged, sg_ti.struct_name_ptr, sg_ti.struct_name_len, sg_ti.tag_layout_ptr, sg_ti.tag_layout_len, sg_ti.elem_type_kind, sg_ti.elem_ptr_depth, sg_ti.array_len, sg_ti.array_len_is_param, sg_ti.array_len_param_ptr, sg_ti.array_len_param_len, bindings);
                } else {
                    sg_ng.type_ptr = 0;
                }
                sg_gargs.push(sg_ng);
            }
            var sg_args: *Vec<*AstNode> = generic_clone_args_vec(nref.static_generic_call.args_vec, bindings);
            var sg_arg_names: *Vec<*NameInfo> = generic_clone_arg_names(nref.static_generic_call.arg_names_vec);
            return (*AstNode)ast_static_generic_call_named(
                nref.static_generic_call.struct_name_ptr,
                nref.static_generic_call.struct_name_len,
                nref.static_generic_call.method_ptr,
                nref.static_generic_call.method_len,
                sg_gargs,
                sg_args,
                sg_arg_names
            );
        case AST_ADDR_OF:
            return ast_addr_of(generic_clone_expr(nref.addr_of.operand, bindings));
        case AST_DEREF:
            return ast_deref(generic_clone_expr(nref.deref.operand, bindings));
        case AST_DEREF8:
            return ast_deref8(generic_clone_expr(nref.deref8.operand, bindings));
        case AST_CAST:
            var sub: *TypeInfo = generic_subst_typeinfo(
                nref.cast_expr.target_type,
                nref.cast_expr.target_ptr_depth,
                nref.cast_expr.target_is_tagged,
                nref.cast_expr.struct_name_ptr,
                nref.cast_expr.struct_name_len,
                nref.cast_expr.tag_layout_ptr,
                nref.cast_expr.tag_layout_len,
                0, 0, 0, 0, 0, 0,
                bindings
            );
            var ti: *TypeInfo = sub;
            return ast_cast_ex(generic_clone_expr(nref.cast_expr.expr, bindings), ti.type_kind, ti.ptr_depth, ti.is_tagged, ti.struct_name_ptr, ti.struct_name_len, ti.tag_layout_ptr, ti.tag_layout_len);
        case AST_MEMBER_ACCESS:
            if (nref.member_access.parent_ptr != 0) {
                return ast_member_access_scoped(
                    generic_clone_expr(nref.member_access.object, bindings),
                    nref.member_access.parent_ptr,
                    nref.member_access.parent_len,
                    nref.member_access.member_ptr,
                    nref.member_access.member_len
                );
            }
            return ast_member_access(generic_clone_expr(nref.member_access.object, bindings), nref.member_access.member_ptr, nref.member_access.member_len);
        case AST_SAFE_MEMBER_ACCESS:
            if (nref.member_access.parent_ptr != 0) {
                return ast_safe_member_access_scoped(
                    generic_clone_expr(nref.member_access.object, bindings),
                    nref.member_access.parent_ptr,
                    nref.member_access.parent_len,
                    nref.member_access.member_ptr,
                    nref.member_access.member_len
                );
            }
            return ast_safe_member_access(generic_clone_expr(nref.member_access.object, bindings), nref.member_access.member_ptr, nref.member_access.member_len);
        case AST_METHOD_CALL:
            var args2: *Vec<*AstNode> = generic_clone_args_vec(nref.method_call.args_vec, bindings);
            var arg_names2: *Vec<*NameInfo> = generic_clone_arg_names(nref.method_call.arg_names_vec);
            return (*AstNode)ast_method_call_named(generic_clone_expr(nref.method_call.receiver, bindings), nref.method_call.method_ptr, nref.method_call.method_len, args2, arg_names2);
        case AST_SAFE_METHOD_CALL:
            var sargs2: *Vec<*AstNode> = generic_clone_args_vec(nref.method_call.args_vec, bindings);
            var sarg_names2: *Vec<*NameInfo> = generic_clone_arg_names(nref.method_call.arg_names_vec);
            return (*AstNode)ast_safe_method_call_named(generic_clone_expr(nref.method_call.receiver, bindings), nref.method_call.method_ptr, nref.method_call.method_len, sargs2, sarg_names2);
        case AST_TRY:
            return ast_try(generic_clone_expr(nref.try_expr.operand, bindings));
        case AST_STRUCT_LITERAL:
            var vals: *Vec<*AstNode> = generic_clone_args_vec(nref.struct_lit.values_vec, bindings);
            return ast_struct_literal(nref.struct_lit.struct_def, vals);
        case AST_SIZEOF:
            var sub2: *TypeInfo = generic_subst_typeinfo(
                nref.sizeof_type.type_kind,
                nref.sizeof_type.ptr_depth,
                0,
                nref.sizeof_type.struct_name_ptr,
                nref.sizeof_type.struct_name_len,
                0, 0,
                nref.sizeof_type.elem_type_kind,
                nref.sizeof_type.elem_ptr_depth,
                nref.sizeof_type.array_len,
                nref.sizeof_type.array_len_is_param,
                nref.sizeof_type.array_len_param_ptr,
                nref.sizeof_type.array_len_param_len,
                bindings
            );
            var ti2: *TypeInfo = sub2;
            if (ti2.elem_typeinfo == 0) {
                ti2.elem_typeinfo = nref.sizeof_type.elem_typeinfo;
            }
            return ast_sizeof(ti2.type_kind, ti2.ptr_depth, ti2.struct_name_ptr, ti2.struct_name_len, ti2.elem_type_kind, ti2.elem_ptr_depth, ti2.array_len, ti2.array_len_is_param, ti2.array_len_param_ptr, ti2.array_len_param_len, ti2.elem_typeinfo);
        case AST_SIZEOF_EXPR:
            return ast_sizeof_expr(generic_clone_expr(nref.sizeof_expr.expr, bindings));
        case AST_INDEX:
            return ast_index(generic_clone_expr(nref.index_expr.base, bindings), generic_clone_expr(nref.index_expr.index, bindings));
        case AST_SLICE:
            return ast_slice(generic_clone_expr(nref.slice_expr.ptr_expr, bindings), generic_clone_expr(nref.slice_expr.len_expr, bindings));
        case AST_CALL_PTR:
            var args3: *Vec<*AstNode> = generic_clone_args_vec(nref.call_ptr.args_vec, bindings);
            return ast_call_ptr(generic_clone_expr(nref.call_ptr.callee, bindings), args3);
        case AST_NEW:
            return generic_clone_expr_new(nref.new_expr, bindings);
        case AST_STACK_CTOR:
            return generic_clone_expr_stack_ctor(nref.stack_ctor, bindings);
        default:
            return node;
    }
}

func generic_clone_stmt(node: *AstNode, bindings: *Vec<*GenericBinding>) -> *AstNode {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    var nref: AstNodeTagRef;
    nref.node = node;
    switch (kind) {
        case AST_RETURN:
            return ast_return(generic_clone_expr(nref.ret_stmt.expr, bindings));
        case AST_VAR_DECL:
            var ti: *TypeInfo = generic_subst_typeinfo(
                nref.var_decl.type_kind,
                nref.var_decl.ptr_depth,
                nref.var_decl.is_tagged,
                nref.var_decl.struct_name_ptr,
                nref.var_decl.struct_name_len,
                nref.var_decl.tag_layout_ptr,
                nref.var_decl.tag_layout_len,
                nref.var_decl.elem_type_kind,
                nref.var_decl.elem_ptr_depth,
                nref.var_decl.array_len,
                nref.var_decl.array_len_is_param,
                nref.var_decl.array_len_param_ptr,
                nref.var_decl.array_len_param_len,
                bindings
            );
            var decl: *AstVarDecl = ast_var_decl(nref.var_decl.name_ptr, nref.var_decl.name_len, ti.type_kind, ti.ptr_depth, generic_clone_expr(nref.var_decl.init_expr, bindings));
            decl.is_tagged = ti.is_tagged;
            decl.struct_name_ptr = ti.struct_name_ptr;
            decl.struct_name_len = ti.struct_name_len;
            decl.tag_layout_ptr = ti.tag_layout_ptr;
            decl.tag_layout_len = ti.tag_layout_len;
            decl.elem_type_kind = ti.elem_type_kind;
            decl.elem_ptr_depth = ti.elem_ptr_depth;
            decl.array_len = ti.array_len;
            decl.array_len_is_param = ti.array_len_is_param;
            decl.array_len_param_ptr = ti.array_len_param_ptr;
            decl.array_len_param_len = ti.array_len_param_len;
            if (ti.elem_typeinfo != 0) {
                decl.elem_typeinfo = ti.elem_typeinfo;
            } else {
                decl.elem_typeinfo = nref.var_decl.elem_typeinfo;
            }
            decl.annotations_vec = nref.var_decl.annotations_vec;
            return (*AstNode)decl;
        case AST_ASSIGN:
            return ast_assign(generic_clone_expr(nref.assign_stmt.target, bindings), generic_clone_expr(nref.assign_stmt.value, bindings));
        case AST_EXPR_STMT:
            return ast_expr_stmt(generic_clone_expr(nref.expr_stmt.expr, bindings));
        case AST_IF:
            return ast_if(
                generic_clone_expr(nref.if_stmt.cond, bindings),
                generic_clone_stmt(nref.if_stmt.then_block, bindings),
                generic_clone_stmt(nref.if_stmt.else_block, bindings)
            );
        case AST_WHILE:
            return ast_while(generic_clone_expr(nref.while_stmt.cond, bindings), generic_clone_stmt(nref.while_stmt.body, bindings));
        case AST_FOR:
            return ast_for(
                generic_clone_stmt(nref.for_stmt.init, bindings),
                generic_clone_expr(nref.for_stmt.cond, bindings),
                generic_clone_expr(nref.for_stmt.update, bindings),
                generic_clone_stmt(nref.for_stmt.body, bindings)
            );
        case AST_SWITCH:
        case AST_MATCH:
            var cases_out: *Vec<*AstNode> = new Vec<*AstNode>(4);
            var cn: u64 = nref.switch_stmt.cases_vec.len();
            for (var i: u64 = 0; i < cn; i++) {
                cases_out.push(generic_clone_stmt(nref.switch_stmt.cases_vec.get(i), bindings));
            }
            if (kind == AST_MATCH) {
                return ast_match(generic_clone_expr(nref.switch_stmt.expr, bindings), cases_out);
            }
            return ast_switch(generic_clone_expr(nref.switch_stmt.expr, bindings), cases_out);
        case AST_CASE:
            return ast_case(nref.case_stmt.value, generic_clone_stmt(nref.case_stmt.body, bindings), nref.case_stmt.is_default);
        case AST_BREAK:
            return ast_break();
        case AST_CONTINUE:
            return ast_continue();
        case AST_BLOCK:
            var stmts_out: *Vec<*AstNode> = new Vec<*AstNode>(8);
            var n: u64 = nref.block_stmt.stmts_vec.len();
            for (var i: u64 = 0; i < n; i++) {
                stmts_out.push(generic_clone_stmt(nref.block_stmt.stmts_vec.get(i), bindings));
            }
            return ast_block(stmts_out);
        case AST_ASM:
            var text_vec: *Vec<u64> = new Vec<u64>(16);
            var tn: u64 = nref.asm_stmt.text_vec.len();
            for (var i2: u64 = 0; i2 < tn; i2++) { text_vec.push(nref.asm_stmt.text_vec.get(i2)); }
            return ast_asm(text_vec);
        case AST_ALIAS:
            return (*AstNode)ast_alias(nref.alias_stmt.reg_ptr, nref.alias_stmt.reg_len, nref.alias_stmt.name_ptr, nref.alias_stmt.name_len);
        case AST_DEFER:
            return (*AstNode)ast_defer(generic_clone_stmt(nref.defer_stmt.stmt, bindings));
        case AST_DELETE:
            return (*AstNode)ast_delete(generic_clone_expr(nref.delete_stmt.expr, bindings));
        default:
            return node;
    }
}

func generic_clone_func(template_ptr: *AstFunc, bindings: *Vec<*GenericBinding>, new_name_ptr: u64, new_name_len: u64) -> *AstFunc {
    var fn: *AstFunc = template_ptr;
    var params_out: *Vec<*Param> = new Vec<*Param>(8);
    var pn: u64 = fn.params_vec.len();
    for (var i: u64 = 0; i < pn; i++) {
        var p: *Param = fn.params_vec.get(i);
        var ti: *TypeInfo = generic_subst_typeinfo(p.type_kind, p.ptr_depth, p.is_tagged, p.struct_name_ptr, p.struct_name_len, p.tag_layout_ptr, p.tag_layout_len, p.elem_type_kind, p.elem_ptr_depth, p.array_len, p.array_len_is_param, p.array_len_param_ptr, p.array_len_param_len, bindings);
        var np: *Param = new Param();
        np.name_ptr = p.name_ptr;
        np.name_len = p.name_len;
        np.fill_from_typeinfo(ti);
        if (np.elem_typeinfo == 0) {
            np.elem_typeinfo = p.elem_typeinfo;
        }
        params_out.push(np);
    }

    var rt: *TypeInfo = generic_subst_typeinfo(fn.ret_type, fn.ret_ptr_depth, fn.ret_is_tagged, fn.ret_struct_name_ptr, fn.ret_struct_name_len, fn.ret_tag_layout_ptr, fn.ret_tag_layout_len, 0, 0, 0, 0, 0, 0, bindings);
    var body_out: *AstNode = generic_clone_stmt(fn.body, bindings);
    var fn_out: *AstFunc = ast_func_ex(new_name_ptr, new_name_len, params_out, rt.type_kind, rt.ptr_depth, rt.is_tagged, rt.struct_name_ptr, rt.struct_name_len, rt.tag_layout_ptr, rt.tag_layout_len, body_out);
    fn_out.annotations_vec = fn.annotations_vec;
    return fn_out;
}

func generic_clone_func_sig(template_ptr: *AstFunc, bindings: *Vec<*GenericBinding>, new_name_ptr: u64, new_name_len: u64) -> *AstFunc {
    var fn: *AstFunc = template_ptr;
    var params_out: *Vec<*Param> = new Vec<*Param>(8);
    var pn: u64 = fn.params_vec.len();
    for (var i: u64 = 0; i < pn; i++) {
        var p: *Param = fn.params_vec.get(i);
        var ti: *TypeInfo = generic_subst_typeinfo(p.type_kind, p.ptr_depth, p.is_tagged, p.struct_name_ptr, p.struct_name_len, p.tag_layout_ptr, p.tag_layout_len, p.elem_type_kind, p.elem_ptr_depth, p.array_len, p.array_len_is_param, p.array_len_param_ptr, p.array_len_param_len, bindings);
        var np: *Param = new Param();
        np.name_ptr = p.name_ptr;
        np.name_len = p.name_len;
        np.fill_from_typeinfo(ti);
        if (np.elem_typeinfo == 0) {
            np.elem_typeinfo = p.elem_typeinfo;
        }
        params_out.push(np);
    }

    var rt: *TypeInfo = generic_subst_typeinfo(fn.ret_type, fn.ret_ptr_depth, fn.ret_is_tagged, fn.ret_struct_name_ptr, fn.ret_struct_name_len, fn.ret_tag_layout_ptr, fn.ret_tag_layout_len, 0, 0, 0, 0, 0, 0, bindings);
    var fn_out: *AstFunc = ast_func_ex(new_name_ptr, new_name_len, params_out, rt.type_kind, rt.ptr_depth, rt.is_tagged, rt.struct_name_ptr, rt.struct_name_len, rt.tag_layout_ptr, rt.tag_layout_len, 0);
    fn_out.annotations_vec = fn.annotations_vec;
    return fn_out;
}

func generic_get_or_create_instance(tpl_ptr: *GenericFuncTemplate, bindings: *Vec<*GenericBinding>) -> *NameInfo {
    var tpl: *GenericFuncTemplate = tpl_ptr;
    var base_ptr: u64 = tpl.mangled_ptr;
    var base_len: u64 = tpl.mangled_len;
    if (base_ptr == 0) {
        base_ptr = tpl.name_ptr;
        base_len = tpl.name_len;
    }

    var name_info: *NameInfo = generic_mangle_name(base_ptr, base_len, tpl.params_vec, bindings);
    var inst_ptr: u64 = name_info.ptr;
    var inst_len: u64 = name_info.len;

    if (g_compiler_ctx.generic_instantiations != 0) {
        var exists: u64 = g_compiler_ctx.generic_instantiations.get(inst_ptr, inst_len);
        if (exists != 0) { return name_info; }
    }

    var def_src: *AstFunc = tpl.func_def;
    if (def_src == 0 && tpl.func_sig != 0) { def_src = tpl.func_sig; }
    if (def_src == 0) {
        emit_stderr("[ERROR] Missing generic function body\n");
        compiler_panic("Compilation failed");
    }

    var fn_new: *AstFunc = generic_clone_func(def_src, bindings, inst_ptr, inst_len);
    var sig_new: *AstFunc = generic_clone_func_sig(def_src, bindings, inst_ptr, inst_len);
    g_compiler_ctx.all_funcs.push(fn_new);
    g_compiler_ctx.all_func_sigs.push(sig_new);
    compiler_invalidate_func_lookup();

    // Preserve impl-method owner/access metadata for instantiated names.
    // Without this, private member access checks inside generic impl methods
    // lose their owner context during codegen.
    compiler_copy_impl_method_metadata_if_needed(base_ptr, base_len, inst_ptr, inst_len);
    if (compiler_is_impl_method(inst_ptr, inst_len) != 0) {
        compiler_register_impl_method_func(inst_ptr, inst_len, fn_new);
    }

    if (g_compiler_ctx.generic_instantiations == 0) { g_compiler_ctx.generic_instantiations = new HashMap<u64, u64>(64); }
    g_compiler_ctx.generic_instantiations.put(inst_ptr, inst_len, 1);

    // Map new function to template module
    if (g_compiler_ctx.func_module_map != 0 && tpl.mangled_ptr != 0) {
        var mod_info: *NameInfo = g_compiler_ctx.func_module_map.get(tpl.mangled_ptr, tpl.mangled_len);
        if (mod_info != 0) {
            g_compiler_ctx.func_module_map.put(inst_ptr, inst_len, mod_info);
        }
    }

    return name_info;
}

func generic_build_bindings_core(params_vec: *Vec<*GenericParam>, gargs: *Vec<*GenericArg>) -> *Vec<*GenericBinding> {
    if (params_vec == 0 || gargs == 0) {
        emit_stderr("[ERROR] Missing generic params/args\n");
        compiler_panic("Compilation failed");
    }
    var bindings: *Vec<*GenericBinding> = new Vec<*GenericBinding>(4);
    var pn: u64 = params_vec.len();
    var an: u64 = gargs.len();
    if (pn != an) {
        emit_stderr("[ERROR] Generic argument count mismatch\n");
        compiler_panic("Compilation failed");
    }
    for (var i: u64 = 0; i < pn; i++) {
        var gp: *GenericParam = params_vec.get(i);
        var ga: *GenericArg = gargs.get(i);
        if (gp.kind == GENERIC_KIND_TYPE) {
            if (ga.kind != GENERIC_KIND_TYPE) {
                emit_stderr("[ERROR] Expected type generic argument\n");
                compiler_panic("Compilation failed");
            }
            if (generic_bind_type(bindings, gp.name_ptr, gp.name_len, ga.type_ptr) != 0) {
                emit_stderr("[ERROR] Conflicting generic type bindings\n");
                compiler_panic("Compilation failed");
            }
        } else {
            if (ga.kind != GENERIC_KIND_VALUE) {
                emit_stderr("[ERROR] Expected value generic argument\n");
                compiler_panic("Compilation failed");
            }
            if (generic_bind_value(bindings, gp.name_ptr, gp.name_len, ga.value) != 0) {
                emit_stderr("[ERROR] Conflicting generic value bindings\n");
                compiler_panic("Compilation failed");
            }
        }
    }
    return bindings;
}

func generic_build_bindings_for_explicit(tpl_ptr: *GenericFuncTemplate, gargs: *Vec<*GenericArg>) -> *Vec<*GenericBinding> {
    var tpl: *GenericFuncTemplate = tpl_ptr;
    return generic_build_bindings_core(tpl.params_vec, gargs);
}

func generic_build_bindings_for_struct(tpl_ptr: *GenericStructTemplate, gargs: *Vec<*GenericArg>) -> *Vec<*GenericBinding> {
    var tpl: *GenericStructTemplate = tpl_ptr;
    return generic_build_bindings_core(tpl.params_vec, gargs);
}

func generic_clone_struct(template_def: *AstStructDef, bindings: *Vec<*GenericBinding>, new_name_ptr: u64, new_name_len: u64) -> *AstStructDef {
    var sd: *AstStructDef = template_def;
    var fields_in: *Vec<*FieldDesc> = sd.fields_vec;
    var fields_out: *Vec<*FieldDesc> = new Vec<*FieldDesc>(fields_in.len());
    var n: u64 = fields_in.len();
    for (var i: u64 = 0; i < n; i++) {
        var f: *FieldDesc = fields_in.get(i);
        var ti: *TypeInfo = generic_subst_typeinfo(f.type_kind, f.ptr_depth, f.is_tagged, f.struct_name_ptr, f.struct_name_len, f.tag_layout_ptr, f.tag_layout_len, f.elem_type_kind, f.elem_ptr_depth, f.array_len, 0, 0, 0, bindings);
        var nf: *FieldDesc = new FieldDesc();
        nf.name_ptr = f.name_ptr;
        nf.name_len = f.name_len;
        nf.type_kind = ti.type_kind;
        nf.struct_name_ptr = ti.struct_name_ptr;
        nf.struct_name_len = ti.struct_name_len;
        nf.ptr_depth = ti.ptr_depth;
        nf.is_tagged = ti.is_tagged;
        nf.tag_layout_ptr = ti.tag_layout_ptr;
        nf.tag_layout_len = ti.tag_layout_len;
        nf.bit_width = f.bit_width;
        nf.elem_type_kind = ti.elem_type_kind;
        nf.elem_ptr_depth = ti.elem_ptr_depth;
        nf.array_len = ti.array_len;
        if (ti.elem_typeinfo != 0) {
            nf.elem_typeinfo = ti.elem_typeinfo;
        } else {
            nf.elem_typeinfo = f.elem_typeinfo;
        }
        nf.access = f.access;
        nf.owner_struct_ptr = new_name_ptr;
        nf.owner_struct_len = new_name_len;
        fields_out.push(nf);
    }
    var parents_out: *Vec<*ParentDesc> = 0;
    if (sd.parents_vec != 0) {
        var parents_in: *Vec<*ParentDesc> = sd.parents_vec;
        parents_out = new Vec<*ParentDesc>(parents_in.len());
        var pn: u64 = parents_in.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_in: *ParentDesc = parents_in.get(pi);
            var parent_out: *ParentDesc = new ParentDesc();
            parent_out.name_ptr = parent_in.name_ptr;
            parent_out.name_len = parent_in.name_len;
            parent_out.struct_def = parent_in.struct_def;
            parents_out.push(parent_out);
        }
    }
    var traits_out: *Vec<*TraitRef> = 0;
    if (sd.traits_vec != 0) {
        var traits_in: *Vec<*TraitRef> = sd.traits_vec;
        traits_out = new Vec<*TraitRef>(traits_in.len());
        var tn: u64 = traits_in.len();
        for (var ti: u64 = 0; ti < tn; ti++) {
            var t_in: *TraitRef = traits_in.get(ti);
            var t_out: *TraitRef = new TraitRef();
            t_out.name_ptr = t_in.name_ptr;
            t_out.name_len = t_in.name_len;
            t_out.trait_def = t_in.trait_def;
            traits_out.push(t_out);
        }
    }
    return ast_struct_def(new_name_ptr, new_name_len, parents_out, fields_out, sd.is_packed, traits_out, sd.is_union);
}

func generic_struct_get_or_create_instance(tpl_ptr: *GenericStructTemplate, bindings: *Vec<*GenericBinding>) -> *NameInfo {
    var tpl: *GenericStructTemplate = tpl_ptr;
    var name_info: *NameInfo = generic_mangle_name(tpl.name_ptr, tpl.name_len, tpl.params_vec, bindings);
    var inst_ptr: u64 = name_info.ptr;
    var inst_len: u64 = name_info.len;

    if (g_compiler_ctx.generic_struct_instantiations != 0) {
        var exists: *AstStructDef = g_compiler_ctx.generic_struct_instantiations.get(inst_ptr, inst_len);
        if (exists != 0) {
            compiler_register_generic_struct_bindings(inst_ptr, inst_len, bindings);
            return name_info;
        }
    }

    var def_src: *AstStructDef = tpl.struct_def;
    if (def_src == 0) {
        emit_stderr("[ERROR] Missing generic struct template\n");
        compiler_panic("Compilation failed");
    }

    var struct_new: *AstStructDef = generic_clone_struct(def_src, bindings, inst_ptr, inst_len);
    register_struct_type(struct_new);

    if (g_compiler_ctx.generic_struct_instantiations == 0) { g_compiler_ctx.generic_struct_instantiations = new HashMap<u64, *AstStructDef>(64); }
    g_compiler_ctx.generic_struct_instantiations.put(inst_ptr, inst_len, struct_new);
    compiler_register_generic_struct_bindings(inst_ptr, inst_len, bindings);
    return name_info;
}

func generic_build_bindings_by_infer(tpl_ptr: *GenericFuncTemplate, call_args: *Vec<*AstNode>, symtab: *HashMap<u64, *TypeInfo>) -> *Vec<*GenericBinding> {
    var tpl: *GenericFuncTemplate = tpl_ptr;
    var bindings: *Vec<*GenericBinding> = new Vec<*GenericBinding>(4);
    var def_src: *AstFunc = tpl.func_def;
    if (def_src == 0) { def_src = tpl.func_sig; }
    if (def_src == 0) {
        emit_stderr("[ERROR] Missing generic signature for inference\n");
        compiler_panic("Compilation failed");
    }
    var fn: *AstFunc = def_src;
    var params: *Vec<*Param> = fn.params_vec;
    var pn: u64 = params.len();
    var an: u64 = call_args.len();
    if (pn != an) {
        emit_stderr("[ERROR] Generic inference arg count mismatch\n");
        compiler_panic("Compilation failed");
    }

    for (var i: u64 = 0; i < pn; i++) {
        var p: *Param = params.get(i);
        var arg_expr: *AstNode = call_args.get(i);
        var arg_ti: *TypeInfo = generic_infer_expr_type(arg_expr, symtab);
        if (generic_infer_from_typeinfo(p.type_kind, p.ptr_depth, p.struct_name_ptr, p.struct_name_len, p.elem_type_kind, p.elem_ptr_depth, p.array_len, p.array_len_is_param, p.array_len_param_ptr, p.array_len_param_len, arg_ti, bindings) != 0) {
            return 0;
        }
    }

    return bindings;
}

func generic_resolve_template(name_ptr: u64, name_len: u64) -> *GenericFuncTemplate {
    var tpl: *GenericFuncTemplate = compiler_find_generic_template_by_name(name_ptr, name_len);
    if (tpl != 0) {
        var t: *GenericFuncTemplate = tpl;
        if (t.params_vec != 0 && t.params_vec.len() > 0) { return tpl; }
    }
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        tpl = compiler_find_generic_template_by_mangled(resolved.ptr, resolved.len);
        if (tpl != 0) {
            var t2: *GenericFuncTemplate = tpl;
            if (t2.params_vec != 0 && t2.params_vec.len() > 0) { return tpl; }
            tpl = 0;
        }
    }
    return tpl;
}

func generic_build_method_template_name(struct_ptr: u64, base_len: u64, method_ptr: u64, method_len: u64) -> *NameInfo {
    var full_len: u64 = base_len + 1 + method_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    var struct_u8: []u8 = slice(struct_ptr, base_len);
    var method_u8: []u8 = slice(method_ptr, method_len);
    for (var i: u64 = 0; i < base_len; i++) {
        full_u8[i] = struct_u8[i];
    }
    full_u8[base_len] = 95;
    for (var j: u64 = 0; j < method_len; j++) {
        full_u8[base_len + 1 + j] = method_u8[j];
    }
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func generic_find_method_template_for_struct(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> *GenericFuncTemplate {
    var base_len: u64 = compiler_find_generic_suffix_index(struct_ptr, struct_len);
    var full_name: *NameInfo = generic_build_method_template_name(struct_ptr, base_len, method_ptr, method_len);
    var tpl: *GenericFuncTemplate = compiler_find_generic_template_by_name(full_name.ptr, full_name.len);
    if (tpl != 0) { return tpl; }

    var base_u8: []u8 = slice(struct_ptr, base_len);
    var last_sep: u64 = base_len;
    for (var si: u64 = 0; si + 1 < base_len; si++) {
        if (base_u8[si] == 95 && base_u8[si + 1] == 95) { last_sep = si + 2; }
    }
    if (last_sep >= base_len) { return 0; }

    var short_base_len: u64 = base_len - last_sep;
    var short_base_ptr: u64 = struct_ptr + last_sep;
    var alt_name: *NameInfo = generic_build_method_template_name(short_base_ptr, short_base_len, method_ptr, method_len);
    return compiler_find_generic_template_by_name(alt_name.ptr, alt_name.len);
}

func generic_try_instantiate_method_template(mc: *AstMethodCall, args: *Vec<*AstNode>, recv_ti: *TypeInfo, symtab: *HashMap<u64, *TypeInfo>) -> u64 {
    if (recv_ti == 0 || recv_ti.type_kind != TYPE_STRUCT) { return 0; }

    var struct_ptr: u64 = recv_ti.struct_name_ptr;
    var struct_len: u64 = recv_ti.struct_name_len;
    var tpl_ptr: *GenericFuncTemplate = generic_find_method_template_for_struct(struct_ptr, struct_len, mc.method_ptr, mc.method_len);
    if (tpl_ptr == 0) { return 0; }

    var base_len: u64 = compiler_find_generic_suffix_index(struct_ptr, struct_len);
    var bindings: *Vec<*GenericBinding> = 0;
    if (base_len != struct_len) {
        bindings = compiler_get_generic_struct_bindings(struct_ptr, struct_len);
    }
    if (bindings == 0) {
        var an: u64 = args.len();
        var infer_args: *Vec<*AstNode> = new Vec<*AstNode>(an + 1);
        if (recv_ti.ptr_depth > 0) { infer_args.push(mc.receiver); }
        else { infer_args.push(ast_addr_of(mc.receiver)); }
        for (var ai: u64 = 0; ai < an; ai++) {
            infer_args.push(args.get(ai));
        }
        bindings = generic_build_bindings_by_infer(tpl_ptr, infer_args, symtab);
    }
    if (bindings != 0) {
        generic_get_or_create_instance(tpl_ptr, bindings);
    }
    return 0;
}

const GENERIC_AST_VISIT_PROCESS = 1;

struct GenericAstVisitor {
    public mode: u64;
    public symtab: *HashMap<u64, *TypeInfo>;
}

func generic_ast_visitor_new_process(symtab: *HashMap<u64, *TypeInfo>) -> GenericAstVisitor {
    var visitor: GenericAstVisitor;
    visitor.mode = GENERIC_AST_VISIT_PROCESS;
    visitor.symtab = symtab;
    return visitor;
}

func generic_ast_visitor_walk_args(visitor: *GenericAstVisitor, args_in: *Vec<*AstNode>) -> *Vec<*AstNode> {
    if (args_in == 0) { return 0; }
    var args_out: *Vec<*AstNode> = new Vec<*AstNode>(4);
    var n: u64 = args_in.len();
    for (var i: u64 = 0; i < n; i++) {
        args_out.push(generic_ast_visitor_walk_expr(visitor, args_in.get(i)));
    }
    return args_out;
}

func generic_try_instantiate_ctor_template(type_kind: u64, struct_name_ptr: u64, struct_name_len: u64, ctor_args_vec: *Vec<*AstNode>) -> u64 {
    if (ctor_args_vec == 0) { return 0; }
    if (type_kind != TYPE_STRUCT) { return 0; }

    var struct_base_len: u64 = compiler_find_generic_suffix_index(struct_name_ptr, struct_name_len);
    var ctor_name: *NameInfo = _compiler_build_constructor_name(struct_name_ptr, struct_base_len);
    var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_name(ctor_name.ptr, ctor_name.len);
    if (tpl_ptr == 0 || tpl_ptr.params_vec == 0 || tpl_ptr.params_vec.len() == 0) { return 0; }

    var ctor_bindings: *Vec<*GenericBinding> = compiler_get_generic_struct_bindings(struct_name_ptr, struct_name_len);
    if (ctor_bindings != 0) {
        generic_get_or_create_instance(tpl_ptr, ctor_bindings);
    }
    return 0;
}

func generic_process_generic_call_expr_visitor(gc: *AstGenericCall, visitor: *GenericAstVisitor) -> *AstNode {
    var tpl_ptr: *GenericFuncTemplate = generic_resolve_template(gc.name_ptr, gc.name_len);
    if (tpl_ptr == 0) {
        emit_stderr("[ERROR] Generic function not found\n");
        compiler_panic("Compilation failed");
    }
    var bindings: *Vec<*GenericBinding> = generic_build_bindings_for_explicit(tpl_ptr, gc.generic_args_vec);
    var name_info: *NameInfo = generic_get_or_create_instance(tpl_ptr, bindings);
    var args_new: *Vec<*AstNode> = generic_ast_visitor_walk_args(visitor, gc.args_vec);
    return ast_call_with_origin(name_info.ptr, name_info.len, args_new, gc.origin);
}

func generic_process_call_expr_visitor(call: *AstCall, visitor: *GenericAstVisitor) -> *AstNode {
    var tpl_ptr: *GenericFuncTemplate = generic_resolve_template(call.name_ptr, call.name_len);
    if (tpl_ptr == 0) {
        var args_new2: *Vec<*AstNode> = generic_ast_visitor_walk_args(visitor, call.args_vec);
        return ast_call_with_origin(call.name_ptr, call.name_len, args_new2, call.origin);
    }
    var bindings2: *Vec<*GenericBinding> = generic_build_bindings_by_infer(tpl_ptr, call.args_vec, visitor.symtab);
    if (bindings2 == 0) {
        var args_fallback: *Vec<*AstNode> = generic_ast_visitor_walk_args(visitor, call.args_vec);
        return ast_call_with_origin(call.name_ptr, call.name_len, args_fallback, call.origin);
    }
    var name_info2: *NameInfo = generic_get_or_create_instance(tpl_ptr, bindings2);
    var args_new3: *Vec<*AstNode> = generic_ast_visitor_walk_args(visitor, call.args_vec);
    return ast_call_with_origin(name_info2.ptr, name_info2.len, args_new3, call.origin);
}

func generic_process_method_call_expr_visitor(mc: *AstMethodCall, visitor: *GenericAstVisitor) -> u64 {
    mc.receiver = generic_ast_visitor_walk_expr(visitor, mc.receiver);
    var args: *Vec<*AstNode> = generic_ast_visitor_walk_args(visitor, mc.args_vec);
    if (args == 0) {
        args = new Vec<*AstNode>(0);
    }
    mc.args_vec = args;
    var recv_ti: *TypeInfo = generic_infer_expr_type(mc.receiver, visitor.symtab);
    generic_try_instantiate_method_template(mc, args, recv_ti, visitor.symtab);
    return 0;
}

func generic_process_new_expr_visitor(nw: *AstNew, visitor: *GenericAstVisitor) -> *AstNode {
    if (nw.literal_expr != 0) {
        nw.literal_expr = generic_ast_visitor_walk_expr(visitor, nw.literal_expr);
    }
    nw.ctor_args_vec = generic_ast_visitor_walk_args(visitor, nw.ctor_args_vec);
    generic_try_instantiate_ctor_template(nw.type_kind, nw.struct_name_ptr, nw.struct_name_len, nw.ctor_args_vec);
    return (*AstNode)nw;
}

func generic_process_stack_ctor_expr_visitor(sc2: *AstStackCtor, visitor: *GenericAstVisitor) -> *AstNode {
    sc2.ctor_args_vec = generic_ast_visitor_walk_args(visitor, sc2.ctor_args_vec);
    generic_try_instantiate_ctor_template(sc2.type_kind, sc2.struct_name_ptr, sc2.struct_name_len, sc2.ctor_args_vec);
    return (*AstNode)sc2;
}

func generic_process_call_ptr_expr_visitor(cp: *AstCallPtr, visitor: *GenericAstVisitor) -> *AstNode {
    cp.callee = generic_ast_visitor_walk_expr(visitor, cp.callee);
    cp.args_vec = generic_ast_visitor_walk_args(visitor, cp.args_vec);
    return (*AstNode)cp;
}

func generic_process_index_expr_visitor(ix: *AstIndex, visitor: *GenericAstVisitor) -> *AstNode {
    ix.base = generic_ast_visitor_walk_expr(visitor, ix.base);
    ix.index = generic_ast_visitor_walk_expr(visitor, ix.index);
    return (*AstNode)ix;
}

func generic_process_slice_expr_visitor(sl: *AstSlice, visitor: *GenericAstVisitor) -> *AstNode {
    sl.ptr_expr = generic_ast_visitor_walk_expr(visitor, sl.ptr_expr);
    sl.len_expr = generic_ast_visitor_walk_expr(visitor, sl.len_expr);
    return (*AstNode)sl;
}

func generic_ast_visitor_walk_expr(visitor: *GenericAstVisitor, expr: *AstNode) -> *AstNode {
    if (expr == 0) { return 0; }
    var kind: u64 = ast_kind(expr);
    switch (kind) {
        case AST_GENERIC_CALL:
            return generic_process_generic_call_expr_visitor((*AstGenericCall)expr, visitor);
        case AST_STATIC_GENERIC_CALL:
            var sgc: *AstStaticGenericCall = (*AstStaticGenericCall)expr;
            sgc.args_vec = generic_ast_visitor_walk_args(visitor, sgc.args_vec);
            return generic_ast_visitor_walk_expr(visitor, compiler_lower_parse_sugar_static_generic_method_call(sgc));
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)expr;
            gsl.values_vec = generic_ast_visitor_walk_args(visitor, gsl.values_vec);
            return compiler_lower_parse_sugar_generic_struct_literal(gsl);
        case AST_CALL:
            return generic_process_call_expr_visitor((*AstCall)expr, visitor);
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)expr;
            bin.left = generic_ast_visitor_walk_expr(visitor, bin.left);
            bin.right = generic_ast_visitor_walk_expr(visitor, bin.right);
            return expr;
        case AST_UNARY:
            var un: *AstUnary = (*AstUnary)expr;
            un.operand = generic_ast_visitor_walk_expr(visitor, un.operand);
            return expr;
        case AST_ADDR_OF:
            var ao: *AstAddrOf = (*AstAddrOf)expr;
            ao.operand = generic_ast_visitor_walk_expr(visitor, ao.operand);
            return expr;
        case AST_DEREF:
            var dr: *AstDeref = (*AstDeref)expr;
            dr.operand = generic_ast_visitor_walk_expr(visitor, dr.operand);
            return expr;
        case AST_DEREF8:
            var dr8: *AstDeref8 = (*AstDeref8)expr;
            dr8.operand = generic_ast_visitor_walk_expr(visitor, dr8.operand);
            return expr;
        case AST_CAST:
            var cs: *AstCast = (*AstCast)expr;
            cs.expr = generic_ast_visitor_walk_expr(visitor, cs.expr);
            return expr;
        case AST_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)expr;
            ma.object = generic_ast_visitor_walk_expr(visitor, ma.object);
            return expr;
        case AST_SAFE_MEMBER_ACCESS:
            var sma: *AstMemberAccess = (*AstMemberAccess)expr;
            sma.object = generic_ast_visitor_walk_expr(visitor, sma.object);
            return expr;
        case AST_TRY:
            var tr2: *AstTry = (*AstTry)expr;
            tr2.operand = generic_ast_visitor_walk_expr(visitor, tr2.operand);
            return expr;
        case AST_FLOAT:
            return expr;
        case AST_SUPER:
            return expr;
        case AST_METHOD_CALL:
            generic_process_method_call_expr_visitor((*AstMethodCall)expr, visitor);
            return expr;
        case AST_SAFE_METHOD_CALL:
            generic_process_method_call_expr_visitor((*AstMethodCall)expr, visitor);
            return expr;
        case AST_NEW:
            return generic_process_new_expr_visitor((*AstNew)expr, visitor);
        case AST_STACK_CTOR:
            return generic_process_stack_ctor_expr_visitor((*AstStackCtor)expr, visitor);
        case AST_INDEX:
            return generic_process_index_expr_visitor((*AstIndex)expr, visitor);
        case AST_SLICE:
            return generic_process_slice_expr_visitor((*AstSlice)expr, visitor);
        case AST_CALL_PTR:
            return generic_process_call_ptr_expr_visitor((*AstCallPtr)expr, visitor);
        case AST_SIZEOF_EXPR:
            var se: *AstSizeofExpr = (*AstSizeofExpr)expr;
            se.expr = generic_ast_visitor_walk_expr(visitor, se.expr);
            return expr;
        default:
            return expr;
    }
}

func generic_ast_visitor_walk_stmt_block(visitor: *GenericAstVisitor, stmts: *Vec<*AstNode>) -> u64 {
    if (stmts == 0) { return 0; }
    var n: u64 = stmts.len();
    for (var i: u64 = 0; i < n; i++) {
        generic_ast_visitor_walk_stmt(visitor, stmts.get(i));
    }
    return 0;
}

func generic_ast_visitor_walk_stmt(visitor: *GenericAstVisitor, stmt: *AstNode) -> u64 {
    if (stmt == 0) { return 0; }
    var kind: u64 = ast_kind(stmt);
    switch (kind) {
        case AST_RETURN:
            var r: *AstReturn = (*AstReturn)stmt;
            r.expr = generic_ast_visitor_walk_expr(visitor, r.expr);
            return 0;
        case AST_VAR_DECL:
            var vd: *AstVarDecl = (*AstVarDecl)stmt;
            vd.init_expr = generic_ast_visitor_walk_expr(visitor, vd.init_expr);
            return 0;
        case AST_ASSIGN:
            var assign_stmt: *AstAssign = (*AstAssign)stmt;
            assign_stmt.target = generic_ast_visitor_walk_expr(visitor, assign_stmt.target);
            assign_stmt.value = generic_ast_visitor_walk_expr(visitor, assign_stmt.value);
            return 0;
        case AST_EXPR_STMT:
            var es: *AstExprStmt = (*AstExprStmt)stmt;
            es.expr = generic_ast_visitor_walk_expr(visitor, es.expr);
            return 0;
        case AST_IF:
            var ifs: *AstIf = (*AstIf)stmt;
            ifs.cond = generic_ast_visitor_walk_expr(visitor, ifs.cond);
            generic_ast_visitor_walk_stmt(visitor, ifs.then_block);
            generic_ast_visitor_walk_stmt(visitor, ifs.else_block);
            return 0;
        case AST_WHILE:
            var wl: *AstWhile = (*AstWhile)stmt;
            wl.cond = generic_ast_visitor_walk_expr(visitor, wl.cond);
            generic_ast_visitor_walk_stmt(visitor, wl.body);
            return 0;
        case AST_FOR:
            var fr: *AstFor = (*AstFor)stmt;
            generic_ast_visitor_walk_stmt(visitor, fr.init);
            fr.cond = generic_ast_visitor_walk_expr(visitor, fr.cond);
            fr.update = generic_ast_visitor_walk_expr(visitor, fr.update);
            generic_ast_visitor_walk_stmt(visitor, fr.body);
            return 0;
        case AST_SWITCH:
        case AST_MATCH:
            var sw: *AstSwitch = (*AstSwitch)stmt;
            sw.expr = generic_ast_visitor_walk_expr(visitor, sw.expr);
            generic_ast_visitor_walk_stmt_block(visitor, sw.cases_vec);
            return 0;
        case AST_CASE:
            var cs: *AstCase = (*AstCase)stmt;
            generic_ast_visitor_walk_stmt(visitor, cs.body);
            return 0;
        case AST_BLOCK:
            var blk: *AstBlock = (*AstBlock)stmt;
            generic_ast_visitor_walk_stmt_block(visitor, blk.stmts_vec);
            return 0;
        default:
            return 0;
    }
}

func generic_process_expr(expr: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> *AstNode {
    var visitor: GenericAstVisitor = generic_ast_visitor_new_process(symtab);
    return generic_ast_visitor_walk_expr(&visitor, expr);
}

func generic_process_stmt_block(stmts: *Vec<*AstNode>, symtab: *HashMap<u64, *TypeInfo>) -> u64 {
    var visitor: GenericAstVisitor = generic_ast_visitor_new_process(symtab);
    return generic_ast_visitor_walk_stmt_block(&visitor, stmts);
}

func generic_process_stmt(stmt: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> u64 {
    var visitor: GenericAstVisitor = generic_ast_visitor_new_process(symtab);
    return generic_ast_visitor_walk_stmt(&visitor, stmt);
}

func compiler_try_resolve_struct_name(name_ptr: u64, name_len: u64) -> CompilerResolvedStructName {
    var result: CompilerResolvedStructName;
    result.found = 0;
    result.resolved_ptr = name_ptr;
    result.resolved_len = name_len;
    result.struct_def = 0;

    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var struct_def: *AstStructDef = get_struct_def(resolved_ptr, resolved_len);
    if (struct_def == 0) {
        var resolved_name: *NameInfo = resolve_name(name_ptr, name_len);
        if (resolved_name != 0) {
            var resolved_def: *AstStructDef = get_struct_def(resolved_name.ptr, resolved_name.len);
            if (resolved_def != 0) {
                resolved_ptr = resolved_name.ptr;
                resolved_len = resolved_name.len;
                struct_def = resolved_def;
            }
        }
    }
    if (struct_def == 0) { return result; }
    result.found = 1;
    result.resolved_ptr = resolved_ptr;
    result.resolved_len = resolved_len;
    result.struct_def = struct_def;
    return result;
}

func compiler_try_resolve_generic_struct_template(name_ptr: u64, name_len: u64) -> *GenericStructTemplate {
    var tpl: *GenericStructTemplate = compiler_find_generic_struct_template_by_name(name_ptr, name_len);
    if (tpl == 0) {
        var resolved_name: *NameInfo = resolve_name(name_ptr, name_len);
        if (resolved_name != 0) {
            tpl = compiler_find_generic_struct_template_by_name(resolved_name.ptr, resolved_name.len);
        }
    }
    return tpl;
}

func compiler_try_resolve_generic_struct_type_instance(name_ptr: u64, name_len: u64, generic_args: *Vec<*GenericArg>, out_name_info: **NameInfo) -> u64 {
    var tpl: *GenericStructTemplate = compiler_try_resolve_generic_struct_template(name_ptr, name_len);
    if (tpl == 0) {
        return 0;
    }
    var bindings: *Vec<*GenericBinding> = generic_build_bindings_for_struct(tpl, generic_args);
    var name_info: *NameInfo = generic_struct_get_or_create_instance(tpl, bindings);
    if (name_info == 0) { return 0; }
    *out_name_info = name_info;
    return 1;
}

func compiler_call_has_named_args(arg_names: *Vec<*NameInfo>) -> u64 {
    if (arg_names == 0) { return 0; }
    var n: u64 = arg_names.len();
    for (var i: u64 = 0; i < n; i++) {
        if (arg_names.get(i) != 0) { return 1; }
    }
    return 0;
}

func compiler_call_named_at(arg_names: *Vec<*NameInfo>, idx: u64) -> *NameInfo {
    if (arg_names == 0) { return 0; }
    if (idx >= arg_names.len()) { return 0; }
    return arg_names.get(idx);
}

func compiler_find_param_index_by_name(params: *Vec<*Param>, params_start: u64, fixed_count: u64, name_ptr: u64, name_len: u64) -> u64 {
    for (var i: u64 = 0; i < fixed_count; i++) {
        var p: *Param = params.get(params_start + i);
        if (p == 0) { continue; }
        if (str_eq(p.name_ptr, p.name_len, name_ptr, name_len) != 0) {
            return i;
        }
    }
    return COMPILER_NOT_FOUND_U64;
}

func compiler_clone_default_expr(expr_u64: u64) -> *AstNode {
    if (expr_u64 == 0) { return 0; }
    return generic_clone_expr((*AstNode)expr_u64, 0);
}

func compiler_call_params_need_normalize(params: *Vec<*Param>, params_start: u64, arg_names: *Vec<*NameInfo>) -> u64 {
    if (compiler_call_has_named_args(arg_names) != 0) { return 1; }
    if (params == 0) { return 0; }
    var param_count: u64 = params.len();
    if (params_start > param_count) { params_start = param_count; }
    if (params_start >= param_count) { return 0; }
    for (var i: u64 = params_start; i < param_count; i++) {
        var p: *Param = params.get(i);
        if (p == 0) { continue; }
        if (p.has_default != 0 || p.is_variadic != 0) { return 1; }
    }
    return 0;
}

func compiler_call_has_variadic_param(params: *Vec<*Param>, param_count: u64, effective_count: u64) -> u64 {
    if (params == 0 || param_count == 0 || effective_count == 0) { return 0; }
    var last_param: *Param = params.get(param_count - 1);
    if (last_param == 0) { return 0; }
    if (last_param.is_variadic == 0) { return 0; }
    return 1;
}

func compiler_call_fill_missing_defaults(call_name_ptr: u64, call_name_len: u64, params: *Vec<*Param>, params_start: u64, fixed_count: u64, out_fixed: *Vec<*AstNode>, assigned: *Vec<u64>) -> u64 {
    for (var fi: u64 = 0; fi < fixed_count; fi++) {
        if (assigned.get(fi) != 0) { continue; }
        var param: *Param = params.get(params_start + fi);
        if (param != 0 && param.has_default != 0) {
            var def_expr: *AstNode = compiler_clone_default_expr(param.default_expr);
            out_fixed.set(fi, compiler_lower_parse_sugar_expr(def_expr));
            assigned.set(fi, 1);
            continue;
        }
        emit_stderr("[ERROR] missing required argument '");
        if (param != 0) { emit_stderr_len(param.name_ptr, param.name_len); }
        emit_stderr("' in call: ");
        emit_stderr_len(call_name_ptr, call_name_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    return 0;
}

func compiler_call_pack_variadic_args(out_fixed: *Vec<*AstNode>, variadic_args: *Vec<*AstNode>) -> *Vec<*AstNode> {
    var out: *Vec<*AstNode> = new Vec<*AstNode>(out_fixed.len() + variadic_args.len() + 1);
    var fixed_n: u64 = out_fixed.len();
    for (var i: u64 = 0; i < fixed_n; i++) {
        out.push(out_fixed.get(i));
    }

    if (variadic_args.len() == 0) {
        // Keep variadic slot deterministic when no extra argument is provided.
        out.push((*AstNode)ast_literal(0));
        return out;
    }

    out.push(variadic_args.get(0));
    var vn: u64 = variadic_args.len();
    for (var vi: u64 = 1; vi < vn; vi++) {
        out.push(variadic_args.get(vi));
    }
    return out;
}

func compiler_normalize_call_args_for_params(call_name_ptr: u64, call_name_len: u64, params: *Vec<*Param>, params_start: u64, args: *Vec<*AstNode>, arg_names: *Vec<*NameInfo>) -> *Vec<*AstNode> {
    var input_args: *Vec<*AstNode> = args;
    if (input_args == 0) { input_args = new Vec<*AstNode>(0); }
    if (params == 0) {
        if (compiler_call_has_named_args(arg_names) != 0) {
            compiler_panic_callsite("named arguments require a resolvable function signature", call_name_ptr, call_name_len);
        }
        return input_args;
    }

    var param_count: u64 = params.len();
    if (params_start > param_count) { params_start = param_count; }
    var effective_count: u64 = param_count - params_start;

    var should_normalize: u64 = compiler_call_params_need_normalize(params, params_start, arg_names);
    if (should_normalize == 0) {
        return input_args;
    }

    var has_variadic: u64 = compiler_call_has_variadic_param(params, param_count, effective_count);

    var fixed_count: u64 = effective_count;
    if (has_variadic != 0 && fixed_count > 0) {
        fixed_count = fixed_count - 1;
    }

    var out_fixed: *Vec<*AstNode> = new Vec<*AstNode>(fixed_count + 2);
    var assigned: *Vec<u64> = new Vec<u64>(fixed_count + 2);
    for (var i: u64 = 0; i < fixed_count; i++) {
        out_fixed.push(0);
        assigned.push(0);
    }
    var variadic_args: *Vec<*AstNode> = new Vec<*AstNode>(4);

    var seen_named: u64 = 0;
    var next_positional: u64 = 0;
    var arg_count: u64 = input_args.len();
    for (var ai: u64 = 0; ai < arg_count; ai++) {
        var arg_expr: *AstNode = input_args.get(ai);
        var arg_name: *NameInfo = compiler_call_named_at(arg_names, ai);
        if (arg_name != 0) {
            seen_named = 1;
            var named_idx: u64 = compiler_find_param_index_by_name(params, params_start, fixed_count, arg_name.ptr, arg_name.len);
            if (named_idx == COMPILER_NOT_FOUND_U64) {
                if (has_variadic != 0) {
                    var variadic_param: *Param = params.get(param_count - 1);
                    if (variadic_param != 0 && str_eq(variadic_param.name_ptr, variadic_param.name_len, arg_name.ptr, arg_name.len) != 0) {
                        emit_stderr("[ERROR] named argument cannot target variadic parameter: ");
                        emit_stderr_len(arg_name.ptr, arg_name.len);
                        emit_stderr("\n");
                        panic("Compiler error");
                    }
                }
                emit_stderr("[ERROR] unknown named argument '");
                emit_stderr_len(arg_name.ptr, arg_name.len);
                emit_stderr("' in call: ");
                emit_stderr_len(call_name_ptr, call_name_len);
                emit_stderr("\n");
                panic("Compiler error");
            }
            if (assigned.get(named_idx) != 0) {
                emit_stderr("[ERROR] duplicate argument for parameter '");
                emit_stderr_len(arg_name.ptr, arg_name.len);
                emit_stderr("' in call: ");
                emit_stderr_len(call_name_ptr, call_name_len);
                emit_stderr("\n");
                panic("Compiler error");
            }
            out_fixed.set(named_idx, arg_expr);
            assigned.set(named_idx, 1);
            continue;
        }

        if (seen_named != 0) {
            compiler_panic_callsite("positional argument cannot follow named arguments in call", call_name_ptr, call_name_len);
        }

        if (next_positional < fixed_count) {
            out_fixed.set(next_positional, arg_expr);
            assigned.set(next_positional, 1);
            next_positional = next_positional + 1;
            continue;
        }

        if (has_variadic == 0) {
            compiler_panic_callsite("too many arguments in call", call_name_ptr, call_name_len);
        }
        variadic_args.push(arg_expr);
    }

    compiler_call_fill_missing_defaults(call_name_ptr, call_name_len, params, params_start, fixed_count, out_fixed, assigned);

    if (has_variadic == 0) {
        return out_fixed;
    }
    return compiler_call_pack_variadic_args(out_fixed, variadic_args);
}

func compiler_name_matches_tail(full_ptr: u64, full_len: u64, target_ptr: u64, target_len: u64) -> u64 {
    if (full_ptr == 0 || full_len == 0 || target_ptr == 0 || target_len == 0) { return 0; }

    var full_n: u64 = full_len;
    var target_n: u64 = target_len;
    var full_u8: []u8 = slice(full_ptr, full_len);
    var target_u8: []u8 = slice(target_ptr, target_len);
    while (full_n > 0 && full_u8[full_n - 1] == 0) { full_n = full_n - 1; }
    while (target_n > 0 && target_u8[target_n - 1] == 0) { target_n = target_n - 1; }
    if (full_n == 0 || target_n == 0) { return 0; }

    if (str_eq(full_ptr, full_n, target_ptr, target_n) != 0) { return 1; }
    if (full_n >= target_n) {
        var suffix_start: u64 = full_n - target_n;
        if (str_eq(full_ptr + suffix_start, target_n, target_ptr, target_n) != 0) {
            return 1;
        }
    }

    if (full_n < target_n + 2) { return 0; }
    for (var i: u64 = 0; i + 1 < full_n; i++) {
        if (full_u8[i] != 95 || full_u8[i + 1] != 95) { continue; }
        var start: u64 = i + 2;
        if (start + target_n != full_n) { continue; }
        if (str_eq(full_ptr + start, target_n, target_ptr, target_n) != 0) {
            return 1;
        }
    }
    return 0;
}

func compiler_find_func_signature_for_call(name_ptr: u64, name_len: u64) -> *AstFunc {
    var fn: *AstFunc = compiler_get_func(name_ptr, name_len);
    if (fn != 0) { return fn; }

    var found: *AstFunc = 0;
    if (g_compiler_ctx.all_funcs != 0) {
        var n: u64 = g_compiler_ctx.all_funcs.len();
        for (var i: u64 = 0; i < n; i++) {
            var cand: *AstFunc = g_compiler_ctx.all_funcs.get(i);
            if (cand == 0) { continue; }
            if (compiler_name_matches_tail(cand.name_ptr, cand.name_len, name_ptr, name_len) == 0) { continue; }
            if (found == 0 || cand.name_len < found.name_len) {
                found = cand;
            }
        }
    }
    if (found != 0) { return found; }

    if (g_compiler_ctx.all_func_sigs != 0) {
        var sn: u64 = g_compiler_ctx.all_func_sigs.len();
        for (var j: u64 = 0; j < sn; j++) {
            var sig: *AstFunc = g_compiler_ctx.all_func_sigs.get(j);
            if (sig == 0) { continue; }
            if (compiler_name_matches_tail(sig.name_ptr, sig.name_len, name_ptr, name_len) == 0) { continue; }
            if (found == 0 || sig.name_len < found.name_len) {
                found = sig;
            }
        }
    }
    return found;
}

func compiler_find_generic_template_for_call(name_ptr: u64, name_len: u64) -> *GenericFuncTemplate {
    var tpl: *GenericFuncTemplate = compiler_find_generic_template_by_name(name_ptr, name_len);
    if (tpl != 0) { return tpl; }
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        tpl = compiler_find_generic_template_by_name(resolved.ptr, resolved.len);
        if (tpl != 0) { return tpl; }
        tpl = compiler_find_generic_template_by_mangled(resolved.ptr, resolved.len);
        if (tpl != 0) { return tpl; }
    }

    var found: *GenericFuncTemplate = 0;
    if (g_compiler_ctx.generic_func_ptrs != 0) {
        var n: u64 = g_compiler_ctx.generic_func_ptrs.len();
        for (var i: u64 = 0; i < n; i++) {
            var cand: *GenericFuncTemplate = g_compiler_ctx.generic_func_ptrs.get(i);
            if (cand == 0) { continue; }
            if (compiler_name_matches_tail(cand.name_ptr, cand.name_len, name_ptr, name_len) == 0 &&
                compiler_name_matches_tail(cand.mangled_ptr, cand.mangled_len, name_ptr, name_len) == 0) {
                continue;
            }
            if (found == 0 || cand.name_len < found.name_len) {
                found = cand;
            }
        }
    }
    return found;
}

func compiler_normalize_direct_call_args(call: *AstCall) -> u64 {
    if (call == 0) { return 0; }
    var fn: *AstFunc = compiler_find_func_signature_for_call(call.name_ptr, call.name_len);
    if (fn == 0) {
        if (compiler_call_has_named_args(call.arg_names_vec) != 0) {
            emit_stderr("[ERROR] named arguments require a known function signature: ");
            emit_stderr_len(call.name_ptr, call.name_len);
            emit_stderr("\n");
            panic("Compiler error");
        }
        return 0;
    }
    call.args_vec = compiler_normalize_call_args_for_params(call.name_ptr, call.name_len, fn.params_vec, 0, call.args_vec, call.arg_names_vec);
    call.arg_names_vec = 0;
    return 0;
}

func compiler_normalize_generic_call_args(gcall: *AstGenericCall) -> u64 {
    if (gcall == 0) { return 0; }
    var tpl: *GenericFuncTemplate = compiler_find_generic_template_for_call(gcall.name_ptr, gcall.name_len);
    if (tpl == 0) {
        if (compiler_call_has_named_args(gcall.arg_names_vec) != 0) {
            emit_stderr("[ERROR] named arguments require a known generic function signature: ");
            emit_stderr_len(gcall.name_ptr, gcall.name_len);
            emit_stderr("\n");
            panic("Compiler error");
        }
        return 0;
    }
    var fn: *AstFunc = tpl.func_def;
    if (fn == 0) { fn = tpl.func_sig; }
    if (fn == 0) {
        emit_stderr("[ERROR] missing generic function signature for call: ");
        emit_stderr_len(gcall.name_ptr, gcall.name_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    gcall.args_vec = compiler_normalize_call_args_for_params(gcall.name_ptr, gcall.name_len, fn.params_vec, 0, gcall.args_vec, gcall.arg_names_vec);
    gcall.arg_names_vec = 0;
    return 0;
}

func compiler_lower_parse_sugar_ctor_call(call: *AstCall) -> *AstNode {
    if (call == 0) { return 0; }
    if (call.origin != AST_CALL_ORIGIN_DIRECT) { return (*AstNode)call; }

    var ctor_struct: CompilerResolvedStructName = compiler_try_resolve_struct_name(call.name_ptr, call.name_len);
    if (ctor_struct.found == 0) {
        return (*AstNode)call;
    }

    var ctor_name: *NameInfo = _compiler_build_constructor_name(ctor_struct.resolved_ptr, ctor_struct.resolved_len);
    var ctor_fn: *AstFunc = compiler_find_func_signature_for_call(ctor_name.ptr, ctor_name.len);
    if (ctor_fn != 0) {
        call.args_vec = compiler_normalize_call_args_for_params(ctor_name.ptr, ctor_name.len, ctor_fn.params_vec, 1, call.args_vec, call.arg_names_vec);
        call.arg_names_vec = 0;
    } else if (compiler_call_has_named_args(call.arg_names_vec) != 0) {
        emit_stderr("[ERROR] named constructor arguments require a known constructor signature: ");
        emit_stderr_len(call.name_ptr, call.name_len);
        emit_stderr("\n");
        panic("Compiler error");
    }

    return (*AstNode)ast_stack_ctor(TYPE_STRUCT, 0, 0, ctor_struct.resolved_ptr, ctor_struct.resolved_len, 0, 0, 0, 0, 0, 0, 0, 0, 0, call.args_vec);
}

func compiler_lower_parse_sugar_generic_ctor_call(gcall: *AstGenericCall) -> *AstNode {
    if (gcall == 0) { return 0; }
    if (gcall.origin != AST_CALL_ORIGIN_DIRECT) { return (*AstNode)gcall; }

    var tpl: *GenericStructTemplate = compiler_try_resolve_generic_struct_template(gcall.name_ptr, gcall.name_len);
    if (tpl == 0) {
        return (*AstNode)gcall;
    }

    var bindings: *Vec<*GenericBinding> = generic_build_bindings_for_struct(tpl, gcall.generic_args_vec);
    var name_info: *NameInfo = generic_struct_get_or_create_instance(tpl, bindings);
    gcall.arg_names_vec = 0;
    return (*AstNode)ast_stack_ctor(TYPE_STRUCT, 0, 0, name_info.ptr, name_info.len, 0, 0, 0, 0, 0, 0, 0, 0, 0, gcall.args_vec);
}

func compiler_lower_parse_sugar_generic_struct_literal(gsl: *AstGenericStructLiteral) -> *AstNode {
    if (gsl == 0) { return 0; }

    var tpl: *GenericStructTemplate = compiler_try_resolve_generic_struct_template(gsl.name_ptr, gsl.name_len);
    if (tpl == 0) {
        emit_stderr("[ERROR] Generic struct template not found: ");
        emit_stderr_len(gsl.name_ptr, gsl.name_len);
        emit_stderr("\n");
        panic("Compiler error");
    }

    var bindings: *Vec<*GenericBinding> = generic_build_bindings_for_struct(tpl, gsl.generic_args_vec);
    var name_info: *NameInfo = generic_struct_get_or_create_instance(tpl, bindings);
    var struct_def: *AstStructDef = get_struct_def(name_info.ptr, name_info.len);
    if (struct_def == 0) {
        emit_stderr("[ERROR] Generic struct def missing\n");
        panic("Compiler error");
    }
    if (struct_def.is_union == 1 && gsl.values_vec != 0 && gsl.values_vec.len() > 1) {
        emit_stderr("[ERROR] union literal accepts at most one initializer\n");
        panic("Compiler error");
    }
    return (*AstNode)ast_struct_literal(struct_def, gsl.values_vec);
}

func compiler_lower_parse_sugar_static_generic_method_call(sgc: *AstStaticGenericCall) -> *AstNode {
    if (sgc == 0) { return 0; }

    var static_struct: CompilerResolvedStructName = compiler_try_resolve_struct_name(sgc.struct_name_ptr, sgc.struct_name_len);
    if (static_struct.found == 0) {
        emit_stderr("[ERROR] static generic method owner type not found: ");
        emit_stderr_len(sgc.struct_name_ptr, sgc.struct_name_len);
        emit_stderr("\n");
        panic("Compiler error");
    }

    var lowered_name: *NameInfo = compiler_build_method_name(static_struct.resolved_ptr, static_struct.resolved_len, sgc.method_ptr, sgc.method_len);
    var lowered_call: *AstGenericCall = ast_generic_call_with_origin_named(lowered_name.ptr, lowered_name.len, sgc.generic_args_vec, sgc.args_vec, sgc.arg_names_vec, AST_CALL_ORIGIN_MEMBER_LOWERED);
    compiler_normalize_generic_call_args(lowered_call);
    return (*AstNode)lowered_call;
}

func compiler_lower_parse_sugar_static_method_call(mc: *AstMethodCall, is_safe: u64) -> *AstNode {
    if (mc == 0 || mc.receiver == 0) { return (*AstNode)mc; }
    if (ast_kind(mc.receiver) != AST_IDENT) { return (*AstNode)mc; }

    var recv_id: *AstIdent = (*AstIdent)mc.receiver;
    var static_recv_struct: CompilerResolvedStructName = compiler_try_resolve_struct_name(recv_id.name_ptr, recv_id.name_len);
    if (static_recv_struct.found == 0) {
        return (*AstNode)mc;
    }

    if (is_safe != 0) {
        emit_stderr("[ERROR] safe navigation is not allowed for static method call\n");
        panic("Compiler error");
    }

    var lowered_name: *NameInfo = compiler_build_method_name(static_recv_struct.resolved_ptr, static_recv_struct.resolved_len, mc.method_ptr, mc.method_len);
    var lowered_call: *AstCall = ast_call_with_origin_named(lowered_name.ptr, lowered_name.len, mc.args_vec, mc.arg_names_vec, AST_CALL_ORIGIN_MEMBER_LOWERED);
    compiler_normalize_direct_call_args(lowered_call);
    return (*AstNode)lowered_call;
}

const COMPILER_AST_WALK_LOWER_PARSE_SUGAR = 1;
const COMPILER_AST_WALK_VALIDATE_DIRECT_IMPL = 2;
const COMPILER_AST_WALK_LOWER_SUPER = 3;
const COMPILER_AST_WALK_FIND_SUPER_CTOR = 4;

struct CompilerAstWalker {
    public mode: u64;
    public owner_ptr: u64;
    public owner_len: u64;
    public super_allowed: u64;
    public found: u64;
}

func compiler_ast_walker_new(mode: u64, owner_ptr: u64, owner_len: u64) -> CompilerAstWalker {
    var walker: CompilerAstWalker;
    walker.mode = mode;
    walker.owner_ptr = owner_ptr;
    walker.owner_len = owner_len;
    walker.super_allowed = 1;
    walker.found = 0;
    return walker;
}

func compiler_ast_walker_walk_args(walker: *CompilerAstWalker, args: *Vec<*AstNode>) -> u64 {
    if (args == 0) { return 0; }
    var n: u64 = args.len();
    for (var i: u64 = 0; i < n; i++) {
        if (walker.mode == COMPILER_AST_WALK_FIND_SUPER_CTOR && walker.found != 0) { return 0; }
        args.set(i, compiler_ast_walker_walk_expr(walker, args.get(i)));
    }
    return 0;
}

func compiler_ast_walker_walk_expr(walker: *CompilerAstWalker, expr: *AstNode) -> *AstNode {
    if (expr == 0) { return 0; }
    if (walker.mode == COMPILER_AST_WALK_FIND_SUPER_CTOR && walker.found != 0) { return expr; }

    var kind: u64 = ast_kind(expr);
    switch (kind) {
        case AST_IDENT:
        case AST_SUPER:
            return expr;
        case AST_CALL:
            var call: *AstCall = (*AstCall)expr;
            if (walker.mode == COMPILER_AST_WALK_VALIDATE_DIRECT_IMPL) {
                compiler_validate_direct_impl_call_name(call.name_ptr, call.name_len, call.origin, walker.owner_ptr, walker.owner_len);
            }
            compiler_ast_walker_walk_args(walker, call.args_vec);
            if (walker.mode == COMPILER_AST_WALK_LOWER_PARSE_SUGAR) {
                var lowered_ctor: *AstNode = compiler_lower_parse_sugar_ctor_call(call);
                if (lowered_ctor != 0 && ast_kind(lowered_ctor) == AST_STACK_CTOR) {
                    return lowered_ctor;
                }
                compiler_normalize_direct_call_args(call);
            }
            return (*AstNode)call;
        case AST_GENERIC_CALL:
            var gcall: *AstGenericCall = (*AstGenericCall)expr;
            if (walker.mode == COMPILER_AST_WALK_VALIDATE_DIRECT_IMPL) {
                compiler_validate_direct_impl_call_name(gcall.name_ptr, gcall.name_len, gcall.origin, walker.owner_ptr, walker.owner_len);
            }
            compiler_ast_walker_walk_args(walker, gcall.args_vec);
            if (walker.mode == COMPILER_AST_WALK_LOWER_PARSE_SUGAR) {
                var lowered_gctor: *AstNode = compiler_lower_parse_sugar_generic_ctor_call(gcall);
                if (lowered_gctor != 0 && ast_kind(lowered_gctor) == AST_STACK_CTOR) {
                    return lowered_gctor;
                }
                compiler_normalize_generic_call_args(gcall);
            }
            return (*AstNode)gcall;
        case AST_GENERIC_STRUCT_LITERAL:
            var gsl: *AstGenericStructLiteral = (*AstGenericStructLiteral)expr;
            compiler_ast_walker_walk_args(walker, gsl.values_vec);
            if (walker.mode == COMPILER_AST_WALK_LOWER_PARSE_SUGAR) {
                return compiler_lower_parse_sugar_generic_struct_literal(gsl);
            }
            return expr;
        case AST_STATIC_GENERIC_CALL:
            var sgc: *AstStaticGenericCall = (*AstStaticGenericCall)expr;
            compiler_ast_walker_walk_args(walker, sgc.args_vec);
            if (walker.mode == COMPILER_AST_WALK_LOWER_PARSE_SUGAR) {
                return compiler_lower_parse_sugar_static_generic_method_call(sgc);
            }
            return expr;
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)expr;
            cp.callee = compiler_ast_walker_walk_expr(walker, cp.callee);
            compiler_ast_walker_walk_args(walker, cp.args_vec);
            return expr;
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)expr;
            bin.left = compiler_ast_walker_walk_expr(walker, bin.left);
            bin.right = compiler_ast_walker_walk_expr(walker, bin.right);
            return expr;
        case AST_UNARY:
            var un: *AstUnary = (*AstUnary)expr;
            un.operand = compiler_ast_walker_walk_expr(walker, un.operand);
            return expr;
        case AST_ADDR_OF:
            var ao: *AstAddrOf = (*AstAddrOf)expr;
            ao.operand = compiler_ast_walker_walk_expr(walker, ao.operand);
            return expr;
        case AST_DEREF:
            var dr: *AstDeref = (*AstDeref)expr;
            dr.operand = compiler_ast_walker_walk_expr(walker, dr.operand);
            return expr;
        case AST_DEREF8:
            var dr8: *AstDeref8 = (*AstDeref8)expr;
            dr8.operand = compiler_ast_walker_walk_expr(walker, dr8.operand);
            return expr;
        case AST_CAST:
            var cs: *AstCast = (*AstCast)expr;
            cs.expr = compiler_ast_walker_walk_expr(walker, cs.expr);
            return expr;
        case AST_MEMBER_ACCESS:
            if (walker.mode == COMPILER_AST_WALK_LOWER_SUPER) {
                return compiler_lower_super_member_access_expr((*AstMemberAccess)expr, walker.owner_ptr, walker.owner_len, walker.super_allowed, 0);
            }
            var ma: *AstMemberAccess = (*AstMemberAccess)expr;
            ma.object = compiler_ast_walker_walk_expr(walker, ma.object);
            return expr;
        case AST_SAFE_MEMBER_ACCESS:
            if (walker.mode == COMPILER_AST_WALK_LOWER_SUPER) {
                return compiler_lower_super_member_access_expr((*AstMemberAccess)expr, walker.owner_ptr, walker.owner_len, walker.super_allowed, 1);
            }
            var sma: *AstMemberAccess = (*AstMemberAccess)expr;
            sma.object = compiler_ast_walker_walk_expr(walker, sma.object);
            return expr;
        case AST_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)expr;
            if (walker.mode == COMPILER_AST_WALK_FIND_SUPER_CTOR) {
                if (compiler_is_super_expr(mc.receiver) != 0 &&
                    compiler_is_constructor_name(mc.method_ptr, mc.method_len) != 0) {
                    walker.found = 1;
                    return expr;
                }
            }
            if (walker.mode == COMPILER_AST_WALK_LOWER_SUPER) {
                return compiler_lower_super_method_call_expr(mc, walker.owner_ptr, walker.owner_len, walker.super_allowed, 0);
            }
            mc.receiver = compiler_ast_walker_walk_expr(walker, mc.receiver);
            compiler_ast_walker_walk_args(walker, mc.args_vec);
            if (walker.mode == COMPILER_AST_WALK_LOWER_PARSE_SUGAR) {
                var lowered_mc: *AstNode = compiler_lower_parse_sugar_static_method_call(mc, 0);
                if (lowered_mc != (*AstNode)mc) { return lowered_mc; }
            }
            return expr;
        case AST_SAFE_METHOD_CALL:
            var smc: *AstMethodCall = (*AstMethodCall)expr;
            if (walker.mode == COMPILER_AST_WALK_FIND_SUPER_CTOR) {
                if (compiler_is_super_expr(smc.receiver) != 0 &&
                    compiler_is_constructor_name(smc.method_ptr, smc.method_len) != 0) {
                    walker.found = 1;
                    return expr;
                }
            }
            if (walker.mode == COMPILER_AST_WALK_LOWER_SUPER) {
                return compiler_lower_super_method_call_expr(smc, walker.owner_ptr, walker.owner_len, walker.super_allowed, 1);
            }
            smc.receiver = compiler_ast_walker_walk_expr(walker, smc.receiver);
            compiler_ast_walker_walk_args(walker, smc.args_vec);
            if (walker.mode == COMPILER_AST_WALK_LOWER_PARSE_SUGAR) {
                var lowered_smc: *AstNode = compiler_lower_parse_sugar_static_method_call(smc, 1);
                if (lowered_smc != (*AstNode)smc) { return lowered_smc; }
            }
            return expr;
        case AST_INDEX:
            var ix: *AstIndex = (*AstIndex)expr;
            ix.base = compiler_ast_walker_walk_expr(walker, ix.base);
            ix.index = compiler_ast_walker_walk_expr(walker, ix.index);
            return expr;
        case AST_SLICE:
            var sl: *AstSlice = (*AstSlice)expr;
            sl.ptr_expr = compiler_ast_walker_walk_expr(walker, sl.ptr_expr);
            sl.len_expr = compiler_ast_walker_walk_expr(walker, sl.len_expr);
            return expr;
        case AST_TRY:
            var tr: *AstTry = (*AstTry)expr;
            tr.operand = compiler_ast_walker_walk_expr(walker, tr.operand);
            return expr;
        case AST_SIZEOF_EXPR:
            var se: *AstSizeofExpr = (*AstSizeofExpr)expr;
            se.expr = compiler_ast_walker_walk_expr(walker, se.expr);
            return expr;
        case AST_STRUCT_LITERAL:
            var lit: *AstStructLiteral = (*AstStructLiteral)expr;
            compiler_ast_walker_walk_args(walker, lit.values_vec);
            return expr;
        case AST_NEW:
            var nw: *AstNew = (*AstNew)expr;
            nw.literal_expr = compiler_ast_walker_walk_expr(walker, nw.literal_expr);
            compiler_ast_walker_walk_args(walker, nw.ctor_args_vec);
            return expr;
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)expr;
            compiler_ast_walker_walk_args(walker, sc.ctor_args_vec);
            return expr;
        default:
            return expr;
    }
}

func compiler_ast_walker_walk_stmt(walker: *CompilerAstWalker, stmt: *AstNode) -> u64 {
    if (stmt == 0) { return 0; }
    if (walker.mode == COMPILER_AST_WALK_FIND_SUPER_CTOR && walker.found != 0) { return 0; }

    var kind: u64 = ast_kind(stmt);
    switch (kind) {
        case AST_RETURN:
            var r: *AstReturn = (*AstReturn)stmt;
            r.expr = compiler_ast_walker_walk_expr(walker, r.expr);
            break;
        case AST_VAR_DECL:
            var vd: *AstVarDecl = (*AstVarDecl)stmt;
            vd.init_expr = compiler_ast_walker_walk_expr(walker, vd.init_expr);
            break;
        case AST_ASSIGN:
            var asn: *AstAssign = (*AstAssign)stmt;
            asn.target = compiler_ast_walker_walk_expr(walker, asn.target);
            asn.value = compiler_ast_walker_walk_expr(walker, asn.value);
            break;
        case AST_EXPR_STMT:
            var es: *AstExprStmt = (*AstExprStmt)stmt;
            es.expr = compiler_ast_walker_walk_expr(walker, es.expr);
            break;
        case AST_IF:
            var ifs: *AstIf = (*AstIf)stmt;
            ifs.cond = compiler_ast_walker_walk_expr(walker, ifs.cond);
            compiler_ast_walker_walk_stmt(walker, ifs.then_block);
            compiler_ast_walker_walk_stmt(walker, ifs.else_block);
            break;
        case AST_WHILE:
            var wl: *AstWhile = (*AstWhile)stmt;
            wl.cond = compiler_ast_walker_walk_expr(walker, wl.cond);
            compiler_ast_walker_walk_stmt(walker, wl.body);
            break;
        case AST_FOR:
            var fr: *AstFor = (*AstFor)stmt;
            compiler_ast_walker_walk_stmt(walker, fr.init);
            fr.cond = compiler_ast_walker_walk_expr(walker, fr.cond);
            fr.update = compiler_ast_walker_walk_expr(walker, fr.update);
            compiler_ast_walker_walk_stmt(walker, fr.body);
            break;
        case AST_SWITCH:
        case AST_MATCH:
            var sw: *AstSwitch = (*AstSwitch)stmt;
            sw.expr = compiler_ast_walker_walk_expr(walker, sw.expr);
            if (sw.cases_vec != 0) {
                var cn: u64 = sw.cases_vec.len();
                for (var ci: u64 = 0; ci < cn; ci++) {
                    compiler_ast_walker_walk_stmt(walker, sw.cases_vec.get(ci));
                }
            }
            break;
        case AST_CASE:
            var cs: *AstCase = (*AstCase)stmt;
            cs.value = compiler_ast_walker_walk_expr(walker, cs.value);
            compiler_ast_walker_walk_stmt(walker, cs.body);
            break;
        case AST_BLOCK:
            var blk: *AstBlock = (*AstBlock)stmt;
            if (blk.stmts_vec != 0) {
                var n: u64 = blk.stmts_vec.len();
                for (var i: u64 = 0; i < n; i++) {
                    compiler_ast_walker_walk_stmt(walker, blk.stmts_vec.get(i));
                }
            }
            break;
        case AST_DEFER:
            var df: *AstDefer = (*AstDefer)stmt;
            compiler_ast_walker_walk_stmt(walker, df.stmt);
            break;
        case AST_DELETE:
            var dl: *AstDelete = (*AstDelete)stmt;
            dl.expr = compiler_ast_walker_walk_expr(walker, dl.expr);
            break;
        default:
            break;
    }
    return 0;
}

func compiler_lower_parse_sugar_expr(expr: *AstNode) -> *AstNode {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_LOWER_PARSE_SUGAR, 0, 0);
    return compiler_ast_walker_walk_expr(&walker, expr);
}

func compiler_lower_parse_sugar_stmt(stmt: *AstNode) -> u64 {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_LOWER_PARSE_SUGAR, 0, 0);
    return compiler_ast_walker_walk_stmt(&walker, stmt);
}

func compiler_lower_parse_sugar() -> u64 {
    if (g_compiler_ctx.all_funcs != 0) {
        var fn_count: u64 = g_compiler_ctx.all_funcs.len();
        for (var i: u64 = 0; i < fn_count; i++) {
            var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
            if (fn == 0 || fn.body == 0) { continue; }
            compiler_lower_parse_sugar_stmt(fn.body);
        }
    }

    if (g_compiler_ctx.all_globals != 0) {
        var gn: u64 = g_compiler_ctx.all_globals.len();
        for (var gi: u64 = 0; gi < gn; gi++) {
            var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(gi);
            if (ginfo == 0 || ginfo.init_expr == 0) { continue; }
            ginfo.init_expr = (u64)compiler_lower_parse_sugar_expr((*AstNode)ginfo.init_expr);
        }
    }
    return 0;
}

func compiler_set_global_init_none(ginfo: *GlobalInfo) -> u64 {
    if (ginfo == 0) { return 0; }
    ginfo.init_kind = GLOBAL_INIT_NONE;
    ginfo.init_value = 0;
    ginfo.init_name_ptr = 0;
    ginfo.init_name_len = 0;
    return 0;
}

func compiler_set_global_init_value(ginfo: *GlobalInfo, value: u64) -> u64 {
    if (ginfo == 0) { return 0; }
    ginfo.init_kind = GLOBAL_INIT_VALUE;
    ginfo.init_value = value;
    ginfo.init_name_ptr = 0;
    ginfo.init_name_len = 0;
    return 0;
}

func compiler_set_global_init_const_name(ginfo: *GlobalInfo, name_ptr: u64, name_len: u64) -> u64 {
    if (ginfo == 0) { return 0; }
    ginfo.init_kind = GLOBAL_INIT_CONST;
    ginfo.init_value = 0;
    ginfo.init_name_ptr = name_ptr;
    ginfo.init_name_len = name_len;
    return 0;
}

func compiler_set_global_init_expr(ginfo: *GlobalInfo) -> u64 {
    if (ginfo == 0) { return 0; }
    ginfo.init_kind = GLOBAL_INIT_EXPR;
    ginfo.init_value = 0;
    ginfo.init_name_ptr = 0;
    ginfo.init_name_len = 0;
    return 0;
}

func compiler_set_global_init_runtime(ginfo: *GlobalInfo) -> u64 {
    if (ginfo == 0) { return 0; }
    ginfo.init_kind = GLOBAL_INIT_RUNTIME;
    ginfo.init_value = 0;
    ginfo.init_name_ptr = 0;
    ginfo.init_name_len = 0;
    return 0;
}

func compiler_finalize_single_global_init_kind(ginfo: *GlobalInfo) -> u64 {
    if (ginfo == 0 || ginfo.init_expr == 0) {
        compiler_set_global_init_none(ginfo);
        return 0;
    }

    var expr: *AstNode = (*AstNode)ginfo.init_expr;
    var kind: u64 = ast_kind(expr);

    if (kind == AST_GENERIC_STRUCT_LITERAL) {
        var lowered: *AstNode = compiler_lower_parse_sugar_generic_struct_literal((*AstGenericStructLiteral)expr);
        ginfo.init_expr = (u64)lowered;
        expr = lowered;
        kind = ast_kind(expr);
    }

    if (kind == AST_LITERAL) {
        var lit: *AstLiteral = (*AstLiteral)expr;
        compiler_set_global_init_value(ginfo, lit.value);
        return 0;
    }

    if (kind == AST_IDENT) {
        var id: *AstIdent = (*AstIdent)expr;
        var const_res: *ConstResult = (*ConstResult)compiler_find_const(id.name_ptr, id.name_len);
        if (const_res != 0 && const_res.found != 0) {
            compiler_set_global_init_value(ginfo, const_res.value);
        } else {
            compiler_set_global_init_const_name(ginfo, id.name_ptr, id.name_len);
        }
        return 0;
    }

    if (kind == AST_STRUCT_LITERAL) {
        if (ginfo.typeinfo_ptr == 0 || ginfo.typeinfo_ptr.type_kind != TYPE_STRUCT || ginfo.typeinfo_ptr.ptr_depth != 0) {
            emit_stderr("[ERROR] Global struct literal requires struct type\n");
            panic("Compiler error");
        }
        compiler_set_global_init_expr(ginfo);
        return 0;
    }

    if (kind == AST_CALL || kind == AST_METHOD_CALL || kind == AST_CALL_PTR || kind == AST_GENERIC_CALL || kind == AST_STATIC_GENERIC_CALL || kind == AST_NEW || kind == AST_STACK_CTOR) {
        compiler_set_global_init_runtime(ginfo);
        return 0;
    }

    emit_stderr("[ERROR] Unsupported global init expression\n");
    panic("Compiler error");
    return 0;
}

func compiler_finalize_global_init_kinds() -> u64 {
    if (g_compiler_ctx.all_globals == 0) { return 0; }
    var n: u64 = g_compiler_ctx.all_globals.len();
    for (var i: u64 = 0; i < n; i++) {
        compiler_finalize_single_global_init_kind(g_compiler_ctx.all_globals.get(i));
    }
    return 0;
}

func compiler_validate_direct_impl_call_name(name_ptr: u64, name_len: u64, origin: u64, owner_ptr: u64, owner_len: u64) -> u64 {
    if (origin != AST_CALL_ORIGIN_DIRECT) { return 0; }
    if (compiler_is_impl_method(name_ptr, name_len) == 0) { return 0; }
    if (owner_ptr != 0 && owner_len != 0) { return 0; }
    emit_stderr("[ERROR] Direct call to impl-lowered method is not allowed: ");
    emit_stderr_len(name_ptr, name_len);
    emit_stderr("\n");
    panic("Compiler error");
    return 0;
}

func compiler_validate_direct_impl_calls_expr(expr: *AstNode, owner_ptr: u64, owner_len: u64) -> u64 {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_VALIDATE_DIRECT_IMPL, owner_ptr, owner_len);
    compiler_ast_walker_walk_expr(&walker, expr);
    return 0;
}

func compiler_validate_direct_impl_calls_stmt(stmt: *AstNode, owner_ptr: u64, owner_len: u64) -> u64 {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_VALIDATE_DIRECT_IMPL, owner_ptr, owner_len);
    return compiler_ast_walker_walk_stmt(&walker, stmt);
}

func compiler_validate_direct_impl_calls() -> u64 {
    if (g_compiler_ctx.all_funcs != 0) {
        var fn_count: u64 = g_compiler_ctx.all_funcs.len();
        for (var i: u64 = 0; i < fn_count; i++) {
            var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
            if (fn == 0 || fn.body == 0) { continue; }
            var owner_info: *NameInfo = compiler_get_impl_method_owner(fn.name_ptr, fn.name_len);
            var owner_ptr: u64 = 0;
            var owner_len: u64 = 0;
            if (owner_info != 0) {
                owner_ptr = owner_info.ptr;
                owner_len = owner_info.len;
            }
            compiler_validate_direct_impl_calls_stmt(fn.body, owner_ptr, owner_len);
        }
    }

    if (g_compiler_ctx.all_globals != 0) {
        var gn: u64 = g_compiler_ctx.all_globals.len();
        for (var gi: u64 = 0; gi < gn; gi++) {
            var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(gi);
            if (ginfo == 0 || ginfo.init_expr == 0) { continue; }
            compiler_validate_direct_impl_calls_expr((*AstNode)ginfo.init_expr, 0, 0);
        }
    }
    return 0;
}

func compiler_is_super_expr(expr: *AstNode) -> u64 {
    if (expr == 0) { return 0; }
    var kind: u64 = ast_kind(expr);
    if (kind == AST_SUPER) { return 1; }
    if (kind != AST_IDENT) { return 0; }
    var id: *AstIdent = (*AstIdent)expr;
    if (str_eq(id.name_ptr, id.name_len, "super", 5) != 0) { return 1; }
    return 0;
}

func compiler_super_require_member_form() -> u64 {
    emit_stderr("[ERROR] 'super' must be followed by '.' and a member name\n");
    panic("Compiler error");
    return 0;
}

func compiler_super_resolve_parent(owner_ptr: u64, owner_len: u64, super_allowed: u64) -> CompilerResolvedParent {
    var result: CompilerResolvedParent;
    result.parent_ptr = 0;
    result.parent_len = 0;
    result.parent_def = 0;

    if (owner_ptr == 0 || owner_len == 0) {
        emit_stderr("[ERROR] 'super' is only allowed inside impl methods\n");
        panic("Compiler error");
    }
    if (super_allowed == 0) {
        emit_stderr("[ERROR] 'super' is not allowed in static methods\n");
        panic("Compiler error");
    }

    var owner_def: *AstStructDef = get_struct_def(owner_ptr, owner_len);
    if (owner_def == 0) {
        emit_stderr("[ERROR] owner struct for super not found: ");
        emit_stderr_len(owner_ptr, owner_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    if (owner_def.parents_vec == 0 || owner_def.parents_vec.len() == 0) {
        emit_stderr("[ERROR] 'super' requires a parent struct\n");
        panic("Compiler error");
    }
    if (owner_def.parents_vec.len() != 1) {
        emit_stderr("[ERROR] ambiguous 'super' with multiple parents; use self.<Parent>member\n");
        panic("Compiler error");
    }

    var parent_desc: *ParentDesc = owner_def.parents_vec.get(0);
    var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
    result.parent_ptr = parent_def.name_ptr;
    result.parent_len = parent_def.name_len;
    result.parent_def = parent_def;
    return result;
}

func compiler_super_check_access(owner_ptr: u64, owner_len: u64, member_owner_ptr: u64, member_owner_len: u64, access: u64, member_ptr: u64, member_len: u64, kind_msg: u64) -> u64 {
    if (compiler_can_access_member_from(owner_ptr, owner_len, member_owner_ptr, member_owner_len, access) != 0) {
        return 1;
    }
    emit_stderr("[ERROR] super ");
    emit_stderr(kind_msg);
    emit_stderr(" access denied: ");
    emit_stderr_len(member_owner_ptr, member_owner_len);
    emit_stderr(".");
    emit_stderr_len(member_ptr, member_len);
    emit_stderr("\n");
    panic("Compiler error");
    return 0;
}

func compiler_quick_infer_super_arg_type(expr: *AstNode) -> *TypeInfo {
    if (expr == 0) { return generic_type_unknown(); }
    var kind: u64 = ast_kind(expr);
    switch (kind) {
        case AST_LITERAL:
            // Integer literal defaults are context-sensitive in overload resolution.
            // Keep this unknown in super-lowering and rely on arity fallback unless
            // caller provides an explicit cast.
            return generic_type_unknown();
        case AST_FLOAT:
            return generic_type_f64();
        case AST_STRING:
            return generic_type_u8_ptr();
        case AST_CAST:
            var c: *AstCast = (*AstCast)expr;
            return generic_make_typeinfo_from_fields(c.target_type, c.target_ptr_depth, c.target_is_tagged, c.struct_name_ptr, c.struct_name_len, c.tag_layout_ptr, c.tag_layout_len, 0, 0, 0, 0, 0, 0);
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)expr;
            return generic_make_typeinfo_from_fields(sc.type_kind, sc.ptr_depth, sc.is_tagged, sc.struct_name_ptr, sc.struct_name_len, sc.tag_layout_ptr, sc.tag_layout_len, sc.elem_type_kind, sc.elem_ptr_depth, sc.array_len, sc.array_len_is_param, sc.array_len_param_ptr, sc.array_len_param_len);
        case AST_NEW:
            var nw: *AstNew = (*AstNew)expr;
            return generic_make_typeinfo_from_fields(TYPE_STRUCT, 1, 0, nw.struct_name_ptr, nw.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
        default:
            return generic_type_unknown();
    }
}

func compiler_collect_super_arg_types(args: *Vec<*AstNode>) -> *Vec<*TypeInfo> {
    if (args == 0) { return new Vec<*TypeInfo>(0); }
    var n: u64 = args.len();
    var out: *Vec<*TypeInfo> = new Vec<*TypeInfo>(n);
    for (var i: u64 = 0; i < n; i++) {
        out.push(compiler_quick_infer_super_arg_type(args.get(i)));
    }
    return out;
}

func compiler_super_has_specific_arg_types(arg_types: *Vec<*TypeInfo>) -> u64 {
    if (arg_types == 0) { return 0; }
    var n: u64 = arg_types.len();
    for (var i: u64 = 0; i < n; i++) {
        var ti: *TypeInfo = arg_types.get(i);
        if (ti == 0) { continue; }
        if (ti.type_kind != TYPE_VOID) { return 1; }
    }
    return 0;
}

func compiler_lower_super_member_access_expr(ma: *AstMemberAccess, owner_ptr: u64, owner_len: u64, super_allowed: u64, is_safe: u64) -> *AstNode {
    if (compiler_is_super_expr(ma.object) == 0) {
        ma.object = compiler_lower_super_expr(ma.object, owner_ptr, owner_len, super_allowed);
        return (*AstNode)ma;
    }

    if (is_safe != 0) {
        emit_stderr("[ERROR] safe navigation is not allowed with super\n");
        panic("Compiler error");
    }
    if (ma.parent_ptr != 0) {
        emit_stderr("[ERROR] super does not allow explicit parent scope; use super.member\n");
        panic("Compiler error");
    }

    var resolved_parent: CompilerResolvedParent = compiler_super_resolve_parent(owner_ptr, owner_len, super_allowed);
    var parent_ptr: u64 = resolved_parent.parent_ptr;
    var parent_len: u64 = resolved_parent.parent_len;
    var parent_def: *AstStructDef = resolved_parent.parent_def;

    var field_desc: *FieldDesc = _compiler_find_field_desc_unscoped(parent_def, ma.member_ptr, ma.member_len, 0);
    if (field_desc == 0) {
        emit_stderr("[ERROR] super field not found: ");
        emit_stderr_len(parent_ptr, parent_len);
        emit_stderr(".");
        emit_stderr_len(ma.member_ptr, ma.member_len);
        emit_stderr("\n");
        panic("Compiler error");
    }

    compiler_super_check_access(owner_ptr, owner_len, field_desc.owner_struct_ptr, field_desc.owner_struct_len, field_desc.access, ma.member_ptr, ma.member_len, "field");
    return (*AstNode)ast_member_access_scoped((*AstNode)ast_ident("self", 4), parent_ptr, parent_len, ma.member_ptr, ma.member_len);
}

func compiler_lower_super_method_call_expr(mc: *AstMethodCall, owner_ptr: u64, owner_len: u64, super_allowed: u64, is_safe: u64) -> *AstNode {
    var temp_walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_LOWER_SUPER, owner_ptr, owner_len);
    temp_walker.super_allowed = super_allowed;
    compiler_ast_walker_walk_args(&temp_walker, mc.args_vec);
    if (compiler_is_super_expr(mc.receiver) == 0) {
        mc.receiver = compiler_lower_super_expr(mc.receiver, owner_ptr, owner_len, super_allowed);
        return (*AstNode)mc;
    }

    if (is_safe != 0) {
        emit_stderr("[ERROR] safe navigation is not allowed with super\n");
        panic("Compiler error");
    }

    var resolved_parent2: CompilerResolvedParent = compiler_super_resolve_parent(owner_ptr, owner_len, super_allowed);
    var parent_ptr: u64 = resolved_parent2.parent_ptr;
    var parent_len: u64 = resolved_parent2.parent_len;
    var parent_def: *AstStructDef = resolved_parent2.parent_def;

    var arg_count_hint: u64 = 0;
    if (mc.args_vec != 0) { arg_count_hint = mc.args_vec.len(); }
    var arg_types: *Vec<*TypeInfo> = compiler_collect_super_arg_types(mc.args_vec);
    var typed_arg_types: *Vec<*TypeInfo> = 0;
    if (compiler_super_has_specific_arg_types(arg_types) != 0) {
        typed_arg_types = arg_types;
    }
    var resolved_call: CompilerMethodResolveResult = compiler_resolve_method_overload_with_count_fallback(parent_ptr, parent_len, mc.method_ptr, mc.method_len, typed_arg_types, arg_count_hint);
    var member_lookup: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
    if (resolved_call.found != 0 && resolved_call.fn != 0) {
        member_lookup.found = 1;
        member_lookup.owner_ptr = resolved_call.owner_ptr;
        member_lookup.owner_len = resolved_call.owner_len;
        member_lookup.access = resolved_call.access;
        member_lookup.sig = resolved_call.fn;
    } else {
        member_lookup = compiler_find_method_decl_in_hierarchy(parent_ptr, parent_len, mc.method_ptr, mc.method_len);
    }
    if (member_lookup.found == 0) {
        emit_stderr("[ERROR] super method not found: ");
        emit_stderr_len(parent_ptr, parent_len);
        emit_stderr(".");
        emit_stderr_len(mc.method_ptr, mc.method_len);
        emit_stderr("\n");
        panic("Compiler error");
    }

    compiler_super_check_access(owner_ptr, owner_len, member_lookup.owner_ptr, member_lookup.owner_len, member_lookup.access, mc.method_ptr, mc.method_len, "method");
    var member_owner_ptr: u64 = member_lookup.owner_ptr;
    var member_owner_len: u64 = member_lookup.owner_len;
    if (member_owner_ptr == 0 || member_owner_len == 0) {
        member_owner_ptr = parent_ptr;
        member_owner_len = parent_len;
    }

    var lowered_name: *NameInfo = 0;
    if (resolved_call.found != 0 && resolved_call.fn != 0) {
        lowered_name = new NameInfo{resolved_call.fn.name_ptr, resolved_call.fn.name_len};
    } else {
        lowered_name = compiler_build_method_name(member_owner_ptr, member_owner_len, mc.method_ptr, mc.method_len);
    }
    var lowered_args: *Vec<*AstNode> = new Vec<*AstNode>(mc.args_vec.?len() + 1);
    lowered_args.push((*AstNode)ast_ident("self", 4));
    var arg_count: u64 = mc.args_vec.?len();
    for (var i: u64 = 0; i < arg_count; i++) {
        lowered_args.push(mc.args_vec.get(i));
    }
    return (*AstNode)ast_call_with_origin(lowered_name.ptr, lowered_name.len, lowered_args, AST_CALL_ORIGIN_MEMBER_LOWERED);
}

func compiler_lower_super_expr(expr: *AstNode, owner_ptr: u64, owner_len: u64, super_allowed: u64) -> *AstNode {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_LOWER_SUPER, owner_ptr, owner_len);
    walker.super_allowed = super_allowed;
    return compiler_ast_walker_walk_expr(&walker, expr);
}

func compiler_lower_super_stmt(stmt: *AstNode, owner_ptr: u64, owner_len: u64, super_allowed: u64) -> u64 {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_LOWER_SUPER, owner_ptr, owner_len);
    walker.super_allowed = super_allowed;
    return compiler_ast_walker_walk_stmt(&walker, stmt);
}

func compiler_resolve_super_references() -> u64 {
    if (g_compiler_ctx.all_funcs != 0) {
        var fn_count: u64 = g_compiler_ctx.all_funcs.len();
        for (var i: u64 = 0; i < fn_count; i++) {
            var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
            if (fn == 0 || fn.body == 0) { continue; }
            var super_allowed: u64 = 0;
            if (compiler_method_param_start_index(fn) != 0) { super_allowed = 1; }
            var owner_info: *NameInfo = compiler_get_impl_method_owner(fn.name_ptr, fn.name_len);
            var owner_ptr: u64 = 0;
            var owner_len: u64 = 0;
            if (owner_info != 0) {
                owner_ptr = owner_info.ptr;
                owner_len = owner_info.len;
            }
            compiler_lower_super_stmt(fn.body, owner_ptr, owner_len, super_allowed);
        }
    }

    if (g_compiler_ctx.all_globals != 0) {
        var gn: u64 = g_compiler_ctx.all_globals.len();
        for (var gi: u64 = 0; gi < gn; gi++) {
            var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(gi);
            if (ginfo == 0 || ginfo.init_expr == 0) { continue; }
            ginfo.init_expr = (u64)compiler_lower_super_expr((*AstNode)ginfo.init_expr, 0, 0, 0);
        }
    }
    return 0;
}

func compiler_is_generic_template(fn: *AstFunc) -> u64 {
    if (fn == 0) { return false; }
    if (compiler_is_generic_func_ptr(fn) != 0) { return true; }
    if (fn.ret_type == TYPE_GENERIC) { return true; }

    var params: *Vec<*Param> = fn.params_vec;
    if (params == 0) { return false; }

    var n: u64 = params.len();
    for (var i: u64 = 0; i < n; i++) {
        var p: *Param = params.get(i);
        if (p.type_kind == TYPE_GENERIC) { return true; }
        if (p.elem_type_kind == TYPE_GENERIC) { return true; }
        if (p.array_len_is_param != 0) { return true; }
    }
    return false;
}

func compiler_monomorphize_generics_funcs() -> u64 {
    if (g_compiler_ctx.all_funcs == 0) { return 0; }
    for (var i: u64 = 0; i < g_compiler_ctx.all_funcs.len(); i++) {
        var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
        if (compiler_is_generic_template(fn) != 0) { continue; }
        set_current_module_for_func(fn.name_ptr, fn.name_len);
        var symtab: *HashMap<u64, *TypeInfo> = generic_build_symtab_for_func(fn);
        generic_process_stmt(fn.body, symtab);
    }
    return 0;
}

func compiler_monomorphize_generics_globals() -> u64 {
    if (g_compiler_ctx.all_globals == 0) { return 0; }
    var gn: u64 = g_compiler_ctx.all_globals.len();
    for (var gi: u64 = 0; gi < gn; gi++) {
        var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(gi);
        if (ginfo == 0 || ginfo.init_expr == 0) { continue; }
        set_current_module_for_global(ginfo.name_ptr, ginfo.name_len);
        var gsymtab: *HashMap<u64, *TypeInfo> = new HashMap<u64, *TypeInfo>(64);
        var init_node: *AstNode = (*AstNode)ginfo.init_expr;
        var new_init: *AstNode = generic_process_expr(init_node, gsymtab);
        ginfo.init_expr = (u64)new_init;
    }
    return 0;
}

func compiler_filter_out_generic_template_funcs() -> u64 {
    if (g_compiler_ctx.all_funcs == 0) { return 0; }
    var filtered_funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(g_compiler_ctx.all_funcs.len());
    var total_funcs: u64 = g_compiler_ctx.all_funcs.len();
    for (var fi: u64 = 0; fi < total_funcs; fi++) {
        var fn2: *AstFunc = g_compiler_ctx.all_funcs.get(fi);
        if (compiler_is_generic_template(fn2) != 0) { continue; }
        filtered_funcs.push(fn2);
    }
    g_compiler_ctx.all_funcs = filtered_funcs;
    return 0;
}

func compiler_monomorphize_generics() -> u64 {
    if (g_compiler_ctx.generic_func_ptrs == 0 || g_compiler_ctx.generic_func_ptrs.len() == 0) {
        return 0;
    }
    compiler_monomorphize_generics_funcs();
    compiler_monomorphize_generics_globals();
    compiler_filter_out_generic_template_funcs();
    return 0;
}

// ============================================
// Driver helpers
// ============================================

func compiler_has_runtime_global_init() -> u64 {
    if (g_compiler_ctx.all_globals == 0) { return false; }
    var n: u64 = g_compiler_ctx.all_globals.len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(i);
        if (ginfo.init_kind == GLOBAL_INIT_RUNTIME) { return true; }
    }
    return false;
}

func _compiler_make_self_param(struct_name_ptr: u64, struct_name_len: u64) -> *Param {
    var p: *Param = new Param();
    p.set_as_self_param(struct_name_ptr, struct_name_len);
    return p;
}

func _compiler_build_constructor_name(struct_name_ptr: u64, struct_name_len: u64) -> *NameInfo {
    var method_ptr: u64 = (u64)"constructor";
    var method_len: u64 = 11;
    return compiler_build_method_name(struct_name_ptr, struct_name_len, method_ptr, method_len);
}

func compiler_build_method_name(struct_name_ptr: u64, struct_name_len: u64, method_ptr: u64, method_len: u64) -> *NameInfo {
    var base_len: u64 = compiler_find_generic_suffix_index(struct_name_ptr, struct_name_len);
    var suffix_len: u64 = struct_name_len - base_len;
    return compiler_build_method_name_base(struct_name_ptr, base_len, method_ptr, method_len, suffix_len);
}

func compiler_build_method_name_base(struct_name_ptr: u64, base_len: u64, method_ptr: u64, method_len: u64, suffix_len: u64) -> *NameInfo {
    return module_util_build_joined_name_with_suffix(struct_name_ptr, base_len, method_ptr, method_len, struct_name_ptr + base_len, suffix_len);
}

// ============================================
// Trait Helpers and VTable Generation
// ============================================

func compiler_is_vptr_field_name(name_ptr: u64, name_len: u64) -> u64 {
    if (name_len < 7) { return false; }
    if (str_eq(name_ptr, 7, "__vptr_", 7) == 0) { return false; }
    return true;
}

func compiler_build_vptr_field_name(trait_ptr: u64, trait_len: u64) -> *NameInfo {
    return module_util_name_concat2("__vptr_", 7, trait_ptr, trait_len);
}

func compiler_downcast_check_info_none() -> CompilerDowncastCheckInfo {
    var info: CompilerDowncastCheckInfo;
    info.found = 0;
    info.src_vptr_offset = 0;
    info.trait_ptr = 0;
    info.trait_len = 0;
    info.expected_vtable_ptr = 0;
    info.expected_vtable_len = 0;
    return info;
}

func compiler_is_strict_downcast(src_struct_ptr: u64, src_struct_len: u64, target_struct_ptr: u64, target_struct_len: u64) -> u64 {
    if (src_struct_ptr == 0 || src_struct_len == 0 || target_struct_ptr == 0 || target_struct_len == 0) { return 0; }
    if (str_eq(src_struct_ptr, src_struct_len, target_struct_ptr, target_struct_len) != 0) { return 0; }
    if (compiler_struct_is_same_or_descendant(target_struct_ptr, target_struct_len, src_struct_ptr, src_struct_len) == 0) { return 0; }
    return 1;
}

func compiler_find_downcast_check_info(src_struct_ptr: u64, src_struct_len: u64, target_struct_ptr: u64, target_struct_len: u64) -> CompilerDowncastCheckInfo {
    var info: CompilerDowncastCheckInfo = compiler_downcast_check_info_none();
    if (src_struct_ptr == 0 || src_struct_len == 0 || target_struct_ptr == 0 || target_struct_len == 0) { return info; }
    if (compiler_struct_is_same_or_descendant(target_struct_ptr, target_struct_len, src_struct_ptr, src_struct_len) == 0) { return info; }

    var src_def: *AstStructDef = get_struct_def(src_struct_ptr, src_struct_len);
    if (src_def == 0 || src_def.fields_vec == 0) { return info; }

    var fields: *Vec<*FieldDesc> = src_def.fields_vec;
    var n: u64 = fields.len();
    for (var i: u64 = 0; i < n; i++) {
        var fd: *FieldDesc = fields.get(i);
        if (fd == 0) { continue; }
        if (compiler_is_vptr_field_name(fd.name_ptr, fd.name_len) == 0) { continue; }
        if (fd.name_len <= 7) { continue; }

        var trait_ptr: u64 = fd.name_ptr + 7;
        var trait_len: u64 = fd.name_len - 7;
        var target_impl: *TraitImpl = compiler_find_trait_impl(trait_ptr, trait_len, target_struct_ptr, target_struct_len);
        if (target_impl == 0) { continue; }
        if (target_impl.vtable_global_ptr == 0 || target_impl.vtable_global_len == 0) { continue; }

        var vptr_name: *NameInfo = compiler_build_vptr_field_name(trait_ptr, trait_len);
        var off: u64 = compiler_struct_find_field_offset(src_def, vptr_name.ptr, vptr_name.len);
        if (compiler_is_not_found_u64(off) != 0) { continue; }

        info.found = 1;
        info.src_vptr_offset = off;
        info.trait_ptr = trait_ptr;
        info.trait_len = trait_len;
        info.expected_vtable_ptr = target_impl.vtable_global_ptr;
        info.expected_vtable_len = target_impl.vtable_global_len;
        return info;
    }
    return info;
}

func compiler_require_checked_struct_downcast_info(src_struct_ptr: u64, src_struct_len: u64, target_struct_ptr: u64, target_struct_len: u64) -> CompilerDowncastCheckInfo {
    var info: CompilerDowncastCheckInfo = compiler_find_downcast_check_info(src_struct_ptr, src_struct_len, target_struct_ptr, target_struct_len);
    if (compiler_is_strict_downcast(src_struct_ptr, src_struct_len, target_struct_ptr, target_struct_len) == 0) {
        return info;
    }
    if (info.found != 0) { return info; }
    emit_stderr("[ERROR] unchecked downcast is forbidden without virtual dispatch metadata: ");
    emit_stderr_len(src_struct_ptr, src_struct_len);
    emit_stderr(" -> ");
    emit_stderr_len(target_struct_ptr, target_struct_len);
    emit_stderr("\n");
    panic("Compiler error");
    return info;
}

func compiler_build_vtable_struct_name(trait_ptr: u64, trait_len: u64) -> *NameInfo {
    return module_util_name_concat2("__VTable_", 9, trait_ptr, trait_len);
}

func compiler_build_vtable_global_name(trait_ptr: u64, trait_len: u64, struct_ptr: u64, struct_len: u64) -> *NameInfo {
    return module_util_name_concat4("__vtable_", 9, trait_ptr, trait_len, "__", 2, struct_ptr, struct_len);
}

func compiler_build_trait_thunk_name(trait_ptr: u64, trait_len: u64, struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> *NameInfo {
    return module_util_name_concat6("__thunk_", 8, trait_ptr, trait_len, "__", 2, struct_ptr, struct_len, "__", 2, method_ptr, method_len);
}

func compiler_find_trait_impl(trait_ptr: u64, trait_len: u64, struct_ptr: u64, struct_len: u64) -> *TraitImpl {
    if (g_compiler_ctx.all_trait_impls_vec == 0) { return 0; }
    var n: u64 = g_compiler_ctx.all_trait_impls_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var ti: *TraitImpl = g_compiler_ctx.all_trait_impls_vec.get(i);
        if (str_eq(ti.trait_ptr, ti.trait_len, trait_ptr, trait_len) &&
            str_eq(ti.struct_ptr, ti.struct_len, struct_ptr, struct_len)) {
            return ti;
        }
    }
    return 0;
}

func compiler_find_trait_impl_method(impl_info: *TraitImpl, name_ptr: u64, name_len: u64) -> *TraitImplMethod {
    if (impl_info == 0 || impl_info.methods_vec == 0) { return 0; }
    var n: u64 = impl_info.methods_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var m: *TraitImplMethod = impl_info.methods_vec.get(i);
        if (str_eq(m.name_ptr, m.name_len, name_ptr, name_len)) { return m; }
    }
    return 0;
}

func compiler_find_trait_method_index(trait_ptr: u64, trait_len: u64, name_ptr: u64, name_len: u64) -> u64 {
    var td: *TraitDef = compiler_get_trait_def(trait_ptr, trait_len);
    if (td == 0 || td.methods_vec == 0) {
        if (TRAIT_LOOKUP_DEBUG != 0) {
            emit_stderr("[DEBUG] Trait def missing for: ");
            emit_stderr_len(trait_ptr, trait_len);
            emit_stderr("\n");
        }
        return COMPILER_NOT_FOUND_U64;
    }
    var n: u64 = td.methods_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var tm: *TraitMethod = td.methods_vec.get(i);
        if (str_eq(tm.name_ptr, tm.name_len, name_ptr, name_len)) { return tm.index; }
    }
    if (TRAIT_LOOKUP_LEGACY_M_PREFIX != 0 && name_len > 1) {
        var name_u8: []u8 = slice(name_ptr, name_len);
        if (name_u8[0] == 109) {
            var alt_ptr: u64 = name_ptr + 1;
            var alt_len: u64 = name_len - 1;
            for (var j: u64 = 0; j < n; j++) {
                var tm2: *TraitMethod = td.methods_vec.get(j);
                if (str_eq(tm2.name_ptr, tm2.name_len, alt_ptr, alt_len)) { return tm2.index; }
            }
        }
    }
    if (TRAIT_LOOKUP_DEBUG != 0) {
        emit_stderr("[DEBUG] Trait method lookup failed. Trait=");
        emit_stderr_len(trait_ptr, trait_len);
        emit_stderr(" name=");
        emit_stderr_len(name_ptr, name_len);
        emit_stderr("\n");
        for (var k: u64 = 0; k < n; k++) {
            var tm3: *TraitMethod = td.methods_vec.get(k);
            emit_stderr("[DEBUG] Trait method: ");
            emit_stderr_len(tm3.name_ptr, tm3.name_len);
            emit_stderr("\n");
        }
    }
    return COMPILER_NOT_FOUND_U64;
}

func compiler_sizeof_type(type_kind: u64, ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    if (ptr_depth > 0) { return 8; }
    switch (type_kind) {
        case TYPE_BOOL: return 1;
        case TYPE_U8: return 1;
        case TYPE_U16: return 2;
        case TYPE_U32: return 4;
        case TYPE_U64: return 8;
        case TYPE_I8: return 1;
        case TYPE_I16: return 2;
        case TYPE_I32: return 4;
        case TYPE_I64: return 8;
        case TYPE_F64: return 8;
        case TYPE_SLICE: return 16;
        case TYPE_STRUCT:
            var sd: *AstStructDef = get_struct_def(struct_name_ptr, struct_name_len);
            if (sd == 0) { return 8; }
            return compiler_struct_size_internal(sd, 0);
        case TYPE_TRAIT:
            return 8;
    }
    return 8;
}

func compiler_sizeof_typeinfo(info: *TypeInfo) -> u64 {
    if (info == 0) { return 8; }
    if (info.ptr_depth > 0) { return 8; }
    if (info.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = 0;
        if (info.elem_typeinfo != 0) {
            elem_size = compiler_sizeof_typeinfo(info.elem_typeinfo);
        } else {
            elem_size = compiler_sizeof_type(info.elem_type_kind, info.elem_ptr_depth, info.struct_name_ptr, info.struct_name_len);
        }
        return elem_size * info.array_len;
    }
    if (info.type_kind == TYPE_SLICE) { return 16; }
    return compiler_sizeof_type(info.type_kind, info.ptr_depth, info.struct_name_ptr, info.struct_name_len);
}

func compiler_sizeof_field_desc(field: *FieldDesc) -> u64 {
    if (field.bit_width > 0) {
        return (field.bit_width + 7) / 8;
    }
    if (field.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = 0;
        if (field.elem_typeinfo != 0) {
            elem_size = compiler_sizeof_typeinfo(field.elem_typeinfo);
        } else {
            elem_size = compiler_sizeof_type(field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len);
        }
        return elem_size * field.array_len;
    }
    if (field.type_kind == TYPE_SLICE) { return 16; }
    return compiler_sizeof_type(field.type_kind, field.ptr_depth, field.struct_name_ptr, field.struct_name_len);
}

func compiler_struct_size_internal(struct_info: *AstStructDef, depth: u64) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("TypeInfo error");
    }
    if (struct_info.is_union == 1) {
        if (struct_info.is_packed == 1) {
            emit_stderr("[ERROR] packed union is not supported\n");
            panic("TypeInfo error");
        }
        if ((struct_info.parents_vec != 0 && struct_info.parents_vec.len() > 0) ||
            (struct_info.traits_vec != 0 && struct_info.traits_vec.len() > 0)) {
            emit_stderr("[ERROR] union cannot use inheritance or traits\n");
            panic("TypeInfo error");
        }
        var max_size: u64 = 0;
        var fields_u: *Vec<*FieldDesc> = struct_info.fields_vec;
        var num_fields_u: u64 = fields_u.len();
        for (var ui: u64 = 0; ui < num_fields_u; ui++) {
            var field_u: *FieldDesc = fields_u.get(ui);
            var size_u: u64 = compiler_sizeof_field_desc(field_u);
            if (size_u > max_size) { max_size = size_u; }
        }
        return max_size;
    }
    if (struct_info.is_packed == 1) {
        emit_stderr("[ERROR] packed struct cannot use trait vptr layout\n");
        panic("TypeInfo error");
    }
    var total_size: u64 = 0;
    if (struct_info.parents_vec != 0) {
        var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
        var pn: u64 = parents.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = parents.get(pi);
            var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "TypeInfo error");
            total_size = total_size + compiler_struct_size_internal(parent_def, depth + 1);
        }
    }
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    for (var i: u64 = 0; i < num_fields; i++) {
        var field: *FieldDesc = fields.get(i);
        total_size = total_size + compiler_sizeof_field_desc(field);
    }
    return total_size;
}

func _compiler_struct_find_field_offset_hier(struct_def: *AstStructDef, field_ptr: u64, field_len: u64, depth: u64) -> u64 {
    if (struct_def == 0) { return COMPILER_NOT_FOUND_U64; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("TypeInfo error");
    }
    if (struct_def.is_union == 1) {
        var ufields: *Vec<*FieldDesc> = struct_def.fields_vec;
        var un: u64 = ufields.len();
        for (var ui: u64 = 0; ui < un; ui++) {
            var uf: *FieldDesc = ufields.get(ui);
            if (str_eq(uf.name_ptr, uf.name_len, field_ptr, field_len)) {
                return 0;
            }
        }
        return COMPILER_NOT_FOUND_U64;
    }

    var parent_total: u64 = 0;
    if (struct_def.parents_vec != 0) {
        var parents0: *Vec<*ParentDesc> = struct_def.parents_vec;
        var pn0: u64 = parents0.len();
        for (var p0: u64 = 0; p0 < pn0; p0++) {
            var pd0: *ParentDesc = parents0.get(p0);
            var pdef0: *AstStructDef = compiler_resolve_parent_def(pd0, "TypeInfo error");
            parent_total = parent_total + compiler_struct_size_internal(pdef0, depth + 1);
        }
    }

    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var n: u64 = fields.len();
    var local_off: u64 = parent_total;
    for (var i: u64 = 0; i < n; i++) {
        var f: *FieldDesc = fields.get(i);
        if (str_eq(f.name_ptr, f.name_len, field_ptr, field_len)) {
            return local_off;
        }
        local_off = local_off + compiler_sizeof_field_desc(f);
    }

    if (struct_def.parents_vec == 0) { return COMPILER_NOT_FOUND_U64; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    var run_off: u64 = 0;
    var found_count: u64 = 0;
    var found_off: u64 = COMPILER_NOT_FOUND_U64;
    for (var pi: u64 = 0; pi < pn; pi++) {
        var pd: *ParentDesc = parents.get(pi);
        var pdef: *AstStructDef = compiler_resolve_parent_def(pd, "TypeInfo error");
        var cand_off: u64 = _compiler_struct_find_field_offset_hier(pdef, field_ptr, field_len, depth + 1);
        if (compiler_is_not_found_u64(cand_off) == 0) {
            found_count = found_count + 1;
            if (found_count == 1) {
                found_off = run_off + cand_off;
            }
        }
        run_off = run_off + compiler_struct_size_internal(pdef, depth + 1);
    }
    if (found_count > 1) {
        emit_stderr("[ERROR] Ambiguous field offset in inheritance: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(field_ptr, field_len);
        emit_stderr("\n");
        panic("TypeInfo error");
    }
    return found_off;
}

func compiler_struct_find_field_offset(struct_def: *AstStructDef, field_ptr: u64, field_len: u64) -> u64 {
    return _compiler_struct_find_field_offset_hier(struct_def, field_ptr, field_len, 0);
}

func compiler_insert_vptr_field(struct_def: *AstStructDef, trait_ptr: u64, trait_len: u64, vtable_struct_ptr: u64, vtable_struct_len: u64) -> u64 {
    if (struct_def == 0) { return 0; }
    if (struct_def.is_union == 1) {
        emit_stderr("[ERROR] union cannot contain vptr field: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }
    var vptr_name: *NameInfo = compiler_build_vptr_field_name(trait_ptr, trait_len);
    var existing_off: u64 = compiler_struct_find_field_offset(struct_def, vptr_name.ptr, vptr_name.len);
    if (compiler_is_not_found_u64(existing_off) == 0) {
        return 0;
    }
    if (struct_def.fields_vec == 0) {
        struct_def.fields_vec = new Vec<*FieldDesc>(1);
    }
    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var n: u64 = fields.len();
    for (var i: u64 = 0; i < n; i++) {
        var f: *FieldDesc = fields.get(i);
        if (str_eq(f.name_ptr, f.name_len, vptr_name.ptr, vptr_name.len)) { return 0; }
    }
    var new_field: *FieldDesc = new FieldDesc();
    new_field.name_ptr = vptr_name.ptr;
    new_field.name_len = vptr_name.len;
    new_field.type_kind = TYPE_STRUCT;
    new_field.struct_name_ptr = vtable_struct_ptr;
    new_field.struct_name_len = vtable_struct_len;
    new_field.ptr_depth = 1;
    new_field.is_tagged = 0;
    new_field.tag_layout_ptr = 0;
    new_field.tag_layout_len = 0;
    new_field.bit_width = 0;
    new_field.elem_type_kind = 0;
    new_field.elem_ptr_depth = 0;
    new_field.array_len = 0;
    new_field.elem_typeinfo = 0;
    new_field.access = ACCESS_PRIVATE;
    new_field.owner_struct_ptr = struct_def.name_ptr;
    new_field.owner_struct_len = struct_def.name_len;

    fields.push(new_field);
    return 0;
}

func compiler_build_trait_thunk_func(thunk_name_ptr: u64, thunk_name_len: u64, trait_def: *TraitDef, trait_method: *TraitMethod, impl_method: *TraitImplMethod, struct_ptr: u64, struct_len: u64, vptr_offset: u64) -> *AstFunc {
    var trait_sig: *AstFunc = trait_method.sig;
    var params_in: *Vec<*Param> = trait_sig.params_vec;
    var param_count: u64 = params_in.len();
    var params_out: *Vec<*Param> = new Vec<*Param>(param_count);

    for (var i: u64 = 0; i < param_count; i++) {
        var src: *Param = params_in.get(i);
        var dst: *Param = module_util_clone_param(src);
        if (i == 0) {
            dst.type_kind = TYPE_TRAIT;
            dst.ptr_depth = 1;
            dst.is_tagged = 0;
            dst.struct_name_ptr = trait_def.name_ptr;
            dst.struct_name_len = trait_def.name_len;
            dst.tag_layout_ptr = 0;
            dst.tag_layout_len = 0;
        }
        params_out.push(dst);
    }

    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(2);

    var self_param: *Param = params_out.get(0);
    var self_ident: *AstNode = (*AstNode)ast_ident(self_param.name_ptr, self_param.name_len);
    var cast_struct_ptr: u64 = struct_ptr;
    var cast_struct_len: u64 = struct_len;
    if (impl_method != 0 && impl_method.func_def != 0 && impl_method.func_def.params_vec != 0 && impl_method.func_def.params_vec.len() != 0) {
        var impl_self: *Param = impl_method.func_def.params_vec.get(0);
        if (impl_self.type_kind == TYPE_STRUCT && impl_self.struct_name_ptr != 0 && impl_self.struct_name_len != 0) {
            cast_struct_ptr = impl_self.struct_name_ptr;
            cast_struct_len = impl_self.struct_name_len;
        }
    }
    var casted: *AstNode = (*AstNode)ast_cast_ex(self_ident, TYPE_STRUCT, 1, 0, cast_struct_ptr, cast_struct_len, 0, 0);

    var call_args: *Vec<*AstNode> = new Vec<*AstNode>(param_count);
    call_args.push(casted);
    for (var j: u64 = 1; j < param_count; j++) {
        var p: *Param = params_out.get(j);
        call_args.push((*AstNode)ast_ident(p.name_ptr, p.name_len));
    }

    var call_node: *AstNode = (*AstNode)ast_call(impl_method.func_def.name_ptr, impl_method.func_def.name_len, call_args);
    if (trait_sig.ret_type == TYPE_VOID) {
        stmts.push((*AstNode)ast_expr_stmt(call_node));
    } else {
        stmts.push((*AstNode)ast_return(call_node));
    }

    var body: *AstNode = (*AstNode)ast_block(stmts);
    return ast_func_ex(thunk_name_ptr, thunk_name_len, params_out,
                       trait_sig.ret_type, trait_sig.ret_ptr_depth, trait_sig.ret_is_tagged,
                       trait_sig.ret_struct_name_ptr, trait_sig.ret_struct_name_len,
                       trait_sig.ret_tag_layout_ptr, trait_sig.ret_tag_layout_len, body);
}

func compiler_validate_struct_trait_inheritance(sd: *AstStructDef) -> u64 {
    if (sd == 0 || sd.traits_vec == 0) { return 0; }
    if (sd.is_union == 1) {
        emit_stderr("[ERROR] union cannot use trait inheritance: ");
        emit_stderr_len(sd.name_ptr, sd.name_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }
    var tn: u64 = sd.traits_vec.len();
    for (var ti: u64 = 0; ti < tn; ti++) {
        var tref: *TraitRef = sd.traits_vec.get(ti);
        var tdef: *TraitDef = compiler_get_trait_def(tref.name_ptr, tref.name_len);
        if (tdef == 0) {
            emit_stderr("[ERROR] Trait not found for struct inheritance: ");
            emit_stderr_len(tref.name_ptr, tref.name_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        var impl_info: *TraitImpl = compiler_find_trait_impl(tref.name_ptr, tref.name_len, sd.name_ptr, sd.name_len);
        if (impl_info == 0) {
            emit_stderr("[ERROR] Trait impl missing for struct inheritance: ");
            emit_stderr_len(sd.name_ptr, sd.name_len);
            emit_stderr(" -> ");
            emit_stderr_len(tref.name_ptr, tref.name_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
    }
    return 0;
}

func compiler_validate_all_struct_trait_inheritance() -> u64 {
    if (g_compiler_ctx.all_structs_vec == 0) { return 0; }
    var sn: u64 = g_compiler_ctx.all_structs_vec.len();
    for (var si: u64 = 0; si < sn; si++) {
        var sd: *AstStructDef = g_compiler_ctx.all_structs_vec.get(si);
        compiler_validate_struct_trait_inheritance(sd);
    }
    return 0;
}

func compiler_get_impl_trait_and_struct(impl_info: *TraitImpl) -> CompilerImplTraitStruct {
    var pair: CompilerImplTraitStruct;
    pair.trait_def = 0;
    pair.struct_def = 0;

    var trait_def: *TraitDef = compiler_get_trait_def(impl_info.trait_ptr, impl_info.trait_len);
    if (trait_def == 0) {
        emit_stderr("[ERROR] Trait not found for impl: ");
        emit_stderr_len(impl_info.trait_ptr, impl_info.trait_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }

    var struct_def: *AstStructDef = get_struct_def(impl_info.struct_ptr, impl_info.struct_len);
    if (struct_def == 0) {
        emit_stderr("[ERROR] Struct not found for trait impl: ");
        emit_stderr_len(impl_info.struct_ptr, impl_info.struct_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }
    if (struct_def.is_union == 1) {
        emit_stderr("[ERROR] union cannot implement traits\n");
        compiler_panic("Compilation failed");
    }
    if (struct_def.is_packed == 1) {
        emit_stderr("[ERROR] packed struct cannot implement traits\n");
        compiler_panic("Compilation failed");
    }

    pair.trait_def = trait_def;
    pair.struct_def = struct_def;
    return pair;
}

func compiler_get_or_create_vtable_struct(trait_def: *TraitDef, trait_ptr: u64, trait_len: u64) -> CompilerVtableStructInfo {
    var info: CompilerVtableStructInfo;
    info.vtable_struct_def = 0;
    info.vtable_name_ptr = 0;
    info.vtable_name_len = 0;

    var vtable_name: *NameInfo = compiler_build_vtable_struct_name(trait_ptr, trait_len);
    info.vtable_name_ptr = vtable_name.ptr;
    info.vtable_name_len = vtable_name.len;

    var vtable_struct_def: *AstStructDef = get_struct_def(vtable_name.ptr, vtable_name.len);
    if (vtable_struct_def != 0) {
        info.vtable_struct_def = vtable_struct_def;
        return info;
    }

    var vtable_fields: *Vec<*FieldDesc> = new Vec<*FieldDesc>(trait_def.methods_vec.len());
    var mcount: u64 = trait_def.methods_vec.len();
    for (var mi: u64 = 0; mi < mcount; mi++) {
        var tm: *TraitMethod = trait_def.methods_vec.get(mi);
        var f: *FieldDesc = new FieldDesc();
        f.name_ptr = tm.name_ptr;
        f.name_len = tm.name_len;
        f.type_kind = TYPE_U64;
        f.ptr_depth = 0;
        f.is_tagged = 0;
        f.struct_name_ptr = 0;
        f.struct_name_len = 0;
        f.tag_layout_ptr = 0;
        f.tag_layout_len = 0;
        f.bit_width = 0;
        f.elem_type_kind = 0;
        f.elem_ptr_depth = 0;
        f.array_len = 0;
        f.elem_typeinfo = 0;
        f.access = ACCESS_PRIVATE;
        f.owner_struct_ptr = vtable_name.ptr;
        f.owner_struct_len = vtable_name.len;
        vtable_fields.push(f);
    }
    vtable_struct_def = ast_struct_def(vtable_name.ptr, vtable_name.len, 0, vtable_fields, 0, 0, 0);
    register_struct_type(vtable_struct_def);
    info.vtable_struct_def = vtable_struct_def;
    return info;
}

func compiler_get_trait_impl_vptr_offset(impl_info: *TraitImpl, struct_def: *AstStructDef, vtable_name_ptr: u64, vtable_name_len: u64) -> u64 {
    compiler_insert_vptr_field(struct_def, impl_info.trait_ptr, impl_info.trait_len, vtable_name_ptr, vtable_name_len);
    var vptr_name: *NameInfo = compiler_build_vptr_field_name(impl_info.trait_ptr, impl_info.trait_len);
    var vptr_offset: u64 = compiler_struct_find_field_offset(struct_def, vptr_name.ptr, vptr_name.len);
    if (vptr_offset == COMPILER_NOT_FOUND_U64) {
        emit_stderr("[ERROR] vptr field not found for trait impl: ");
        emit_stderr_len(impl_info.struct_ptr, impl_info.struct_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }
    return vptr_offset;
}

func compiler_validate_trait_signature_method(trait_ptr: u64, trait_len: u64, trait_method: *TraitMethod, trait_sig: *AstFunc) -> u64 {
    if (trait_sig.params_vec == 0 || trait_sig.params_vec.len() == 0) {
        module_util_trait_method_error("[ERROR] Trait method must have self parameter: ", trait_method.name_ptr, trait_method.name_len);
    }
    var self_param: *Param = trait_sig.params_vec.get(0);
    var is_virtual_trait: u64 = compiler_is_virtual_trait_name(trait_ptr, trait_len);
    if (module_util_is_self_type(self_param.type_kind, self_param.struct_name_ptr, self_param.struct_name_len) == 0 || self_param.ptr_depth == 0) {
        module_util_trait_method_error("[ERROR] Trait method self must be *Self: ", trait_method.name_ptr, trait_method.name_len);
    }
    if (is_virtual_trait == 0 && trait_sig.ret_type == TYPE_STRUCT && trait_sig.ret_ptr_depth == 0) {
        module_util_trait_method_error("[ERROR] Trait method cannot return struct by value: ", trait_method.name_ptr, trait_method.name_len);
    }
    if (is_virtual_trait == 0 && module_util_is_self_type(trait_sig.ret_type, trait_sig.ret_struct_name_ptr, trait_sig.ret_struct_name_len) != 0) {
        module_util_trait_method_error("[ERROR] Trait method cannot return Self type: ", trait_method.name_ptr, trait_method.name_len);
    }
    return 0;
}

func compiler_validate_trait_impl_signature(trait_method: *TraitMethod, trait_sig: *AstFunc, impl_sig: *AstFunc, impl_info: *TraitImpl) -> u64 {
    if (impl_sig.params_vec.len() != trait_sig.params_vec.len()) {
        module_util_trait_method_error("[ERROR] Trait method param count mismatch: ", trait_method.name_ptr, trait_method.name_len);
    }

    var impl_self: *Param = impl_sig.params_vec.get(0);
    if (impl_self.ptr_depth == 0 || impl_self.type_kind != TYPE_STRUCT) {
        module_util_trait_method_error("[ERROR] Trait impl self must be struct pointer: ", trait_method.name_ptr, trait_method.name_len);
    }
    var is_virtual_trait: u64 = compiler_is_virtual_trait_name(impl_info.trait_ptr, impl_info.trait_len);
    if (is_virtual_trait == 0) {
        if (!(str_eq(impl_self.struct_name_ptr, impl_self.struct_name_len, impl_info.struct_ptr, impl_info.struct_len) ||
              module_util_is_self_type(impl_self.type_kind, impl_self.struct_name_ptr, impl_self.struct_name_len) != 0)) {
            module_util_trait_method_error("[ERROR] Trait impl self type mismatch: ", trait_method.name_ptr, trait_method.name_len);
        }
    } else {
        var self_ok: u64 = 0;
        if (str_eq(impl_self.struct_name_ptr, impl_self.struct_name_len, impl_info.struct_ptr, impl_info.struct_len) != 0) {
            self_ok = 1;
        } else if (compiler_struct_is_same_or_descendant(impl_info.struct_ptr, impl_info.struct_len, impl_self.struct_name_ptr, impl_self.struct_name_len) != 0) {
            self_ok = 1;
        }
        if (self_ok == 0) {
            module_util_trait_method_error("[ERROR] Virtual impl self type mismatch: ", trait_method.name_ptr, trait_method.name_len);
        }
    }

    for (var pi: u64 = 1; pi < trait_sig.params_vec.len(); pi++) {
        var tp: *Param = trait_sig.params_vec.get(pi);
        if (is_virtual_trait == 0 && module_util_is_self_type(tp.type_kind, tp.struct_name_ptr, tp.struct_name_len) != 0) {
            module_util_trait_method_error("[ERROR] Trait method params cannot use Self type: ", trait_method.name_ptr, trait_method.name_len);
        }
        var ip: *Param = impl_sig.params_vec.get(pi);
        if (tp.type_kind != ip.type_kind || tp.ptr_depth != ip.ptr_depth) {
            module_util_trait_method_error("[ERROR] Trait impl param type mismatch: ", trait_method.name_ptr, trait_method.name_len);
        }
        if (tp.type_kind == TYPE_STRUCT) {
            if (!str_eq(tp.struct_name_ptr, tp.struct_name_len, ip.struct_name_ptr, ip.struct_name_len)) {
                module_util_trait_method_error("[ERROR] Trait impl struct param mismatch: ", trait_method.name_ptr, trait_method.name_len);
            }
        }
    }

    if (trait_sig.ret_type != impl_sig.ret_type || trait_sig.ret_ptr_depth != impl_sig.ret_ptr_depth) {
        module_util_trait_method_error("[ERROR] Trait impl return type mismatch: ", trait_method.name_ptr, trait_method.name_len);
    }
    if (trait_sig.ret_type == TYPE_STRUCT) {
        if (!str_eq(trait_sig.ret_struct_name_ptr, trait_sig.ret_struct_name_len, impl_sig.ret_struct_name_ptr, impl_sig.ret_struct_name_len)) {
            module_util_trait_method_error("[ERROR] Trait impl return struct mismatch: ", trait_method.name_ptr, trait_method.name_len);
        }
    }
    return 0;
}

func compiler_register_trait_thunk(impl_info: *TraitImpl, trait_def: *TraitDef, trait_method: *TraitMethod, impl_method: *TraitImplMethod, vptr_offset: u64, values: *Vec<*AstNode>) -> u64 {
    var thunk_name: *NameInfo = compiler_build_trait_thunk_name(impl_info.trait_ptr, impl_info.trait_len, impl_info.struct_ptr, impl_info.struct_len, trait_method.name_ptr, trait_method.name_len);
    var thunk_fn: *AstFunc = compiler_build_trait_thunk_func(thunk_name.ptr, thunk_name.len, trait_def, trait_method, impl_method, impl_info.struct_ptr, impl_info.struct_len, vptr_offset);
    g_compiler_ctx.all_funcs.push(thunk_fn);
    g_compiler_ctx.all_func_sigs.push(thunk_fn);
    compiler_register_impl_method_ex(thunk_name.ptr, thunk_name.len, impl_info.struct_ptr, impl_info.struct_len, ACCESS_PUBLIC);
    compiler_register_impl_method_func(thunk_name.ptr, thunk_name.len, thunk_fn);
    compiler_invalidate_func_lookup();
    values.push((*AstNode)ast_ident(thunk_name.ptr, thunk_name.len));
    return 0;
}

func compiler_register_trait_vtable_global(impl_info: *TraitImpl, vtable_name_ptr: u64, vtable_name_len: u64, vtable_struct_def: *AstStructDef, values: *Vec<*AstNode>) -> u64 {
    var vtable_global: *NameInfo = compiler_build_vtable_global_name(impl_info.trait_ptr, impl_info.trait_len, impl_info.struct_ptr, impl_info.struct_len);
    impl_info.vtable_global_ptr = vtable_global.ptr;
    impl_info.vtable_global_len = vtable_global.len;

    var vtable_lit: *AstStructLiteral = ast_struct_literal(vtable_struct_def, values);
    var vtable_type: *TypeInfo = new TypeInfo(TYPE_STRUCT, 0);
    vtable_type.struct_name_ptr = vtable_name_ptr;
    vtable_type.struct_name_len = vtable_name_len;
    vtable_type.struct_def = vtable_struct_def;

    var ginfo: *GlobalInfo = new GlobalInfo();
    ginfo.name_ptr = vtable_global.ptr;
    ginfo.name_len = vtable_global.len;
    ginfo.typeinfo_ptr = vtable_type;
    ginfo.init_kind = GLOBAL_INIT_EXPR;
    ginfo.init_expr = (u64)vtable_lit;
    g_compiler_ctx.all_globals.push(ginfo);
    compiler_invalidate_global_lookup();
    return 0;
}

func compiler_build_trait_default_impl_func(impl_info: *TraitImpl, trait_method: *TraitMethod, trait_sig: *AstFunc) -> *AstFunc {
    if (impl_info == 0 || trait_method == 0 || trait_sig == 0 || trait_sig.body == 0) { return 0; }
    if (trait_sig.params_vec == 0 || trait_sig.params_vec.len() == 0) { return 0; }

    var fn_name: *NameInfo = compiler_build_method_name(impl_info.struct_ptr, impl_info.struct_len, trait_method.name_ptr, trait_method.name_len);
    var params_out: *Vec<*Param> = new Vec<*Param>(trait_sig.params_vec.len());
    var pn: u64 = trait_sig.params_vec.len();
    for (var i: u64 = 0; i < pn; i++) {
        var src: *Param = trait_sig.params_vec.get(i);
        var dst: *Param = module_util_clone_param(src);
        if (i == 0) {
            dst.type_kind = TYPE_STRUCT;
            dst.ptr_depth = 1;
            dst.is_tagged = 0;
            dst.struct_name_ptr = impl_info.struct_ptr;
            dst.struct_name_len = impl_info.struct_len;
            dst.tag_layout_ptr = 0;
            dst.tag_layout_len = 0;
        }
        params_out.push(dst);
    }

    return ast_func_ex(fn_name.ptr, fn_name.len, params_out,
                       trait_sig.ret_type, trait_sig.ret_ptr_depth, trait_sig.ret_is_tagged,
                       trait_sig.ret_struct_name_ptr, trait_sig.ret_struct_name_len,
                       trait_sig.ret_tag_layout_ptr, trait_sig.ret_tag_layout_len,
                       trait_sig.body);
}

func compiler_register_trait_default_impl_method(impl_info: *TraitImpl, trait_method: *TraitMethod, trait_sig: *AstFunc) -> *TraitImplMethod {
    var fn: *AstFunc = compiler_build_trait_default_impl_func(impl_info, trait_method, trait_sig);
    if (fn == 0) { return 0; }
    g_compiler_ctx.all_funcs.push(fn);
    g_compiler_ctx.all_func_sigs.push(fn);
    compiler_invalidate_func_lookup();
    compiler_register_impl_method_ex(fn.name_ptr, fn.name_len, impl_info.struct_ptr, impl_info.struct_len, ACCESS_PUBLIC);
    compiler_register_impl_method_func(fn.name_ptr, fn.name_len, fn);

    var impl_method: *TraitImplMethod = new TraitImplMethod();
    impl_method.name_ptr = trait_method.name_ptr;
    impl_method.name_len = trait_method.name_len;
    impl_method.func_def = fn;
    if (impl_info.methods_vec != 0) {
        impl_info.methods_vec.push(impl_method);
    }
    return impl_method;
}

func compiler_finalize_single_trait_impl(impl_info: *TraitImpl) -> u64 {
    var impl_types: CompilerImplTraitStruct = compiler_get_impl_trait_and_struct(impl_info);
    var trait_def: *TraitDef = impl_types.trait_def;
    var struct_def: *AstStructDef = impl_types.struct_def;

    var vtable_info: CompilerVtableStructInfo = compiler_get_or_create_vtable_struct(trait_def, impl_info.trait_ptr, impl_info.trait_len);
    var vtable_name_ptr: u64 = vtable_info.vtable_name_ptr;
    var vtable_name_len: u64 = vtable_info.vtable_name_len;
    var vtable_struct_def: *AstStructDef = vtable_info.vtable_struct_def;
    impl_info.vtable_struct_def = vtable_struct_def;

    var vptr_offset: u64 = compiler_get_trait_impl_vptr_offset(impl_info, struct_def, vtable_name_ptr, vtable_name_len);

    var method_count: u64 = trait_def.methods_vec.len();
    var values: *Vec<*AstNode> = new Vec<*AstNode>(method_count);
    for (var m: u64 = 0; m < method_count; m++) {
        var trait_method: *TraitMethod = trait_def.methods_vec.get(m);
        var trait_sig: *AstFunc = trait_method.sig;
        compiler_validate_trait_signature_method(impl_info.trait_ptr, impl_info.trait_len, trait_method, trait_sig);

        var impl_method: *TraitImplMethod = compiler_find_trait_impl_method(impl_info, trait_method.name_ptr, trait_method.name_len);
        if (impl_method == 0) {
            if (trait_sig.body != 0) {
                impl_method = compiler_register_trait_default_impl_method(impl_info, trait_method, trait_sig);
            }
        }
        if (impl_method == 0) {
            module_util_trait_method_error("[ERROR] Trait method not implemented: ", trait_method.name_ptr, trait_method.name_len);
        }

        var impl_sig: *AstFunc = impl_method.func_def;
        compiler_validate_trait_impl_signature(trait_method, trait_sig, impl_sig, impl_info);
        compiler_register_trait_thunk(impl_info, trait_def, trait_method, impl_method, vptr_offset, values);
    }

    compiler_register_trait_vtable_global(impl_info, vtable_name_ptr, vtable_name_len, vtable_struct_def, values);
    return 0;
}

func compiler_finalize_traits() -> u64 {
    compiler_validate_all_struct_trait_inheritance();
    if (g_compiler_ctx.all_trait_impls_vec == 0 || g_compiler_ctx.all_trait_impls_vec.len() == 0) { return 0; }

    var num_impls: u64 = g_compiler_ctx.all_trait_impls_vec.len();
    for (var ii: u64 = 0; ii < num_impls; ii++) {
        var impl_info: *TraitImpl = g_compiler_ctx.all_trait_impls_vec.get(ii);
        compiler_finalize_single_trait_impl(impl_info);
    }
    return 0;
}

func compiler_collect_parent_abst_methods(parent_def: *AstStructDef, out: *Vec<*NameInfo>) -> u64 {
    if (parent_def == 0 || out == 0) { return 0; }
    compiler_collect_abst_methods_recursive(parent_def, out);

    var list: *Vec<*NameInfo> = compiler_get_abst_methods(parent_def.name_ptr, parent_def.name_len);
    if (list == 0) { return 0; }

    var n: u64 = list.len();
    for (var i: u64 = 0; i < n; i++) {
        module_util_nameinfo_vec_push_unique(out, list.get(i));
    }
    return 0;
}

func compiler_collect_abst_methods_recursive(struct_def: *AstStructDef, out: *Vec<*NameInfo>) -> u64 {
    if (struct_def == 0 || out == 0) { return 0; }
    if (struct_def.parents_vec != 0) {
        var pn: u64 = struct_def.parents_vec.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = struct_def.parents_vec.get(pi);
            var parent_def: *AstStructDef = parent_desc.struct_def;
            if (parent_def == 0) {
                parent_def = get_struct_def(parent_desc.name_ptr, parent_desc.name_len);
            }
            if (parent_def != 0) {
                compiler_collect_parent_abst_methods(parent_def, out);
            }
        }
    }
    return 0;
}

func compiler_collect_self_and_parent_abst_methods(struct_def: *AstStructDef, out: *Vec<*NameInfo>) -> u64 {
    if (struct_def == 0 || out == 0) { return 0; }
    compiler_collect_abst_methods_recursive(struct_def, out);
    var own: *Vec<*NameInfo> = compiler_get_abst_methods(struct_def.name_ptr, struct_def.name_len);
    if (own == 0) { return 0; }
    var n: u64 = own.len();
    for (var i: u64 = 0; i < n; i++) {
        module_util_nameinfo_vec_push_unique(out, own.get(i));
    }
    return 0;
}

func _compiler_find_abst_decl_in_hierarchy(struct_def: *AstStructDef, method_ptr: u64, method_len: u64, depth: u64) -> CompilerDeclLookup {
    var lookup: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PRIVATE);
    if (struct_def == 0) { return lookup; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }

    if (compiler_is_abst_method(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len) != 0) {
        lookup.found = 1;
        lookup.owner_ptr = struct_def.name_ptr;
        lookup.owner_len = struct_def.name_len;
        lookup.access = compiler_get_abst_method_access(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
        lookup.sig = compiler_get_abst_method_sig(struct_def.name_ptr, struct_def.name_len, method_ptr, method_len);
        return lookup;
    }

    if (struct_def.parents_vec == 0) { return lookup; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    var found: u64 = 0;
    var first_hit: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PRIVATE);
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var child_lookup: CompilerDeclLookup = _compiler_find_abst_decl_in_hierarchy(parent_def, method_ptr, method_len, depth + 1);
        if (child_lookup.found != 0) {
            found = found + 1;
            if (found == 1) { first_hit = child_lookup; }
        }
    }
    if (found > 1) {
        emit_stderr("[ERROR] Ambiguous abstract method declaration in inheritance: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    if (found == 0) { return lookup; }
    return first_hit;
}

func compiler_find_abst_decl_in_hierarchy(struct_def: *AstStructDef, method_ptr: u64, method_len: u64) -> CompilerDeclLookup {
    return _compiler_find_abst_decl_in_hierarchy(struct_def, method_ptr, method_len, 0);
}

func compiler_build_virtual_trait_name(base_ptr: u64, base_len: u64) -> *NameInfo {
    return module_util_name_concat2("__Virt_", 7, base_ptr, base_len);
}

func compiler_build_virtual_trait_method_sig(abst_sig: *AstFunc, method_ptr: u64, method_len: u64) -> *AstFunc {
    if (abst_sig == 0 || abst_sig.params_vec == 0 || abst_sig.params_vec.len() == 0) {
        emit_stderr("[ERROR] abstract method requires self parameter for virtual dispatch: ");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }

    var params_out: *Vec<*Param> = new Vec<*Param>(abst_sig.params_vec.len());
    var pn: u64 = abst_sig.params_vec.len();
    for (var i: u64 = 0; i < pn; i++) {
        var src: *Param = abst_sig.params_vec.get(i);
        var dst: *Param = module_util_clone_param(src);
        if (i == 0) {
            dst.type_kind = TYPE_STRUCT;
            dst.ptr_depth = 1;
            dst.is_tagged = 0;
            dst.struct_name_ptr = (u64)"Self";
            dst.struct_name_len = 4;
            dst.tag_layout_ptr = 0;
            dst.tag_layout_len = 0;
        }
        params_out.push(dst);
    }

    return ast_func_ex(method_ptr, method_len, params_out,
                       abst_sig.ret_type, abst_sig.ret_ptr_depth, abst_sig.ret_is_tagged,
                       abst_sig.ret_struct_name_ptr, abst_sig.ret_struct_name_len,
                       abst_sig.ret_tag_layout_ptr, abst_sig.ret_tag_layout_len, 0);
}

func compiler_setup_single_virtual_dispatch_trait(base_def: *AstStructDef) -> u64 {
    if (base_def == 0) { return 0; }
    var own_abst: *Vec<*NameInfo> = compiler_get_abst_methods(base_def.name_ptr, base_def.name_len);
    if (own_abst == 0 || own_abst.len() == 0) { return 0; }

    var required: *Vec<*NameInfo> = new Vec<*NameInfo>(8);
    compiler_collect_self_and_parent_abst_methods(base_def, required);
    if (required.len() == 0) { return 0; }

    var trait_name: *NameInfo = compiler_build_virtual_trait_name(base_def.name_ptr, base_def.name_len);
    var trait_def: *TraitDef = compiler_get_trait_def(trait_name.ptr, trait_name.len);
    if (trait_def == 0) {
        var methods: *Vec<*TraitMethod> = new Vec<*TraitMethod>(required.len());
        var rn: u64 = required.len();
        for (var ri: u64 = 0; ri < rn; ri++) {
            var mi: *NameInfo = required.get(ri);
            var abst_lookup: CompilerDeclLookup = compiler_find_abst_decl_in_hierarchy(base_def, mi.ptr, mi.len);
            if (abst_lookup.found == 0 || abst_lookup.sig == 0) {
                emit_stderr("[ERROR] abstract signature missing for virtual dispatch: ");
                emit_stderr_len(base_def.name_ptr, base_def.name_len);
                emit_stderr(".");
                emit_stderr_len(mi.ptr, mi.len);
                emit_stderr("\n");
                compiler_panic("Compilation failed");
            }

            var tm: *TraitMethod = new TraitMethod();
            tm.name_ptr = mi.ptr;
            tm.name_len = mi.len;
            tm.sig = compiler_build_virtual_trait_method_sig(abst_lookup.sig, mi.ptr, mi.len);
            tm.index = methods.len();
            methods.push(tm);
        }

        trait_def = new TraitDef();
        trait_def.name_ptr = trait_name.ptr;
        trait_def.name_len = trait_name.len;
        trait_def.methods_vec = methods;
        compiler_register_trait_def(trait_def);
    }

    var vtable_info2: CompilerVtableStructInfo = compiler_get_or_create_vtable_struct(trait_def, trait_name.ptr, trait_name.len);
    var vtable_name_ptr: u64 = vtable_info2.vtable_name_ptr;
    var vtable_name_len: u64 = vtable_info2.vtable_name_len;
    var vtable_struct_def: *AstStructDef = vtable_info2.vtable_struct_def;
    if (vtable_struct_def == 0) {
        emit_stderr("[ERROR] failed to build virtual vtable struct\n");
        compiler_panic("Compilation failed");
    }

    var sn: u64 = g_compiler_ctx.all_structs_vec.len();
    for (var si: u64 = 0; si < sn; si++) {
        var sd: *AstStructDef = g_compiler_ctx.all_structs_vec.get(si);
        if (sd == 0) { continue; }
        if (compiler_struct_is_same_or_descendant(sd.name_ptr, sd.name_len, base_def.name_ptr, base_def.name_len) == 0) { continue; }

        compiler_insert_vptr_field(sd, trait_name.ptr, trait_name.len, vtable_name_ptr, vtable_name_len);

        var rn2: u64 = required.len();
        for (var rj: u64 = 0; rj < rn2; rj++) {
            var mref: *NameInfo = required.get(rj);
            compiler_register_virtual_dispatch_trait(sd.name_ptr, sd.name_len, mref.ptr, mref.len, trait_name.ptr, trait_name.len);
        }

        if (compiler_find_trait_impl(trait_name.ptr, trait_name.len, sd.name_ptr, sd.name_len) != 0) { continue; }

        var impl_methods: *Vec<*TraitImplMethod> = new Vec<*TraitImplMethod>(required.len());
        var has_all_impls: u64 = 1;
        for (var rk: u64 = 0; rk < required.len(); rk++) {
            var mk: *NameInfo = required.get(rk);
            var fn: *AstFunc = compiler_find_method_func_in_hierarchy(sd, mk.ptr, mk.len);
            if (fn == 0) {
                has_all_impls = 0;
                break;
            }
            var tim: *TraitImplMethod = new TraitImplMethod();
            tim.name_ptr = mk.ptr;
            tim.name_len = mk.len;
            tim.func_def = fn;
            impl_methods.push(tim);
        }
        if (has_all_impls == 0) { continue; }

        var impl_info: *TraitImpl = new TraitImpl();
        impl_info.trait_ptr = trait_name.ptr;
        impl_info.trait_len = trait_name.len;
        impl_info.struct_ptr = sd.name_ptr;
        impl_info.struct_len = sd.name_len;
        impl_info.methods_vec = impl_methods;
        impl_info.vtable_struct_def = 0;
        impl_info.vtable_global_ptr = 0;
        impl_info.vtable_global_len = 0;
        compiler_register_trait_impl(impl_info);
    }
    return 0;
}

func compiler_setup_virtual_dispatch_traits() -> u64 {
    if (g_compiler_ctx.all_structs_vec == 0) { return 0; }
    var sn: u64 = g_compiler_ctx.all_structs_vec.len();
    for (var si: u64 = 0; si < sn; si++) {
        var sd: *AstStructDef = g_compiler_ctx.all_structs_vec.get(si);
        if (sd == 0) { continue; }
        compiler_setup_single_virtual_dispatch_trait(sd);
    }
    return 0;
}

func compiler_find_parent_method_decl_for_override(struct_def: *AstStructDef, method_ptr: u64, method_len: u64, arg_types: *Vec<*TypeInfo>, arg_count_hint: u64) -> CompilerDeclLookup {
    var lookup: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
    if (struct_def == 0 || struct_def.parents_vec == 0) { return lookup; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    var found: u64 = 0;
    var first_hit: CompilerDeclLookup = compiler_decl_lookup_none(ACCESS_PUBLIC);
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var child_lookup: CompilerDeclLookup = compiler_find_method_decl_in_hierarchy_overload(parent_def.name_ptr, parent_def.name_len, method_ptr, method_len, arg_types, arg_count_hint);
        if (child_lookup.found != 0) {
            found = found + 1;
            if (found == 1) { first_hit = child_lookup; }
        }
    }
    if (found > 1) {
        emit_stderr("[ERROR] Ambiguous override target in inheritance: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    if (found == 0) { return lookup; }
    return first_hit;
}

func compiler_is_trait_impl_func(fn: *AstFunc) -> u64 {
    if (fn == 0 || g_compiler_ctx.all_trait_impls_vec == 0) { return 0; }
    var inum: u64 = g_compiler_ctx.all_trait_impls_vec.len();
    for (var ii: u64 = 0; ii < inum; ii++) {
        var impl_info: *TraitImpl = g_compiler_ctx.all_trait_impls_vec.get(ii);
        if (impl_info == 0 || impl_info.methods_vec == 0) { continue; }
        var mn: u64 = impl_info.methods_vec.len();
        for (var mi: u64 = 0; mi < mn; mi++) {
            var method: *TraitImplMethod = impl_info.methods_vec.get(mi);
            if (method != 0 && method.func_def == fn) { return 1; }
        }
    }
    return 0;
}

func compiler_validate_single_impl_override(fn: *AstFunc) -> u64 {
    if (fn == 0) { return 0; }
    if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { return 0; }
    if (compiler_is_trait_impl_func(fn) != 0) { return 0; }

    var owner_def: *AstStructDef = get_struct_def(fn.impl_owner_ptr, fn.impl_owner_len);
    if (owner_def == 0 || owner_def.parents_vec == 0) { return 0; }

    var method_ptr: u64 = fn.impl_original_name_ptr;
    var method_len: u64 = fn.impl_original_name_len;
    if (method_ptr == 0 || method_len == 0) {
        method_ptr = fn.name_ptr;
        method_len = fn.name_len;
    }

    var method_arg_types: *Vec<*TypeInfo> = compiler_method_arg_types_from_params(fn);
    var arg_count_hint: u64 = 0;
    if (method_arg_types != 0) { arg_count_hint = method_arg_types.len(); }
    var base_lookup: CompilerDeclLookup = compiler_find_parent_method_decl_for_override(owner_def, method_ptr, method_len, method_arg_types, arg_count_hint);
    var require_override: u64 = 0;

    if (base_lookup.found == 0) {
        if (fn.impl_is_override != 0) {
            emit_stderr("[ERROR] @[override] has no base method: ");
            emit_stderr_len(fn.impl_owner_ptr, fn.impl_owner_len);
            emit_stderr(".");
            emit_stderr_len(method_ptr, method_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        return 0;
    }
    if (base_lookup.sig != 0 && base_lookup.sig.body == 0) {
        require_override = 1;
    } else if (base_lookup.owner_ptr != 0 && base_lookup.owner_len != 0 &&
               compiler_is_abst_method(base_lookup.owner_ptr, base_lookup.owner_len, method_ptr, method_len) != 0) {
        require_override = 1;
    }

    var base_access: u64 = base_lookup.access;
    if (base_lookup.sig != 0 && base_lookup.sig.impl_method_access == ACCESS_PRIVATE) {
        base_access = ACCESS_PRIVATE;
    }
    if (base_access == ACCESS_PRIVATE) {
        if (fn.impl_is_override != 0) {
            emit_stderr("[ERROR] cannot override private base method: ");
            emit_stderr_len(fn.impl_owner_ptr, fn.impl_owner_len);
            emit_stderr(".");
            emit_stderr_len(method_ptr, method_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        return 0;
    }

    if (require_override != 0 && fn.impl_is_override == 0) {
        emit_stderr("[ERROR] missing @[override] on overriding method: ");
        emit_stderr_len(fn.impl_owner_ptr, fn.impl_owner_len);
        emit_stderr(".");
        emit_stderr_len(method_ptr, method_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }
    return 0;
}

func compiler_validate_impl_overrides() -> u64 {
    if (g_compiler_ctx.all_func_sigs == 0) { return 0; }
    var n: u64 = g_compiler_ctx.all_func_sigs.len();
    for (var i: u64 = 0; i < n; i++) {
        compiler_validate_single_impl_override(g_compiler_ctx.all_func_sigs.get(i));
    }
    return 0;
}

func compiler_annotation_is_builtin_name(name_ptr: u64, name_len: u64) -> u64 {
    if (str_eq(name_ptr, name_len, "override", 8) != 0) { return 1; }
    if (str_eq(name_ptr, name_len, "entry", 5) != 0) { return 1; }
    if (str_eq(name_ptr, name_len, "used", 4) != 0) { return 1; }
    if (str_eq(name_ptr, name_len, "hot", 3) != 0) { return 1; }
    if (str_eq(name_ptr, name_len, "cold", 4) != 0) { return 1; }
    if (str_eq(name_ptr, name_len, "trace", 5) != 0) { return 1; }
    if (str_eq(name_ptr, name_len, "config", 6) != 0) { return 1; }
    return 0;
}

func compiler_annotation_count_name(annotations: *Vec<*NameInfo>, name_ptr: u64, name_len: u64) -> u64 {
    if (annotations == 0) { return 0; }
    var n: u64 = annotations.len();
    var count: u64 = 0;
    for (var i: u64 = 0; i < n; i++) {
        var ann: *NameInfo = annotations.get(i);
        if (str_eq(ann.ptr, ann.len, name_ptr, name_len) != 0) {
            count = count + 1;
        }
    }
    return count;
}

func compiler_annotation_param_shape_equal(a: *Param, b: *Param) -> u64 {
    if (a == 0 || b == 0) { return 0; }
    if (a.type_kind != b.type_kind) { return 0; }
    if (a.ptr_depth != b.ptr_depth) { return 0; }
    if (a.is_tagged != b.is_tagged) { return 0; }
    if (a.elem_type_kind != b.elem_type_kind) { return 0; }
    if (a.elem_ptr_depth != b.elem_ptr_depth) { return 0; }
    if (a.array_len != b.array_len) { return 0; }
    if (a.array_len_is_param != b.array_len_is_param) { return 0; }
    if (a.array_len_is_param != 0) {
        if (str_eq(a.array_len_param_ptr, a.array_len_param_len, b.array_len_param_ptr, b.array_len_param_len) == 0) {
            return 0;
        }
    }
    if (a.type_kind == TYPE_STRUCT || a.type_kind == TYPE_GENERIC || a.type_kind == TYPE_TRAIT || a.type_kind == TYPE_ARRAY || a.type_kind == TYPE_SLICE) {
        if (str_eq(a.struct_name_ptr, a.struct_name_len, b.struct_name_ptr, b.struct_name_len) == 0) {
            return 0;
        }
    }
    if (a.is_tagged != 0) {
        if (str_eq(a.tag_layout_ptr, a.tag_layout_len, b.tag_layout_ptr, b.tag_layout_len) == 0) {
            return 0;
        }
    }
    return 1;
}

func compiler_annotation_return_shape_equal(lhs: *AstFunc, rhs: *AstFunc) -> u64 {
    if (lhs == 0 || rhs == 0) { return 0; }
    if (lhs.ret_type != rhs.ret_type) { return 0; }
    if (lhs.ret_ptr_depth != rhs.ret_ptr_depth) { return 0; }
    if (lhs.ret_is_tagged != rhs.ret_is_tagged) { return 0; }
    if (lhs.ret_type == TYPE_STRUCT || lhs.ret_type == TYPE_GENERIC || lhs.ret_type == TYPE_TRAIT || lhs.ret_type == TYPE_ARRAY || lhs.ret_type == TYPE_SLICE) {
        if (str_eq(lhs.ret_struct_name_ptr, lhs.ret_struct_name_len, rhs.ret_struct_name_ptr, rhs.ret_struct_name_len) == 0) {
            return 0;
        }
    }
    if (lhs.ret_is_tagged != 0) {
        if (str_eq(lhs.ret_tag_layout_ptr, lhs.ret_tag_layout_len, rhs.ret_tag_layout_ptr, rhs.ret_tag_layout_len) == 0) {
            return 0;
        }
    }
    return 1;
}

func compiler_annotation_clone_params(params: *Vec<*Param>) -> *Vec<*Param> {
    if (params == 0) { return new Vec<*Param>(1); }
    var n: u64 = params.len();
    var out: *Vec<*Param> = new Vec<*Param>(n + 1);
    for (var i: u64 = 0; i < n; i++) {
        out.push(module_util_clone_param(params.get(i)));
    }
    return out;
}

func compiler_annotation_clone_sig(template: *AstFunc, new_name_ptr: u64, new_name_len: u64) -> *AstFunc {
    var params_out: *Vec<*Param> = compiler_annotation_clone_params(template.params_vec);
    var sig_out: *AstFunc = ast_func_ex(new_name_ptr, new_name_len, params_out,
                                        template.ret_type, template.ret_ptr_depth, template.ret_is_tagged,
                                        template.ret_struct_name_ptr, template.ret_struct_name_len,
                                        template.ret_tag_layout_ptr, template.ret_tag_layout_len, 0);
    sig_out.annotations_vec = 0;
    return sig_out;
}

func compiler_annotation_build_generated_name(prefix_ptr: u64, prefix_len: u64, base_ptr: u64, base_len: u64, id: u64) -> *NameInfo {
    var id_buf: u64 = heap_alloc(32 * sizeof(u8));
    var id_len: u64 = io_u64_to_ascii(id_buf, id);
    var sep_len: u64 = 2;
    var total_len: u64 = prefix_len + base_len + sep_len + id_len;
    var out_ptr: u64 = heap_alloc((total_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, total_len + 1);
    str_copy(out_ptr, prefix_ptr, prefix_len);
    str_copy(out_ptr + prefix_len, base_ptr, base_len);
    out_u8[prefix_len + base_len] = 95;
    out_u8[prefix_len + base_len + 1] = 95;
    str_copy(out_ptr + prefix_len + base_len + sep_len, id_buf, id_len);
    out_u8[total_len] = 0;
    return new NameInfo{out_ptr, total_len};
}

func compiler_annotation_collect_decorators(fn: *AstFunc) -> *Vec<*NameInfo> {
    if (fn == 0 || fn.annotations_vec == 0) { return 0; }

    var annotations: *Vec<*NameInfo> = fn.annotations_vec;
    var n: u64 = annotations.len();
    var out: *Vec<*NameInfo> = 0;
    for (var i: u64 = 0; i < n; i++) {
        var ann: *NameInfo = annotations.get(i);
        if (compiler_annotation_is_builtin_name(ann.ptr, ann.len) != 0) { continue; }

        var deco_sig: *AstFunc = compiler_find_func_signature_for_call(ann.ptr, ann.len);
        if (deco_sig == 0) { continue; }
        if (compiler_name_matches_tail(fn.name_ptr, fn.name_len, ann.ptr, ann.len) != 0) {
            emit_stderr("[ERROR] function cannot decorate itself: ");
            emit_stderr_len(fn.name_ptr, fn.name_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }

        if (out == 0) {
            out = new Vec<*NameInfo>(2);
        } else {
            var dup: u64 = 0;
            var on: u64 = out.len();
            for (var j: u64 = 0; j < on; j++) {
                var prev: *NameInfo = out.get(j);
                if (str_eq(prev.ptr, prev.len, ann.ptr, ann.len) != 0) {
                    dup = 1;
                    break;
                }
            }
            if (dup != 0) { continue; }
        }
        out.push(ann);
    }
    return out;
}

func compiler_annotation_validate_decorator_signature(deco_sig: *AstFunc, target: *AstFunc, deco_ptr: u64, deco_len: u64) -> u64 {
    if (deco_sig == 0 || target == 0) {
        emit_stderr("[ERROR] internal: decorator signature validation received null function\n");
        compiler_panic("Compilation failed");
    }

    if (compiler_annotation_return_shape_equal(deco_sig, target) == 0) {
        emit_stderr("[ERROR] decorator return type must match target function: ");
        emit_stderr_len(deco_ptr, deco_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }

    var target_params: *Vec<*Param> = target.params_vec;
    var target_n: u64 = 0;
    if (target_params != 0) { target_n = target_params.len(); }

    var deco_params: *Vec<*Param> = deco_sig.params_vec;
    if (deco_params == 0 || deco_params.len() != target_n + 1) {
        emit_stderr("[ERROR] decorator must have signature: (next: u64, <target params...>) -> <target return>: ");
        emit_stderr_len(deco_ptr, deco_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }

    var next_param: *Param = deco_params.get(0);
    if (next_param.type_kind != TYPE_U64 || next_param.ptr_depth != 0 || next_param.is_variadic != 0 || next_param.has_default != 0) {
        emit_stderr("[ERROR] decorator first parameter must be plain u64 function pointer: ");
        emit_stderr_len(deco_ptr, deco_len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }

    for (var i: u64 = 0; i < target_n; i++) {
        var tp: *Param = target_params.get(i);
        var dp: *Param = deco_params.get(i + 1);
        if (tp.is_variadic != 0 || tp.has_default != 0) {
            emit_stderr("[ERROR] decorated target cannot use variadic/default parameters: ");
            emit_stderr_len(target.name_ptr, target.name_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        if (dp.is_variadic != 0 || dp.has_default != 0) {
            emit_stderr("[ERROR] decorator cannot use variadic/default parameters: ");
            emit_stderr_len(deco_ptr, deco_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        if (compiler_annotation_param_shape_equal(tp, dp) == 0) {
            emit_stderr("[ERROR] decorator parameter list must match target function after the first parameter: ");
            emit_stderr_len(deco_ptr, deco_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
    }
    return 0;
}

func compiler_annotation_build_wrapper_body(template: *AstFunc, decorator_ptr: u64, decorator_len: u64, callee_ptr: u64, callee_len: u64, wrapper_params: *Vec<*Param>) -> *AstNode {
    var n_params: u64 = 0;
    if (wrapper_params != 0) { n_params = wrapper_params.len(); }

    var args: *Vec<*AstNode> = new Vec<*AstNode>(n_params + 1);
    args.push((*AstNode)ast_addr_of((*AstNode)ast_ident(callee_ptr, callee_len)));
    for (var i: u64 = 0; i < n_params; i++) {
        var p: *Param = wrapper_params.get(i);
        args.push((*AstNode)ast_ident(p.name_ptr, p.name_len));
    }

    var call_node: *AstNode = (*AstNode)ast_call_with_origin_named(decorator_ptr, decorator_len, args, 0, AST_CALL_ORIGIN_DIRECT);
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
    if (template.ret_type == TYPE_VOID && template.ret_ptr_depth == 0) {
        stmts.push((*AstNode)ast_expr_stmt(call_node));
    } else {
        stmts.push((*AstNode)ast_return(call_node));
    }
    return (*AstNode)ast_block(stmts);
}

func compiler_annotation_build_wrapper_func(template: *AstFunc, wrapper_name_ptr: u64, wrapper_name_len: u64, decorator_ptr: u64, decorator_len: u64, callee_ptr: u64, callee_len: u64) -> *AstFunc {
    var params_out: *Vec<*Param> = compiler_annotation_clone_params(template.params_vec);
    var body_out: *AstNode = compiler_annotation_build_wrapper_body(template, decorator_ptr, decorator_len, callee_ptr, callee_len, params_out);
    var fn_out: *AstFunc = ast_func_ex(wrapper_name_ptr, wrapper_name_len, params_out,
                                       template.ret_type, template.ret_ptr_depth, template.ret_is_tagged,
                                       template.ret_struct_name_ptr, template.ret_struct_name_len,
                                       template.ret_tag_layout_ptr, template.ret_tag_layout_len, body_out);
    fn_out.annotations_vec = 0;
    return fn_out;
}

func compiler_annotation_rename_first_signature(old_ptr: u64, old_len: u64, new_ptr: u64, new_len: u64) -> u64 {
    if (g_compiler_ctx.all_func_sigs == 0) { return 0; }
    var n: u64 = g_compiler_ctx.all_func_sigs.len();
    for (var i: u64 = 0; i < n; i++) {
        var sig: *AstFunc = g_compiler_ctx.all_func_sigs.get(i);
        if (sig == 0) { continue; }
        if (str_eq(sig.name_ptr, sig.name_len, old_ptr, old_len) == 0) { continue; }
        sig.name_ptr = new_ptr;
        sig.name_len = new_len;
        return 1;
    }
    return 0;
}

func compiler_apply_annotations() -> u64 {
    if (g_compiler_ctx.all_funcs == 0) { return 0; }

    var original_count: u64 = g_compiler_ctx.all_funcs.len();
    var generated_id: u64 = 0;
    var entry_ptr: u64 = 0;
    var entry_len: u64 = 0;

    for (var i: u64 = 0; i < original_count; i++) {
        var fn: *AstFunc = g_compiler_ctx.all_funcs.get(i);
        if (fn == 0) { continue; }

        var entry_count: u64 = compiler_annotation_count_name(fn.annotations_vec, "entry", 5);
        if (entry_count > 0) {
            if (fn.impl_owner_ptr != 0 && fn.impl_owner_len != 0) {
                emit_stderr("[ERROR] @[entry] is only allowed on top-level functions\n");
                compiler_panic("Compilation failed");
            }
            var entry_param_n: u64 = 0;
            if (fn.params_vec != 0) { entry_param_n = fn.params_vec.len(); }
            if (entry_param_n != 0) {
                emit_stderr("[ERROR] @[entry] function must not declare parameters: ");
                emit_stderr_len(fn.name_ptr, fn.name_len);
                emit_stderr("\n");
                compiler_panic("Compilation failed");
            }
            if (entry_count > 1) {
                emit_stderr("[ERROR] duplicate @[entry] annotation on function: ");
                emit_stderr_len(fn.name_ptr, fn.name_len);
                emit_stderr("\n");
                compiler_panic("Compilation failed");
            }
            if (entry_ptr != 0 && str_eq(entry_ptr, entry_len, fn.name_ptr, fn.name_len) == 0) {
                emit_stderr("[ERROR] multiple @[entry] functions are not allowed: ");
                emit_stderr_len(entry_ptr, entry_len);
                emit_stderr(" and ");
                emit_stderr_len(fn.name_ptr, fn.name_len);
                emit_stderr("\n");
                compiler_panic("Compilation failed");
            }
            entry_ptr = fn.name_ptr;
            entry_len = fn.name_len;
        }

        var decorators: *Vec<*NameInfo> = compiler_annotation_collect_decorators(fn);
        if (decorators == 0 || decorators.len() == 0) { continue; }

        if (fn.impl_owner_ptr != 0 && fn.impl_owner_len != 0) {
            emit_stderr("[ERROR] function decorators are currently supported only on top-level functions: ");
            emit_stderr_len(fn.name_ptr, fn.name_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        if (fn.body == 0) {
            emit_stderr("[ERROR] function decorator requires a function body: ");
            emit_stderr_len(fn.name_ptr, fn.name_len);
            emit_stderr("\n");
            compiler_panic("Compilation failed");
        }
        if (compiler_is_generic_template(fn) != 0) {
            // Generic templates are expanded later into concrete instances.
            // Decorators are applied to concrete instantiations only.
            continue;
        }

        var public_name_ptr: u64 = fn.name_ptr;
        var public_name_len: u64 = fn.name_len;

        generated_id = generated_id + 1;
        var hidden_name: *NameInfo = compiler_annotation_build_generated_name("__ann_orig__", 11, public_name_ptr, public_name_len, generated_id);
        fn.name_ptr = hidden_name.ptr;
        fn.name_len = hidden_name.len;
        fn.annotations_vec = 0;

        if (compiler_annotation_rename_first_signature(public_name_ptr, public_name_len, hidden_name.ptr, hidden_name.len) == 0) {
            if (g_compiler_ctx.all_func_sigs != 0) {
                g_compiler_ctx.all_func_sigs.push(compiler_annotation_clone_sig(fn, hidden_name.ptr, hidden_name.len));
            }
        }

        var callee_ptr: u64 = hidden_name.ptr;
        var callee_len: u64 = hidden_name.len;
        var deco_n: u64 = decorators.len();
        for (var rev: u64 = 0; rev < deco_n; rev++) {
            var di: u64 = deco_n - rev - 1;
            var deco: *NameInfo = decorators.get(di);
            var deco_sig: *AstFunc = compiler_find_func_signature_for_call(deco.ptr, deco.len);
            if (deco_sig == 0) {
                emit_stderr("[ERROR] unresolved decorator function: ");
                emit_stderr_len(deco.ptr, deco.len);
                emit_stderr("\n");
                compiler_panic("Compilation failed");
            }
            compiler_annotation_validate_decorator_signature(deco_sig, fn, deco.ptr, deco.len);

            var wrapper_name_ptr: u64 = 0;
            var wrapper_name_len: u64 = 0;
            if (di == 0) {
                wrapper_name_ptr = public_name_ptr;
                wrapper_name_len = public_name_len;
            } else {
                generated_id = generated_id + 1;
                var wrap_name: *NameInfo = compiler_annotation_build_generated_name("__ann_wrap__", 11, public_name_ptr, public_name_len, generated_id);
                wrapper_name_ptr = wrap_name.ptr;
                wrapper_name_len = wrap_name.len;
            }

            var wrapper_fn: *AstFunc = compiler_annotation_build_wrapper_func(fn, wrapper_name_ptr, wrapper_name_len, deco.ptr, deco.len, callee_ptr, callee_len);
            g_compiler_ctx.all_funcs.push(wrapper_fn);
            if (g_compiler_ctx.all_func_sigs != 0) {
                g_compiler_ctx.all_func_sigs.push(compiler_annotation_clone_sig(wrapper_fn, wrapper_name_ptr, wrapper_name_len));
            }
            callee_ptr = wrapper_name_ptr;
            callee_len = wrapper_name_len;
        }
    }

    g_compiler_ctx.entry_func_ptr = entry_ptr;
    g_compiler_ctx.entry_func_len = entry_len;
    compiler_invalidate_func_lookup();
    return 0;
}

func compiler_validate_child_implements_abst_method(sd: *AstStructDef, mi: *NameInfo) -> u64 {
    if (compiler_is_abst_method(sd.name_ptr, sd.name_len, mi.ptr, mi.len) != 0) {
        // Child remains abstract on this method; allowed.
        return 0;
    }
    var found_impl: *AstFunc = compiler_find_method_func_in_hierarchy(sd, mi.ptr, mi.len);
    if (found_impl == 0) {
        emit_stderr("[ERROR] Missing abstract method implementation in child: ");
        emit_stderr_len(sd.name_ptr, sd.name_len);
        emit_stderr(".");
        emit_stderr_len(mi.ptr, mi.len);
        emit_stderr("\n");
        compiler_panic("Compilation failed");
    }
    return 0;
}

func compiler_finalize_abst_methods() -> u64 {
    if (g_compiler_ctx.all_structs_vec == 0) { return 0; }
    var sn: u64 = g_compiler_ctx.all_structs_vec.len();
    for (var si: u64 = 0; si < sn; si++) {
        var sd: *AstStructDef = g_compiler_ctx.all_structs_vec.get(si);
        if (sd == 0 || sd.parents_vec == 0) { continue; }
        var required: *Vec<*NameInfo> = new Vec<*NameInfo>(8);
        compiler_collect_abst_methods_recursive(sd, required);
        var rn: u64 = required.len();
        for (var ri: u64 = 0; ri < rn; ri++) {
            var mi: *NameInfo = required.get(ri);
            compiler_validate_child_implements_abst_method(sd, mi);
        }
    }
    compiler_setup_virtual_dispatch_traits();
    return 0;
}

func compiler_insert_default_constructor(struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    if (g_compiler_ctx.all_funcs == 0 || g_compiler_ctx.all_func_sigs == 0) { return 0; }
    var ctor_name: *NameInfo = _compiler_build_constructor_name(struct_name_ptr, struct_name_len);
    if (compiler_func_exists(ctor_name.ptr, ctor_name.len) != 0) { return 0; }

    var params: *Vec<*Param> = new Vec<*Param>(1);
    params.push(_compiler_make_self_param(struct_name_ptr, struct_name_len));
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(0);
    var body: *AstNode = (*AstNode)ast_block(stmts);
    var fn: *AstFunc = ast_func_ex(ctor_name.ptr, ctor_name.len, params, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
    g_compiler_ctx.all_funcs.push(fn);
    g_compiler_ctx.all_func_sigs.push(fn);
    compiler_invalidate_func_lookup();
    return 0;
}

func compiler_insert_default_constructors() -> u64 {
    var n: u64 = g_compiler_ctx.all_structs_vec.?len();
    if (n == 0) { return 0; }
    for (var i: u64 = 0; i < n; i++) {
        var def: *AstStructDef = g_compiler_ctx.all_structs_vec.get(i);
        if (def == 0) { continue; }
        if (compiler_is_generic_struct_def(def) != 0) { continue; }
        compiler_insert_default_constructor(def.name_ptr, def.name_len);
    }
    return 0;
}

func compiler_expr_has_super_constructor_call(expr: *AstNode) -> u64 {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_FIND_SUPER_CTOR, 0, 0);
    compiler_ast_walker_walk_expr(&walker, expr);
    return walker.found;
}

func compiler_stmt_has_super_constructor_call(stmt: *AstNode) -> u64 {
    var walker: CompilerAstWalker = compiler_ast_walker_new(COMPILER_AST_WALK_FIND_SUPER_CTOR, 0, 0);
    compiler_ast_walker_walk_stmt(&walker, stmt);
    return walker.found;
}

func compiler_insert_auto_super_constructor_chain_for_fn(fn: *AstFunc) -> u64 {
    if (fn == 0) { return 0; }
    if (fn.impl_owner_ptr == 0 || fn.impl_owner_len == 0) { return 0; }

    var method_ptr: u64 = fn.impl_original_name_ptr;
    var method_len: u64 = fn.impl_original_name_len;
    if (method_ptr == 0 || method_len == 0) {
        method_ptr = fn.name_ptr;
        method_len = fn.name_len;
    }
    if (compiler_is_constructor_name(method_ptr, method_len) == 0) { return 0; }

    var owner_def: *AstStructDef = get_struct_def(fn.impl_owner_ptr, fn.impl_owner_len);
    if (owner_def == 0 || owner_def.parents_vec == 0 || owner_def.parents_vec.len() == 0) { return 0; }
    if (compiler_stmt_has_super_constructor_call(fn.body) != 0) { return 0; }

    if (owner_def.parents_vec.len() != 1) {
        emit_stderr("[ERROR] automatic super constructor chaining is ambiguous with multiple parents: ");
        emit_stderr_len(owner_def.name_ptr, owner_def.name_len);
        emit_stderr("\n");
        panic("Compiler error");
    }

    var parent_desc: *ParentDesc = owner_def.parents_vec.get(0);
    var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
    var parent_ctor: CompilerMethodResolveResult = compiler_resolve_method_overload(parent_def.name_ptr, parent_def.name_len, "constructor", 11, 0, 0);
    if (parent_ctor.found == 0) {
        emit_stderr("[ERROR] parent constructor() is required for automatic super chaining: ");
        emit_stderr_len(parent_def.name_ptr, parent_def.name_len);
        emit_stderr("\n");
        panic("Compiler error");
    }

    var injected_args: *Vec<*AstNode> = new Vec<*AstNode>(0);
    var injected_call: *AstMethodCall = ast_method_call((*AstNode)ast_super(), "constructor", 11, injected_args);
    var injected_stmt: *AstNode = (*AstNode)ast_expr_stmt((*AstNode)injected_call);

    if (fn.body == 0) {
        var only_stmts: *Vec<*AstNode> = new Vec<*AstNode>(1);
        only_stmts.push(injected_stmt);
        fn.body = (*AstNode)ast_block(only_stmts);
        return 0;
    }

    if (ast_kind(fn.body) != AST_BLOCK) {
        var wrapped_stmts: *Vec<*AstNode> = new Vec<*AstNode>(2);
        wrapped_stmts.push(injected_stmt);
        wrapped_stmts.push(fn.body);
        fn.body = (*AstNode)ast_block(wrapped_stmts);
        return 0;
    }

    var body_block: *AstBlock = (*AstBlock)fn.body;
    var old_stmts: *Vec<*AstNode> = body_block.stmts_vec;
    if (old_stmts == 0) {
        old_stmts = new Vec<*AstNode>(1);
    }
    var old_len: u64 = old_stmts.len();
    var new_stmts: *Vec<*AstNode> = new Vec<*AstNode>(old_len + 1);
    new_stmts.push(injected_stmt);
    for (var i2: u64 = 0; i2 < old_len; i2++) {
        new_stmts.push(old_stmts.get(i2));
    }
    body_block.stmts_vec = new_stmts;
    return 0;
}

func compiler_insert_auto_super_constructor_chains() -> u64 {
    if (g_compiler_ctx.all_funcs == 0) { return 0; }
    var n: u64 = g_compiler_ctx.all_funcs.len();
    for (var i: u64 = 0; i < n; i++) {
        compiler_insert_auto_super_constructor_chain_for_fn(g_compiler_ctx.all_funcs.get(i));
    }
    return 0;
}

func compiler_insert_global_init_func() -> u64 {
    if (compiler_has_runtime_global_init() == 0) { return 0; }
    if (compiler_func_exists("__global_init", 13)) { return 0; }

    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var n: u64 = g_compiler_ctx.all_globals.len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = g_compiler_ctx.all_globals.get(i);
        if (ginfo.init_kind != GLOBAL_INIT_RUNTIME) { continue; }
        var init_expr: *AstNode = (*AstNode)ginfo.init_expr;
        if (init_expr == 0) {
            emit_stderr("[ERROR] runtime global init expr missing\n");
            compiler_panic("Compilation failed");
        }
        var target: *AstNode = (*AstNode)ast_ident(ginfo.name_ptr, ginfo.name_len);
        var assign: *AstAssign = ast_assign(target, init_expr);
        stmts.push((*AstNode)assign);
    }

    if (stmts.len() == 0) { return 0; }

    var block: *AstNode = (*AstNode)ast_block(stmts);
    var params: *Vec<*Param> = new Vec<*Param>(0);
    var fn: *AstFunc = ast_func("__global_init", 13, params, TYPE_VOID, block);
    g_compiler_ctx.all_funcs.push(fn);
    g_compiler_ctx.all_func_sigs.push(fn);
    compiler_invalidate_func_lookup();
    return 0;
}

func setup_paths_with_compiler(filename: u64, filename_len: u64) -> u64 {
    compiler_ctx_reset_state();
    g_compiler_ctx.base_dir = path_dirname(filename, filename_len);
    g_compiler_ctx.base_dir_len = str_len(g_compiler_ctx.base_dir);
    g_compiler_ctx.project_dir = g_compiler_ctx.base_dir;
    g_compiler_ctx.project_dir_len = g_compiler_ctx.base_dir_len;
    g_compiler_ctx.lib_dir = 0;
    g_compiler_ctx.lib_dir_len = 0;
    g_compiler_ctx.tool_nasm_path = 0;
    g_compiler_ctx.tool_ld_path = 0;

    // Optional package manifest (`bpp.toml`) discovered upward from source dir.
    // Supported keys (simple key=value):
    // - module_root=...
    // - std_root=...
    // - version=...
    // - nasm_path=...
    // - ld_path=...
    var manifest_path: u64 = compiler_find_manifest_path(g_compiler_ctx.base_dir, g_compiler_ctx.base_dir_len);
    if (manifest_path != 0) {
        var manifest_len: u64 = str_len(manifest_path);
        var manifest_dir: u64 = path_dirname(manifest_path, manifest_len);
        var manifest_dir_len: u64 = str_len(manifest_dir);

        var module_root_val: u64 = read_manifest_value(manifest_path, "module_root=", 12);
        if (module_root_val != 0) {
            g_compiler_ctx.project_dir = compiler_manifest_resolve_path(manifest_dir, manifest_dir_len, module_root_val);
            g_compiler_ctx.project_dir_len = str_len(g_compiler_ctx.project_dir);
        }

        var std_root_val: u64 = read_manifest_value(manifest_path, "std_root=", 9);
        if (std_root_val != 0) {
            g_compiler_ctx.lib_dir = compiler_manifest_resolve_path(manifest_dir, manifest_dir_len, std_root_val);
            g_compiler_ctx.lib_dir_len = str_len(g_compiler_ctx.lib_dir);
        } else {
            var version_val: u64 = read_manifest_value(manifest_path, "version=", 8);
            if (version_val != 0) {
                var v_len: u64 = str_len(version_val);
                var version_src_rel: u64 = str_concat3(version_val, v_len, "/", 1, "src", 3);
                g_compiler_ctx.lib_dir = compiler_manifest_resolve_path(manifest_dir, manifest_dir_len, version_src_rel);
                g_compiler_ctx.lib_dir_len = str_len(g_compiler_ctx.lib_dir);
            }
        }

        g_compiler_ctx.tool_nasm_path = read_manifest_value(manifest_path, "nasm_path=", 10);
        g_compiler_ctx.tool_ld_path = read_manifest_value(manifest_path, "ld_path=", 8);
    }

    if (g_compiler_ctx.lib_dir != 0 && g_compiler_ctx.lib_dir_len != 0) {
        return 0;
    }

    if (compiler_try_autodetect_lib_dir(g_compiler_ctx.base_dir, g_compiler_ctx.base_dir_len) != 0) {
        return 0;
    }

    emit_stderr("[ERROR] Could not determine std root.\n");
    emit_stderr("[ERROR] Provide std_root in bpp.toml or place sources under a tree that contains src/std.\n");
    panic("Path setup error");
    return 0;
}

func compiler_get_nasm_path() -> u64 {
    return g_compiler_ctx.tool_nasm_path;
}

func compiler_get_ld_path() -> u64 {
    return g_compiler_ctx.tool_ld_path;
}

func compiler_get_entry_func_ptr() -> u64 {
    if (g_compiler_ctx.entry_func_ptr != 0 && g_compiler_ctx.entry_func_len != 0) {
        return g_compiler_ctx.entry_func_ptr;
    }
    return (u64)"main";
}

func compiler_get_entry_func_len() -> u64 {
    if (g_compiler_ctx.entry_func_ptr != 0 && g_compiler_ctx.entry_func_len != 0) {
        return g_compiler_ctx.entry_func_len;
    }
    return 4;
}

func build_merged_program() -> *AstProgram {
    var dummy_imports: *Vec<u64> = new Vec<u64>(1);
    var merged_prog: *AstProgram = ast_program(g_compiler_ctx.all_funcs, g_compiler_ctx.all_consts, dummy_imports);
    merged_prog.globals_vec = g_compiler_ctx.all_globals;
    merged_prog.structs_vec = g_compiler_ctx.all_structs_vec;
    return merged_prog;
}

func get_func_sigs() -> *Vec<*AstFunc> {
    return g_compiler_ctx.all_func_sigs;
}
