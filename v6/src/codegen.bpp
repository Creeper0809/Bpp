// codegen.b - Code generator wrapper for v3.13
//
// This is a thin wrapper that re-exports functionality from:
// - symtab.b: Symbol table management
// - typeinfo.b: Type size/compatibility calculations
// - emitter.b: ASM output helpers and global state
// - gen_expr.b: Expression code generation
// - gen_stmt.b: Statement code generation

import std.io;
import std.util;
import std.str;
import types;
import std.vec;
import ast;
import compiler;
import ssa.datastruct;
import ssa;
import ssa.mem2reg;
import ssa.opt_o1;
import ssa.destroy;
import ssa.regalloc;
import ssa.lower_phys;
import ssa.codegen;
import ssa.dump;
import opt;
import emitter.symtab;
import emitter.typeinfo;
import emitter.emitter;
import emitter.gen_expr;
import emitter.gen_stmt;

const CODEGEN_DEBUG = 0;

const CG_USED_HAS_CALL_PTR = 1;
const CG_USED_HAS_METHOD_CALL = 2;
const CG_USED_HAS_FUNC_ADDR = 4;

func _cg_used_mark_flag(flags_ptr: u64, mask: u64) -> u64 {
    *(flags_ptr) = *(flags_ptr) | mask;
    return 0;
}

func _cg_used_has_name(used: *Vec<*NameInfo>, name_ptr: u64, name_len: u64) -> u64 {
    if (used == 0) { return false; }
    var n: u64 = used->len();
    for (var i: u64 = 0; i < n; i++) {
        var info: *NameInfo = used->get(i);
        var ptr: u64 = info->ptr;
        var len: u64 = info->len;
        if (len == name_len && str_eq(ptr, len, name_ptr, name_len) != 0) { return true; }
    }
    return false;
}

func _cg_used_add_name(used: *Vec<*NameInfo>, name_ptr: u64, name_len: u64) -> u64 {
    if (_cg_used_has_name(used, name_ptr, name_len) != 0) { return false; }
    var info: *NameInfo = new NameInfo{name_ptr, name_len};
    used->push(info);
    return true;
}

func _cg_used_add_resolved_name(used: *Vec<*NameInfo>, name_ptr: u64, name_len: u64) -> u64 {
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        name_ptr = resolved->ptr;
        name_len = resolved->len;
    }
    return _cg_used_add_name(used, name_ptr, name_len);
}

func _cg_collect_calls_in_expr(node: u64, used: *Vec<*NameInfo>, flags_ptr: u64) -> u64 {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);

    if (kind == AST_CALL) {
        var call: *AstCall = (*AstCall)node;
        _cg_used_add_resolved_name(used, call->name_ptr, call->name_len);
        var args: *Vec<*AstNode> = call->args_vec;
        if (args != 0) {
            var n: u64 = args->len();
            for (var i: u64 = 0; i < n; i++) {
                _cg_collect_calls_in_expr(args->get(i), used, flags_ptr);
            }
        }
        return 0;
    }

    if (kind == AST_CALL_PTR) {
        var cp: *AstCallPtr = (*AstCallPtr)node;
        _cg_used_mark_flag(flags_ptr, CG_USED_HAS_CALL_PTR);
        _cg_collect_calls_in_expr(cp->callee, used, flags_ptr);
        var args2: *Vec<*AstNode> = cp->args_vec;
        if (args2 != 0) {
            var n2: u64 = args2->len();
            for (var j: u64 = 0; j < n2; j++) {
                _cg_collect_calls_in_expr(args2->get(j), used, flags_ptr);
            }
        }
        return 0;
    }

    if (kind == AST_METHOD_CALL) {
        var mc: *AstMethodCall = (*AstMethodCall)node;
        _cg_used_mark_flag(flags_ptr, CG_USED_HAS_METHOD_CALL);
        _cg_collect_calls_in_expr(mc->receiver, used, flags_ptr);
        var args3: *Vec<*AstNode> = mc->args_vec;
        if (args3 != 0) {
            var n3: u64 = args3->len();
            for (var k: u64 = 0; k < n3; k++) {
                _cg_collect_calls_in_expr(args3->get(k), used, flags_ptr);
            }
        }
        return 0;
    }

    if (kind == AST_BINARY) {
        var bin: *AstBinary = (*AstBinary)node;
        _cg_collect_calls_in_expr(bin->left, used, flags_ptr);
        _cg_collect_calls_in_expr(bin->right, used, flags_ptr);
        return 0;
    }

    if (kind == AST_UNARY) {
        var un: *AstUnary = (*AstUnary)node;
        _cg_collect_calls_in_expr(un->operand, used, flags_ptr);
        return 0;
    }

    if (kind == AST_ADDR_OF) {
        var ao: *AstAddrOf = (*AstAddrOf)node;
        var op_kind: u64 = ast_kind(ao->operand);
        if (op_kind == AST_IDENT) {
            var idn: *AstIdent = (*AstIdent)ao->operand;
            if (compiler_func_exists(idn->name_ptr, idn->name_len) != 0) {
                _cg_used_mark_flag(flags_ptr, CG_USED_HAS_FUNC_ADDR);
            }
        }
        _cg_collect_calls_in_expr(ao->operand, used, flags_ptr);
        return 0;
    }

    if (kind == AST_DEREF) {
        var dr: *AstDeref = (*AstDeref)node;
        _cg_collect_calls_in_expr(dr->operand, used, flags_ptr);
        return 0;
    }

    if (kind == AST_DEREF8) {
        var dr8: *AstDeref8 = (*AstDeref8)node;
        _cg_collect_calls_in_expr(dr8->operand, used, flags_ptr);
        return 0;
    }

    if (kind == AST_INDEX) {
        var ix: *AstIndex = (*AstIndex)node;
        _cg_collect_calls_in_expr(ix->base, used, flags_ptr);
        _cg_collect_calls_in_expr(ix->index, used, flags_ptr);
        return 0;
    }

    if (kind == AST_CAST) {
        var ca: *AstCast = (*AstCast)node;
        _cg_collect_calls_in_expr(ca->expr, used, flags_ptr);
        return 0;
    }

    if (kind == AST_MEMBER_ACCESS) {
        var ma: *AstMemberAccess = (*AstMemberAccess)node;
        _cg_collect_calls_in_expr(ma->object, used, flags_ptr);
        return 0;
    }

    if (kind == AST_ASSIGN) {
        var asg2: *AstAssign = (*AstAssign)node;
        _cg_collect_calls_in_expr(asg2->target, used, flags_ptr);
        _cg_collect_calls_in_expr(asg2->value, used, flags_ptr);
        return 0;
    }

    if (kind == AST_NEW) {
        var nw: *AstNew = (*AstNew)node;
        _cg_used_add_resolved_name(used, (u64)"malloc", 6);
        _cg_used_add_resolved_name(used, (u64)"memset", 6);

        if (nw->literal_expr != 0) {
            _cg_collect_calls_in_expr(nw->literal_expr, used, flags_ptr);
        }

        if (nw->ctor_args_vec != 0 && nw->type_kind == TYPE_STRUCT) {
            var method_ptr: u64 = (u64)"constructor";
            var method_len: u64 = 11;
            var base_len: u64 = compiler_find_generic_suffix_index(nw->struct_name_ptr, nw->struct_name_len);
            var suffix_len: u64 = nw->struct_name_len - base_len;
            var full_len: u64 = base_len + 1 + method_len + suffix_len;
            var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
            var full_u8: []u8 = slice(full_ptr, full_len + 1);
            var struct_u8: []u8 = slice(nw->struct_name_ptr, nw->struct_name_len);
            var method_u8: []u8 = slice(method_ptr, method_len);
            for (var i: u64 = 0; i < base_len; i++) {
                full_u8[i] = struct_u8[i];
            }
            full_u8[base_len] = 95;
            for (var j: u64 = 0; j < method_len; j++) {
                full_u8[base_len + 1 + j] = method_u8[j];
            }
            for (var k: u64 = 0; k < suffix_len; k++) {
                full_u8[base_len + 1 + method_len + k] = struct_u8[base_len + k];
            }
            full_u8[full_len] = 0;
            _cg_used_add_resolved_name(used, full_ptr, full_len);

            var args: *Vec<*AstNode> = nw->ctor_args_vec;
            var n5: u64 = args->len();
            for (var t5: u64 = 0; t5 < n5; t5++) {
                _cg_collect_calls_in_expr(args->get(t5), used, flags_ptr);
            }
        }
        return 0;
    }

    if (kind == AST_STRUCT_LITERAL) {
        var st: *AstStructLiteral = (*AstStructLiteral)node;
        var vals: *Vec<*AstNode> = st->values_vec;
        if (vals != 0) {
            var n4: u64 = vals->len();
            for (var t: u64 = 0; t < n4; t++) {
                _cg_collect_calls_in_expr(vals->get(t), used, flags_ptr);
            }
        }
        return 0;
    }

    return 0;
}

func _cg_collect_calls_in_stmt(node: u64, used: *Vec<*NameInfo>, flags_ptr: u64) -> u64 {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);

    if (kind == AST_RETURN) {
        var r: *AstReturn = (*AstReturn)node;
        _cg_collect_calls_in_expr(r->expr, used, flags_ptr);
        return 0;
    }

    if (kind == AST_VAR_DECL) {
        var vd: *AstVarDecl = (*AstVarDecl)node;
        _cg_collect_calls_in_expr(vd->init_expr, used, flags_ptr);
        return 0;
    }

    if (kind == AST_CONST_DECL) {
        var cd: *AstConstDecl = (*AstConstDecl)node;
        _cg_collect_calls_in_expr(cd->value, used, flags_ptr);
        return 0;
    }

    if (kind == AST_ASSIGN) {
        var asg: *AstAssign = (*AstAssign)node;
        _cg_collect_calls_in_expr(asg->target, used, flags_ptr);
        _cg_collect_calls_in_expr(asg->value, used, flags_ptr);
        return 0;
    }

    if (kind == AST_DELETE) {
        var dl: *AstDelete = (*AstDelete)node;
        _cg_used_mark_flag(flags_ptr, CG_USED_HAS_METHOD_CALL);
        _cg_used_add_resolved_name(used, (u64)"free", 4);
        if (dl->expr != 0) {
            _cg_collect_calls_in_expr(dl->expr, used, flags_ptr);
        }
        return 0;
    }

    if (kind == AST_EXPR_STMT) {
        var es: *AstExprStmt = (*AstExprStmt)node;
        _cg_collect_calls_in_expr(es->expr, used, flags_ptr);
        return 0;
    }

    if (kind == AST_DEFER) {
        var df: *AstDefer = (*AstDefer)node;
        _cg_collect_calls_in_stmt((u64)df->stmt, used, flags_ptr);
        return 0;
    }

    if (kind == AST_IF) {
        var ifs: *AstIf = (*AstIf)node;
        _cg_collect_calls_in_expr(ifs->cond, used, flags_ptr);
        _cg_collect_calls_in_stmt(ifs->then_block, used, flags_ptr);
        _cg_collect_calls_in_stmt(ifs->else_block, used, flags_ptr);
        return 0;
    }

    if (kind == AST_WHILE) {
        var wl: *AstWhile = (*AstWhile)node;
        _cg_collect_calls_in_expr(wl->cond, used, flags_ptr);
        _cg_collect_calls_in_stmt(wl->body, used, flags_ptr);
        return 0;
    }

    if (kind == AST_FOR) {
        var fr: *AstFor = (*AstFor)node;
        _cg_collect_calls_in_stmt(fr->init, used, flags_ptr);
        _cg_collect_calls_in_expr(fr->cond, used, flags_ptr);
        _cg_collect_calls_in_stmt(fr->update, used, flags_ptr);
        _cg_collect_calls_in_stmt(fr->body, used, flags_ptr);
        return 0;
    }

    if (kind == AST_SWITCH) {
        var sw: *AstSwitch = (*AstSwitch)node;
        _cg_collect_calls_in_expr(sw->expr, used, flags_ptr);
        var cases: *Vec<*AstCase> = sw->cases_vec;
        var has_string_case: u64 = 0;
        if (cases != 0) {
            var n5: u64 = cases->len();
            for (var c: u64 = 0; c < n5; c++) {
                var cs: *AstCase = cases->get(c);
                if (cs->is_default == 0) {
                    if (ast_kind(cs->value) == AST_STRING) {
                        has_string_case = 1;
                    }
                    _cg_collect_calls_in_expr(cs->value, used, flags_ptr);
                }
                _cg_collect_calls_in_stmt(cs->body, used, flags_ptr);
            }
        }
        if (has_string_case == 1) {
            _cg_used_add_resolved_name(used, (u64)"str_len", 7);
            _cg_used_add_resolved_name(used, (u64)"str_eq", 6);
        }
        return 0;
    }

    if (kind == AST_BLOCK) {
        var blk: *AstBlock = (*AstBlock)node;
        var stmts: *Vec<*AstNode> = blk->stmts_vec;
        if (stmts != 0) {
            var n6: u64 = stmts->len();
            for (var s: u64 = 0; s < n6; s++) {
                _cg_collect_calls_in_stmt(stmts->get(s), used, flags_ptr);
            }
        }
        return 0;
    }

    return 0;
}

func _cg_collect_calls_in_func(fn: *AstFunc, used: *Vec<*NameInfo>, flags_ptr: u64) -> u64 {
    if (fn == 0) { return 0; }
    _cg_collect_calls_in_stmt(fn->body, used, flags_ptr);
    return 0;
}

func _cg_collect_used_func_names(program: *AstProgram, used: *Vec<*NameInfo>, flags_ptr: u64) -> u64 {
    if (program == 0) { return 0; }
    var funcs: *Vec<*AstFunc> = program->funcs_vec;
    if (funcs == 0) { return 0; }

    _cg_used_add_name(used, (u64)"main", 4);

    var changed: u64 = 1;
    while (changed != 0) {
        changed = 0;
        var n: u64 = funcs->len();
        for (var i: u64 = 0; i < n; i++) {
            var fn: *AstFunc = funcs->get(i);
            var fn_ptr: u64 = (u64)fn;
            if (_cg_used_has_name(used, fn->name_ptr, fn->name_len) != 0) {
                set_current_module_for_func(fn->name_ptr, fn->name_len);
                var before: u64 = used->len();
                _cg_collect_calls_in_func(fn, used, flags_ptr);
                if (used->len() != before) { changed = 1; }
            }
        }
    }
    return 0;
}

func cg_is_generic_template(fn: *AstFunc) -> u64 {
    if (fn == 0) { return false; }
    if (compiler_is_generic_func_ptr(fn) != 0) { return true; }
    if (fn->ret_type == TYPE_GENERIC) { return true; }

    var params: *Vec<*Param> = fn->params_vec;
    if (params != 0) {
        var n: u64 = params->len();
        for (var i: u64 = 0; i < n; i++) {
            var p: *Param = params->get(i);
            if (p->type_kind == TYPE_GENERIC) { return true; }
            if (p->elem_type_kind == TYPE_GENERIC) { return true; }
            if (p->array_len_is_param != 0) { return true; }
        }
    }
    return false;
}

// ============================================
// Function Codegen
// ============================================

// Function parameter layout (48 bytes)
struct FuncParam {
    name_ptr: u64;
    name_len: u64;
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
}

func _cg_sysv_emit_arg_reg_name(idx: u64) -> u64 {
    if (idx == 0) { emit("rdi", 3); return 0; }
    if (idx == 1) { emit("rsi", 3); return 0; }
    if (idx == 2) { emit("rdx", 3); return 0; }
    if (idx == 3) { emit("rcx", 3); return 0; }
    if (idx == 4) { emit("r8", 2); return 0; }
    if (idx == 5) { emit("r9", 2); return 0; }
    return 0;
}

func _cg_sysv_store_arg_word(arg_idx: u64, dst_offset: u64) -> u64 {
    if (arg_idx < 6) {
        emit("    mov [rbp", 12);
        if (dst_offset < 0) { emit_i64(dst_offset); }
        else { emit("+", 1); emit_u64(dst_offset); }
        emit("], ", 3);
        _cg_sysv_emit_arg_reg_name(arg_idx);
        emit_nl();
        return 0;
    }
    var src_offset: u64 = 16 + (arg_idx - 6) * 8;
    emit("    mov rax, [rbp+", 20);
    emit_u64(src_offset);
    emit("]\n", 2);
    emit("    mov [rbp", 12);
    if (dst_offset < 0) { emit_i64(dst_offset); }
    else { emit("+", 1); emit_u64(dst_offset); }
    emit("], rax\n", 7);
    return 0;
}

func cg_func(fn: *AstFunc) -> u64 {
    if (fn == 0) { return 0; }

    compiler_reg_alias_reset();
    set_current_module_for_func(fn->name_ptr, fn->name_len);
    
    // Store return type information
    emitter_set_ret_type(fn->ret_type);
    emitter_set_ret_ptr_depth(fn->ret_ptr_depth);
    emitter_set_ret_struct_name(fn->ret_struct_name_ptr, fn->ret_struct_name_len);
    
    var g_symtab: *Symtab = emitter_get_symtab();
    symtab_clear(g_symtab);

    emit(fn->name_ptr, fn->name_len);
    emit(":\n", 2);
    
    emitln("    push rbp");
    emitln("    mov rbp, rsp");
    emitln("    sub rsp, 2048");
    
    var g_structs_vec: *Vec<*AstStructDef> = typeinfo_get_structs();
    
    var nparams: u64 = fn->params_vec->len();
    var arg_word_index: u64 = 0;
    if (fn->ret_type == TYPE_STRUCT && fn->ret_ptr_depth == 0) {
        var ret_struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, fn->ret_struct_name_ptr, fn->ret_struct_name_len);
        if (ret_struct_size > 16) { arg_word_index = 1; }
    }
    for(var i: u64 = 0 ; i < nparams ; i++){
        var p: *Param = fn->params_vec->get(i);
        var param_size: u64 = 8;
        if (p->type_kind == TYPE_SLICE && p->ptr_depth == 0) {
            param_size = 16;
        } else if (p->type_kind == TYPE_STRUCT && p->ptr_depth == 0) {
            param_size = sizeof_type(TYPE_STRUCT, 0, p->struct_name_ptr, p->struct_name_len);
            var param_rem: u64 = param_size % 8;
            if (param_rem != 0) {
                param_size = param_size + (8 - param_rem);
            }
        }
        var offset: u64 = symtab_add(g_symtab, p->name_ptr, p->name_len, p->type_kind, p->ptr_depth, param_size);
        var ti: *TypeInfo = symtab_get_type(g_symtab, p->name_ptr, p->name_len);
        ti->type_kind = p->type_kind;
        ti->ptr_depth = p->ptr_depth;
        ti->is_tagged = p->is_tagged;
        ti->struct_name_ptr = p->struct_name_ptr;
        ti->struct_name_len = p->struct_name_len;
        ti->tag_layout_ptr = p->tag_layout_ptr;
        ti->tag_layout_len = p->tag_layout_len;
        ti->struct_def = 0;
        ti->elem_type_kind = p->elem_type_kind;
        ti->elem_ptr_depth = p->elem_ptr_depth;
        ti->array_len = p->array_len;

        // If this is a struct, resolve its struct_def now
        // This applies even for pointer types (*Point) - we store the base struct def
        if (p->type_kind == TYPE_STRUCT && g_structs_vec != 0 && p->struct_name_ptr != 0) {
            var num_structs: u64 = g_structs_vec->len();
            for(var si: u64 = 0 ; si < num_structs ; si++){
                var sd: *AstStructDef = g_structs_vec->get(si);
                if (sd->name_len == p->struct_name_len && str_eq(sd->name_ptr, sd->name_len, p->struct_name_ptr, p->struct_name_len) != 0) {
                    ti->struct_def = sd;
                    break;
                }
            }
        }
        if (p->elem_type_kind == TYPE_STRUCT && g_structs_vec != 0 && p->struct_name_ptr != 0) {
            var num_structs2: u64 = g_structs_vec->len();
            for(var sj: u64 = 0 ; sj < num_structs2 ; sj++){
                var sd2: *AstStructDef = g_structs_vec->get(sj);
                if (sd2->name_len == p->struct_name_len && str_eq(sd2->name_ptr, sd2->name_len, p->struct_name_ptr, p->struct_name_len) != 0) {
                    ti->struct_def = sd2;
                    break;
                }
            }
        }

        if (p->type_kind == TYPE_STRUCT && p->ptr_depth == 0) {
            var struct_size_copy: u64 = sizeof_type(TYPE_STRUCT, 0, p->struct_name_ptr, p->struct_name_len);
            if (struct_size_copy > 16) {
                if (arg_word_index < 6) {
                    emit("    mov rax, ", 13);
                    _cg_sysv_emit_arg_reg_name(arg_word_index);
                    emit_nl();
                } else {
                    var src_offset: u64 = 16 + (arg_word_index - 6) * 8;
                    emit("    mov rax, [rbp+", 20);
                    emit_u64(src_offset);
                    emit("]\n", 2);
                }

                emit("    lea rbx, [rbp", 17);
                if (offset < 0) { emit_i64(offset); }
                else { emit("+", 1); emit_u64(offset); }
                emit("]\n", 2);

                var off_copy: u64 = 0;
                while (off_copy + 8 <= struct_size_copy) {
                    emit("    mov rcx, [rax", 18);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("]\n", 2);
                    emit("    mov [rbx", 12);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("], rcx\n", 7);
                    off_copy = off_copy + 8;
                }
                var rem_copy: u64 = struct_size_copy - off_copy;
                if (rem_copy >= 4) {
                    emit("    mov ecx, [rax", 18);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("]\n", 2);
                    emit("    mov [rbx", 12);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("], ecx\n", 7);
                    off_copy = off_copy + 4;
                    rem_copy = rem_copy - 4;
                }
                if (rem_copy >= 2) {
                    emit("    mov cx, [rax", 16);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("]\n", 2);
                    emit("    mov [rbx", 12);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("], cx\n", 6);
                    off_copy = off_copy + 2;
                    rem_copy = rem_copy - 2;
                }
                if (rem_copy >= 1) {
                    emit("    mov cl, [rax", 16);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("]\n", 2);
                    emit("    mov [rbx", 12);
                    if (off_copy != 0) { emit("+", 1); emit_u64(off_copy); }
                    emit("], cl\n", 6);
                }

                arg_word_index = arg_word_index + 1;
                continue;
            }
        }

        if (p->type_kind == TYPE_SLICE && p->ptr_depth == 0) {
            _cg_sysv_store_arg_word(arg_word_index, offset);
            _cg_sysv_store_arg_word(arg_word_index + 1, offset + 8);
            arg_word_index = arg_word_index + 2;
        } else if (p->type_kind == TYPE_STRUCT && p->ptr_depth == 0) {
            var struct_size: u64 = sizeof_type(TYPE_STRUCT, 0, p->struct_name_ptr, p->struct_name_len);
            if (struct_size <= 8) {
                _cg_sysv_store_arg_word(arg_word_index, offset);
                arg_word_index = arg_word_index + 1;
            } else if (struct_size <= 16) {
                _cg_sysv_store_arg_word(arg_word_index, offset);
                _cg_sysv_store_arg_word(arg_word_index + 1, offset + 8);
                arg_word_index = arg_word_index + 2;
            } else {
                _cg_sysv_store_arg_word(arg_word_index, offset);
                arg_word_index = arg_word_index + 1;
            }
        } else {
            _cg_sysv_store_arg_word(arg_word_index, offset);
            arg_word_index = arg_word_index + 1;
        }
    }
    
    cg_block(fn->body);
    
    emitln("   xor eax, eax");
    emitln("    mov rsp, rbp");
    emitln("    pop rbp");
    emitln("   ret");
}

// ============================================
// Program Codegen
// ============================================

func _cg_program_has_runtime_global_init(program: *AstProgram) -> u64 {
    if (program == 0) { return false; }
    if (program->globals_vec == 0) { return false; }
    var n: u64 = program->globals_vec->len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = program->globals_vec->get(i);
        if (ginfo->init_kind == GLOBAL_INIT_RUNTIME) { return true; }
    }
    return false;
}

func cg_program_with_sigs(prog: *AstProgram, sigs: *Vec<*AstFunc>) -> u64 {
    push_trace("cg_program_with_sigs", "codegen.b", __LINE__);

    var program: *AstProgram = prog;

    var used_names: *Vec<*NameInfo> = 0;
    var has_runtime_init: u64 = _cg_program_has_runtime_global_init(program);
    if (opt_get_level() >= 1) {
        used_names = new Vec<*NameInfo>(64);
        var used_flags: u64 = 0;
        _cg_collect_used_func_names(program, used_names, &used_flags);
        if ((used_flags & (CG_USED_HAS_CALL_PTR | CG_USED_HAS_METHOD_CALL | CG_USED_HAS_FUNC_ADDR)) != 0) {
            used_names = 0;
        }
    }
    if (used_names != 0 && has_runtime_init != 0) {
        _cg_used_add_resolved_name(used_names, (u64)"__global_init", 13);
    }

    // SSA CFG scaffold (no codegen impact unless SSA/opt enabled)
    typeinfo_set_structs(program->structs_vec);
    typeinfo_set_funcs(sigs);
    var ssa_ctx_ptr: *SSAContext = 0;
    var ssa_ctx: *SSAContext = 0;
    var ir_mode: u64 = opt_get_ir_mode();
    var out_mode: u64 = opt_get_output_mode();
    var use_ir: u64 = 0;
    if (ir_mode != IR_NONE) { use_ir = 1; }
    var use_ssa: u64 = 0;
    if (out_mode == OUT_IR) { use_ssa = 1; }

    if (use_ssa != 0) {
        ssa_ctx_ptr = ssa_builder_build_program(prog);
        ssa_ctx = ssa_ctx_ptr;
        ssa_mem2reg_run(ssa_ctx_ptr);
        if (CODEGEN_DEBUG != 0) {
            println("[DEBUG] codegen: mem2reg", 25);
        }
        if (opt_get_level() >= 1) {
            ssa_opt_o1_run(ssa_ctx_ptr);
            if (CODEGEN_DEBUG != 0) {
                println("[DEBUG] codegen: opt_o1", 25);
            }
        }
        ssa_destroy_run(ssa_ctx_ptr);
        if (CODEGEN_DEBUG != 0) {
            println("[DEBUG] codegen: destroy", 25);
        }
        ssa_regalloc_run(ssa_ctx_ptr, 8);
        if (CODEGEN_DEBUG != 0) {
            println("[DEBUG] codegen: regalloc", 26);
        }
        ssa_lower_phys_run(ssa_ctx_ptr);
        if (CODEGEN_DEBUG != 0) {
            println("[DEBUG] codegen: lower_phys", 27);
        }
    }

    // Initialize emitter state
    emitter_init();

    // Set structs and functions for typeinfo module
    typeinfo_set_structs(program->structs_vec);
    typeinfo_set_funcs(sigs);
    
    // Set globals
    if (program->globals_vec == 0) {
        var globals_vec: *Vec<*GlobalInfo> = new Vec<*GlobalInfo>(32);
        emitter_set_globals(globals_vec);
    } else {
        emitter_set_globals(program->globals_vec);
    }
    compiler_set_all_globals(emitter_get_globals());
    
    // Copy constants
    var g_consts: *Vec<*ConstInfo> = emitter_get_consts();
    var consts_vec: *Vec<*AstConstDecl> = program->consts_vec;
    for(var ci: u64 = 0; ci < consts_vec->len(); ci++){
        var c: *AstConstDecl = consts_vec->get(ci);
        var cinfo: *ConstInfo = new ConstInfo{c->name_ptr, c->name_len, c->value};
        g_consts->push(cinfo);
    }
    
    emitln("default rel");
    emitln("section .text");
    emitln("global _start");
    emitln("_start:");
    if (has_runtime_init != 0) {
        emitln("    call __global_init");
    }
    emitln("    pop rdi          ; argc");
    emitln("    mov rsi, rsp     ; argv");
    emitln("    push rsi");
    emitln("    push rdi");
    emitln("    call main");
    emitln("    mov rdi, rax");
    emitln("    mov rax, 60");
    emitln("    syscall");
    
    var ssa_funcs: []*SSAFunction = slice(0, 0);
    if (use_ssa != 0) {
        ssa_funcs = ssa_ctx->funcs;
    }
    for(var i : u64 = 0; i < program->funcs_vec->len(); i++){
        var fn: *AstFunc = program->funcs_vec->get(i);
        if (cg_is_generic_template(fn) != 0) {
            continue;
        }
        if (used_names != 0 && _cg_used_has_name(used_names, fn->name_ptr, fn->name_len) == 0) {
            continue;
        }
        if (use_ssa != 0) {
            var ssa_fn_ptr: *SSAFunction = ssa_funcs[i];
            if (ssa_codegen_is_supported_func(fn, program->globals_vec) != 0) {
                ssa_codegen_emit_func(fn, (u64)ssa_fn_ptr);
            } else {
                cg_func(fn);
            }
        } else {
            cg_func(fn);
        }
    }
    
    globals_emit_data();
    string_emit_data();
    globals_emit_bss();
    
    pop_trace();
}

func cg_program_with_sigs_ir(prog: *AstProgram, sigs: *Vec<*AstFunc>) -> u64 {
    push_trace("cg_program_with_sigs_ir", "codegen.b", __LINE__);

    var program: *AstProgram = prog;

    typeinfo_set_structs(program->structs_vec);
    typeinfo_set_funcs(sigs);

    var ir_mode: u64 = opt_get_ir_mode();
    var opt_level: u64 = opt_get_level();
    if (ir_mode == IR_3ADDR) {
        var ssa_ctx_ptr3: *SSAContext = ssa_builder_build_program(prog);
        if (opt_level >= 1) {
            ssa_opt_o1_run(ssa_ctx_ptr3);
        }
        ssa_destroy_run(ssa_ctx_ptr3);
        ssa_dump_ctx(ssa_ctx_ptr3, 0);
    } else {
        var ssa_ctx_ptr: *SSAContext = ssa_builder_build_program(prog);
        ssa_mem2reg_run(ssa_ctx_ptr);
        if (opt_level >= 1) {
            ssa_opt_o1_run(ssa_ctx_ptr);
        }
        ssa_dump_ctx(ssa_ctx_ptr, 1);
    }

    pop_trace();
    return 0;
}

func cg_program(prog: u64) -> u64 {
    push_trace("cg_program", "codegen.b", __LINE__);
    
    var program: *AstProgram = (*AstProgram)prog;
    
    // Reuse full function list as signature list
    cg_program_with_sigs(program, program->funcs_vec);
    
    pop_trace();
}
