// ast.b - AST node constructors for v3.8

import std.io;
import types;

// Base AST node header
struct AstNode {
    kind: u64;
}

// ============================================
// Expression Nodes
// ============================================

// AST Literal node layout (16 bytes)
struct AstLiteral {
    kind: u64;
    value: u64;
}

// AST Identifier node layout (24 bytes)
struct AstIdent {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
}

// AST String node layout (24 bytes)
struct AstString {
    kind: u64;
    str_ptr: u64;
    str_len: u64;
}

// AST Binary operation node layout (32 bytes)
struct AstBinary {
    kind: u64;
    op: u64;
    left: *AstNode;
    right: *AstNode;
}

// AST Unary operation node layout (24 bytes)
struct AstUnary {
    kind: u64;
    op: u64;
    operand: *AstNode;
}

// AST Float literal node layout (24 bytes)
struct AstFloat {
    kind: u64;
    str_ptr: u64;
    str_len: u64;
}

// AST Try node layout (16 bytes)
struct AstTry {
    kind: u64;
    operand: *AstNode;
}

// AST Function call node layout (32 bytes)
struct AstCall {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    args_vec: *Vec<*AstNode>;
}

// AST Generic call node layout (40 bytes)
struct AstGenericCall {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    generic_args_vec: *Vec<*GenericArg>;
    args_vec: *Vec<*AstNode>;
}

// AST Function pointer call node layout (24 bytes)
struct AstCallPtr {
    kind: u64;
    callee: *AstNode;
    args_vec: *Vec<*AstNode>;
}

// AST_LITERAL: [kind, value]
func ast_literal(val: u64) -> *AstLiteral {
    var node: *AstLiteral = (*AstLiteral)heap_alloc(sizeof(AstLiteral));
    node.kind = AST_LITERAL;
    node.value = val;
    return node;
}

// AST_IDENT: [kind, name_ptr, name_len]
func ast_ident(name_ptr: u64, name_len: u64) -> *AstIdent {
    var node: *AstIdent = (*AstIdent)heap_alloc(sizeof(AstIdent));
    node.kind = AST_IDENT;
    node.name_ptr = name_ptr;
    node.name_len = name_len;
    return node;
}

// AST_STRING: [kind, str_ptr, str_len]
func ast_string(str_ptr: u64, str_len: u64) -> *AstString {
    var node: *AstString = (*AstString)heap_alloc(sizeof(AstString));
    node.kind = AST_STRING;
    node.str_ptr = str_ptr;
    node.str_len = str_len;
    return node;
}

// AST_FLOAT: [kind, str_ptr, str_len]
func ast_float(str_ptr: u64, str_len: u64) -> *AstFloat {
    var node: *AstFloat = (*AstFloat)heap_alloc(sizeof(AstFloat));
    node.kind = AST_FLOAT;
    node.str_ptr = str_ptr;
    node.str_len = str_len;
    return node;
}

// AST_BINARY: [kind, op, left, right]
func ast_binary(op: u64, left: *AstNode, right: *AstNode) -> *AstBinary {
    var node: *AstBinary = (*AstBinary)heap_alloc(sizeof(AstBinary));
    node.kind = AST_BINARY;
    node.op = op;
    node.left = left;
    node.right = right;
    return node;
}

// AST_UNARY: [kind, op, operand]
func ast_unary(op: u64, operand: *AstNode) -> *AstUnary {
    var node: *AstUnary = (*AstUnary)heap_alloc(sizeof(AstUnary));
    node.kind = AST_UNARY;
    node.op = op;
    node.operand = operand;
    return node;
}

// AST_TRY: [kind, operand]
func ast_try(operand: *AstNode) -> *AstTry {
    var node: *AstTry = (*AstTry)heap_alloc(sizeof(AstTry));
    node.kind = AST_TRY;
    node.operand = operand;
    return node;
}

// AST_CALL: [kind, name_ptr, name_len, args_vec]
func ast_call(name_ptr: u64, name_len: u64, args: *Vec<*AstNode>) -> *AstCall {
    var node: *AstCall = (*AstCall)heap_alloc(sizeof(AstCall));
    node.kind = AST_CALL;
    node.name_ptr = name_ptr;
    node.name_len = name_len;
    node.args_vec = args;
    return node;
}

// AST_GENERIC_CALL: [kind, name_ptr, name_len, generic_args_vec, args_vec]
func ast_generic_call(name_ptr: u64, name_len: u64, generic_args: *Vec<*GenericArg>, args: *Vec<*AstNode>) -> *AstGenericCall {
    return new AstGenericCall{AST_GENERIC_CALL, name_ptr, name_len, generic_args, args};
}

// AST Address-of node layout (16 bytes)
struct AstAddrOf {
    kind: u64;
    operand: *AstNode;
}

// AST Dereference node layout (16 bytes)
struct AstDeref {
    kind: u64;
    operand: *AstNode;
}

// AST Byte dereference node layout (16 bytes)
struct AstDeref8 {
    kind: u64;
    operand: *AstNode;
}

// AST Index node layout (24 bytes)
struct AstIndex {
    kind: u64;
    base: *AstNode;
    index: *AstNode;
}

// AST Slice literal node layout (24 bytes)
struct AstSlice {
    kind: u64;
    ptr_expr: *AstNode;
    len_expr: *AstNode;
}

// AST Cast node layout (72 bytes)
struct AstCast {
    kind: u64;
    expr: *AstNode;
    target_type: u64;
    target_ptr_depth: u64;
    target_is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
}

// AST Sizeof node layout (88 bytes)
struct AstSizeof {
    kind: u64;
    type_kind: u64;
    ptr_depth: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
}

// AST Sizeof Expr node layout (16 bytes)
struct AstSizeofExpr {
    kind: u64;
    expr: *AstNode;
}

// AST New expression node layout (152 bytes)
struct AstNew {
    kind: u64;
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
    literal_expr: *AstNode;
    ctor_args_vec: *Vec<*AstNode>;
}

// AST Stack Constructor expression node layout (144 bytes)
struct AstStackCtor {
    kind: u64;
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
    ctor_args_vec: *Vec<*AstNode>;
}

// AST_ADDR_OF: [kind, operand]
func ast_addr_of(operand: *AstNode) -> *AstAddrOf {
    return new AstAddrOf{AST_ADDR_OF, operand};
}

// AST_DEREF: [kind, operand]
func ast_deref(operand: *AstNode) -> *AstDeref {
    return new AstDeref{AST_DEREF, operand};
}

// AST_DEREF8: [kind, operand] - byte dereference
func ast_deref8(operand: *AstNode) -> *AstDeref8 {
    return new AstDeref8{AST_DEREF8, operand};
}

// AST_INDEX: [kind, base, index]
func ast_index(base: *AstNode, index: *AstNode) -> *AstIndex {
    return new AstIndex{AST_INDEX, base, index};
}

// AST_SLICE: [kind, ptr_expr, len_expr]
func ast_slice(ptr_expr: *AstNode, len_expr: *AstNode) -> *AstSlice {
    return new AstSlice{AST_SLICE, ptr_expr, len_expr};
}

// AST_CAST: [kind, expr, target_type, target_ptr_depth, target_is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len]
func ast_cast(expr: *AstNode, target_type: u64, ptr_depth: u64) -> *AstCast {
    return new AstCast{AST_CAST, expr, target_type, ptr_depth, 0, 0, 0, 0, 0};
}

func ast_cast_ex(expr: *AstNode, target_type: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64) -> *AstCast {
    return new AstCast{AST_CAST, expr, target_type, ptr_depth, is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len};
}

// AST_SIZEOF: [kind, type_kind, ptr_depth, struct_name_ptr, struct_name_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len]
func ast_sizeof(type_kind: u64, ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64, elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64) -> *AstSizeof {
    return new AstSizeof{AST_SIZEOF, type_kind, ptr_depth, struct_name_ptr, struct_name_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len};
}

// AST_SIZEOF_EXPR: [kind, expr]
func ast_sizeof_expr(expr: *AstNode) -> *AstSizeofExpr {
    return new AstSizeofExpr{AST_SIZEOF_EXPR, expr};
}

// AST_NEW: [kind, type info..., literal_expr, ctor_args_vec]
func ast_new(type_kind: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64,
             elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64,
             literal_expr: *AstNode, ctor_args_vec: *Vec<*AstNode>) -> *AstNew {
    return new AstNew{AST_NEW, type_kind, ptr_depth, is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len,
                      elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len,
                      literal_expr, ctor_args_vec};
}

// AST_STACK_CTOR: [kind, type info..., ctor_args_vec]
func ast_stack_ctor(type_kind: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64,
                    elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64,
                    ctor_args_vec: *Vec<*AstNode>) -> *AstStackCtor {
    return new AstStackCtor{AST_STACK_CTOR, type_kind, ptr_depth, is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len,
                            elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len,
                            ctor_args_vec};
}

// ============================================
// Statement Nodes
// ============================================

// AST Return statement node layout (16 bytes)
struct AstReturn {
    kind: u64;
    expr: *AstNode;
}

// AST Variable declaration node layout (136 bytes)
struct AstVarDecl {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    init_expr: *AstNode;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
}

// AST Constant declaration node layout (32 bytes)
struct AstConstDecl {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    value: u64;
}

// AST Assignment node layout (24 bytes)
struct AstAssign {
    kind: u64;
    target: *AstNode;
    value: *AstNode;
}

// AST_RETURN: [kind, expr]
func ast_return(expr: *AstNode) -> *AstReturn {
    return new AstReturn{AST_RETURN, expr};
}

// AST_VAR_DECL: [kind, name_ptr, name_len, type_kind, ptr_depth, init_expr]
func ast_var_decl(name_ptr: u64, name_len: u64, type_kind: u64, ptr_depth: u64, init: *AstNode) -> *AstVarDecl {
    var node: *AstVarDecl = (*AstVarDecl)heap_alloc(sizeof(AstVarDecl));
    node.kind = AST_VAR_DECL;
    node.name_ptr = name_ptr;
    node.name_len = name_len;
    node.type_kind = type_kind;
    node.ptr_depth = ptr_depth;
    node.is_tagged = 0;
    node.init_expr = init;
    node.struct_name_ptr = 0;
    node.struct_name_len = 0;
    node.tag_layout_ptr = 0;
    node.tag_layout_len = 0;
    node.elem_type_kind = 0;
    node.elem_ptr_depth = 0;
    node.array_len = 0;
    node.array_len_is_param = 0;
    node.array_len_param_ptr = 0;
    node.array_len_param_len = 0;
    return node;
}

// AST_CONST_DECL: [kind, name_ptr, name_len, value]
func ast_const_decl(name_ptr: u64, name_len: u64, value: u64) -> *AstConstDecl {
    return new AstConstDecl{AST_CONST_DECL, name_ptr, name_len, value};
}

// AST_ASSIGN: [kind, target, value]
func ast_assign(target: *AstNode, value: *AstNode) -> *AstAssign {
    return new AstAssign{AST_ASSIGN, target, value};
}

// AST Expression statement node layout (16 bytes)
struct AstExprStmt {
    kind: u64;
    expr: *AstNode;
}

// AST If statement node layout (32 bytes)
struct AstIf {
    kind: u64;
    cond: *AstNode;
    then_block: *AstNode;
    else_block: *AstNode;
}

// AST While loop node layout (24 bytes)
struct AstWhile {
    kind: u64;
    cond: *AstNode;
    body: *AstNode;
}

// AST For loop node layout (40 bytes)
struct AstFor {
    kind: u64;
    init: *AstNode;
    cond: *AstNode;
    update: *AstNode;
    body: *AstNode;
}

// AST_EXPR_STMT: [kind, expr]
func ast_expr_stmt(expr: *AstNode) -> *AstExprStmt {
    return new AstExprStmt{AST_EXPR_STMT, expr};
}

// AST_IF: [kind, cond, then_block, else_block]
func ast_if(cond: *AstNode, then_blk: *AstNode, else_blk: *AstNode) -> *AstIf {
    return new AstIf{AST_IF, cond, then_blk, else_blk};
}

// AST_WHILE: [kind, cond, body]
func ast_while(cond: *AstNode, body: *AstNode) -> *AstWhile {
    return new AstWhile{AST_WHILE, cond, body};
}

// AST_FOR: [kind, init, cond, update, body]
func ast_for(init: *AstNode, cond: *AstNode, update: *AstNode, body: *AstNode) -> *AstFor {
    return new AstFor{AST_FOR, init, cond, update, body};
}

// AST Switch statement node layout (24 bytes)
struct AstSwitch {
    kind: u64;
    expr: *AstNode;
    cases_vec: *Vec<*AstNode>;
}

// AST Case node layout (32 bytes)
struct AstCase {
    kind: u64;
    value: *AstNode;
    body: *AstNode;
    is_default: u64;
}

// AST Break statement node layout (8 bytes)
struct AstBreak {
    kind: u64;
}

// AST Continue statement node layout (8 bytes)
struct AstContinue {
    kind: u64;
}

// AST Inline assembly node layout (16 bytes)
struct AstAsm {
    kind: u64;
    text_vec: *Vec<u64>;
}

// AST Alias statement node layout (40 bytes)
struct AstAlias {
    kind: u64;
    reg_ptr: u64;
    reg_len: u64;
    name_ptr: u64;
    name_len: u64;
}

// AST Defer statement node layout (16 bytes)
struct AstDefer {
    kind: u64;
    stmt: *AstNode;
}

// AST Delete statement node layout (16 bytes)
struct AstDelete {
    kind: u64;
    expr: *AstNode;
}

// AST Block node layout (16 bytes)
struct AstBlock {
    kind: u64;
    stmts_vec: *Vec<*AstNode>;
}

// AST_SWITCH: [kind, expr, cases_vec]
func ast_switch(expr: *AstNode, cases: *Vec<*AstNode>) -> *AstSwitch {
    return new AstSwitch{AST_SWITCH, expr, cases};
}

// AST_CASE: [kind, value, body, is_default]
func ast_case(value: *AstNode, body: *AstNode, is_default: u64) -> *AstCase {
    return new AstCase{AST_CASE, value, body, is_default};
}

// AST_BREAK: [kind]
func ast_break() -> *AstBreak {
    return new AstBreak{AST_BREAK};
}

// AST_CONTINUE: [kind]
func ast_continue() -> *AstContinue {
    return new AstContinue{AST_CONTINUE};
}

// AST_ASM: [kind, text_vec]
func ast_asm(text_vec: *Vec<u64>) -> *AstAsm {
    return new AstAsm{AST_ASM, text_vec};
}

// AST_ALIAS: [kind, reg_ptr, reg_len, name_ptr, name_len]
func ast_alias(reg_ptr: u64, reg_len: u64, name_ptr: u64, name_len: u64) -> *AstAlias {
    return new AstAlias{AST_ALIAS, reg_ptr, reg_len, name_ptr, name_len};
}

// AST_DEFER: [kind, stmt]
func ast_defer(stmt: *AstNode) -> *AstDefer {
    return new AstDefer{AST_DEFER, stmt};
}

// AST_DELETE: [kind, expr]
func ast_delete(expr: *AstNode) -> *AstDelete {
    return new AstDelete{AST_DELETE, expr};
}

// AST_BLOCK: [kind, stmts_vec]
func ast_block(stmts: *Vec<*AstNode>) -> *AstBlock {
    return new AstBlock{AST_BLOCK, stmts};
}

// ============================================
// Top-level Nodes
// ============================================

// AST Function definition node layout (96 bytes)
struct AstFunc {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    params_vec: *Vec<*Param>;
    ret_type: u64;
    body: *AstNode;
    ret_ptr_depth: u64;
    ret_is_tagged: u64;
    ret_struct_name_ptr: u64;
    ret_struct_name_len: u64;
    ret_tag_layout_ptr: u64;
    ret_tag_layout_len: u64;
}

// AST Program node layout (48 bytes)
struct AstProgram {
    kind: u64;
    funcs_vec: *Vec<*AstFunc>;
    consts_vec: *Vec<*AstConstDecl>;
    imports_vec: *Vec<*AstImport>;
    globals_vec: *Vec<*GlobalInfo>;
    structs_vec: *Vec<*AstStructDef>;
}

// AST Import statement node layout (56 bytes)
struct AstImport {
    kind: u64;
    path_ptr: u64;
    path_len: u64;
    symbol_ptr: u64;
    symbol_len: u64;
    alias_ptr: u64;
    alias_len: u64;
}

// AST Struct definition node layout (48 bytes)
struct AstStructDef {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    parents_vec: *Vec<*ParentDesc>;
    fields_vec: *Vec<*FieldDesc>;
    is_packed: u64;
    traits_vec: *Vec<*TraitRef>;
}

// AST Member access node layout (48 bytes)
struct AstMemberAccess {
    kind: u64;
    object: *AstNode;
    member_ptr: u64;
    member_len: u64;
    parent_ptr: u64;
    parent_len: u64;
}

// AST Method call node layout (40 bytes)
struct AstMethodCall {
    kind: u64;
    receiver: *AstNode;
    method_ptr: u64;
    method_len: u64;
    args_vec: *Vec<*AstNode>;
}

// AST Struct literal node layout (24 bytes)
struct AstStructLiteral {
    kind: u64;
    struct_def: *AstStructDef;
    values_vec: *Vec<*AstNode>;
}

// AST_FUNC: [kind, name_ptr, name_len, params_vec, ret_type, body]
// Legacy ast_func() now creates 72-byte nodes with extra fields zeroed for compatibility
func ast_func(name_ptr: u64, name_len: u64, params: *Vec<*Param>, ret_type: u64, body: *AstNode) -> *AstFunc {
    return new AstFunc{AST_FUNC, name_ptr, name_len, params, ret_type, body, 0, 0, 0, 0, 0, 0};
}

// AST_FUNC (extended): [kind, name_ptr, name_len, params, ret_type, body, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len]
func ast_func_ex(name_ptr: u64, name_len: u64, params: *Vec<*Param>, ret_type: u64, ret_ptr_depth: u64, ret_is_tagged: u64, ret_struct_name_ptr: u64, ret_struct_name_len: u64, ret_tag_layout_ptr: u64, ret_tag_layout_len: u64, body: *AstNode) -> *AstFunc {
    return new AstFunc{AST_FUNC, name_ptr, name_len, params, ret_type, body, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len};
}

// AST_PROGRAM: [kind, funcs_vec, consts_vec, imports_vec, globals_vec]
func ast_program(funcs: *Vec<*AstFunc>, consts: *Vec<*AstConstDecl>, imports: *Vec<*AstImport>) -> *AstProgram {
    return new AstProgram{AST_PROGRAM, funcs, consts, imports, 0, 0};
}

// AST_IMPORT: [kind, path_ptr, path_len, symbol_ptr, symbol_len, alias_ptr, alias_len]
func ast_import(path_ptr: u64, path_len: u64, symbol_ptr: u64, symbol_len: u64, alias_ptr: u64, alias_len: u64) -> *AstImport {
    return new AstImport{AST_IMPORT, path_ptr, path_len, symbol_ptr, symbol_len, alias_ptr, alias_len};
}

// AST_STRUCT_DEF: [kind, name_ptr, name_len, parents_vec, fields_vec, is_packed, traits_vec]
func ast_struct_def(name_ptr: u64, name_len: u64, parents: *Vec<*ParentDesc>, fields: *Vec<*FieldDesc>, is_packed: u64, traits: *Vec<*TraitRef>) -> *AstStructDef {
    return new AstStructDef{AST_STRUCT_DEF, name_ptr, name_len, parents, fields, is_packed, traits};
}

// AST_MEMBER_ACCESS: [kind, object, member_ptr, member_len, parent_ptr, parent_len]
func ast_member_access(object: *AstNode, member_ptr: u64, member_len: u64) -> *AstMemberAccess {
    var node: *AstMemberAccess = (*AstMemberAccess)heap_alloc(sizeof(AstMemberAccess));
    node.kind = AST_MEMBER_ACCESS;
    node.object = object;
    node.member_ptr = member_ptr;
    node.member_len = member_len;
    node.parent_ptr = 0;
    node.parent_len = 0;
    return node;
}

// AST_MEMBER_ACCESS (scoped): [kind, object, member_ptr, member_len, parent_ptr, parent_len]
func ast_member_access_scoped(object: *AstNode, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> *AstMemberAccess {
    var node: *AstMemberAccess = (*AstMemberAccess)heap_alloc(sizeof(AstMemberAccess));
    node.kind = AST_MEMBER_ACCESS;
    node.object = object;
    node.member_ptr = member_ptr;
    node.member_len = member_len;
    node.parent_ptr = parent_ptr;
    node.parent_len = parent_len;
    return node;
}

// AST_SAFE_MEMBER_ACCESS: [kind, object, member_ptr, member_len, parent_ptr, parent_len]
func ast_safe_member_access(object: *AstNode, member_ptr: u64, member_len: u64) -> *AstMemberAccess {
    var node: *AstMemberAccess = (*AstMemberAccess)heap_alloc(sizeof(AstMemberAccess));
    node.kind = AST_SAFE_MEMBER_ACCESS;
    node.object = object;
    node.member_ptr = member_ptr;
    node.member_len = member_len;
    node.parent_ptr = 0;
    node.parent_len = 0;
    return node;
}

// AST_SAFE_MEMBER_ACCESS (scoped): [kind, object, member_ptr, member_len, parent_ptr, parent_len]
func ast_safe_member_access_scoped(object: *AstNode, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> *AstMemberAccess {
    var node: *AstMemberAccess = (*AstMemberAccess)heap_alloc(sizeof(AstMemberAccess));
    node.kind = AST_SAFE_MEMBER_ACCESS;
    node.object = object;
    node.member_ptr = member_ptr;
    node.member_len = member_len;
    node.parent_ptr = parent_ptr;
    node.parent_len = parent_len;
    return node;
}

// AST_METHOD_CALL: [kind, receiver, method_ptr, method_len, args_vec]
func ast_method_call(receiver: *AstNode, method_ptr: u64, method_len: u64, args: *Vec<*AstNode>) -> *AstMethodCall {
    return new AstMethodCall{AST_METHOD_CALL, receiver, method_ptr, method_len, args};
}

// AST_SAFE_METHOD_CALL: [kind, receiver, method_ptr, method_len, args_vec]
func ast_safe_method_call(receiver: *AstNode, method_ptr: u64, method_len: u64, args: *Vec<*AstNode>) -> *AstMethodCall {
    return new AstMethodCall{AST_SAFE_METHOD_CALL, receiver, method_ptr, method_len, args};
}

// AST_CALL_PTR: [kind, callee, args_vec]
func ast_call_ptr(callee: *AstNode, args: *Vec<*AstNode>) -> *AstCallPtr {
    return new AstCallPtr{AST_CALL_PTR, callee, args};
}

// AST_STRUCT_LITERAL: struct_def_ptr, values (vec of exprs)
// Layout: [kind:8][struct_def:8][values:8]
func ast_struct_literal(struct_def: *AstStructDef, values: *Vec<*AstNode>) -> *AstStructLiteral {
    return new AstStructLiteral{AST_STRUCT_LITERAL, struct_def, values};
}

// ============================================
// AST Accessors
// ============================================

func ast_kind(n: *AstNode) -> u64 { return *(n); }
