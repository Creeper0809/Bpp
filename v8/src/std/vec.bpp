// vec.b - Dynamic array implementation (pointer arithmetic for bootstrap)

import std.io;

// Vec<T> structure: [data_ptr, length, capacity] (24 bytes)
// Storage is byte-based; element stride is sizeof(T).
struct Vec<T> {
    data_ptr: u64;
    length: u64;
    capacity: u64;
}

impl Vec {
    constructor(cap: u64) {
        var elem_size: u64 = sizeof(T);
        var buf: u64 = heap_alloc(cap * elem_size);
        self.data_ptr = buf;
        self.length = 0;
        self.capacity = cap;
    }

    func len<T>(self: *Vec<T>) -> u64 {
        return self.length;
    }

    func cap<T>(self: *Vec<T>) -> u64 {
        return self.capacity;
    }

    func push<T>(self: *Vec<T>, item: T) -> u64 {
        var len: u64 = self.length;
        var cap: u64 = self.capacity;
        var elem_size: u64 = sizeof(T);

        // Grow if needed
        if (len >= cap) {
            var new_cap: u64 = cap * 2;
            if (new_cap < 4) { new_cap = 4; }
            var new_buf: u64 = heap_alloc(new_cap * elem_size);
            var old_buf: u64 = self.data_ptr;
            // Copy old data (byte-wise)
            for (var i: u64 = 0; i < len; i++) {
                var src: u64 = old_buf + i * elem_size;
                var dst: u64 = new_buf + i * elem_size;
                var src_u8: *u8 = (*u8)src;
                var dst_u8: *u8 = (*u8)dst;
                for (var j: u64 = 0; j < elem_size; j++) {
                    dst_u8[j] = src_u8[j];
                }
            }
            self.data_ptr = new_buf;
            self.capacity = new_cap;
        }

        var buf: u64 = self.data_ptr;
        var dst2: u64 = buf + len * elem_size;
        var src2: u64 = (u64)&item;
        var dst2_u8: *u8 = (*u8)dst2;
        var src2_u8: *u8 = (*u8)src2;
        for (var k: u64 = 0; k < elem_size; k++) {
            dst2_u8[k] = src2_u8[k];
        }
        self.length = len + 1;
        return 0;
    }

    func get<T>(self: *Vec<T>, i: u64) -> T {
        var buf: u64 = self.data_ptr;
        var elem_size: u64 = sizeof(T);
        var out: T;
        var src: u64 = buf + i * elem_size;
        var dst: u64 = (u64)&out;
        var src_u8: *u8 = (*u8)src;
        var dst_u8: *u8 = (*u8)dst;
        for (var j: u64 = 0; j < elem_size; j++) {
            dst_u8[j] = src_u8[j];
        }
        return out;
    }

    func set<T>(self: *Vec<T>, i: u64, val: T) -> u64 {
        var buf: u64 = self.data_ptr;
        var elem_size: u64 = sizeof(T);
        var dst: u64 = buf + i * elem_size;
        var src: u64 = (u64)&val;
        var dst_u8: *u8 = (*u8)dst;
        var src_u8: *u8 = (*u8)src;
        for (var j: u64 = 0; j < elem_size; j++) {
            dst_u8[j] = src_u8[j];
        }
        return 0;
    }

    func pop<T>(self: *Vec<T>) -> T {
        var len: u64 = self.length;
        if (len == 0) {
            return 0;
        }
        var buf: u64 = self.data_ptr;
        var elem_size: u64 = sizeof(T);
        var out: T;
        var src: u64 = buf + (len - 1) * elem_size;
        var dst: u64 = (u64)&out;
        var src_u8: *u8 = (*u8)src;
        var dst_u8: *u8 = (*u8)dst;
        for (var j: u64 = 0; j < elem_size; j++) {
            dst_u8[j] = src_u8[j];
        }
        self.length = len - 1;
        return out;
    }
}


