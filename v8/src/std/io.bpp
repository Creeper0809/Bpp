// io.b - I/O helpers and memory allocation
// Low-level I/O + heap helpers
import std.str;
import std.os;

var heap_inited;
var heap_brk;
var heap_reserved_end;
var g_out_fd;
const EMIT_STRLEN_CACHE_SIZE = 1024;
var g_emit_strlen_cache_ptr;
var g_emit_strlen_cache_len;
var g_emit_strlen_cache_inited;

func sys_brk(addr) { return os_sys_brk(addr); }
func sys_write(fd, buf, count) { return os_sys_write(fd, buf, count); }
func sys_read(fd, buf, count) { return os_sys_read(fd, buf, count); }
func sys_open(path, flags, mode) { return os_sys_open(path, flags, mode); }
func sys_close(fd) { return os_sys_close(fd); }
func sys_fstat(fd, statbuf) { return os_sys_fstat(fd, statbuf); }
func sys_exit(code) { return os_sys_exit(code); }

func io_set_output_fd(fd: u64) -> u64 {
    g_out_fd = fd;
    return 0;
}

func io_get_output_fd() -> u64 {
    if (g_out_fd == 0) { return 1; }
    return g_out_fd;
}

func emit_strlen_cache_init() -> u64 {
    if (g_emit_strlen_cache_inited != 0) { return 0; }
    var bytes: u64 = EMIT_STRLEN_CACHE_SIZE * sizeof(u64);
    g_emit_strlen_cache_ptr = heap_alloc(bytes);
    g_emit_strlen_cache_len = heap_alloc(bytes);
    if (g_emit_strlen_cache_ptr == 0 || g_emit_strlen_cache_len == 0) {
        g_emit_strlen_cache_inited = 1;
        return 0;
    }
    var p_arr: *u64 = (*u64)g_emit_strlen_cache_ptr;
    var l_arr: *u64 = (*u64)g_emit_strlen_cache_len;
    for (var i: u64 = 0; i < EMIT_STRLEN_CACHE_SIZE; i++) {
        p_arr[i] = 0;
        l_arr[i] = 0;
    }
    g_emit_strlen_cache_inited = 1;
    return 0;
}

func emit_cached_strlen(s: u64) -> u64 {
    if (s == 0) { return 0; }
    emit_strlen_cache_init();
    if (g_emit_strlen_cache_ptr == 0 || g_emit_strlen_cache_len == 0) {
        return str_len(s);
    }
    var idx: u64 = (s >> 3) & (EMIT_STRLEN_CACHE_SIZE - 1);
    var p_arr: *u64 = (*u64)g_emit_strlen_cache_ptr;
    var l_arr: *u64 = (*u64)g_emit_strlen_cache_len;
    if (p_arr[idx] == s) {
        return l_arr[idx];
    }
    var len: u64 = str_len(s);
    p_arr[idx] = s;
    l_arr[idx] = len;
    return len;
}

func heap_alloc(size) {
    if (size == 0) {
        return 0;
    }

    // Align allocation size to 8 bytes to keep u64 stores within mapped pages.
    var align_mask: u64 = 0;
    align_mask = align_mask - 8; // ~7 via wrap-around
    var aligned_size: u64 = size + 7;
    aligned_size = aligned_size & align_mask;
    
    if (heap_inited == 0) {
        var cur_brk: u64 = os_sys_brk(0);
        heap_brk = cur_brk;
        heap_reserved_end = cur_brk;
        heap_inited = 1;
    }

    var aligned_brk: u64 = heap_brk + 7;
    aligned_brk = aligned_brk & align_mask;

    var p: u64 = aligned_brk;
    var new_brk: u64 = p + aligned_size;
    if (new_brk > heap_reserved_end) {
        var grow: u64 = aligned_size;
        if (grow < 1048576) { grow = 1048576; } // Reserve 1 MiB chunks.
        var target_end: u64 = new_brk + grow;
        var res: u64 = os_sys_brk(target_end);
        if (res < target_end) {
            return 0;
        }
        heap_reserved_end = target_end;
    }
    heap_brk = new_brk;
    return p;
}

func emitln(s: u64) {
    var len: u64 = emit_cached_strlen(s);
    var fd: u64 = io_get_output_fd();
    os_sys_write(fd, s, len);
    os_sys_write(fd, "\n", 1);
}

func emit(s: u64) {
    if (s == 0) { return; }
    emit_len(s, emit_cached_strlen(s));
}

func emit_len(s: u64, len: u64) {
    if (s == 0) { return; }
    var fd2: u64 = io_get_output_fd();
    os_sys_write(fd2, s, len);
}

func print(s, len) {
    emit_len(s, len);
}

func print_nl() {
    var fd4: u64 = io_get_output_fd();
    os_sys_write(fd4, "\n", 1);
}

func println(s, len) {
    var fd5: u64 = io_get_output_fd();
    os_sys_write(fd5, s, len);
    os_sys_write(fd5, "\n", 1);
}

func print_u64(n: u64) {
    if (n == 0) {
        var fd6: u64 = io_get_output_fd();
        os_sys_write(fd6, "0", 1);
        return;
    }
    var buf = heap_alloc(32 * sizeof(u8));
    var buf_u8: *u8 = (*u8)buf;
    var i: u64 = 0;
    var value: u64 = n;
    for (; value > 0; ) {
        var digit: u64 = value % 10;
        buf_u8[i] = digit + 48;
        value = value / 10;
        i = i + 1;
    }
    var j: i64 = (i64)i - 1;
    for (; j >= 0; j = j - 1) {
        var fd7: u64 = io_get_output_fd();
        os_sys_write(fd7, buf + (u64)j, 1);
    }
}

func print_i64(n: i64) {
    if (n < 0) {
        var fd8: u64 = io_get_output_fd();
        os_sys_write(fd8, "-", 1);
        print_u64((u64)(0 - n));
    } else {
        print_u64((u64)n);
    }
}
