// ssa_destroy.b - SSA destruction (v3_17)
//
// Phi 제거: 각 Phi의 인자를 predecessor에 COPY로 낮추고, Phi 리스트를 제거합니다.

import std.vec;
import std.util;
import ssa.datastruct;
import ssa.core;

func _ssa_destroy_find_pred(block: *SSABlock, pred_id: u64) -> *SSABlock {
    push_trace("_ssa_destroy_find_pred", "ssa_destroy.b", __LINE__);
    defer pop_trace();
    var preds: []*SSABlock = block.preds;
    var n: u64 = ssa_slice_len(preds);
    for (var i: u64 = 0; i < n; i++) {
        var p: *SSABlock = preds[i];
        if (p.id == pred_id) { return p; }
    }
    return 0;
}

func _ssa_destroy_get_split(map_pred: *Vec<*SSABlock>, map_dst: *Vec<*SSABlock>, map_split: *Vec<*SSABlock>, pred: *SSABlock, block: *SSABlock) -> *SSABlock {
    push_trace("_ssa_destroy_get_split", "ssa_destroy.b", __LINE__);
    defer pop_trace();
    var n: u64 = map_pred.len();
    for (var i: u64 = 0; i < n; i++) {
        var p_ptr: *SSABlock = map_pred.get(i);
        if (p_ptr == pred && map_dst.get(i) == block) {
            return map_split.get(i);
        }
    }
    return 0;
}

func _ssa_destroy_max_reg(fn: *SSAFunction) -> u64 {
    var max_id: u64 = 0;
    var blocks: []*SSABlock = fn.blocks;
    var n: u64 = ssa_slice_len(blocks);
    for (var i: u64 = 0; i < n; i++) {
        var b: *SSABlock = blocks[i];
        if (b == 0) { continue; }

        var phi: *SSAInstruction = b.phi_head;
        while (phi != 0) {
            if (phi.dest > max_id) { max_id = phi.dest; }
            var arg: *SSAPhiArg = (*SSAPhiArg)phi.src1;
            while (arg != 0) {
                if (arg.val > max_id) { max_id = arg.val; }
                arg = arg.next;
            }
            phi = phi.next;
        }

        var cur: *SSAInstruction = b.inst_head;
        while (cur != 0) {
            var op: u64 = ssa_inst_get_op(cur);
            if (op != SSA_OP_BR && op != SSA_OP_JMP && op != SSA_OP_RET_SLICE_HEAP && cur.dest > max_id) {
                max_id = cur.dest;
            }

            if (op == SSA_OP_CALL || op == SSA_OP_CALL_SLICE_STORE) {
                var info_ptr: u64 = ssa_operand_value(cur.src1);
                if (op == SSA_OP_CALL) {
                    var info: *SSACallInfo = (*SSACallInfo)info_ptr;
                    var args_vec: *Vec<u64> = info.args_vec;
                    var nargs: u64 = info.nargs;
                    if (nargs == 0 && args_vec != 0) { nargs = args_vec.len(); }
                    for (var ai: u64 = 0; ai < nargs; ai++) {
                        var r: u64 = args_vec.get(ai);
                        if (r > max_id) { max_id = r; }
                    }
                } else {
                    var info_s: *SSACallSliceStoreInfo = (*SSACallSliceStoreInfo)info_ptr;
                    if (info_s.is_ptr > 1) {
                        var info_call: *SSACallInfo = (*SSACallInfo)info_ptr;
                        var args_vec2: *Vec<u64> = info_call.args_vec;
                        var nargs2: u64 = info_call.nargs;
                        if (nargs2 == 0 && args_vec2 != 0) { nargs2 = args_vec2.len(); }
                        for (var ai2: u64 = 0; ai2 < nargs2; ai2++) {
                            var r2: u64 = args_vec2.get(ai2);
                            if (r2 > max_id) { max_id = r2; }
                        }
                    } else {
                        if (info_s.is_ptr != 0 && info_s.callee_reg > max_id) {
                            max_id = info_s.callee_reg;
                        }
                        var args_vec2b: *Vec<u64> = info_s.args_vec;
                        var nargs2b: u64 = info_s.nargs;
                        if (nargs2b == 0 && args_vec2b != 0) { nargs2b = args_vec2b.len(); }
                        for (var ai2b: u64 = 0; ai2b < nargs2b; ai2b++) {
                            var r2b: u64 = args_vec2b.get(ai2b);
                            if (r2b > max_id) { max_id = r2b; }
                        }
                    }
                }
            }

            if (op == SSA_OP_CALL_PTR) {
                var info_ptrp: u64 = ssa_operand_value(cur.src1);
                var info_ptrp_info: *SSACallPtrInfo = (*SSACallPtrInfo)info_ptrp;
                var callee_reg: u64 = info_ptrp_info.callee_reg;
                if (callee_reg > max_id) { max_id = callee_reg; }
                var args_vecp: *Vec<u64> = info_ptrp_info.args_vec;
                var nargsp: u64 = info_ptrp_info.nargs;
                if (nargsp == 0 && args_vecp != 0) { nargsp = args_vecp.len(); }
                for (var aip: u64 = 0; aip < nargsp; aip++) {
                    var rp: u64 = args_vecp.get(aip);
                    if (rp > max_id) { max_id = rp; }
                }
            }

            if (ssa_operand_is_const(cur.src1) == 0) {
                var r1: u64 = ssa_operand_value(cur.src1);
                if (r1 > max_id) { max_id = r1; }
            }
            if (ssa_operand_is_const(cur.src2) == 0) {
                var r2c: u64 = ssa_operand_value(cur.src2);
                if (r2c > max_id) { max_id = r2c; }
            }
            cur = cur.next;
        }
    }
    return max_id;
}

func _ssa_destroy_find_phi_src(phi: *SSAInstruction, pred_id: u64, src_out: u64) -> u64 {
    var args: *SSAPhiArg = (*SSAPhiArg)phi.src1;
    while (args != 0) {
        if (args.block_id == pred_id) {
            var src_out_u64: *u64 = (*u64)src_out;
            src_out_u64[0] = args.val;
            return true;
        }
        args = args.next;
    }
    return false;
}

func _ssa_destroy_emit_copy(ctx: *SSAContext, block: *SSABlock, dst: u64, src: u64) -> u64 {
    var inst_ptr: *SSAInstruction = ssa_new_inst(ctx, SSA_OP_COPY, dst, ssa_operand_reg(src), 0);
    ssa_inst_insert_before_terminator(block, inst_ptr);
    return 0;
}

func _ssa_destroy_emit_parallel_copies(ctx: *SSAContext, block: *SSABlock, dsts: *Vec<u64>, srcs: *Vec<u64>, next_reg_ptr: *u64) -> u64 {
    var n: u64 = dsts.len();
    if (n == 0) { return 0; }

    var active: *Vec<u64> = new Vec<u64>(n);
    for (var i0: u64 = 0; i0 < n; i0++) {
        active.push(1);
    }

    var remain: u64 = n;
    while (remain > 0) {
        var progressed: u64 = 0;

        for (var i: u64 = 0; i < n; i++) {
            if (active.get(i) == 0) { continue; }
            var dst: u64 = dsts.get(i);
            var src: u64 = srcs.get(i);
            if (dst == src) {
                active.set(i, 0);
                remain = remain - 1;
                progressed = 1;
                continue;
            }

            var src_pending_as_dst: u64 = 0;
            for (var j: u64 = 0; j < n; j++) {
                if (active.get(j) == 0) { continue; }
                if (dsts.get(j) == src) {
                    src_pending_as_dst = 1;
                    break;
                }
            }
            if (src_pending_as_dst == 0) {
                _ssa_destroy_emit_copy(ctx, block, dst, src);
                active.set(i, 0);
                remain = remain - 1;
                progressed = 1;
            }
        }

        if (remain == 0) { break; }
        if (progressed != 0) { continue; }

        var pick: u64 = 0;
        for (var k: u64 = 0; k < n; k++) {
            if (active.get(k) != 0) {
                pick = k;
                break;
            }
        }
        var cycle_src: u64 = srcs.get(pick);
        var tmp: u64 = *next_reg_ptr;
        *next_reg_ptr = tmp + 1;
        _ssa_destroy_emit_copy(ctx, block, tmp, cycle_src);
        srcs.set(pick, tmp);
    }
    return 0;
}

func ssa_destroy_block(ctx: *SSAContext, fn: *SSAFunction, block: *SSABlock, next_reg_ptr: *u64) -> u64 {
    push_trace("ssa_destroy_block", "ssa_destroy.b", __LINE__);
    defer pop_trace();
    if (block == 0 || block.phi_head == 0) { return 0; }

    var split_pred: *Vec<*SSABlock> = new Vec<*SSABlock>(4);
    var split_dst: *Vec<*SSABlock> = new Vec<*SSABlock>(4);
    var split_block: *Vec<*SSABlock> = new Vec<*SSABlock>(4);

    var preds: []*SSABlock = block.preds;
    var pcount: u64 = ssa_slice_len(preds);
    for (var pi: u64 = 0; pi < pcount; pi++) {
        var pred: *SSABlock = preds[pi];
        if (pred == 0) { continue; }

        var emit_block: *SSABlock = pred;
        var critical: u64 = 0;
        if (ssa_slice_len(pred.succs) >= 2 && ssa_slice_len(block.preds) >= 2) { critical = 1; }
        if (critical != 0) {
            var split: *SSABlock = _ssa_destroy_get_split(split_pred, split_dst, split_block, pred, block);
            if (split == 0) {
                split = ssa_new_block(ctx, fn);
                ssa_block_replace_succ(pred, block, split);
                ssa_block_replace_pred(block, pred, split);
                ssa_block_add_pred(split, pred);
                ssa_block_add_succ(split, block);
                split_pred.push(pred);
                split_dst.push(block);
                split_block.push(split);
            }
            emit_block = split;
        }

        var dsts: *Vec<u64> = new Vec<u64>(8);
        var srcs: *Vec<u64> = new Vec<u64>(8);
        var phi: *SSAInstruction = block.phi_head;
        while (phi != 0) {
            var incoming_src: u64 = 0;
            if (_ssa_destroy_find_phi_src(phi, pred.id, &incoming_src) != 0) {
                dsts.push(phi.dest);
                srcs.push(incoming_src);
            }
            phi = phi.next;
        }
        _ssa_destroy_emit_parallel_copies(ctx, emit_block, dsts, srcs, next_reg_ptr);
    }

    block.phi_head = 0;
    return 0;
}

func ssa_destroy_run(ctx: *SSAContext) -> u64 {
    push_trace("ssa_destroy_run", "ssa_destroy.b", __LINE__);
    defer pop_trace();
    if (ctx == 0) { return 0; }
    var funcs: []*SSAFunction = ctx.funcs;
    var n: u64 = ssa_slice_len(funcs);
    for (var i: u64 = 0; i < n; i++) {
        var fn: *SSAFunction = funcs[i];
        var next_reg: u64 = _ssa_destroy_max_reg(fn) + 1;

        var blocks: []*SSABlock = fn.blocks;
        var bcount: u64 = ssa_slice_len(blocks);
        for (var bi: u64 = 0; bi < bcount; bi++) {
            ssa_destroy_block(ctx, fn, blocks[bi], &next_reg);
        }
    }
    return 0;
}
