// compiler.b - Compiler globals and driver helpers

import std.io;
import std.str;
import std.path;
import std.vec;
import std.hashmap;
import std.util;
import types;
import lexer;
import ast;
import parser.util;
import parser.decl;

const GENERIC_DEBUG = 0;

// ============================================
// Global Module State
// ============================================
var g_loaded_modules: *HashMap<u64, u64> = new HashMap<u64, u64>(64);          // HashMap: path -> 1 (tracks fully loaded files)
var g_loaded_modules_pass1: *HashMap<u64, u64> = new HashMap<u64, u64>(64);    // HashMap: path -> 1 (tracks pass1 signature scan)
var g_module_imports_pass1: *HashMap<u64, *Vec<*AstImport>> = new HashMap<u64, *Vec<*AstImport>>(64);    // HashMap: path -> imports vec from pass1
var g_module_imports_pass2: *HashMap<u64, *Vec<*AstImport>> = new HashMap<u64, *Vec<*AstImport>>(64);    // HashMap: path -> imports vec from pass2 (stable copies)
var g_loaded_modules_vec: *Vec<*NameInfo> = new Vec<*NameInfo>(64);               // Vec<NameInfo> of fully loaded module paths
var g_all_funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(64);         // Vec of all function ASTs
var g_all_func_sigs: *Vec<*AstFunc> = new Vec<*AstFunc>(64);     // Vec of all function signatures (pass 1)
var g_all_consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(128);        // Vec of all const ASTs
var g_all_globals: *Vec<*GlobalInfo> = new Vec<*GlobalInfo>(64);       // Vec of all global var info
var g_all_structs: *HashMap<u64, *AstStructDef> = new HashMap<u64, *AstStructDef>(64);       // HashMap: struct_name -> struct_def
var g_all_structs_vec: *Vec<*AstStructDef> = new Vec<*AstStructDef>(16);   // Vec of all struct_defs (for codegen)
var g_all_traits: *HashMap<u64, *TraitDef> = new HashMap<u64, *TraitDef>(64);       // HashMap: trait_name -> trait_def
var g_all_traits_vec: *Vec<*TraitDef> = new Vec<*TraitDef>(16);   // Vec of all trait_defs
var g_all_trait_impls_vec: *Vec<*TraitImpl> = new Vec<*TraitImpl>(32);   // Vec of all trait impls
var g_abst_methods: *HashMap<u64, *Vec<*NameInfo>> = 0;                 // HashMap: struct name -> abstract methods
var g_base_dir = 0;          // Base directory for imports
var g_base_dir_len = 0;
var g_lib_dir = 0;           // Library root directory for compiler/runtime modules
var g_lib_dir_len = 0;

// Generic templates and instantiations
var g_generic_funcs: *HashMap<u64, *GenericFuncTemplate> = new HashMap<u64, *GenericFuncTemplate>(64);          // HashMap: base name -> GenericFuncTemplate
var g_generic_funcs_mangled: *HashMap<u64, *GenericFuncTemplate> = new HashMap<u64, *GenericFuncTemplate>(64);  // HashMap: mangled name -> GenericFuncTemplate
var g_generic_func_ptrs: *Vec<*GenericFuncTemplate> = new Vec<*GenericFuncTemplate>(16);      // Vec of generic template pointers
var g_generic_instantiations: *HashMap<u64, u64> = new HashMap<u64, u64>(64); // HashMap: mangled instantiation name -> 1
var g_generic_structs: *HashMap<u64, *GenericStructTemplate> = new HashMap<u64, *GenericStructTemplate>(64);         // HashMap: base name -> GenericStructTemplate
var g_generic_struct_ptrs: *Vec<*GenericStructTemplate> = new Vec<*GenericStructTemplate>(16);     // Vec of generic struct template pointers
var g_generic_struct_instantiations: *HashMap<u64, *AstStructDef> = new HashMap<u64, *AstStructDef>(64); // HashMap: instantiation name -> struct_def
var g_generic_struct_bindings: *HashMap<u64, *Vec<*GenericBinding>> = new HashMap<u64, *Vec<*GenericBinding>>(64); // HashMap: instantiation name -> bindings

var g_file_ptr = 0;
var g_file_len = 0;
var g_module_aliases: *HashMap<u64, *HashMap<u64, *NameInfo>> = new HashMap<u64, *HashMap<u64, *NameInfo>>(128);     // HashMap: module_id -> alias_map
var g_prelude_aliases: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(128);    // HashMap: alias -> [mangled_ptr, mangled_len]
var g_prelude_miss_cache: *HashMap<u64, u64> = new HashMap<u64, u64>(256);              // HashMap: alias -> 1 when confirmed not in prelude
var g_prelude_loaded: u64 = 0;
var g_module_exports: *HashMap<u64, *Vec<*ExportEntry>> = new HashMap<u64, *Vec<*ExportEntry>>(64);     // HashMap: module_id -> exports vec
var g_func_module_map: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(128);    // HashMap: mangled func -> module_id
var g_global_module_map: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(128);  // HashMap: mangled global -> module_id
var g_current_module_ptr = 0;
var g_current_module_len = 0;
var g_impl_prefix_ptr = 0;
var g_impl_prefix_len = 0;
var g_impl_methods: *HashMap<u64, u64> = new HashMap<u64, u64>(64);       // HashMap: impl-lowered name -> 1
var g_reg_aliases: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(64);   // HashMap: alias name -> register name

// Generic function template (48 bytes)
struct GenericFuncTemplate {
    name_ptr: u64;
    name_len: u64;
    mangled_ptr: u64;
    mangled_len: u64;
    params_vec: *Vec<*GenericParam>;
    func_sig: *AstFunc;
    func_def: *AstFunc;
}

impl GenericFuncTemplate {
    constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.mangled_ptr = 0;
        self.mangled_len = 0;
        self.params_vec = 0;
        self.func_sig = 0;
        self.func_def = 0;
    }
}

// Generic struct template (24 bytes)
struct GenericStructTemplate {
    name_ptr: u64;
    name_len: u64;
    params_vec: *Vec<*GenericParam>;
    struct_def: *AstStructDef;
}

impl GenericStructTemplate {
    constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.params_vec = 0;
        self.struct_def = 0;
    }
}

// Generic binding (40 bytes)
struct GenericBinding {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    type: *TypeInfo;
    value: u64;
}

impl GenericBinding {
    constructor() {
        self.kind = 0;
        self.name_ptr = 0;
        self.name_len = 0;
        self.type = 0;
        self.value = 0;
    }
}

struct Stat {
    pad0: u64;
    pad1: u64;
    pad2: u64;
    pad3: u64;
    pad4: u64;
    pad5: u64;
    size: u64;
}

// ============================================
// File Reading
// ============================================

func read_entire_file(path: u64) -> u64 {
    var fd_i: i64 = (i64)sys_open(path, 0, 0);
    if (fd_i < 0) { return 0; }
    var fd: u64 = (u64)fd_i;

    var statbuf_raw: u64 = heap_alloc(144 * sizeof(u8));
    var statbuf: *Stat = (*Stat)statbuf_raw;
    var st_res: i64 = (i64)sys_fstat(fd, statbuf_raw);
    if (st_res < 0) {
        sys_close(fd);
        return 0;
    }
    var size: u64 = statbuf.size;

    var buf: u64 = heap_alloc((size + 1) * sizeof(u8));

    var total: u64 = 0;
    for (; total < size; ) {
        var n: i64 = (i64)sys_read(fd, buf + total, size - total);
        if (n <= 0) { break; }
        total = total + (u64)n;
    }

    var buf_u8: []u8 = slice(buf, size + 1);
    buf_u8[total] = 0;

    // Preprocess: split ">>" into "> >" only on global var lines (line starts with "var ").
    var repl_count: u64 = 0;
    var i: u64 = 0;
    var line_start: u64 = 1;
    var in_global_var: u64 = 0;
    while (i + 1 < total) {
        var c: u64 = buf_u8[i];
        if (line_start != 0) {
            if (c == 118 && i + 3 < total && buf_u8[i + 1] == 97 && buf_u8[i + 2] == 114 && (buf_u8[i + 3] == 32 || buf_u8[i + 3] == 9)) {
                in_global_var = 1;
                line_start = 0;
            } else if (c == 10) {
                in_global_var = 0;
                line_start = 1;
            } else if (c == 32 || c == 9) {
                line_start = 0;
                in_global_var = 0;
            } else {
                in_global_var = 0;
                line_start = 0;
            }
        }
        if (c == 10) {
            in_global_var = 0;
            line_start = 1;
            i = i + 1;
            continue;
        }
        if (in_global_var != 0 && c == 62 && buf_u8[i + 1] == 62) {
            repl_count = repl_count + 1;
            i = i + 2;
            continue;
        }
        i = i + 1;
    }

    if (repl_count != 0) {
        var new_size: u64 = total + repl_count;
        var new_buf: u64 = heap_alloc((new_size + 1) * sizeof(u8));
        var new_u8: []u8 = slice(new_buf, new_size + 1);
        var si: u64 = 0;
        var di: u64 = 0;
        line_start = 1;
        in_global_var = 0;
        while (si < total) {
            var ch: u64 = buf_u8[si];
            if (line_start != 0) {
                if (ch == 118 && si + 3 < total && buf_u8[si + 1] == 97 && buf_u8[si + 2] == 114 && (buf_u8[si + 3] == 32 || buf_u8[si + 3] == 9)) {
                    in_global_var = 1;
                    line_start = 0;
                } else if (ch == 10) {
                    in_global_var = 0;
                    line_start = 1;
                } else if (ch == 32 || ch == 9) {
                    line_start = 0;
                    in_global_var = 0;
                } else {
                    in_global_var = 0;
                    line_start = 0;
                }
            }
            if (ch == 10) {
                new_u8[di] = ch;
                di = di + 1;
                si = si + 1;
                in_global_var = 0;
                line_start = 1;
                continue;
            }
            if (in_global_var != 0 && ch == 62 && si + 1 < total && buf_u8[si + 1] == 62) {
                new_u8[di] = 62;
                new_u8[di + 1] = 32;
                new_u8[di + 2] = 62;
                di = di + 3;
                si = si + 2;
                continue;
            }
            new_u8[di] = ch;
            di = di + 1;
            si = si + 1;
        }
        new_u8[new_size] = 0;
        buf = new_buf;
        total = new_size;
    }

    sys_close(fd);

    g_file_ptr = buf;
    g_file_len = total;

    return buf;
}

func compiler_get_source_ptr() -> u64 {
    return g_file_ptr;
}

func compiler_get_source_len() -> u64 {
    return g_file_len;
}

// ============================================
// Config File Parsing
// ============================================

// Simple line-by-line config parser
func find_line_starting_with(content: u64, content_len: u64, prefix: u64, prefix_len: u64) -> u64 {
    var content_u8: []u8 = slice(content, content_len);
    for (var i: u64 = 0; i < content_len; ) {
        // Find start of current line
        var line_start: u64 = i;

        // Find end of line
        var line_end: u64 = i;
        for (; line_end < content_len; line_end++) {
            if (content_u8[line_end] == 10) { break; }
        }

        var line_len: u64 = line_end - line_start;

        // Check if line starts with prefix
        if (line_len >= prefix_len) {
            if (str_eq(content + line_start, prefix_len, prefix, prefix_len)) {
                // Found matching line, return pointer to start of value (after prefix)
                var value_start: u64 = line_start + prefix_len;
                var value_len: u64 = line_len - prefix_len;

                // Allocate and copy value
                var value: u64 = heap_alloc((value_len + 1) * sizeof(u8));
                var value_u8: []u8 = slice(value, value_len + 1);
                for (var j: u64 = 0; j < value_len; j++) {
                    value_u8[j] = content_u8[value_start + j];
                }
                value_u8[value_len] = 0;
                return value;
            }
        }

        // Move to next line
        i = line_end + 1;
    }

    return 0;
}

// Read config.ini and extract VERSION value
func read_version_from_config(config_path: u64) -> u64 {
    var content: u64 = read_entire_file(config_path);
    if (content == 0) {
        return 0;
    }

    return find_line_starting_with(content, g_file_len, "VERSION=", 8);
}

// ============================================
// Module Id + Mangling Helpers
// ============================================

// Return 1 if s starts with prefix
func str_has_prefix(s: u64, s_len: u64, prefix: u64, prefix_len: u64) -> u64 {
    if (s_len < prefix_len) { return false; }
    var s_u8: []u8 = slice(s, s_len);
    var prefix_u8: []u8 = slice(prefix, prefix_len);
    for (var i: u64 = 0; i < prefix_len; i++) {
        if (s_u8[i] != prefix_u8[i]) { return false; }
    }
    return true;
}

// Returns [ptr,len] struct (16 bytes)
func module_id_from_path(path: u64, path_len: u64) -> *NameInfo {
    var start: u64 = 0;
    var path_u8: []u8 = slice(path, path_len);
    if (g_lib_dir != 0 && str_has_prefix(path, path_len, g_lib_dir, g_lib_dir_len)) {
        if (path_len > g_lib_dir_len && path_u8[g_lib_dir_len] == 47) {
            start = g_lib_dir_len + 1;
        }
    }
    if (start == 0 && g_base_dir != 0 && str_has_prefix(path, path_len, g_base_dir, g_base_dir_len)) {
        if (path_len > g_base_dir_len && path_u8[g_base_dir_len] == 47) {
            start = g_base_dir_len + 1;
        }
    }

    var end: u64 = path_len;
    if (end >= 4) {
        if (path_u8[end - 4] == 46 && path_u8[end - 3] == 98 && path_u8[end - 2] == 112 && path_u8[end - 1] == 112) {
            end = end - 4;
        }
    }
    if (end == path_len && end >= 2) {
        if (path_u8[end - 2] == 46 && path_u8[end - 1] == 98) {
            end = end - 2;
        }
    }

    var id_len: u64 = 0;
    if (end > start) { id_len = end - start; }
    var id_ptr: u64 = heap_alloc((id_len + 1) * sizeof(u8));
    var id_u8: []u8 = slice(id_ptr, id_len + 1);
    for (var i: u64 = 0; i < id_len; i++) {
        id_u8[i] = path_u8[start + i];
    }
    id_u8[id_len] = 0;

    var out: *NameInfo = new NameInfo{id_ptr, id_len};
    return out;
}

// Import path already normalized to "a/b" without extension
func module_id_from_import(path: u64, path_len: u64) -> *NameInfo {
    var id_ptr: u64 = heap_alloc((path_len + 1) * sizeof(u8));
    var id_u8: []u8 = slice(id_ptr, path_len + 1);
    var path_u8: []u8 = slice(path, path_len);
    for (var i: u64 = 0; i < path_len; i++) {
        id_u8[i] = path_u8[i];
    }
    id_u8[path_len] = 0;
    var out: *NameInfo = new NameInfo{id_ptr, path_len};
    return out;
}

func module_prefix_from_id(id_ptr: u64, id_len: u64) -> *NameInfo {
    var extra: u64 = 0;
    if (id_len > 0) {
        var id_u8: []u8 = slice(id_ptr, id_len);
        var c0: u64 = id_u8[0];
        if (c0 >= 48 && c0 <= 57) { extra = 1; }
    }

    var pref_ptr: u64 = heap_alloc((id_len + extra + 1) * sizeof(u8));
    var pref_u8: []u8 = slice(pref_ptr, id_len + extra + 1);
    if (extra == 1) {
        pref_u8[0] = 95;
    }
    var id_u8b: []u8 = slice(id_ptr, id_len);
    for (var i: u64 = 0; i < id_len; i++) {
        var c: u64 = id_u8b[i];
        if (c == 47 || c == 46) { c = 95; }
        pref_u8[extra + i] = c;
    }
    pref_u8[id_len + extra] = 0;
    var out: *NameInfo = new NameInfo{pref_ptr, id_len + extra};
    return out;
}

// Returns [ptr,len]
func mangle_name(prefix_ptr: u64, prefix_len: u64, name_ptr: u64, name_len: u64) -> *NameInfo {
    if (prefix_len == 0) {
        var out0: *NameInfo = new NameInfo{name_ptr, name_len};
        return out0;
    }
    var sep_len: u64 = 2;
    var total: u64 = prefix_len + sep_len + name_len;
    var buf: u64 = heap_alloc((total + 1) * sizeof(u8));
    var buf_u8: []u8 = slice(buf, total + 1);
    var prefix_u8: []u8 = slice(prefix_ptr, prefix_len);
    var name_u8: []u8 = slice(name_ptr, name_len);
    for (var i: u64 = 0; i < prefix_len; i++) {
        buf_u8[i] = prefix_u8[i];
    }
    buf_u8[prefix_len] = 95;
    buf_u8[prefix_len + 1] = 95;
    for (var j: u64 = 0; j < name_len; j++) {
        buf_u8[prefix_len + sep_len + j] = name_u8[j];
    }
    buf_u8[total] = 0;
    var out: *NameInfo = new NameInfo{buf, total};
    return out;
}

// ============================================
// Module Loading
// ============================================

func file_exists(path: u64) -> u64 {
    var fd_i: i64 = (i64)sys_open(path, 0, 0);
    if (fd_i < 0) { return false; }
    sys_close((u64)fd_i);
    return true;
}

func is_std_alias(module_path: u64, module_len: u64) -> u64 {
    if (str_eq(module_path, module_len, "io", 2)) { return true; }
    if (str_eq(module_path, module_len, "util", 4)) { return true; }
    if (str_eq(module_path, module_len, "vec", 3)) { return true; }
    if (str_eq(module_path, module_len, "hashmap", 7)) { return true; }
    return false;
}

func compiler_resolve_parent_def(parent_desc: *ParentDesc, panic_context: u64) -> *AstStructDef {
    if (parent_desc == 0) { return 0; }
    if (parent_desc.struct_def != 0) { return parent_desc.struct_def; }
    var parent_def: *AstStructDef = get_struct_def(parent_desc.name_ptr, parent_desc.name_len);
    if (parent_def == 0) {
        emit_stderr("[ERROR] Parent struct not found: ");
        emit_stderr_len(parent_desc.name_ptr, parent_desc.name_len);
        emit_stderr("\n");
        panic(panic_context);
    }
    parent_desc.struct_def = parent_def;
    return parent_def;
}

func std_alias_to_module_path(module_path: u64, module_len: u64) -> u64 {
    if (str_eq(module_path, module_len, "io", 2)) { return "std/io"; }
    if (str_eq(module_path, module_len, "util", 4)) { return "std/util"; }
    if (str_eq(module_path, module_len, "vec", 3)) { return "std/vec"; }
    if (str_eq(module_path, module_len, "hashmap", 7)) { return "std/hashmap"; }
    return 0;
}

func is_std_path(module_path: u64, module_len: u64) -> u64 {
    if (module_len < 4) { return false; }
    var module_u8: []u8 = slice(module_path, module_len);
    if (module_u8[0] != 115) { return false; }      // s
    if (module_u8[1] != 116) { return false; } // t
    if (module_u8[2] != 100) { return false; } // d
    if (module_u8[3] != 47) { return false; }  // /
    return true;
}

func resolve_module_path(module_path: u64, module_len: u64) -> u64 {
    var eff_path: u64 = module_path;
    var eff_len: u64 = module_len;

    var prefer_lib: u64 = 0;

    if (is_std_alias(module_path, module_len)) {
        eff_path = std_alias_to_module_path(module_path, module_len);
        eff_len = str_len(eff_path);
        prefer_lib = 1;
    }

    if (is_std_path(eff_path, eff_len)) {
        prefer_lib = 1;
    }

    var ext: u64 = heap_alloc(3 * sizeof(u8));
    var ext_u8: []u8 = slice(ext, 3);
    ext_u8[0] = 46;
    ext_u8[1] = 98;
    ext_u8[2] = 0;

    var with_ext: u64 = str_concat(eff_path, eff_len, ext, 2);
    var with_ext_len: u64 = eff_len + 2;

    var ext_bpp: u64 = heap_alloc(5 * sizeof(u8));
    var ext_bpp_u8: []u8 = slice(ext_bpp, 5);
    ext_bpp_u8[0] = 46;
    ext_bpp_u8[1] = 98;
    ext_bpp_u8[2] = 112;
    ext_bpp_u8[3] = 112;
    ext_bpp_u8[4] = 0;

    var with_ext_bpp: u64 = str_concat(eff_path, eff_len, ext_bpp, 4);
    var with_ext_bpp_len: u64 = eff_len + 4;

    var slash: u64 = heap_alloc(sizeof(u8));
    var slash_u8: []u8 = slice(slash, 1);
    slash_u8[0] = 47;

    var full1: u64;
    var full2: u64;
    if (prefer_lib) {
        full1 = str_concat3(g_lib_dir, g_lib_dir_len, slash, 1, with_ext_bpp, with_ext_bpp_len);
        if (file_exists(full1)) { return full1; }
        full2 = str_concat3(g_base_dir, g_base_dir_len, slash, 1, with_ext_bpp, with_ext_bpp_len);
        if (file_exists(full2)) { return full2; }

        full1 = str_concat3(g_lib_dir, g_lib_dir_len, slash, 1, with_ext, with_ext_len);
        if (file_exists(full1)) { return full1; }
        full2 = str_concat3(g_base_dir, g_base_dir_len, slash, 1, with_ext, with_ext_len);
        return full2;
    }

    full1 = str_concat3(g_base_dir, g_base_dir_len, slash, 1, with_ext_bpp, with_ext_bpp_len);
    if (file_exists(full1)) { return full1; }
    full2 = str_concat3(g_lib_dir, g_lib_dir_len, slash, 1, with_ext_bpp, with_ext_bpp_len);
    if (file_exists(full2)) { return full2; }

    full1 = str_concat3(g_base_dir, g_base_dir_len, slash, 1, with_ext, with_ext_len);
    if (file_exists(full1)) { return full1; }
    full2 = str_concat3(g_lib_dir, g_lib_dir_len, slash, 1, with_ext, with_ext_len);
    return full2;
}

// ============================================
// Import Alias + Export Table
// ============================================

// Export entry: [name_ptr, name_len, mangled_ptr, mangled_len] = 32 bytes
func module_exports_get(module_ptr: u64, module_len: u64) -> *Vec<*ExportEntry> {
    return g_module_exports.?get(module_ptr, module_len);
}

func module_exports_ensure(module_ptr: u64, module_len: u64) -> *Vec<*ExportEntry> {
    if (g_module_exports == 0) {
        g_module_exports = new HashMap<u64, *Vec<*ExportEntry>>(64);
    }
    var existing: *Vec<*ExportEntry> = g_module_exports.get(module_ptr, module_len);
    if (existing != 0) { return existing; }
    var vec: *Vec<*ExportEntry> = new Vec<*ExportEntry>(32);
    g_module_exports.put(module_ptr, module_len, vec);
    return vec;
}

func add_module_export(module_ptr: u64, module_len: u64, name_ptr: u64, name_len: u64, mangled_ptr: u64, mangled_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_ensure(module_ptr, module_len);
    var entry: *ExportEntry = new ExportEntry{name_ptr, name_len, mangled_ptr, mangled_len};
    exports.push(entry);
    return 0;
}

func module_aliases_get(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    return g_module_aliases.?get(module_ptr, module_len);
}

func module_aliases_ensure(module_ptr: u64, module_len: u64) -> *HashMap<u64, *NameInfo> {
    if (g_module_aliases == 0) {
        g_module_aliases = new HashMap<u64, *HashMap<u64, *NameInfo>>(128);
    }
    var existing: *HashMap<u64, *NameInfo> = g_module_aliases.get(module_ptr, module_len);
    if (existing != 0) { return existing; }
    var map: *HashMap<u64, *NameInfo> = new HashMap<u64, *NameInfo>(128);
    g_module_aliases.put(module_ptr, module_len, map);
    return map;
}

func add_import_alias(module_ptr: u64, module_len: u64, alias_ptr: u64, alias_len: u64, mangled_ptr: u64, mangled_len: u64) -> u64 {
    var alias_map: *HashMap<u64, *NameInfo> = module_aliases_ensure(module_ptr, module_len);
    var existing: *NameInfo = alias_map.get(alias_ptr, alias_len);
    if (existing != 0) {
        var ex_ptr: u64 = existing.ptr;
        var ex_len: u64 = existing.len;
        if (ex_ptr == mangled_ptr && ex_len == mangled_len) {
            return 0;
        }
        emit_stderr("[ERROR] import alias conflict: ");
        emit_stderr_len(alias_ptr, alias_len);
        emit_stderr_nl();
        panic("Parse error");
    }
    var info: *NameInfo = new NameInfo{mangled_ptr, mangled_len};
    alias_map.put(alias_ptr, alias_len, info);
    return 0;
}

func add_prelude_alias(alias_ptr: u64, alias_len: u64, mangled_ptr: u64, mangled_len: u64) -> u64 {
    if (g_prelude_aliases == 0) {
        g_prelude_aliases = new HashMap<u64, *NameInfo>(128);
    }
    var existing: *NameInfo = g_prelude_aliases.get(alias_ptr, alias_len);
    if (existing != 0) {
        var ex_ptr: u64 = existing.ptr;
        var ex_len: u64 = existing.len;
        if (ex_ptr == mangled_ptr && ex_len == mangled_len) {
            return 0;
        }
        emit_stderr("[ERROR] prelude alias conflict: ");
        emit_stderr_len(alias_ptr, alias_len);
        emit_stderr_nl();
        panic("Parse error");
    }
    var info: *NameInfo = new NameInfo{mangled_ptr, mangled_len};
    g_prelude_aliases.put(alias_ptr, alias_len, info);
    // Clear any previous negative-cache mark for this symbol.
    if (g_prelude_miss_cache != 0) {
        g_prelude_miss_cache.put(alias_ptr, alias_len, 0);
    }
    return 0;
}

func resolve_import_alias(module_ptr: u64, module_len: u64, name_ptr: u64, name_len: u64) -> *NameInfo {
    var alias_map: *HashMap<u64, *NameInfo> = module_aliases_get(module_ptr, module_len);
    return alias_map.?get(name_ptr, name_len);
}

func resolve_prelude_alias(name_ptr: u64, name_len: u64) -> *NameInfo {
    return g_prelude_aliases.?get(name_ptr, name_len);
}

func compiler_func_exists(name_ptr: u64, name_len: u64) -> u64 {
    if (g_all_funcs == 0) { return false; }
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    var n: u64 = g_all_funcs.len();
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = g_all_funcs.get(i);
        if (str_eq(fn.name_ptr, fn.name_len, resolved_ptr, resolved_len)) { return true; }
    }
    return false;
}

func compiler_get_func(name_ptr: u64, name_len: u64) -> *AstFunc {
    if (g_all_funcs == 0) { return 0; }
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    var n: u64 = g_all_funcs.len();
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = g_all_funcs.get(i);
        if (str_eq(fn.name_ptr, fn.name_len, resolved_ptr, resolved_len)) { return fn; }
    }
    return 0;
}

func compiler_global_exists(name_ptr: u64, name_len: u64) -> u64 {
    var n: u64 = g_all_globals.?len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = g_all_globals.get(i);
        if (str_eq(ginfo.name_ptr, ginfo.name_len, name_ptr, name_len)) { return true; }
    }
    return false;
}

func compiler_find_global_info(name_ptr: u64, name_len: u64) -> *GlobalInfo {
    var n: u64 = g_all_globals.?len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = g_all_globals.get(i);
        if (str_eq(ginfo.name_ptr, ginfo.name_len, name_ptr, name_len)) { return ginfo; }
    }
    return 0;
}

func compiler_set_all_globals(globals: *Vec<*GlobalInfo>) -> u64 {
    g_all_globals = globals;
    return 0;
}

func prelude_try_symbol(module_path: u64, module_len: u64, name_ptr: u64, name_len: u64) -> *NameInfo {
    var mod_id: *NameInfo = module_id_from_import(module_path, module_len);
    if (mod_id == 0) { return 0; }
    var mod_ptr: u64 = mod_id.ptr;
    var mod_len: u64 = mod_id.len;
    var exports: *Vec<*ExportEntry> = module_exports_get(mod_ptr, mod_len);
    if (exports == 0) { return 0; }

    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var sym_ptr: u64 = e.name_ptr;
        var sym_len: u64 = e.name_len;
        if (str_eq(sym_ptr, sym_len, name_ptr, name_len) != 0) {
            var mangled_ptr: u64 = e.mangled_ptr;
            var mangled_len: u64 = e.mangled_len;
            add_prelude_alias(name_ptr, name_len, mangled_ptr, mangled_len);
            var info: *NameInfo = new NameInfo{mangled_ptr, mangled_len};
            return info;
        }
    }
    return 0;
}

func load_std_prelude_modules() -> u64 {
    if (!load_module_by_name("std/io", 6)) { return false; }
    if (!load_module_by_name("std/mem", 7)) { return false; }
    if (!load_module_by_name("std/str", 7)) { return false; }
    if (!load_module_by_name("std/char", 8)) { return false; }
    if (!load_module_by_name("std/util", 8)) { return false; }
    if (!load_module_by_name("std/vec", 7)) { return false; }
    if (!load_module_by_name("std/hashmap", 11)) { return false; }
    return true;
}

func resolve_prelude_alias_lazy(name_ptr: u64, name_len: u64) -> *NameInfo {
    // Fast path: most prelude symbols are already preloaded via load_std_prelude().
    var cached: *NameInfo = resolve_prelude_alias(name_ptr, name_len);
    if (cached != 0) { return cached; }

    // Miss cache avoids repeated export scans for non-prelude identifiers.
    if (g_prelude_miss_cache != 0) {
        var miss: u64 = g_prelude_miss_cache.get(name_ptr, name_len);
        if (miss == 1) { return 0; }
    }

    // Once prelude is fully loaded, a cache miss means definitive miss.
    if (g_prelude_loaded != 0) {
        if (g_prelude_miss_cache == 0) {
            g_prelude_miss_cache = new HashMap<u64, u64>(256);
        }
        g_prelude_miss_cache.put(name_ptr, name_len, 1);
        return 0;
    }

    var info: *NameInfo = prelude_try_symbol("std/io", 6, name_ptr, name_len);
    if (info != 0) { return info; }
    info = prelude_try_symbol("std/mem", 7, name_ptr, name_len);
    if (info != 0) { return info; }
    info = prelude_try_symbol("std/str", 7, name_ptr, name_len);
    if (info != 0) { return info; }
    info = prelude_try_symbol("std/char", 8, name_ptr, name_len);
    if (info != 0) { return info; }
    info = prelude_try_symbol("std/util", 8, name_ptr, name_len);
    if (info != 0) { return info; }
    info = prelude_try_symbol("std/vec", 7, name_ptr, name_len);
    if (info != 0) { return info; }
    info = prelude_try_symbol("std/hashmap", 11, name_ptr, name_len);
    if (info != 0) { return info; }
    if (g_prelude_miss_cache == 0) {
        g_prelude_miss_cache = new HashMap<u64, u64>(256);
    }
    g_prelude_miss_cache.put(name_ptr, name_len, 1);
    return 0;
}

func resolve_name(name_ptr: u64, name_len: u64) -> *NameInfo {
    var suffix_idx: u64 = compiler_find_generic_suffix_index(name_ptr, name_len);
    if (suffix_idx < name_len) {
        var base_ptr: u64 = name_ptr;
        var base_len: u64 = suffix_idx;
        var resolved_base: *NameInfo = resolve_name(base_ptr, base_len);
        if (resolved_base != 0) {
            var suffix_len: u64 = name_len - suffix_idx;
            var combined_len: u64 = resolved_base.len + suffix_len;
            var combined_ptr: u64 = heap_alloc((combined_len + 1) * sizeof(u8));
            var combined_u8: []u8 = slice(combined_ptr, combined_len + 1);
            var resolved_base_u8: []u8 = slice(resolved_base.ptr, resolved_base.len);
            var name_u8: []u8 = slice(name_ptr, name_len);
            for (var i: u64 = 0; i < resolved_base.len; i++) {
                combined_u8[i] = resolved_base_u8[i];
            }
            for (var j: u64 = 0; j < suffix_len; j++) {
                combined_u8[resolved_base.len + j] = name_u8[suffix_idx + j];
            }
            combined_u8[combined_len] = 0;
            var info_out: *NameInfo = new NameInfo{combined_ptr, combined_len};
            return info_out;
        }
    }
    if (g_current_module_ptr != 0 && g_current_module_len != 0) {
        var import_alias: *NameInfo = resolve_import_alias(g_current_module_ptr, g_current_module_len, name_ptr, name_len);
        if (import_alias != 0) { return import_alias; }
    }

    if (g_current_module_ptr != 0 && g_current_module_len != 0) {
        var exports: *Vec<*ExportEntry> = module_exports_get(g_current_module_ptr, g_current_module_len);
        if (exports != 0) {
            var n: u64 = exports.len();
            for (var i: u64 = 0; i < n; i++) {
                var e: *ExportEntry = exports.get(i);
                var n_ptr: u64 = e.name_ptr;
                var n_len: u64 = e.name_len;
                if (str_eq(n_ptr, n_len, name_ptr, name_len)) {
                    var info: *NameInfo = new NameInfo{e.mangled_ptr, e.mangled_len};
                    return info;
                }
            }
        }
    }

    var prelude_info: *NameInfo = resolve_prelude_alias_lazy(name_ptr, name_len);
    if (prelude_info != 0) { return prelude_info; }

    return 0;
}

// ============================================
// ASM Register Alias
// ============================================

func compiler_reg_alias_reset() -> u64 {
    g_reg_aliases = new HashMap<u64, *NameInfo>(64);
    return 0;
}

func compiler_reg_alias_set(reg_ptr: u64, reg_len: u64, alias_ptr: u64, alias_len: u64) -> u64 {
    if (g_reg_aliases == 0) { g_reg_aliases = new HashMap<u64, *NameInfo>(64); }
    var info: *NameInfo = new NameInfo{reg_ptr, reg_len};
    g_reg_aliases.put(alias_ptr, alias_len, info);
    return 0;
}

func compiler_reg_alias_get(alias_ptr: u64, alias_len: u64) -> *NameInfo {
    return g_reg_aliases.?get(alias_ptr, alias_len);
}

// ============================================
// Const Lookup (SSA/Codegen Shared)
// ============================================

func compiler_find_const(name_ptr: u64, name_len: u64) -> u64 {
    var res: *ConstResult = new ConstResult{0, 0};
    var result: u64 = (u64)res;

    if (g_all_consts == 0) { return result; }
    var n: u64 = g_all_consts.len();
    for (var i: u64 = 0; i < n; i++) {
        var c: *AstConstDecl = g_all_consts.get(i);
        if (str_eq(c.name_ptr, c.name_len, name_ptr, name_len)) {
            res.found = 1;
            res.value = c.value;
            return result;
        }
    }
    return result;
}

func import_all_from_module(importer_ptr: u64, importer_len: u64, module_ptr: u64, module_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_get(module_ptr, module_len);
    if (exports == 0) { return false; }
    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var name_ptr: u64 = e.name_ptr;
        var name_len: u64 = e.name_len;
        var mangled_ptr: u64 = e.mangled_ptr;
        var mangled_len: u64 = e.mangled_len;
        add_import_alias(importer_ptr, importer_len, name_ptr, name_len, mangled_ptr, mangled_len);
    }
    return true;
}

func import_symbol_from_module(importer_ptr: u64, importer_len: u64, module_ptr: u64, module_len: u64, symbol_ptr: u64, symbol_len: u64, alias_ptr: u64, alias_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_get(module_ptr, module_len);
    if (exports == 0) { return false; }
    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var name_ptr: u64 = e.name_ptr;
        var name_len: u64 = e.name_len;
        if (str_eq(name_ptr, name_len, symbol_ptr, symbol_len)) {
            var mangled_ptr: u64 = e.mangled_ptr;
            var mangled_len: u64 = e.mangled_len;
            add_import_alias(importer_ptr, importer_len, alias_ptr, alias_len, mangled_ptr, mangled_len);
            return true;
        }
    }
    emit_stderr("[ERROR] import symbol not found: ");
    emit_stderr_len(symbol_ptr, symbol_len);
    emit_stderr_nl();
    panic("Parse error");
    return false;
}

func prelude_import_all_from_module(module_ptr: u64, module_len: u64) -> u64 {
    var exports: *Vec<*ExportEntry> = module_exports_get(module_ptr, module_len);
    if (exports == 0) { return false; }
    var n: u64 = exports.len();
    for (var i: u64 = 0; i < n; i++) {
        var e: *ExportEntry = exports.get(i);
        var name_ptr: u64 = e.name_ptr;
        var name_len: u64 = e.name_len;
        var mangled_ptr: u64 = e.mangled_ptr;
        var mangled_len: u64 = e.mangled_len;
        add_prelude_alias(name_ptr, name_len, mangled_ptr, mangled_len);
    }
    return true;
}

// After all modules are loaded, resolve import aliases using stored import lists.
func finalize_import_aliases() -> u64 {
    if (g_loaded_modules_vec == 0) { return false; }
    var n: u64 = g_loaded_modules_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var info: *NameInfo = g_loaded_modules_vec.get(i);
        var module_path: u64 = info.ptr;
        var module_path_len: u64 = info.len;
        var module_id: *NameInfo = module_id_from_path(module_path, module_path_len);
        var module_ptr: u64 = module_id.ptr;
        var module_len: u64 = module_id.len;

        var imports: *Vec<*AstImport> = g_module_imports_pass2.get(module_path, module_path_len);
        if (imports == 0) { continue; }
        var num_imports: u64 = imports.len();
        for (var ii: u64 = 0; ii < num_imports; ii++) {
            var imp: *AstImport = imports.get(ii);
            var imp_path: u64 = imp.path_ptr;
            var imp_len: u64 = imp.path_len;
            var imp_sym_ptr: u64 = imp.symbol_ptr;
            var imp_sym_len: u64 = imp.symbol_len;
            var imp_alias_ptr: u64 = imp.alias_ptr;
            var imp_alias_len: u64 = imp.alias_len;

            var imp_mod_id: *NameInfo = module_id_from_import(imp_path, imp_len);
            var imp_mod_ptr: u64 = imp_mod_id.ptr;
            var imp_mod_len: u64 = imp_mod_id.len;

            if (imp_sym_ptr == 0) {
                import_all_from_module(module_ptr, module_len, imp_mod_ptr, imp_mod_len);
            } else {
                import_symbol_from_module(module_ptr, module_len, imp_mod_ptr, imp_mod_len, imp_sym_ptr, imp_sym_len, imp_alias_ptr, imp_alias_len);
            }
        }
    }
    return true;
}

func set_current_module_for_func(func_ptr: u64, func_len: u64) -> u64 {
    g_current_module_ptr = 0;
    g_current_module_len = 0;
    if (g_func_module_map == 0) { return 0; }
    var info: *NameInfo = g_func_module_map.get(func_ptr, func_len);
    if (info != 0) {
        g_current_module_ptr = info.ptr;
        g_current_module_len = info.len;
    }
    return 0;
}

func set_current_module_for_global(name_ptr: u64, name_len: u64) -> u64 {
    g_current_module_ptr = 0;
    g_current_module_len = 0;
    if (g_global_module_map == 0) { return 0; }
    var info: *NameInfo = g_global_module_map.get(name_ptr, name_len);
    if (info != 0) {
        g_current_module_ptr = info.ptr;
        g_current_module_len = info.len;
    }
    return 0;
}

// ============================================
// Export Registration + Mangling
// ============================================

func register_module_exports(prog: u64, module_ptr: u64, module_len: u64, prefix_ptr: u64, prefix_len: u64) -> u64 {
    var prog_info: *AstProgram = (*AstProgram)prog;
    var funcs: *Vec<*AstFunc> = prog_info.funcs_vec;
    if (funcs != 0) {
        var num_funcs: u64 = funcs.len();
        for (var i: u64 = 0; i < num_funcs; i++) {
            var fn: *AstFunc = funcs.get(i);
            var orig_ptr: u64 = fn.name_ptr;
            var orig_len: u64 = fn.name_len;
            var mangled_ptr: u64 = orig_ptr;
            var mangled_len: u64 = orig_len;

            if (prefix_len != 0 && !(orig_len == 4 && str_eq(orig_ptr, orig_len, "main", 4))) {
                var mangled_info: *NameInfo = mangle_name(prefix_ptr, prefix_len, orig_ptr, orig_len);
                mangled_ptr = mangled_info.ptr;
                mangled_len = mangled_info.len;
                fn.name_ptr = mangled_ptr;
                fn.name_len = mangled_len;
            }

            add_module_export(module_ptr, module_len, orig_ptr, orig_len, mangled_ptr, mangled_len);

            if (compiler_is_generic_template(fn) != 0) {
                var tpl: *GenericFuncTemplate = compiler_find_generic_template_by_func_ptr(fn);
                if (tpl != 0) {
                    tpl.mangled_ptr = mangled_ptr;
                    tpl.mangled_len = mangled_len;
                    if (g_generic_funcs == 0) { g_generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64); }
                    g_generic_funcs.put(mangled_ptr, mangled_len, tpl);
                }
            }

            if (g_func_module_map == 0) {
                g_func_module_map = new HashMap<u64, *NameInfo>(128);
            }
            var info: *NameInfo = new NameInfo{module_ptr, module_len};
            g_func_module_map.put(mangled_ptr, mangled_len, info);
        }
    }

    var consts: *Vec<*AstConstDecl> = prog_info.consts_vec;
    if (consts != 0) {
        var num_consts: u64 = consts.len();
        for (var ci: u64 = 0; ci < num_consts; ci++) {
            var c: *AstConstDecl = consts.get(ci);
            var orig_ptr: u64 = c.name_ptr;
            var orig_len: u64 = c.name_len;
            var mangled_ptr: u64 = orig_ptr;
            var mangled_len: u64 = orig_len;

            if (prefix_len != 0) {
                var mangled_info2: *NameInfo = mangle_name(prefix_ptr, prefix_len, orig_ptr, orig_len);
                mangled_ptr = mangled_info2.ptr;
                mangled_len = mangled_info2.len;
                c.name_ptr = mangled_ptr;
                c.name_len = mangled_len;
            }
            add_module_export(module_ptr, module_len, orig_ptr, orig_len, mangled_ptr, mangled_len);
        }
    }

    var globals: *Vec<*GlobalInfo> = prog_info.globals_vec;
    if (globals != 0) {
        var num_globals: u64 = globals.len();
        for (var gi: u64 = 0; gi < num_globals; gi++) {
            var ginfo: *GlobalInfo = globals.get(gi);
            var orig_ptr: u64 = ginfo.name_ptr;
            var orig_len: u64 = ginfo.name_len;
            var mangled_ptr: u64 = orig_ptr;
            var mangled_len: u64 = orig_len;

            if (prefix_len != 0) {
                var mangled_info3: *NameInfo = mangle_name(prefix_ptr, prefix_len, orig_ptr, orig_len);
                mangled_ptr = mangled_info3.ptr;
                mangled_len = mangled_info3.len;
                ginfo.name_ptr = mangled_ptr;
                ginfo.name_len = mangled_len;
            }
            add_module_export(module_ptr, module_len, orig_ptr, orig_len, mangled_ptr, mangled_len);

            if (g_global_module_map == 0) {
                g_global_module_map = new HashMap<u64, *NameInfo>(128);
            }
            var ginfo_module: *NameInfo = new NameInfo{module_ptr, module_len};
            g_global_module_map.put(mangled_ptr, mangled_len, ginfo_module);
        }
    }
    return 0;
}

func load_module_by_name(module_path: u64, module_len: u64) -> u64 {
    var resolved: u64 = resolve_module_path(module_path, module_len);
    var resolved_len: u64 = str_len(resolved);
    return load_module(resolved, resolved_len);
}

// Pass1: scan signatures and register generic templates before full parse.
func load_module_pass1(file_path: u64, file_path_len: u64) -> u64 {
    if (g_loaded_modules_pass1.has(file_path, file_path_len)) {
        return true;
    }
    g_loaded_modules_pass1.put(file_path, file_path_len, 1);

    var content: u64 = read_entire_file(file_path);
    if (content == 0) {
        emit_stderr("[ERROR] Cannot open module: ");
        var file_path_u8: []u8 = slice(file_path, file_path_len);
        for (var i: u64 = 0; i < file_path_len; i++) {
            emit_char(file_path_u8[i]);
        }
        emit_nl();
        return false;
    }

    var src: u64 = g_file_ptr;
    var slen: u64 = g_file_len;
    var tokens: *Vec<*Token> = lex_all(src, slen);

    // Pre-scan imports to ensure templates are registered before signature parse.
    var p0: *Parser = parse_new(tokens);
    var imports_only: *Vec<*AstImport> = parse_program_imports_only(p0);
    var imports_copy: *Vec<*AstImport> = new Vec<*AstImport>(4);
    var num_imports: u64 = imports_only.len();
    for (var ii: u64 = 0; ii < num_imports; ii++) {
        var imp: *AstImport = imports_only.get(ii);
        var imp_path: u64 = imp.path_ptr;
        var imp_len: u64 = imp.path_len;
        var path_copy: u64 = heap_alloc((imp_len + 1) * sizeof(u8));
        var path_copy_u8: []u8 = slice(path_copy, imp_len + 1);
        var imp_path_u8: []u8 = slice(imp_path, imp_len);
        for (var ci: u64 = 0; ci < imp_len; ci++) {
            path_copy_u8[ci] = imp_path_u8[ci];
        }
        path_copy_u8[imp_len] = 0;
        var imp_copy: *AstImport = ast_import(path_copy, imp_len, 0, 0, 0, 0);
        imports_copy.push(imp_copy);
    }
    if (g_module_imports_pass1 == 0) { g_module_imports_pass1 = new HashMap<u64, *Vec<*AstImport>>(64); }
    g_module_imports_pass1.put(file_path, file_path_len, imports_copy);

    for (var ii2: u64 = 0; ii2 < num_imports; ii2++) {
        var imp2: *AstImport = imports_copy.get(ii2);
        var imp_path2: u64 = imp2.path_ptr;
        var imp_len2: u64 = imp2.path_len;
        var resolved: u64 = resolve_module_path(imp_path2, imp_len2);
        var resolved_len: u64 = str_len(resolved);
        if (!load_module_pass1(resolved, resolved_len)) {
            return false;
        }
    }

    var p1: *Parser = parse_new(tokens);
    var prog_sig: *AstProgram = parse_program_pass1(p1);

    var prog_sig_info: *AstProgram = prog_sig;
    var sig_funcs: *Vec<*AstFunc> = prog_sig_info.funcs_vec;
    var num_sig_funcs: u64 = sig_funcs.len();
    for (var sfi: u64 = 0; sfi < num_sig_funcs; sfi++) {
        g_all_func_sigs.push(sig_funcs.get(sfi));
    }
    return true;
}

func load_std_prelude() -> u64 {
    g_prelude_loaded = 0;
    g_prelude_miss_cache = new HashMap<u64, u64>(256);

    if (!load_module_by_name("std/io", 6)) { return false; }
    var id_io: *NameInfo = module_id_from_import("std/io", 6);
    prelude_import_all_from_module(id_io.ptr, id_io.len);

    if (!load_module_by_name("std/mem", 7)) { return false; }
    var id_mem: *NameInfo = module_id_from_import("std/mem", 7);
    prelude_import_all_from_module(id_mem.ptr, id_mem.len);

    if (!load_module_by_name("std/str", 7)) { return false; }
    var id_str: *NameInfo = module_id_from_import("std/str", 7);
    prelude_import_all_from_module(id_str.ptr, id_str.len);

    if (!load_module_by_name("std/char", 8)) { return false; }
    var id_char: *NameInfo = module_id_from_import("std/char", 8);
    prelude_import_all_from_module(id_char.ptr, id_char.len);

    if (!load_module_by_name("std/util", 8)) { return false; }
    var id_util: *NameInfo = module_id_from_import("std/util", 8);
    prelude_import_all_from_module(id_util.ptr, id_util.len);

    if (!load_module_by_name("std/vec", 7)) { return false; }
    var id_vec: *NameInfo = module_id_from_import("std/vec", 7);
    prelude_import_all_from_module(id_vec.ptr, id_vec.len);

    if (!load_module_by_name("std/hashmap", 11)) { return false; }
    var id_hm: *NameInfo = module_id_from_import("std/hashmap", 11);
    prelude_import_all_from_module(id_hm.ptr, id_hm.len);
    g_prelude_loaded = 1;
    return true;
}

func load_module(file_path: u64, file_path_len: u64) -> u64 {
    if (g_loaded_modules.has(file_path, file_path_len)) {
        return true;
    }

    if (!load_module_pass1(file_path, file_path_len)) {
        return false;
    }

    g_loaded_modules.put(file_path, file_path_len, 1);

    var path_copy2: u64 = heap_alloc((file_path_len + 1) * sizeof(u8));
    var path_copy2_u8: []u8 = slice(path_copy2, file_path_len + 1);
    var file_path_u8: []u8 = slice(file_path, file_path_len);
    for (var pc: u64 = 0; pc < file_path_len; pc++) {
        path_copy2_u8[pc] = file_path_u8[pc];
    }
    path_copy2_u8[file_path_len] = 0;
    var path_info: *NameInfo = new NameInfo{path_copy2, file_path_len};
    g_loaded_modules_vec.push(path_info);

    // Ensure imports are fully parsed before this module (type resolution).
    if (g_module_imports_pass1 != 0) {
        var imports_p1: *Vec<*AstImport> = g_module_imports_pass1.get(file_path, file_path_len);
        if (imports_p1 != 0) {
            var num_imports_p1: u64 = imports_p1.len();
            for (var pi: u64 = 0; pi < num_imports_p1; pi++) {
                var imp_p1: *AstImport = imports_p1.get(pi);
                var imp_path_p1: u64 = imp_p1.path_ptr;
                var imp_len_p1: u64 = imp_p1.path_len;
                var resolved_p1: u64 = resolve_module_path(imp_path_p1, imp_len_p1);
                var resolved_len_p1: u64 = str_len(resolved_p1);
                if (!load_module(resolved_p1, resolved_len_p1)) {
                    return false;
                }
            }
        }
    }

    var content: u64 = read_entire_file(file_path);
    if (content == 0) {
        emit_stderr("[ERROR] Cannot open module: ");
        var file_path_u8b: []u8 = slice(file_path, file_path_len);
        for (var i: u64 = 0; i< file_path_len;i++){
            emit_char(file_path_u8b[i]);
        }
        emit_nl();
        return false;
    }

    var src: u64 = g_file_ptr;
    var slen: u64  = g_file_len;

    var tokens: *Vec<*Token> = lex_all(src, slen);
    
    // Module identity for mangling
    var module_id: *NameInfo = module_id_from_path(file_path, file_path_len);
    var module_ptr: u64 = module_id.ptr;
    var module_len: u64 = module_id.len;
    var module_prefix: *NameInfo = module_prefix_from_id(module_ptr, module_len);
    var prefix_ptr: u64 = module_prefix.ptr;
    var prefix_len: u64 = module_prefix.len;
    
    // Pass 2: full parse with bodies
    var p: *Parser = parse_new(tokens);
    var prog: *AstProgram = parse_program(p);

    // Register exports + mangle symbols
    register_module_exports(prog, module_ptr, module_len, prefix_ptr, prefix_len);
    compiler_generic_update_mangled_names(prog);

    // Store imports for deferred alias resolution
    var prog_info2: *AstProgram = prog;
    var imports: *Vec<*AstImport> = prog_info2.imports_vec;
    var imports_copy: *Vec<*AstImport> = new Vec<*AstImport>(4);
    var num_imports: u64 = imports.len();
    for (var ii: u64 = 0; ii < num_imports; ii++) {
        var imp: *AstImport = imports.get(ii);
        var imp_path: u64 = imp.path_ptr;
        var imp_len: u64 = imp.path_len;
        var imp_sym_ptr: u64 = imp.symbol_ptr;
        var imp_sym_len: u64 = imp.symbol_len;
        var imp_alias_ptr: u64 = imp.alias_ptr;
        var imp_alias_len: u64 = imp.alias_len;

        var path_copy: u64 = heap_alloc((imp_len + 1) * sizeof(u8));
        var path_copy_u8: []u8 = slice(path_copy, imp_len + 1);
        var imp_path_u8: []u8 = slice(imp_path, imp_len);
        for (var ci: u64 = 0; ci < imp_len; ci++) {
            path_copy_u8[ci] = imp_path_u8[ci];
        }
        path_copy_u8[imp_len] = 0;

        var sym_copy: u64 = 0;
        var alias_copy: u64 = 0;
        if (imp_sym_ptr != 0) {
            sym_copy = heap_alloc((imp_sym_len + 1) * sizeof(u8));
            var sym_copy_u8: []u8 = slice(sym_copy, imp_sym_len + 1);
            var imp_sym_u8: []u8 = slice(imp_sym_ptr, imp_sym_len);
            for (var si: u64 = 0; si < imp_sym_len; si++) {
                sym_copy_u8[si] = imp_sym_u8[si];
            }
            sym_copy_u8[imp_sym_len] = 0;

            alias_copy = heap_alloc((imp_alias_len + 1) * sizeof(u8));
            var alias_copy_u8: []u8 = slice(alias_copy, imp_alias_len + 1);
            var imp_alias_u8: []u8 = slice(imp_alias_ptr, imp_alias_len);
            for (var ai: u64 = 0; ai < imp_alias_len; ai++) {
                alias_copy_u8[ai] = imp_alias_u8[ai];
            }
            alias_copy_u8[imp_alias_len] = 0;
        }

        var imp_copy: *AstImport = ast_import(path_copy, imp_len, sym_copy, imp_sym_len, alias_copy, imp_alias_len);
        imports_copy.push(imp_copy);
    }
    g_module_imports_pass2.put(file_path, file_path_len, imports_copy);

    // Add consts
    var consts: *Vec<*AstConstDecl> = prog_info2.consts_vec;
    var num_consts: u64  = consts.len();
    for (var ci: u64 = 0; ci < num_consts; ci++){
        g_all_consts.push(consts.get(ci));
    }

    // Add funcs
    var funcs: *Vec<*AstFunc> = prog_info2.funcs_vec;
    var num_funcs: u64 = funcs.len();
    for (var fi: u64 = 0; fi < num_funcs; fi++){
        var fn: *AstFunc = funcs.get(fi);
        g_all_funcs.push(fn);
    }

    // Add globals
    var globals: *Vec<*GlobalInfo>  = prog_info2.globals_vec;
    if (globals != 0) {
        var num_globals: u64  = globals.len();
        for (var gi: u64 = 0; gi < num_globals; gi++){
            g_all_globals.push(globals.get(gi));
        }
    }

    // Register structs
    var structs: *Vec<*AstStructDef> = prog_info2.structs_vec;
    if (structs != 0) {
        var num_structs: u64 = structs.len();
        for (var si: u64 = 0; si < num_structs; si++){
            var struct_info: *AstStructDef = structs.get(si);
            var struct_name_ptr: u64 = struct_info.name_ptr;
            var struct_name_len: u64 = struct_info.name_len;
            g_all_structs.put(struct_name_ptr, struct_name_len, struct_info);
        }
    }

    return true;
}

// ============================================
// Helper functions for parser
// ============================================

// Check if a name is a registered struct type
func is_struct_type(name_ptr: u64, name_len: u64) -> u64 {
    var struct_def: *AstStructDef = g_all_structs.?get(name_ptr, name_len);
    if (struct_def == 0) { return false; }
    return true;
}

// Get struct definition by name
func get_struct_def(name_ptr: u64, name_len: u64) -> *AstStructDef {
    return g_all_structs.?get(name_ptr, name_len);
}

// Register a struct type during parsing
func register_struct_type(struct_def: *AstStructDef) -> u64 {
    if (g_all_structs == 0) {
        g_all_structs = new HashMap<u64, *AstStructDef>(64);
    }
    if (g_all_structs_vec == 0) {
        g_all_structs_vec = new Vec<*AstStructDef>(16);
    }
    var struct_info: *AstStructDef = struct_def;
    var struct_name_ptr: u64 = struct_info.name_ptr;
    var struct_name_len: u64 = struct_info.name_len;
    if (compiler_is_trait_name(struct_name_ptr, struct_name_len) != 0) {
        emit_stderr("[ERROR] Struct name conflicts with trait: ");
        emit_stderr_len(struct_name_ptr, struct_name_len);
        emit_stderr("\n");
        panic("Parse error");
    }
    g_all_structs.put(struct_name_ptr, struct_name_len, struct_info);
    g_all_structs_vec.push(struct_info);
}

// ============================================
// Trait Registry
// ============================================

func compiler_register_trait_def(trait_def: *TraitDef) -> u64 {
    if (trait_def == 0) { return 0; }
    if (g_all_traits == 0) {
        g_all_traits = new HashMap<u64, *TraitDef>(64);
    }
    if (g_all_traits_vec == 0) {
        g_all_traits_vec = new Vec<*TraitDef>(16);
    }
    var name_ptr: u64 = trait_def.name_ptr;
    var name_len: u64 = trait_def.name_len;
    var existing: *TraitDef = g_all_traits.get(name_ptr, name_len);
    if (existing != 0) {
        existing.name_ptr = name_ptr;
        existing.name_len = name_len;
        existing.methods_vec = trait_def.methods_vec;
        return 0;
    }
    if (g_all_structs != 0) {
        var struct_def: *AstStructDef = g_all_structs.?get(name_ptr, name_len);
        if (struct_def != 0) {
            emit_stderr("[ERROR] Trait name conflicts with struct: ");
            emit_stderr_len(name_ptr, name_len);
            emit_stderr("\n");
            panic("Parse error");
        }
    }
    g_all_traits.put(name_ptr, name_len, trait_def);
    g_all_traits_vec.push(trait_def);
    return 0;
}

func compiler_get_trait_def(name_ptr: u64, name_len: u64) -> *TraitDef {
    if (g_all_traits == 0) { return 0; }
    return g_all_traits.?get(name_ptr, name_len);
}

func compiler_is_trait_name(name_ptr: u64, name_len: u64) -> u64 {
    var td: *TraitDef = compiler_get_trait_def(name_ptr, name_len);
    if (td == 0) { return false; }
    return true;
}

func compiler_get_trait_defs() -> *Vec<*TraitDef> {
    return g_all_traits_vec;
}

func compiler_register_trait_impl(trait_impl: *TraitImpl) -> u64 {
    if (trait_impl == 0) { return 0; }
    if (g_all_trait_impls_vec == 0) {
        g_all_trait_impls_vec = new Vec<*TraitImpl>(32);
    }
    var existing: *TraitImpl = compiler_find_trait_impl(trait_impl.trait_ptr, trait_impl.trait_len, trait_impl.struct_ptr, trait_impl.struct_len);
    if (existing != 0) {
        if (trait_impl.methods_vec != 0) {
            if (existing.methods_vec == 0) {
                existing.methods_vec = trait_impl.methods_vec;
            } else {
                var n: u64 = trait_impl.methods_vec.len();
                for (var i: u64 = 0; i < n; i++) {
                    var m: *TraitImplMethod = trait_impl.methods_vec.get(i);
                    if (compiler_find_trait_impl_method(existing, m.name_ptr, m.name_len) == 0) {
                        existing.methods_vec.push(m);
                    }
                }
            }
        }
        return 0;
    }
    g_all_trait_impls_vec.push(trait_impl);
    return 0;
}

func compiler_get_trait_impls() -> *Vec<*TraitImpl> {
    return g_all_trait_impls_vec;
}

// ============================================
// Generic Template Registry
// ============================================

func compiler_get_or_create_generic_template(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>) -> *GenericFuncTemplate {
    if (g_generic_funcs == 0) { g_generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64); }
    var existing: *GenericFuncTemplate = g_generic_funcs.get(name_ptr, name_len);
    if (existing != 0) { return existing; }

    var tpl: *GenericFuncTemplate = new GenericFuncTemplate();
    tpl.name_ptr = name_ptr;
    tpl.name_len = name_len;
    tpl.mangled_ptr = 0;
    tpl.mangled_len = 0;
    tpl.params_vec = params_vec;
    tpl.func_sig = 0;
    tpl.func_def = 0;
    g_generic_funcs.put(name_ptr, name_len, tpl);
    return tpl;
}

func compiler_get_or_create_generic_struct_template(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>) -> *GenericStructTemplate {
    if (g_generic_structs == 0) { g_generic_structs = new HashMap<u64, *GenericStructTemplate>(64); }
    var existing: *GenericStructTemplate = g_generic_structs.get(name_ptr, name_len);
    if (existing != 0) { return existing; }

    var tpl: *GenericStructTemplate = new GenericStructTemplate();
    tpl.name_ptr = name_ptr;
    tpl.name_len = name_len;
    tpl.params_vec = params_vec;
    tpl.struct_def = 0;
    g_generic_structs.put(name_ptr, name_len, tpl);
    return tpl;
}

func compiler_register_generic_struct_def(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>, struct_def: *AstStructDef) -> u64 {
    if (params_vec == 0 || params_vec.len() == 0) { return 0; }
    var tpl: *GenericStructTemplate = compiler_get_or_create_generic_struct_template(name_ptr, name_len, params_vec);
    tpl.params_vec = params_vec;
    tpl.struct_def = struct_def;
    if (g_generic_struct_ptrs == 0) { g_generic_struct_ptrs = new Vec<*GenericStructTemplate>(16); }
    g_generic_struct_ptrs.push(tpl);
    if (GENERIC_DEBUG != 0) {
        emit_stderr("[DEBUG] generic struct template: ");
        emit_stderr_len(name_ptr, name_len);
        emit_stderr("\n");
    }
    return 0;
}

func compiler_register_generic_struct_sig(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>) -> u64 {
    if (params_vec == 0 || params_vec.len() == 0) { return 0; }
    var tpl: *GenericStructTemplate = compiler_get_or_create_generic_struct_template(name_ptr, name_len, params_vec);
    tpl.params_vec = params_vec;
    return 0;
}

func compiler_find_generic_struct_template_by_name(name_ptr: u64, name_len: u64) -> *GenericStructTemplate {
    return g_generic_structs.?get(name_ptr, name_len);
}

func compiler_is_generic_struct_def(struct_def: *AstStructDef) -> u64 {
    if (g_generic_struct_ptrs == 0) { return false; }
    var n: u64 = g_generic_struct_ptrs.len();
    for (var i: u64 = 0; i < n; i++) {
        var tpl: *GenericStructTemplate = g_generic_struct_ptrs.get(i);
        if (tpl.struct_def == struct_def) { return true; }
    }
    return false;
}

func compiler_register_generic_struct_bindings(inst_ptr: u64, inst_len: u64, bindings: *Vec<*GenericBinding>) -> u64 {
    if (inst_ptr == 0 || inst_len == 0 || bindings == 0) { return 0; }
    if (g_generic_struct_bindings == 0) { g_generic_struct_bindings = new HashMap<u64, *Vec<*GenericBinding>>(64); }
    if (g_generic_struct_bindings.has(inst_ptr, inst_len) != 0) { return 0; }
    g_generic_struct_bindings.put(inst_ptr, inst_len, bindings);
    return 0;
}

func compiler_get_generic_struct_bindings(inst_ptr: u64, inst_len: u64) -> *Vec<*GenericBinding> {
    if (g_generic_struct_bindings == 0) { return 0; }
    return g_generic_struct_bindings.get(inst_ptr, inst_len);
}

func compiler_find_generic_suffix_index(name_ptr: u64, name_len: u64) -> u64 {
    if (name_ptr == 0 || name_len < 5) { return name_len; }
    for (var i: u64 = 0; i + 5 <= name_len; i++) {
        if (str_eq(name_ptr + i, 5, "__G__", 5)) { return i; }
    }
    return name_len;
}

func compiler_register_generic_func_sig(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>, func_sig: *AstFunc) -> u64 {
    if (params_vec == 0 || params_vec.len() == 0) {
        if (compiler_is_impl_context() != 0) {
            var tpl0: *GenericStructTemplate = compiler_find_generic_struct_template_by_name(g_impl_prefix_ptr, g_impl_prefix_len);
            if (tpl0 != 0) {
                if (tpl0.params_vec != 0 && tpl0.params_vec.len() > 0) {
                    params_vec = tpl0.params_vec;
                    if (GENERIC_DEBUG != 0) {
                        emit_stderr("[DEBUG] impl generic params adopted for func sig: ");
                        emit_stderr_len(name_ptr, name_len);
                        emit_stderr("\n");
                    }
                }
            }
        }
    }
    if (params_vec == 0 || params_vec.len() == 0) { return 0; }
    var reg_name_ptr: u64 = name_ptr;
    var reg_name_len: u64 = name_len;
    if (g_impl_prefix_ptr != 0 && g_impl_prefix_len != 0) {
        var combined: *Vec<u64> = new Vec<u64>(g_impl_prefix_len + name_len + 1);
        var impl_prefix_u8: []u8 = slice(g_impl_prefix_ptr, g_impl_prefix_len);
        for (var i: u64 = 0; i < g_impl_prefix_len; i++) {
            combined.push(impl_prefix_u8[i]);
        }
        combined.push(95);
        var name_u8: []u8 = slice(name_ptr, name_len);
        for (var j: u64 = 0; j < name_len; j++) {
            combined.push(name_u8[j]);
        }
        var cname_len: u64 = combined.len();
        var cname_ptr: u64 = heap_alloc((cname_len + 1) * sizeof(u8));
        var cname_u8: []u8 = slice(cname_ptr, cname_len + 1);
        for (var k: u64 = 0; k < cname_len; k++) {
            cname_u8[k] = combined.get(k);
        }
        cname_u8[cname_len] = 0;
        reg_name_ptr = cname_ptr;
        reg_name_len = cname_len;
    }
    var tpl: *GenericFuncTemplate = compiler_get_or_create_generic_template(reg_name_ptr, reg_name_len, params_vec);
    tpl.params_vec = params_vec;
    tpl.func_sig = func_sig;
    return 0;
}

func compiler_register_generic_func_def(name_ptr: u64, name_len: u64, params_vec: *Vec<*GenericParam>, func_def: *AstFunc) -> u64 {
    if (params_vec == 0 || params_vec.len() == 0) {
        if (compiler_is_impl_context() != 0) {
            var tpl1: *GenericStructTemplate = compiler_find_generic_struct_template_by_name(g_impl_prefix_ptr, g_impl_prefix_len);
            if (tpl1 != 0) {
                if (tpl1.params_vec != 0 && tpl1.params_vec.len() > 0) {
                    params_vec = tpl1.params_vec;
                    if (GENERIC_DEBUG != 0) {
                        emit_stderr("[DEBUG] impl generic params adopted for func def: ");
                        emit_stderr_len(name_ptr, name_len);
                        emit_stderr("\n");
                    }
                }
            }
        }
    }
    if (params_vec == 0 || params_vec.len() == 0) { return 0; }
    var reg_name_ptr: u64 = name_ptr;
    var reg_name_len: u64 = name_len;
    if (g_impl_prefix_ptr != 0 && g_impl_prefix_len != 0) {
        var combined: *Vec<u64> = new Vec<u64>(g_impl_prefix_len + name_len + 1);
        var impl_prefix_u8: []u8 = slice(g_impl_prefix_ptr, g_impl_prefix_len);
        for (var i: u64 = 0; i < g_impl_prefix_len; i++) {
            combined.push(impl_prefix_u8[i]);
        }
        combined.push(95);
        var name_u8: []u8 = slice(name_ptr, name_len);
        for (var j: u64 = 0; j < name_len; j++) {
            combined.push(name_u8[j]);
        }
        var cname_len: u64 = combined.len();
        var cname_ptr: u64 = heap_alloc((cname_len + 1) * sizeof(u8));
        var cname_u8: []u8 = slice(cname_ptr, cname_len + 1);
        for (var k: u64 = 0; k < cname_len; k++) {
            cname_u8[k] = combined.get(k);
        }
        cname_u8[cname_len] = 0;
        reg_name_ptr = cname_ptr;
        reg_name_len = cname_len;
    }
    var tpl: *GenericFuncTemplate = compiler_get_or_create_generic_template(reg_name_ptr, reg_name_len, params_vec);
    tpl.params_vec = params_vec;
    tpl.func_def = func_def;
    if (g_generic_func_ptrs == 0) { g_generic_func_ptrs = new Vec<*GenericFuncTemplate>(16); }
    g_generic_func_ptrs.push(tpl);
    if (GENERIC_DEBUG != 0) {
        emit_stderr("[DEBUG] generic template: ");
        emit_stderr_len(name_ptr, name_len);
        emit_stderr("\n");
    }
    return 0;
}

func compiler_set_impl_prefix(prefix_ptr: u64, prefix_len: u64) -> u64 {
    g_impl_prefix_ptr = prefix_ptr;
    g_impl_prefix_len = prefix_len;
    return 0;
}

func compiler_clear_impl_prefix() -> u64 {
    g_impl_prefix_ptr = 0;
    g_impl_prefix_len = 0;
    return 0;
}

func compiler_is_impl_context() -> u64 {
    if (g_impl_prefix_ptr != 0 && g_impl_prefix_len != 0) { return true; }
    return false;
}

func compiler_register_impl_method(name_ptr: u64, name_len: u64) -> u64 {
    if (name_ptr == 0 || name_len == 0) { return 0; }
    if (g_impl_methods == 0) { g_impl_methods = new HashMap<u64, u64>(64); }
    if (g_impl_methods.has(name_ptr, name_len) != 0) { return 0; }
    g_impl_methods.put(name_ptr, name_len, 1);
    return 0;
}

func compiler_register_abst_method(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> u64 {
    if (struct_ptr == 0 || struct_len == 0 || method_ptr == 0 || method_len == 0) { return 0; }
    if (g_abst_methods == 0) { g_abst_methods = new HashMap<u64, *Vec<*NameInfo>>(32); }
    var list: *Vec<*NameInfo> = g_abst_methods.get(struct_ptr, struct_len);
    if (list == 0) {
        list = new Vec<*NameInfo>(4);
        g_abst_methods.put(struct_ptr, struct_len, list);
    }
    var n: u64 = list.len();
    for (var i: u64 = 0; i < n; i++) {
        var ni: *NameInfo = list.get(i);
        if (str_eq(ni.ptr, ni.len, method_ptr, method_len)) { return 0; }
    }
    var name_info: *NameInfo = new NameInfo{method_ptr, method_len};
    list.push(name_info);
    return 0;
}

func compiler_get_abst_methods(struct_ptr: u64, struct_len: u64) -> *Vec<*NameInfo> {
    if (g_abst_methods == 0) { return 0; }
    return g_abst_methods.get(struct_ptr, struct_len);
}

func compiler_is_abst_method(struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> u64 {
    var list: *Vec<*NameInfo> = compiler_get_abst_methods(struct_ptr, struct_len);
    if (list == 0) { return false; }
    var n: u64 = list.len();
    for (var i: u64 = 0; i < n; i++) {
        var ni: *NameInfo = list.get(i);
        if (str_eq(ni.ptr, ni.len, method_ptr, method_len)) { return true; }
    }
    return false;
}

func compiler_is_impl_method(name_ptr: u64, name_len: u64) -> u64 {
    return g_impl_methods.?has(name_ptr, name_len);
}

func compiler_is_generic_func_ptr(fn: *AstFunc) -> u64 {
    if (fn == 0) { return false; }
    var n: u64 = g_generic_func_ptrs.?len();
    if (n == 0) { return false; }
    for (var i: u64 = 0; i < n; i++) {
        var tpl: *GenericFuncTemplate = g_generic_func_ptrs.get(i);
        if (tpl.func_def == fn) { return true; }
    }
    return false;
}

func compiler_find_generic_template_by_name(name_ptr: u64, name_len: u64) -> *GenericFuncTemplate {
    return g_generic_funcs.?get(name_ptr, name_len);
}

func compiler_find_generic_template_by_mangled(name_ptr: u64, name_len: u64) -> *GenericFuncTemplate {
    return g_generic_funcs_mangled.?get(name_ptr, name_len);
}

func compiler_find_generic_template_by_func_ptr(fn_ptr: *AstFunc) -> *GenericFuncTemplate {
    var n: u64 = g_generic_func_ptrs.?len();
    if (n == 0) { return 0; }
    for (var i: u64 = 0; i < n; i++) {
        var tpl: *GenericFuncTemplate = g_generic_func_ptrs.get(i);
        if (tpl.func_def == fn_ptr) { return tpl; }
        if (tpl.func_sig == fn_ptr) { return tpl; }
    }
    return 0;
}

func compiler_alias_generic_template_by_func_ptr(fn_ptr: *AstFunc, new_name_ptr: u64, new_name_len: u64) -> u64 {
    var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_func_ptr(fn_ptr);
    if (tpl_ptr == 0) { return 0; }
    if (g_generic_funcs == 0) { g_generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64); }
    var tpl: *GenericFuncTemplate = tpl_ptr;
    g_generic_funcs.put(new_name_ptr, new_name_len, tpl);
    return 0;
}

func compiler_clone_generic_template_for_impl(fn_ptr: *AstFunc, new_name_ptr: u64, new_name_len: u64) -> u64 {
    var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_func_ptr(fn_ptr);
    if (tpl_ptr == 0) { return 0; }
    if (g_generic_funcs == 0) { g_generic_funcs = new HashMap<u64, *GenericFuncTemplate>(64); }
    var existing: *GenericFuncTemplate = g_generic_funcs.get(new_name_ptr, new_name_len);
    if (existing != 0) { return 0; }

    var src: *GenericFuncTemplate = tpl_ptr;
    var tpl: *GenericFuncTemplate = new GenericFuncTemplate();
    tpl.name_ptr = new_name_ptr;
    tpl.name_len = new_name_len;
    tpl.mangled_ptr = 0;
    tpl.mangled_len = 0;
    tpl.params_vec = src.params_vec;
    tpl.func_sig = src.func_sig;
    tpl.func_def = src.func_def;
    g_generic_funcs.put(new_name_ptr, new_name_len, tpl);
    if (g_generic_func_ptrs == 0) { g_generic_func_ptrs = new Vec<*GenericFuncTemplate>(16); }
    g_generic_func_ptrs.push(tpl);
    return 0;
}

func compiler_generic_update_mangled_names(prog: *AstProgram) -> u64 {
    if (g_generic_func_ptrs == 0) { return 0; }
    var funcs: *Vec<*AstFunc> = prog.funcs_vec;
    var n: u64 = funcs.?len();
    if (n == 0) { return 0; }
    for (var i: u64 = 0; i < n; i++) {
        var fn: *AstFunc = funcs.get(i);
        var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_func_ptr(fn);
        if (tpl_ptr == 0) { continue; }
        var tpl: *GenericFuncTemplate = tpl_ptr;
        tpl.mangled_ptr = fn.name_ptr;
        tpl.mangled_len = fn.name_len;
        if (g_generic_funcs_mangled == 0) { g_generic_funcs_mangled = new HashMap<u64, *GenericFuncTemplate>(64); }
        g_generic_funcs_mangled.put(tpl.mangled_ptr, tpl.mangled_len, tpl);
    }
    return 0;
}

// ============================================
// Generic Monomorphization
// ============================================

// Append a string to a vec<u8>
func generic_vec_append_str(v: *Vec<u64>, s_ptr: u64, s_len: u64) -> u64 {
    var s_u8: []u8 = slice(s_ptr, s_len);
    for (var i: u64 = 0; i < s_len; i++) {
        v.push(s_u8[i]);
    }
    return 0;
}

// Append unsigned integer to vec as decimal
func generic_vec_append_u64(v: *Vec<u64>, value: u64) -> u64 {
    if (value == 0) {
        v.push(48);
        return 0;
    }
    var buf: u64 = heap_alloc(32 * sizeof(u8));
    var buf_u8: []u8 = slice(buf, 32);
    var idx: u64 = 0;
    var x: u64 = value;
    while (x > 0) {
        var digit: u64 = x % 10;
        buf_u8[idx] = 48 + digit;
        idx = idx + 1;
        x = x / 10;
    }
    for (var i: u64 = 0; i < idx; i++) {
        v.push(buf_u8[idx - 1 - i]);
    }
    return 0;
}

func generic_type_equal(ta: *TypeInfo, tb: *TypeInfo) -> u64 {
    if (ta.type_kind != tb.type_kind) { return false; }
    if (ta.ptr_depth != tb.ptr_depth) { return false; }
    if (ta.type_kind == TYPE_STRUCT) {
        if (!str_eq(ta.struct_name_ptr, ta.struct_name_len, tb.struct_name_ptr, tb.struct_name_len)) { return false; }
    }
    if (ta.type_kind == TYPE_ARRAY || ta.type_kind == TYPE_SLICE) {
        if (ta.elem_type_kind != tb.elem_type_kind) { return false; }
        if (ta.elem_ptr_depth != tb.elem_ptr_depth) { return false; }
        if (ta.type_kind == TYPE_ARRAY && ta.array_len != tb.array_len) { return false; }
        if (!str_eq(ta.struct_name_ptr, ta.struct_name_len, tb.struct_name_ptr, tb.struct_name_len)) { return false; }
    }
    return true;
}

func generic_find_binding(bindings: *Vec<*GenericBinding>, kind: u64, name_ptr: u64, name_len: u64) -> *GenericBinding {
    if (bindings == 0) { return 0; }
    var n: u64 = bindings.len();
    for (var i: u64 = 0; i < n; i++) {
        var b: *GenericBinding = bindings.get(i);
        if (b.kind == kind && str_eq(b.name_ptr, b.name_len, name_ptr, name_len)) {
            return b;
        }
    }
    return 0;
}

func generic_bind_type(bindings: *Vec<*GenericBinding>, name_ptr: u64, name_len: u64, type_ptr: *TypeInfo) -> u64 {
    var existing: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, name_ptr, name_len);
    if (existing != 0) {
        if (!generic_type_equal(existing.type, type_ptr)) {
            return true;
        }
        return false;
    }
    var nb: *GenericBinding = new GenericBinding();
    nb.kind = GENERIC_KIND_TYPE;
    nb.name_ptr = name_ptr;
    nb.name_len = name_len;
    nb.type = type_ptr;
    nb.value = 0;
    bindings.push(nb);
    return false;
}

func generic_bind_value(bindings: *Vec<*GenericBinding>, name_ptr: u64, name_len: u64, value: u64) -> u64 {
    var existing: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_VALUE, name_ptr, name_len);
    if (existing != 0) {
        if (existing.value != value) {
            return true;
        }
        return false;
    }
    var nb: *GenericBinding = new GenericBinding();
    nb.kind = GENERIC_KIND_VALUE;
    nb.name_ptr = name_ptr;
    nb.name_len = name_len;
    nb.type = 0;
    nb.value = value;
    bindings.push(nb);
    return false;
}

func compiler_typeinfo_new(type_kind: u64, ptr_depth: u64) -> *TypeInfo {
    var ti: *TypeInfo = (*TypeInfo)heap_alloc(sizeof(TypeInfo));
    ti.type_kind = type_kind;
    ti.ptr_depth = ptr_depth;
    ti.is_tagged = 0;
    ti.struct_name_ptr = 0;
    ti.struct_name_len = 0;
    ti.tag_layout_ptr = 0;
    ti.tag_layout_len = 0;
    ti.struct_def = 0;
    ti.elem_type_kind = 0;
    ti.elem_ptr_depth = 0;
    ti.array_len = 0;
    ti.array_len_is_param = 0;
    ti.array_len_param_ptr = 0;
    ti.array_len_param_len = 0;
    return ti;
}

func generic_make_typeinfo_from_fields(type_kind: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64, elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64) -> *TypeInfo {
    var ti: *TypeInfo = compiler_typeinfo_new(type_kind, ptr_depth);
    ti.is_tagged = is_tagged;
    ti.struct_name_ptr = struct_name_ptr;
    ti.struct_name_len = struct_name_len;
    ti.tag_layout_ptr = tag_layout_ptr;
    ti.tag_layout_len = tag_layout_len;
    ti.struct_def = 0;
    ti.elem_type_kind = elem_type_kind;
    ti.elem_ptr_depth = elem_ptr_depth;
    ti.array_len = array_len;
    ti.array_len_is_param = array_len_is_param;
    ti.array_len_param_ptr = array_len_param_ptr;
    ti.array_len_param_len = array_len_param_len;
    return ti;
}

func generic_subst_typeinfo(type_kind: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64, elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64, bindings: *Vec<*GenericBinding>) -> *TypeInfo {
    if (type_kind == TYPE_GENERIC) {
        if (struct_name_ptr == 0 || struct_name_len == 0) {
            return generic_make_typeinfo_from_fields(TYPE_GENERIC, ptr_depth, is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len);
        }
        var b_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, struct_name_ptr, struct_name_len);
        if (b_ptr == 0) {
            emit_stderr("[ERROR] Missing generic type binding: ");
            emit_stderr_len(struct_name_ptr, struct_name_len);
            emit_stderr(" len=");
            print_u64(struct_name_len);
            emit_stderr(" ptr=");
            print_u64(struct_name_ptr);
            emit_stderr("\n");
            panic("Parse error");
        }
        var bt: *TypeInfo = b_ptr.type;
        var merged_ptr_depth: u64 = bt.ptr_depth + ptr_depth;
        return generic_make_typeinfo_from_fields(bt.type_kind, merged_ptr_depth, bt.is_tagged, bt.struct_name_ptr, bt.struct_name_len, bt.tag_layout_ptr, bt.tag_layout_len, bt.elem_type_kind, bt.elem_ptr_depth, bt.array_len, bt.array_len_is_param, bt.array_len_param_ptr, bt.array_len_param_len);
    }

    if (bindings != 0 && type_kind == TYPE_STRUCT && struct_name_ptr != 0 && struct_name_len != 0) {
        var b_ptr2: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, struct_name_ptr, struct_name_len);
        if (b_ptr2 != 0) {
            var bt2: *TypeInfo = b_ptr2.type;
            var merged_ptr_depth2: u64 = bt2.ptr_depth + ptr_depth;
            return generic_make_typeinfo_from_fields(bt2.type_kind, merged_ptr_depth2, bt2.is_tagged, bt2.struct_name_ptr, bt2.struct_name_len, bt2.tag_layout_ptr, bt2.tag_layout_len, bt2.elem_type_kind, bt2.elem_ptr_depth, bt2.array_len, bt2.array_len_is_param, bt2.array_len_param_ptr, bt2.array_len_param_len);
        }
    }

    if (type_kind == TYPE_STRUCT && bindings != 0) {
        var base_len: u64 = compiler_find_generic_suffix_index(struct_name_ptr, struct_name_len);
        if (base_len < struct_name_len) {
            var tpl_ptr: *GenericStructTemplate = compiler_find_generic_struct_template_by_name(struct_name_ptr, base_len);
            if (tpl_ptr != 0) {
                var name_info: *NameInfo = generic_struct_get_or_create_instance(tpl_ptr, bindings);
                return generic_make_typeinfo_from_fields(type_kind, ptr_depth, is_tagged, name_info.ptr, name_info.len, tag_layout_ptr, tag_layout_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len);
            }
        }
    }

    if (type_kind == TYPE_ARRAY || type_kind == TYPE_SLICE) {
        var new_array_len: u64 = array_len;
        var new_array_len_is_param: u64 = array_len_is_param;
        var new_array_param_ptr: u64 = array_len_param_ptr;
        var new_array_param_len: u64 = array_len_param_len;
        if (array_len_is_param != 0) {
            var vb_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_VALUE, array_len_param_ptr, array_len_param_len);
            if (vb_ptr == 0) {
                emit_stderr("[ERROR] Missing generic value binding\n");
                panic("Parse error");
            }
            new_array_len = vb_ptr.value;
            new_array_len_is_param = 0;
            new_array_param_ptr = 0;
            new_array_param_len = 0;
        }

        var et: *TypeInfo = generic_subst_typeinfo(elem_type_kind, elem_ptr_depth, 0, struct_name_ptr, struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0, bindings);
        return generic_make_typeinfo_from_fields(type_kind, ptr_depth, is_tagged, et.struct_name_ptr, et.struct_name_len, tag_layout_ptr, tag_layout_len, et.type_kind, et.ptr_depth, new_array_len, new_array_len_is_param, new_array_param_ptr, new_array_param_len);
    }

    return generic_make_typeinfo_from_fields(type_kind, ptr_depth, is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len);
}

func generic_append_type_repr(v: *Vec<u64>, ti: *TypeInfo) -> u64 {
    if (ti.ptr_depth > 0) {
        v.push(112); // 'p'
        generic_vec_append_u64(v, ti.ptr_depth);
        v.push(95); // '_'
        var base: *TypeInfo = generic_make_typeinfo_from_fields(ti.type_kind, 0, ti.is_tagged, ti.struct_name_ptr, ti.struct_name_len, ti.tag_layout_ptr, ti.tag_layout_len, ti.elem_type_kind, ti.elem_ptr_depth, ti.array_len, ti.array_len_is_param, ti.array_len_param_ptr, ti.array_len_param_len);
        return generic_append_type_repr(v, base);
    }

    switch (ti.type_kind) {
        case TYPE_U8: generic_vec_append_str(v, "u8", 2); break;
        case TYPE_U16: generic_vec_append_str(v, "u16", 3); break;
        case TYPE_U32: generic_vec_append_str(v, "u32", 3); break;
        case TYPE_U64: generic_vec_append_str(v, "u64", 3); break;
        case TYPE_I64: generic_vec_append_str(v, "i64", 3); break;
        case TYPE_STRUCT:
            v.push(83); // 'S'
            var struct_name_u8: []u8 = slice(ti.struct_name_ptr, ti.struct_name_len);
            for (var i: u64 = 0; i < ti.struct_name_len; i++) {
                var c: u64 = struct_name_u8[i];
                if (c == 47 || c == 46) { c = 95; }
                v.push(c);
            }
            break;
        case TYPE_ARRAY:
            v.push(97); // 'a'
            generic_vec_append_u64(v, ti.array_len);
            v.push(95);
            var elem: *TypeInfo = generic_make_typeinfo_from_fields(ti.elem_type_kind, ti.elem_ptr_depth, 0, ti.struct_name_ptr, ti.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
            generic_append_type_repr(v, elem);
            break;
        case TYPE_SLICE:
            v.push(115); // 's'
            v.push(95);
            var elem2: *TypeInfo = generic_make_typeinfo_from_fields(ti.elem_type_kind, ti.elem_ptr_depth, 0, ti.struct_name_ptr, ti.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
            generic_append_type_repr(v, elem2);
            break;
        default:
            generic_vec_append_str(v, "t", 1);
            break;
    }
    return 0;
}

func generic_mangle_name(base_ptr: u64, base_len: u64, params_vec: *Vec<*GenericParam>, bindings: *Vec<*GenericBinding>) -> *NameInfo {
    var v: *Vec<u64> = new Vec<u64>(base_len + 32);
    generic_vec_append_str(v, base_ptr, base_len);
    generic_vec_append_str(v, "__G__", 5);
    var n: u64 = params_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var gp: *GenericParam = params_vec.get(i);
        if (gp.kind == GENERIC_KIND_TYPE) {
            v.push(84); // 'T'
            v.push(95);
            var b_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, gp.name_ptr, gp.name_len);
            if (b_ptr == 0) {
                emit_stderr("[ERROR] Missing generic type binding\n");
                panic("Parse error");
            }
            generic_append_type_repr(v, b_ptr.type);
        } else {
            v.push(86); // 'V'
            v.push(95);
            var b2_ptr: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_VALUE, gp.name_ptr, gp.name_len);
            if (b2_ptr == 0) {
                emit_stderr("[ERROR] Missing generic value binding\n");
                panic("Parse error");
            }
            generic_vec_append_u64(v, b2_ptr.value);
        }

        if (i + 1 < n) { v.push(95); }
    }

    var out_len: u64 = v.len();
    var out_ptr: u64 = heap_alloc((out_len + 1) * sizeof(u8));
    var out_u8: []u8 = slice(out_ptr, out_len + 1);
    for (var i2: u64 = 0; i2 < out_len; i2++) {
        out_u8[i2] = v.get(i2);
    }
    out_u8[out_len] = 0;
    var info: *NameInfo = new NameInfo{out_ptr, out_len};
    return info;
}

func generic_make_typeinfo_from_param(param: *Param) -> *TypeInfo {
    return generic_make_typeinfo_from_fields(param.type_kind, param.ptr_depth, param.is_tagged, param.struct_name_ptr, param.struct_name_len, param.tag_layout_ptr, param.tag_layout_len, param.elem_type_kind, param.elem_ptr_depth, param.array_len, param.array_len_is_param, param.array_len_param_ptr, param.array_len_param_len);
}

func generic_make_typeinfo_from_vardecl(decl: *AstVarDecl) -> *TypeInfo {
    return generic_make_typeinfo_from_fields(decl.type_kind, decl.ptr_depth, decl.is_tagged, decl.struct_name_ptr, decl.struct_name_len, decl.tag_layout_ptr, decl.tag_layout_len, decl.elem_type_kind, decl.elem_ptr_depth, decl.array_len, decl.array_len_is_param, decl.array_len_param_ptr, decl.array_len_param_len);
}

func generic_infer_from_typeinfo(tk: u64, pd: u64, sn_ptr: u64, sn_len: u64, elem_k: u64, elem_pd: u64, array_len: u64, array_len_is_param: u64, array_param_ptr: u64, array_param_len: u64, arg_ti: *TypeInfo, bindings: *Vec<*GenericBinding>) -> u64 {
    if (tk == TYPE_GENERIC) {
        if (arg_ti.ptr_depth < pd) {
            return true;
        }
        var adj_ptr_depth: u64 = arg_ti.ptr_depth - pd;
        var bound: *TypeInfo = generic_make_typeinfo_from_fields(arg_ti.type_kind, adj_ptr_depth, arg_ti.is_tagged, arg_ti.struct_name_ptr, arg_ti.struct_name_len, arg_ti.tag_layout_ptr, arg_ti.tag_layout_len, arg_ti.elem_type_kind, arg_ti.elem_ptr_depth, arg_ti.array_len, arg_ti.array_len_is_param, arg_ti.array_len_param_ptr, arg_ti.array_len_param_len);
        if (generic_bind_type(bindings, sn_ptr, sn_len, bound) != 0) { return true; }
        return false;
    }

    if (tk == TYPE_ARRAY || tk == TYPE_SLICE) {
        if (arg_ti.type_kind != tk) {
            return true;
        }
        if (array_len_is_param != 0) {
            if (generic_bind_value(bindings, array_param_ptr, array_param_len, arg_ti.array_len) != 0) { return true; }
        } else if (tk == TYPE_ARRAY && array_len != arg_ti.array_len) {
            return true;
        }

        return generic_infer_from_typeinfo(elem_k, elem_pd, sn_ptr, sn_len, 0, 0, 0, 0, 0, 0, generic_make_typeinfo_from_fields(arg_ti.elem_type_kind, arg_ti.elem_ptr_depth, 0, arg_ti.struct_name_ptr, arg_ti.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0), bindings);
    }

    if (tk != arg_ti.type_kind || pd != arg_ti.ptr_depth) {
        return true;
    }
    if (tk == TYPE_STRUCT && !str_eq(sn_ptr, sn_len, arg_ti.struct_name_ptr, arg_ti.struct_name_len)) {
        return true;
    }
    return false;
}

func _compiler_find_parent_def(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, depth: u64) -> *AstStructDef {
    if (struct_def == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }
    if (str_eq(struct_def.name_ptr, struct_def.name_len, parent_ptr, parent_len)) { return struct_def; }
    if (struct_def.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var found: *AstStructDef = _compiler_find_parent_def(parent_def, parent_ptr, parent_len, depth + 1);
        if (found != 0) { return found; }
    }
    return 0;
}

func _compiler_find_field_desc_unscoped(struct_def: *AstStructDef, member_ptr: u64, member_len: u64, depth: u64) -> *FieldDesc {
    if (struct_def == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("Compiler error");
    }
    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var n: u64 = fields.len();
    for (var i: u64 = 0; i < n; i++) {
        var f: *FieldDesc = fields.get(i);
        if (str_eq(f.name_ptr, f.name_len, member_ptr, member_len)) { return f; }
    }
    if (struct_def.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
    var pn: u64 = parents.len();
    var match_desc: *FieldDesc = 0;
    var match_count: u64 = 0;
    for (var j: u64 = 0; j < pn; j++) {
        var parent_desc: *ParentDesc = parents.get(j);
        var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "Compiler error");
        var cand: *FieldDesc = _compiler_find_field_desc_unscoped(parent_def, member_ptr, member_len, depth + 1);
        if (cand != 0) {
            match_count = match_count + 1;
            if (match_count == 1) { match_desc = cand; }
        }
    }
    if (match_count > 1) {
        emit_stderr("[ERROR] Ambiguous field access: ");
        emit_stderr_len(struct_def.name_ptr, struct_def.name_len);
        emit_stderr(".");
        emit_stderr_len(member_ptr, member_len);
        emit_stderr("\n");
        panic("Compiler error");
    }
    return match_desc;
}

func compiler_find_struct_field_desc_scoped(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> *FieldDesc {
    if (struct_def == 0) { return 0; }
    if (parent_ptr != 0) {
        var parent_def: *AstStructDef = _compiler_find_parent_def(struct_def, parent_ptr, parent_len, 0);
        if (parent_def == 0) {
            emit_stderr("[ERROR] Parent scope not found: ");
            emit_stderr_len(parent_ptr, parent_len);
            emit_stderr("\n");
            panic("Compiler error");
        }
        var desc: *FieldDesc = _compiler_find_field_desc_unscoped(parent_def, member_ptr, member_len, 0);
        if (desc == 0) {
            emit_stderr("[ERROR] Field not found in parent scope: ");
            emit_stderr_len(parent_ptr, parent_len);
            emit_stderr(".");
            emit_stderr_len(member_ptr, member_len);
            emit_stderr("\n");
            panic("Compiler error");
        }
        return desc;
    }
    return _compiler_find_field_desc_unscoped(struct_def, member_ptr, member_len, 0);
}

func generic_find_struct_field_type(struct_name_ptr: u64, struct_name_len: u64, parent_ptr: u64, parent_len: u64, member_ptr: u64, member_len: u64) -> *TypeInfo {
    if (struct_name_ptr == 0 || struct_name_len == 0) { return 0; }
    var sd: *AstStructDef = get_struct_def(struct_name_ptr, struct_name_len);
    if (sd == 0) {
        if (GENERIC_DEBUG != 0) {
            emit_stderr("[DEBUG] Missing struct def for member access: ");
            emit_stderr_len(struct_name_ptr, struct_name_len);
            emit_stderr("\n");
        }
        return 0;
    }
    var field_desc: *FieldDesc = compiler_find_struct_field_desc_scoped(sd, parent_ptr, parent_len, member_ptr, member_len);
    if (field_desc != 0) {
        var f: *FieldDesc = field_desc;
        return generic_make_typeinfo_from_fields(f.type_kind, f.ptr_depth, f.is_tagged, f.struct_name_ptr, f.struct_name_len, f.tag_layout_ptr, f.tag_layout_len, f.elem_type_kind, f.elem_ptr_depth, f.array_len, 0, 0, 0);
    }

    if (GENERIC_DEBUG != 0) {
        emit_stderr("[DEBUG] Missing struct field: ");
        emit_stderr_len(struct_name_ptr, struct_name_len);
        emit_stderr(".");
        emit_stderr_len(member_ptr, member_len);
        emit_stderr("\n");
    }
    return 0;
}

func generic_infer_expr_type(expr: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> *TypeInfo {
    var kind: u64 = ast_kind(expr);
    switch (kind) {
        case AST_LITERAL:
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_STRING:
            return generic_make_typeinfo_from_fields(TYPE_U8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)expr;
            var t_ptr: *TypeInfo = 0;
            if (symtab != 0) {
                t_ptr = symtab.get(id.name_ptr, id.name_len);
            }
            if (t_ptr != 0) { return t_ptr; }
            var ginfo: *GlobalInfo = compiler_find_global_info(id.name_ptr, id.name_len);
            if (ginfo == 0) {
                var resolved: *NameInfo = resolve_name(id.name_ptr, id.name_len);
                if (resolved != 0) {
                    ginfo = compiler_find_global_info(resolved.ptr, resolved.len);
                }
            }
            if (ginfo != 0) {
                if (ginfo.typeinfo_ptr != 0) { return ginfo.typeinfo_ptr; }
            }
            // fallback: consts assumed u64
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_ADDR_OF:
            var a: *AstAddrOf = (*AstAddrOf)expr;
            var base_t: *TypeInfo = generic_infer_expr_type(a.operand, symtab);
            return generic_make_typeinfo_from_fields(base_t.type_kind, base_t.ptr_depth + 1, base_t.is_tagged, base_t.struct_name_ptr, base_t.struct_name_len, base_t.tag_layout_ptr, base_t.tag_layout_len, base_t.elem_type_kind, base_t.elem_ptr_depth, base_t.array_len, base_t.array_len_is_param, base_t.array_len_param_ptr, base_t.array_len_param_len);
        case AST_DEREF:
            var d: *AstDeref = (*AstDeref)expr;
            var dt: *TypeInfo = generic_infer_expr_type(d.operand, symtab);
            if (dt.ptr_depth == 0) { return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); }
            return generic_make_typeinfo_from_fields(dt.type_kind, dt.ptr_depth - 1, dt.is_tagged, dt.struct_name_ptr, dt.struct_name_len, dt.tag_layout_ptr, dt.tag_layout_len, dt.elem_type_kind, dt.elem_ptr_depth, dt.array_len, dt.array_len_is_param, dt.array_len_param_ptr, dt.array_len_param_len);
        case AST_CAST:
            var c: *AstCast = (*AstCast)expr;
            return generic_make_typeinfo_from_fields(c.target_type, c.target_ptr_depth, c.target_is_tagged, c.struct_name_ptr, c.struct_name_len, c.tag_layout_ptr, c.tag_layout_len, 0, 0, 0, 0, 0, 0);
        case AST_INDEX:
            var ix: *AstIndex = (*AstIndex)expr;
            var bt: *TypeInfo = generic_infer_expr_type(ix.base, symtab);
            if (bt.type_kind == TYPE_ARRAY || bt.type_kind == TYPE_SLICE) {
                return generic_make_typeinfo_from_fields(bt.elem_type_kind, bt.elem_ptr_depth, 0, bt.struct_name_ptr, bt.struct_name_len, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            if (bt.ptr_depth > 0) {
                return generic_make_typeinfo_from_fields(bt.type_kind, bt.ptr_depth - 1, bt.is_tagged, bt.struct_name_ptr, bt.struct_name_len, bt.tag_layout_ptr, bt.tag_layout_len, bt.elem_type_kind, bt.elem_ptr_depth, bt.array_len, bt.array_len_is_param, bt.array_len_param_ptr, bt.array_len_param_len);
            }
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)expr;
            var obj_ti: *TypeInfo = generic_infer_expr_type(ma.object, symtab);
            if (obj_ti == 0) {
                return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            if (obj_ti.type_kind != TYPE_STRUCT) {
                return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            var field_ti: *TypeInfo = generic_find_struct_field_type(obj_ti.struct_name_ptr, obj_ti.struct_name_len, ma.parent_ptr, ma.parent_len, ma.member_ptr, ma.member_len);
            if (field_ti != 0) { return field_ti; }
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_SAFE_MEMBER_ACCESS:
            var sma: *AstMemberAccess = (*AstMemberAccess)expr;
            var sobj_ti: *TypeInfo = generic_infer_expr_type(sma.object, symtab);
            if (sobj_ti == 0) {
                return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            if (sobj_ti.type_kind != TYPE_STRUCT) {
                return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            var sfield_ti: *TypeInfo = generic_find_struct_field_type(sobj_ti.struct_name_ptr, sobj_ti.struct_name_len, sma.parent_ptr, sma.parent_len, sma.member_ptr, sma.member_len);
            if (sfield_ti != 0) { return sfield_ti; }
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_TRY:
            var tr: *AstTry = (*AstTry)expr;
            var opt_ti: *TypeInfo = generic_infer_expr_type(tr.operand, symtab);
            if (opt_ti == 0) {
                return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            if (opt_ti.type_kind != TYPE_STRUCT || opt_ti.ptr_depth != 0) {
                return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            }
            var base_len: u64 = compiler_find_generic_suffix_index(opt_ti.struct_name_ptr, opt_ti.struct_name_len);
            if (str_eq(opt_ti.struct_name_ptr, base_len, "Option", 6)) {
                var vt: *TypeInfo = generic_find_struct_field_type(opt_ti.struct_name_ptr, opt_ti.struct_name_len, 0, 0, (u64)"value", 5);
                if (vt != 0) { return vt; }
            }
            if (str_eq(opt_ti.struct_name_ptr, base_len, "Result", 6)) {
                var ok_t: *TypeInfo = generic_find_struct_field_type(opt_ti.struct_name_ptr, opt_ti.struct_name_len, 0, 0, (u64)"ok", 2);
                if (ok_t != 0) { return ok_t; }
            }
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_FLOAT:
            return generic_make_typeinfo_from_fields(TYPE_F64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        case AST_STACK_CTOR:
            var sc3: *AstStackCtor = (*AstStackCtor)expr;
            return generic_make_typeinfo_from_fields(sc3.type_kind, sc3.ptr_depth, sc3.is_tagged, sc3.struct_name_ptr, sc3.struct_name_len, sc3.tag_layout_ptr, sc3.tag_layout_len,
                                                     sc3.elem_type_kind, sc3.elem_ptr_depth, sc3.array_len, sc3.array_len_is_param, sc3.array_len_param_ptr, sc3.array_len_param_len);
        case AST_CALL:
            // Try function signatures
            var call: *AstCall = (*AstCall)expr;
            var resolved_ptr: u64 = call.name_ptr;
            var resolved_len: u64 = call.name_len;
            var resolved: *NameInfo = resolve_name(call.name_ptr, call.name_len);
            if (resolved != 0) {
                resolved_ptr = resolved.ptr;
                resolved_len = resolved.len;
            }
            if (g_all_func_sigs != 0) {
                var n: u64 = g_all_func_sigs.len();
                for (var i2: u64 = 0; i2 < n; i2++) {
                    var fn: *AstFunc = g_all_func_sigs.get(i2);
                    if (str_eq(fn.name_ptr, fn.name_len, resolved_ptr, resolved_len)) {
                        return generic_make_typeinfo_from_fields(fn.ret_type, fn.ret_ptr_depth, fn.ret_is_tagged, fn.ret_struct_name_ptr, fn.ret_struct_name_len, fn.ret_tag_layout_ptr, fn.ret_tag_layout_len, 0, 0, 0, 0, 0, 0);
                    }
                }
            }
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        default:
            return generic_make_typeinfo_from_fields(TYPE_U64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}

func generic_collect_var_decls(stmt: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> u64 {
    var kind: u64 = ast_kind(stmt);
    switch (kind) {
        case AST_VAR_DECL:
            var vd: *AstVarDecl = (*AstVarDecl)stmt;
            var t_ptr: *TypeInfo = generic_make_typeinfo_from_vardecl(vd);
            symtab.put(vd.name_ptr, vd.name_len, t_ptr);
            break;
        case AST_BLOCK:
            var blk: *AstBlock = (*AstBlock)stmt;
            var stmts: *Vec<*AstNode> = blk.stmts_vec;
            var n: u64 = stmts.len();
            for (var i: u64 = 0; i < n; i++) {
                generic_collect_var_decls(stmts.get(i), symtab);
            }
            break;
        case AST_IF:
            var ifs: *AstIf = (*AstIf)stmt;
            if (ifs.then_block != 0) { generic_collect_var_decls(ifs.then_block, symtab); }
            if (ifs.else_block != 0) { generic_collect_var_decls(ifs.else_block, symtab); }
            break;
        case AST_WHILE:
            var wl: *AstWhile = (*AstWhile)stmt;
            if (wl.body != 0) { generic_collect_var_decls(wl.body, symtab); }
            break;
        case AST_FOR:
            var fr: *AstFor = (*AstFor)stmt;
            if (fr.init != 0) { generic_collect_var_decls(fr.init, symtab); }
            if (fr.body != 0) { generic_collect_var_decls(fr.body, symtab); }
            break;
        case AST_SWITCH:
            var sw: *AstSwitch = (*AstSwitch)stmt;
            var cases: *Vec<*AstNode> = sw.cases_vec;
            var cn: u64 = cases.len();
            for (var j: u64 = 0; j < cn; j++) {
                generic_collect_var_decls(cases.get(j), symtab);
            }
            break;
        case AST_CASE:
            var cs: *AstCase = (*AstCase)stmt;
            if (cs.body != 0) { generic_collect_var_decls(cs.body, symtab); }
            break;
        default:
            break;
    }
    return 0;
}

func generic_build_symtab_for_func(fn: *AstFunc) -> *HashMap<u64, *TypeInfo> {
    var symtab: *HashMap<u64, *TypeInfo> = new HashMap<u64, *TypeInfo>(64);
    var params: *Vec<*Param> = fn.params_vec;
    if (params != 0) {
        var n: u64 = params.len();
        for (var i: u64 = 0; i < n; i++) {
            var p: *Param = params.get(i);
            var t_ptr: *TypeInfo = generic_make_typeinfo_from_param(p);
            symtab.put(p.name_ptr, p.name_len, t_ptr);
        }
    }
    if (fn.body != 0) {
        generic_collect_var_decls(fn.body, symtab);
    }
    return symtab;
}

func generic_clone_args_vec(args: *Vec<*AstNode>, bindings: *Vec<*GenericBinding>) -> *Vec<*AstNode> {
    if (args == 0) { return 0; }
    var out: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var n: u64 = args.len();
    for (var i: u64 = 0; i < n; i++) {
        var expr: *AstNode = args.get(i);
        out.push(generic_clone_expr(expr, bindings));
    }
    return out;
}

    func generic_clone_expr(node: *AstNode, bindings: *Vec<*GenericBinding>) -> *AstNode {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_LITERAL:
            var lit: *AstLiteral = (*AstLiteral)node;
            return ast_literal(lit.value);
        case AST_FLOAT:
            var fl: *AstFloat = (*AstFloat)node;
            return ast_float(fl.str_ptr, fl.str_len);
        case AST_IDENT:
            var id: *AstIdent = (*AstIdent)node;
            return ast_ident(id.name_ptr, id.name_len);
        case AST_STRING:
            var st: *AstString = (*AstString)node;
            return ast_string(st.str_ptr, st.str_len);
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)node;
            return ast_binary(bin.op, generic_clone_expr(bin.left, bindings), generic_clone_expr(bin.right, bindings));
        case AST_UNARY:
            var un: *AstUnary = (*AstUnary)node;
            return ast_unary(un.op, generic_clone_expr(un.operand, bindings));
        case AST_CALL:
            var call: *AstCall = (*AstCall)node;
            var args: *Vec<*AstNode> = generic_clone_args_vec(call.args_vec, bindings);
            return ast_call(call.name_ptr, call.name_len, args);
        case AST_GENERIC_CALL:
            var gc: *AstGenericCall = (*AstGenericCall)node;
            var gargs: *Vec<*GenericArg> = new Vec<*GenericArg>(4);
            var gn: u64 = gc.generic_args_vec.len();
            for (var i: u64 = 0; i < gn; i++) {
                var ga: *GenericArg = gc.generic_args_vec.get(i);
                var ng: *GenericArg = new GenericArg();
                ng.kind = ga.kind;
                ng.value = ga.value;
                if (ga.kind == GENERIC_KIND_TYPE) {
                    var ti: *TypeInfo = ga.type_ptr;
                    if (ti.type_kind == TYPE_GENERIC) {
                        var chk: *GenericBinding = generic_find_binding(bindings, GENERIC_KIND_TYPE, ti.struct_name_ptr, ti.struct_name_len);
                        if (chk == 0) {
                            emit_stderr("[DEBUG] Missing binding for generic arg in call: ");
                            emit_stderr_len(gc.name_ptr, gc.name_len);
                            emit_stderr(" arg=");
                            emit_stderr_len(ti.struct_name_ptr, ti.struct_name_len);
                            emit_stderr("\n");
                        }
                    }
                    var subst: *TypeInfo = generic_subst_typeinfo(ti.type_kind, ti.ptr_depth, ti.is_tagged, ti.struct_name_ptr, ti.struct_name_len, ti.tag_layout_ptr, ti.tag_layout_len, ti.elem_type_kind, ti.elem_ptr_depth, ti.array_len, ti.array_len_is_param, ti.array_len_param_ptr, ti.array_len_param_len, bindings);
                    ng.type_ptr = subst;
                } else {
                    ng.type_ptr = 0;
                }
                gargs.push(ng);
            }
            var args_g: *Vec<*AstNode> = generic_clone_args_vec(gc.args_vec, bindings);
            return ast_generic_call(gc.name_ptr, gc.name_len, gargs, args_g);
        case AST_ADDR_OF:
            var ao: *AstAddrOf = (*AstAddrOf)node;
            return ast_addr_of(generic_clone_expr(ao.operand, bindings));
        case AST_DEREF:
            var dr: *AstDeref = (*AstDeref)node;
            return ast_deref(generic_clone_expr(dr.operand, bindings));
        case AST_DEREF8:
            var dr8: *AstDeref8 = (*AstDeref8)node;
            return ast_deref8(generic_clone_expr(dr8.operand, bindings));
        case AST_CAST:
            var cs: *AstCast = (*AstCast)node;
            var sub: *TypeInfo = generic_subst_typeinfo(cs.target_type, cs.target_ptr_depth, cs.target_is_tagged, cs.struct_name_ptr, cs.struct_name_len, cs.tag_layout_ptr, cs.tag_layout_len, 0, 0, 0, 0, 0, 0, bindings);
            var ti: *TypeInfo = sub;
            return ast_cast_ex(generic_clone_expr(cs.expr, bindings), ti.type_kind, ti.ptr_depth, ti.is_tagged, ti.struct_name_ptr, ti.struct_name_len, ti.tag_layout_ptr, ti.tag_layout_len);
        case AST_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)node;
            if (ma.parent_ptr != 0) {
                return ast_member_access_scoped(generic_clone_expr(ma.object, bindings), ma.parent_ptr, ma.parent_len, ma.member_ptr, ma.member_len);
            }
            return ast_member_access(generic_clone_expr(ma.object, bindings), ma.member_ptr, ma.member_len);
        case AST_SAFE_MEMBER_ACCESS:
            var sma: *AstMemberAccess = (*AstMemberAccess)node;
            if (sma.parent_ptr != 0) {
                return ast_safe_member_access_scoped(generic_clone_expr(sma.object, bindings), sma.parent_ptr, sma.parent_len, sma.member_ptr, sma.member_len);
            }
            return ast_safe_member_access(generic_clone_expr(sma.object, bindings), sma.member_ptr, sma.member_len);
        case AST_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)node;
            var args2: *Vec<*AstNode> = generic_clone_args_vec(mc.args_vec, bindings);
            return ast_method_call(generic_clone_expr(mc.receiver, bindings), mc.method_ptr, mc.method_len, args2);
        case AST_SAFE_METHOD_CALL:
            var smc: *AstMethodCall = (*AstMethodCall)node;
            var sargs2: *Vec<*AstNode> = generic_clone_args_vec(smc.args_vec, bindings);
            return ast_safe_method_call(generic_clone_expr(smc.receiver, bindings), smc.method_ptr, smc.method_len, sargs2);
        case AST_TRY:
            var tr: *AstTry = (*AstTry)node;
            return ast_try(generic_clone_expr(tr.operand, bindings));
        case AST_STRUCT_LITERAL:
            var sl: *AstStructLiteral = (*AstStructLiteral)node;
            var vals: *Vec<*AstNode> = generic_clone_args_vec(sl.values_vec, bindings);
            return ast_struct_literal(sl.struct_def, vals);
        case AST_SIZEOF:
            var sz: *AstSizeof = (*AstSizeof)node;
            var sub2: *TypeInfo = generic_subst_typeinfo(sz.type_kind, sz.ptr_depth, 0, sz.struct_name_ptr, sz.struct_name_len, 0, 0, sz.elem_type_kind, sz.elem_ptr_depth, sz.array_len, sz.array_len_is_param, sz.array_len_param_ptr, sz.array_len_param_len, bindings);
            var ti2: *TypeInfo = sub2;
            return ast_sizeof(ti2.type_kind, ti2.ptr_depth, ti2.struct_name_ptr, ti2.struct_name_len, ti2.elem_type_kind, ti2.elem_ptr_depth, ti2.array_len, ti2.array_len_is_param, ti2.array_len_param_ptr, ti2.array_len_param_len);
        case AST_SIZEOF_EXPR:
            var se: *AstSizeofExpr = (*AstSizeofExpr)node;
            return ast_sizeof_expr(generic_clone_expr(se.expr, bindings));
        case AST_INDEX:
            var ix: *AstIndex = (*AstIndex)node;
            return ast_index(generic_clone_expr(ix.base, bindings), generic_clone_expr(ix.index, bindings));
        case AST_SLICE:
            var sl2: *AstSlice = (*AstSlice)node;
            return ast_slice(generic_clone_expr(sl2.ptr_expr, bindings), generic_clone_expr(sl2.len_expr, bindings));
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)node;
            var args3: *Vec<*AstNode> = generic_clone_args_vec(cp.args_vec, bindings);
            return ast_call_ptr(generic_clone_expr(cp.callee, bindings), args3);
        case AST_NEW:
            var nw: *AstNew = (*AstNew)node;
            var sub3: *TypeInfo = generic_subst_typeinfo(nw.type_kind, nw.ptr_depth, nw.is_tagged, nw.struct_name_ptr, nw.struct_name_len, nw.tag_layout_ptr, nw.tag_layout_len,
                                                        nw.elem_type_kind, nw.elem_ptr_depth, nw.array_len, nw.array_len_is_param, nw.array_len_param_ptr, nw.array_len_param_len, bindings);
            var lit2: *AstNode = generic_clone_expr(nw.literal_expr, bindings);
            var args4: *Vec<*AstNode> = generic_clone_args_vec(nw.ctor_args_vec, bindings);
            if (args4 != 0 && sub3.type_kind == TYPE_STRUCT) {
                var struct_base_len: u64 = compiler_find_generic_suffix_index(sub3.struct_name_ptr, sub3.struct_name_len);
                var ctor_name: *NameInfo = _compiler_build_constructor_name(sub3.struct_name_ptr, struct_base_len);
                var tpl_ptr: *GenericFuncTemplate = compiler_find_generic_template_by_name(ctor_name.ptr, ctor_name.len);
                if (tpl_ptr != 0 && tpl_ptr.params_vec != 0 && tpl_ptr.params_vec.len() > 0) {
                    var ctor_bindings: *Vec<*GenericBinding> = compiler_get_generic_struct_bindings(sub3.struct_name_ptr, sub3.struct_name_len);
                    if (ctor_bindings != 0) {
                        generic_get_or_create_instance(tpl_ptr, ctor_bindings);
                    }
                }
            }
            return (*AstNode)ast_new(sub3.type_kind, sub3.ptr_depth, sub3.is_tagged, sub3.struct_name_ptr, sub3.struct_name_len, sub3.tag_layout_ptr, sub3.tag_layout_len,
                                     sub3.elem_type_kind, sub3.elem_ptr_depth, sub3.array_len, sub3.array_len_is_param, sub3.array_len_param_ptr, sub3.array_len_param_len,
                                     lit2, args4);
        case AST_STACK_CTOR:
            var sc: *AstStackCtor = (*AstStackCtor)node;
            var sub_sc: *TypeInfo = generic_subst_typeinfo(sc.type_kind, sc.ptr_depth, sc.is_tagged, sc.struct_name_ptr, sc.struct_name_len, sc.tag_layout_ptr, sc.tag_layout_len,
                                                          sc.elem_type_kind, sc.elem_ptr_depth, sc.array_len, sc.array_len_is_param, sc.array_len_param_ptr, sc.array_len_param_len, bindings);
            var args_sc: *Vec<*AstNode> = generic_clone_args_vec(sc.ctor_args_vec, bindings);
            if (args_sc != 0 && sub_sc.type_kind == TYPE_STRUCT) {
                var struct_base_len_sc: u64 = compiler_find_generic_suffix_index(sub_sc.struct_name_ptr, sub_sc.struct_name_len);
                var ctor_name_sc: *NameInfo = _compiler_build_constructor_name(sub_sc.struct_name_ptr, struct_base_len_sc);
                var tpl_ptr_sc: *GenericFuncTemplate = compiler_find_generic_template_by_name(ctor_name_sc.ptr, ctor_name_sc.len);
                if (tpl_ptr_sc != 0 && tpl_ptr_sc.params_vec != 0 && tpl_ptr_sc.params_vec.len() > 0) {
                    var ctor_bindings_sc: *Vec<*GenericBinding> = compiler_get_generic_struct_bindings(sub_sc.struct_name_ptr, sub_sc.struct_name_len);
                    if (ctor_bindings_sc != 0) {
                        generic_get_or_create_instance(tpl_ptr_sc, ctor_bindings_sc);
                    }
                }
            }
            return (*AstNode)ast_stack_ctor(sub_sc.type_kind, sub_sc.ptr_depth, sub_sc.is_tagged, sub_sc.struct_name_ptr, sub_sc.struct_name_len, sub_sc.tag_layout_ptr, sub_sc.tag_layout_len,
                                            sub_sc.elem_type_kind, sub_sc.elem_ptr_depth, sub_sc.array_len, sub_sc.array_len_is_param, sub_sc.array_len_param_ptr, sub_sc.array_len_param_len,
                                            args_sc);
        default:
            return node;
    }
}

func generic_clone_stmt(node: *AstNode, bindings: *Vec<*GenericBinding>) -> *AstNode {
    if (node == 0) { return 0; }
    var kind: u64 = ast_kind(node);
    switch (kind) {
        case AST_RETURN:
            var r: *AstReturn = (*AstReturn)node;
            return ast_return(generic_clone_expr(r.expr, bindings));
        case AST_VAR_DECL:
            var vd: *AstVarDecl = (*AstVarDecl)node;
            var ti: *TypeInfo = generic_subst_typeinfo(vd.type_kind, vd.ptr_depth, vd.is_tagged, vd.struct_name_ptr, vd.struct_name_len, vd.tag_layout_ptr, vd.tag_layout_len, vd.elem_type_kind, vd.elem_ptr_depth, vd.array_len, vd.array_len_is_param, vd.array_len_param_ptr, vd.array_len_param_len, bindings);
            var decl: *AstVarDecl = ast_var_decl(vd.name_ptr, vd.name_len, ti.type_kind, ti.ptr_depth, generic_clone_expr(vd.init_expr, bindings));
            decl.is_tagged = ti.is_tagged;
            decl.struct_name_ptr = ti.struct_name_ptr;
            decl.struct_name_len = ti.struct_name_len;
            decl.tag_layout_ptr = ti.tag_layout_ptr;
            decl.tag_layout_len = ti.tag_layout_len;
            decl.elem_type_kind = ti.elem_type_kind;
            decl.elem_ptr_depth = ti.elem_ptr_depth;
            decl.array_len = ti.array_len;
            decl.array_len_is_param = ti.array_len_is_param;
            decl.array_len_param_ptr = ti.array_len_param_ptr;
            decl.array_len_param_len = ti.array_len_param_len;
            return (*AstNode)decl;
        case AST_ASSIGN:
            var assign_node: *AstAssign = (*AstAssign)node;
            return ast_assign(generic_clone_expr(assign_node.target, bindings), generic_clone_expr(assign_node.value, bindings));
        case AST_EXPR_STMT:
            var es: *AstExprStmt = (*AstExprStmt)node;
            return ast_expr_stmt(generic_clone_expr(es.expr, bindings));
        case AST_IF:
            var ifs: *AstIf = (*AstIf)node;
            return ast_if(generic_clone_expr(ifs.cond, bindings), generic_clone_stmt(ifs.then_block, bindings), generic_clone_stmt(ifs.else_block, bindings));
        case AST_WHILE:
            var wl: *AstWhile = (*AstWhile)node;
            return ast_while(generic_clone_expr(wl.cond, bindings), generic_clone_stmt(wl.body, bindings));
        case AST_FOR:
            var fr: *AstFor = (*AstFor)node;
            return ast_for(generic_clone_stmt(fr.init, bindings), generic_clone_expr(fr.cond, bindings), generic_clone_expr(fr.update, bindings), generic_clone_stmt(fr.body, bindings));
        case AST_SWITCH:
            var sw: *AstSwitch = (*AstSwitch)node;
            var cases_out: *Vec<*AstNode> = new Vec<*AstNode>(4);
            var cn: u64 = sw.cases_vec.len();
            for (var i: u64 = 0; i < cn; i++) {
                cases_out.push(generic_clone_stmt(sw.cases_vec.get(i), bindings));
            }
            return ast_switch(generic_clone_expr(sw.expr, bindings), cases_out);
        case AST_CASE:
            var cs: *AstCase = (*AstCase)node;
            return ast_case(cs.value, generic_clone_stmt(cs.body, bindings), cs.is_default);
        case AST_BREAK:
            return ast_break();
        case AST_CONTINUE:
            return ast_continue();
        case AST_BLOCK:
            var blk: *AstBlock = (*AstBlock)node;
            var stmts_out: *Vec<*AstNode> = new Vec<*AstNode>(8);
            var n: u64 = blk.stmts_vec.len();
            for (var i: u64 = 0; i < n; i++) {
                stmts_out.push(generic_clone_stmt(blk.stmts_vec.get(i), bindings));
            }
            return ast_block(stmts_out);
        case AST_ASM:
            var asmnode: *AstAsm = (*AstAsm)node;
            var text_vec: *Vec<u64> = new Vec<u64>(16);
            var tn: u64 = asmnode.text_vec.len();
            for (var i2: u64 = 0; i2 < tn; i2++) { text_vec.push(asmnode.text_vec.get(i2)); }
            return ast_asm(text_vec);
        case AST_ALIAS:
            var al: *AstAlias = (*AstAlias)node;
            return (*AstNode)ast_alias(al.reg_ptr, al.reg_len, al.name_ptr, al.name_len);
        case AST_DEFER:
            var df: *AstDefer = (*AstDefer)node;
            return (*AstNode)ast_defer(generic_clone_stmt(df.stmt, bindings));
        case AST_DELETE:
            var dl: *AstDelete = (*AstDelete)node;
            return (*AstNode)ast_delete(generic_clone_expr(dl.expr, bindings));
        default:
            return node;
    }
}

func generic_clone_func(template_ptr: *AstFunc, bindings: *Vec<*GenericBinding>, new_name_ptr: u64, new_name_len: u64) -> *AstFunc {
    var fn: *AstFunc = template_ptr;
    var params_out: *Vec<*Param> = new Vec<*Param>(8);
    var pn: u64 = fn.params_vec.len();
    for (var i: u64 = 0; i < pn; i++) {
        var p: *Param = fn.params_vec.get(i);
        var ti: *TypeInfo = generic_subst_typeinfo(p.type_kind, p.ptr_depth, p.is_tagged, p.struct_name_ptr, p.struct_name_len, p.tag_layout_ptr, p.tag_layout_len, p.elem_type_kind, p.elem_ptr_depth, p.array_len, p.array_len_is_param, p.array_len_param_ptr, p.array_len_param_len, bindings);
        var np: *Param = new Param();
        np.name_ptr = p.name_ptr;
        np.name_len = p.name_len;
        np.type_kind = ti.type_kind;
        np.ptr_depth = ti.ptr_depth;
        np.is_tagged = ti.is_tagged;
        np.struct_name_ptr = ti.struct_name_ptr;
        np.struct_name_len = ti.struct_name_len;
        np.tag_layout_ptr = ti.tag_layout_ptr;
        np.tag_layout_len = ti.tag_layout_len;
        np.elem_type_kind = ti.elem_type_kind;
        np.elem_ptr_depth = ti.elem_ptr_depth;
        np.array_len = ti.array_len;
        np.array_len_is_param = ti.array_len_is_param;
        np.array_len_param_ptr = ti.array_len_param_ptr;
        np.array_len_param_len = ti.array_len_param_len;
        params_out.push(np);
    }

    var rt: *TypeInfo = generic_subst_typeinfo(fn.ret_type, fn.ret_ptr_depth, fn.ret_is_tagged, fn.ret_struct_name_ptr, fn.ret_struct_name_len, fn.ret_tag_layout_ptr, fn.ret_tag_layout_len, 0, 0, 0, 0, 0, 0, bindings);
    var body_out: *AstNode = generic_clone_stmt(fn.body, bindings);
    return ast_func_ex(new_name_ptr, new_name_len, params_out, rt.type_kind, rt.ptr_depth, rt.is_tagged, rt.struct_name_ptr, rt.struct_name_len, rt.tag_layout_ptr, rt.tag_layout_len, body_out);
}

func generic_clone_func_sig(template_ptr: *AstFunc, bindings: *Vec<*GenericBinding>, new_name_ptr: u64, new_name_len: u64) -> *AstFunc {
    var fn: *AstFunc = template_ptr;
    var params_out: *Vec<*Param> = new Vec<*Param>(8);
    var pn: u64 = fn.params_vec.len();
    for (var i: u64 = 0; i < pn; i++) {
        var p: *Param = fn.params_vec.get(i);
        var ti: *TypeInfo = generic_subst_typeinfo(p.type_kind, p.ptr_depth, p.is_tagged, p.struct_name_ptr, p.struct_name_len, p.tag_layout_ptr, p.tag_layout_len, p.elem_type_kind, p.elem_ptr_depth, p.array_len, p.array_len_is_param, p.array_len_param_ptr, p.array_len_param_len, bindings);
        var np: *Param = new Param();
        np.name_ptr = p.name_ptr;
        np.name_len = p.name_len;
        np.type_kind = ti.type_kind;
        np.ptr_depth = ti.ptr_depth;
        np.is_tagged = ti.is_tagged;
        np.struct_name_ptr = ti.struct_name_ptr;
        np.struct_name_len = ti.struct_name_len;
        np.tag_layout_ptr = ti.tag_layout_ptr;
        np.tag_layout_len = ti.tag_layout_len;
        np.elem_type_kind = ti.elem_type_kind;
        np.elem_ptr_depth = ti.elem_ptr_depth;
        np.array_len = ti.array_len;
        np.array_len_is_param = ti.array_len_is_param;
        np.array_len_param_ptr = ti.array_len_param_ptr;
        np.array_len_param_len = ti.array_len_param_len;
        params_out.push(np);
    }

    var rt: *TypeInfo = generic_subst_typeinfo(fn.ret_type, fn.ret_ptr_depth, fn.ret_is_tagged, fn.ret_struct_name_ptr, fn.ret_struct_name_len, fn.ret_tag_layout_ptr, fn.ret_tag_layout_len, 0, 0, 0, 0, 0, 0, bindings);
    return ast_func_ex(new_name_ptr, new_name_len, params_out, rt.type_kind, rt.ptr_depth, rt.is_tagged, rt.struct_name_ptr, rt.struct_name_len, rt.tag_layout_ptr, rt.tag_layout_len, 0);
}

func generic_get_or_create_instance(tpl_ptr: *GenericFuncTemplate, bindings: *Vec<*GenericBinding>) -> *NameInfo {
    var tpl: *GenericFuncTemplate = tpl_ptr;
    var base_ptr: u64 = tpl.mangled_ptr;
    var base_len: u64 = tpl.mangled_len;
    if (base_ptr == 0) {
        base_ptr = tpl.name_ptr;
        base_len = tpl.name_len;
    }

    var name_info: *NameInfo = generic_mangle_name(base_ptr, base_len, tpl.params_vec, bindings);
    var inst_ptr: u64 = name_info.ptr;
    var inst_len: u64 = name_info.len;

    if (g_generic_instantiations != 0) {
        var exists: u64 = g_generic_instantiations.get(inst_ptr, inst_len);
        if (exists != 0) { return name_info; }
    }

    var def_src: *AstFunc = tpl.func_def;
    if (def_src == 0 && tpl.func_sig != 0) { def_src = tpl.func_sig; }
    if (def_src == 0) {
        emit_stderr("[ERROR] Missing generic function body\n");
        panic("Parse error");
    }

    var fn_new: *AstFunc = generic_clone_func(def_src, bindings, inst_ptr, inst_len);
    var sig_new: *AstFunc = generic_clone_func_sig(def_src, bindings, inst_ptr, inst_len);
    g_all_funcs.push(fn_new);
    g_all_func_sigs.push(sig_new);

    if (g_generic_instantiations == 0) { g_generic_instantiations = new HashMap<u64, u64>(64); }
    g_generic_instantiations.put(inst_ptr, inst_len, 1);

    // Map new function to template module
    if (g_func_module_map != 0 && tpl.mangled_ptr != 0) {
        var mod_info: *NameInfo = g_func_module_map.get(tpl.mangled_ptr, tpl.mangled_len);
        if (mod_info != 0) {
            g_func_module_map.put(inst_ptr, inst_len, mod_info);
        }
    }

    return name_info;
}

func generic_build_bindings_for_explicit(tpl_ptr: *GenericFuncTemplate, gargs: *Vec<*GenericArg>) -> *Vec<*GenericBinding> {
    var tpl: *GenericFuncTemplate = tpl_ptr;
    var bindings: *Vec<*GenericBinding> = new Vec<*GenericBinding>(4);
    var pn: u64 = tpl.params_vec.len();
    var an: u64 = gargs.len();
    if (pn != an) {
        emit_stderr("[ERROR] Generic argument count mismatch\n");
        panic("Parse error");
    }
    for (var i: u64 = 0; i < pn; i++) {
        var gp: *GenericParam = tpl.params_vec.get(i);
        var ga: *GenericArg = gargs.get(i);
        if (gp.kind == GENERIC_KIND_TYPE) {
            if (ga.kind != GENERIC_KIND_TYPE) {
                emit_stderr("[ERROR] Expected type generic argument\n");
                panic("Parse error");
            }
            if (generic_bind_type(bindings, gp.name_ptr, gp.name_len, ga.type_ptr) != 0) {
                emit_stderr("[ERROR] Conflicting generic type bindings\n");
                panic("Parse error");
            }
        } else {
            if (ga.kind != GENERIC_KIND_VALUE) {
                emit_stderr("[ERROR] Expected value generic argument\n");
                panic("Parse error");
            }
            if (generic_bind_value(bindings, gp.name_ptr, gp.name_len, ga.value) != 0) {
                emit_stderr("[ERROR] Conflicting generic value bindings\n");
                panic("Parse error");
            }
        }
    }
    return bindings;
}

func generic_build_bindings_for_struct(tpl_ptr: *GenericStructTemplate, gargs: *Vec<*GenericArg>) -> *Vec<*GenericBinding> {
    var tpl: *GenericStructTemplate = tpl_ptr;
    var bindings: *Vec<*GenericBinding> = new Vec<*GenericBinding>(4);
    var pn: u64 = tpl.params_vec.len();
    var an: u64 = gargs.len();
    if (pn != an) {
        emit_stderr("[ERROR] Generic argument count mismatch\n");
        panic("Parse error");
    }
    for (var i: u64 = 0; i < pn; i++) {
        var gp: *GenericParam = tpl.params_vec.get(i);
        var ga: *GenericArg = gargs.get(i);
        if (gp.kind == GENERIC_KIND_TYPE) {
            if (ga.kind != GENERIC_KIND_TYPE) {
                emit_stderr("[ERROR] Expected type generic argument\n");
                panic("Parse error");
            }
            if (generic_bind_type(bindings, gp.name_ptr, gp.name_len, ga.type_ptr) != 0) {
                emit_stderr("[ERROR] Conflicting generic type bindings\n");
                panic("Parse error");
            }
        } else {
            if (ga.kind != GENERIC_KIND_VALUE) {
                emit_stderr("[ERROR] Expected value generic argument\n");
                panic("Parse error");
            }
            if (generic_bind_value(bindings, gp.name_ptr, gp.name_len, ga.value) != 0) {
                emit_stderr("[ERROR] Conflicting generic value bindings\n");
                panic("Parse error");
            }
        }
    }
    return bindings;
}

func generic_clone_struct(template_def: *AstStructDef, bindings: *Vec<*GenericBinding>, new_name_ptr: u64, new_name_len: u64) -> *AstStructDef {
    var sd: *AstStructDef = template_def;
    var fields_in: *Vec<*FieldDesc> = sd.fields_vec;
    var fields_out: *Vec<*FieldDesc> = new Vec<*FieldDesc>(fields_in.len());
    var n: u64 = fields_in.len();
    for (var i: u64 = 0; i < n; i++) {
        var f: *FieldDesc = fields_in.get(i);
        var ti: *TypeInfo = generic_subst_typeinfo(f.type_kind, f.ptr_depth, f.is_tagged, f.struct_name_ptr, f.struct_name_len, f.tag_layout_ptr, f.tag_layout_len, f.elem_type_kind, f.elem_ptr_depth, f.array_len, 0, 0, 0, bindings);
        var nf: *FieldDesc = new FieldDesc();
        nf.name_ptr = f.name_ptr;
        nf.name_len = f.name_len;
        nf.type_kind = ti.type_kind;
        nf.struct_name_ptr = ti.struct_name_ptr;
        nf.struct_name_len = ti.struct_name_len;
        nf.ptr_depth = ti.ptr_depth;
        nf.is_tagged = ti.is_tagged;
        nf.tag_layout_ptr = ti.tag_layout_ptr;
        nf.tag_layout_len = ti.tag_layout_len;
        nf.bit_width = f.bit_width;
        nf.elem_type_kind = ti.elem_type_kind;
        nf.elem_ptr_depth = ti.elem_ptr_depth;
        nf.array_len = ti.array_len;
        fields_out.push(nf);
    }
    var parents_out: *Vec<*ParentDesc> = 0;
    if (sd.parents_vec != 0) {
        var parents_in: *Vec<*ParentDesc> = sd.parents_vec;
        parents_out = new Vec<*ParentDesc>(parents_in.len());
        var pn: u64 = parents_in.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_in: *ParentDesc = parents_in.get(pi);
            var parent_out: *ParentDesc = new ParentDesc();
            parent_out.name_ptr = parent_in.name_ptr;
            parent_out.name_len = parent_in.name_len;
            parent_out.struct_def = parent_in.struct_def;
            parents_out.push(parent_out);
        }
    }
    var traits_out: *Vec<*TraitRef> = 0;
    if (sd.traits_vec != 0) {
        var traits_in: *Vec<*TraitRef> = sd.traits_vec;
        traits_out = new Vec<*TraitRef>(traits_in.len());
        var tn: u64 = traits_in.len();
        for (var ti: u64 = 0; ti < tn; ti++) {
            var t_in: *TraitRef = traits_in.get(ti);
            var t_out: *TraitRef = new TraitRef();
            t_out.name_ptr = t_in.name_ptr;
            t_out.name_len = t_in.name_len;
            t_out.trait_def = t_in.trait_def;
            traits_out.push(t_out);
        }
    }
    return ast_struct_def(new_name_ptr, new_name_len, parents_out, fields_out, sd.is_packed, traits_out);
}

func generic_struct_get_or_create_instance(tpl_ptr: *GenericStructTemplate, bindings: *Vec<*GenericBinding>) -> *NameInfo {
    var tpl: *GenericStructTemplate = tpl_ptr;
    var name_info: *NameInfo = generic_mangle_name(tpl.name_ptr, tpl.name_len, tpl.params_vec, bindings);
    var inst_ptr: u64 = name_info.ptr;
    var inst_len: u64 = name_info.len;

    if (g_generic_struct_instantiations != 0) {
        var exists: *AstStructDef = g_generic_struct_instantiations.get(inst_ptr, inst_len);
        if (exists != 0) {
            compiler_register_generic_struct_bindings(inst_ptr, inst_len, bindings);
            return name_info;
        }
    }

    var def_src: *AstStructDef = tpl.struct_def;
    if (def_src == 0) {
        emit_stderr("[ERROR] Missing generic struct template\n");
        panic("Parse error");
    }

    var struct_new: *AstStructDef = generic_clone_struct(def_src, bindings, inst_ptr, inst_len);
    register_struct_type(struct_new);

    if (g_generic_struct_instantiations == 0) { g_generic_struct_instantiations = new HashMap<u64, *AstStructDef>(64); }
    g_generic_struct_instantiations.put(inst_ptr, inst_len, struct_new);
    compiler_register_generic_struct_bindings(inst_ptr, inst_len, bindings);
    return name_info;
}

func generic_build_bindings_by_infer(tpl_ptr: *GenericFuncTemplate, call_args: *Vec<*AstNode>, symtab: *HashMap<u64, *TypeInfo>) -> *Vec<*GenericBinding> {
    var tpl: *GenericFuncTemplate = tpl_ptr;
    var bindings: *Vec<*GenericBinding> = new Vec<*GenericBinding>(4);
    var def_src: *AstFunc = tpl.func_def;
    if (def_src == 0) { def_src = tpl.func_sig; }
    if (def_src == 0) {
        emit_stderr("[ERROR] Missing generic signature for inference\n");
        panic("Parse error");
    }
    var fn: *AstFunc = def_src;
    var params: *Vec<*Param> = fn.params_vec;
    var pn: u64 = params.len();
    var an: u64 = call_args.len();
    if (pn != an) {
        emit_stderr("[ERROR] Generic inference arg count mismatch\n");
        panic("Parse error");
    }

    for (var i: u64 = 0; i < pn; i++) {
        var p: *Param = params.get(i);
        var arg_expr: *AstNode = call_args.get(i);
        var arg_ti: *TypeInfo = generic_infer_expr_type(arg_expr, symtab);
        if (generic_infer_from_typeinfo(p.type_kind, p.ptr_depth, p.struct_name_ptr, p.struct_name_len, p.elem_type_kind, p.elem_ptr_depth, p.array_len, p.array_len_is_param, p.array_len_param_ptr, p.array_len_param_len, arg_ti, bindings) != 0) {
            return 0;
        }
    }

    return bindings;
}

func generic_resolve_template(name_ptr: u64, name_len: u64) -> *GenericFuncTemplate {
    var tpl: *GenericFuncTemplate = compiler_find_generic_template_by_name(name_ptr, name_len);
    if (tpl != 0) {
        var t: *GenericFuncTemplate = tpl;
        if (t.params_vec != 0 && t.params_vec.len() > 0) { return tpl; }
    }
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        tpl = compiler_find_generic_template_by_mangled(resolved.ptr, resolved.len);
        if (tpl != 0) {
            var t2: *GenericFuncTemplate = tpl;
            if (t2.params_vec != 0 && t2.params_vec.len() > 0) { return tpl; }
            tpl = 0;
        }
    }
    return tpl;
}

func generic_process_expr(expr: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> *AstNode {
    if (expr == 0) { return 0; }
    var kind: u64 = ast_kind(expr);
    switch (kind) {
        case AST_GENERIC_CALL:
            var gc: *AstGenericCall = (*AstGenericCall)expr;
            var tpl_ptr: *GenericFuncTemplate = generic_resolve_template(gc.name_ptr, gc.name_len);
            if (tpl_ptr == 0) {
                emit_stderr("[ERROR] Generic function not found\n");
                panic("Parse error");
            }
            var bindings: *Vec<*GenericBinding> = generic_build_bindings_for_explicit(tpl_ptr, gc.generic_args_vec);
            var name_info: *NameInfo = generic_get_or_create_instance(tpl_ptr, bindings);
            var args_new: *Vec<*AstNode> = new Vec<*AstNode>(4);
            var an: u64 = gc.args_vec.len();
            for (var i: u64 = 0; i < an; i++) {
                args_new.push(generic_process_expr(gc.args_vec.get(i), symtab));
            }
            return ast_call(name_info.ptr, name_info.len, args_new);
        case AST_CALL:
            var call: *AstCall = (*AstCall)expr;
            var tpl_ptr2: *GenericFuncTemplate = generic_resolve_template(call.name_ptr, call.name_len);
            if (tpl_ptr2 == 0) {
                var args_new2: *Vec<*AstNode> = new Vec<*AstNode>(4);
                var an2: u64 = call.args_vec.len();
                for (var i2: u64 = 0; i2 < an2; i2++) {
                    args_new2.push(generic_process_expr(call.args_vec.get(i2), symtab));
                }
                return ast_call(call.name_ptr, call.name_len, args_new2);
            }
            var bindings2: *Vec<*GenericBinding> = generic_build_bindings_by_infer(tpl_ptr2, call.args_vec, symtab);
            if (bindings2 == 0) {
                var args_fallback: *Vec<*AstNode> = new Vec<*AstNode>(4);
                var an_fallback: u64 = call.args_vec.len();
                for (var ifb: u64 = 0; ifb < an_fallback; ifb++) {
                    args_fallback.push(generic_process_expr(call.args_vec.get(ifb), symtab));
                }
                return ast_call(call.name_ptr, call.name_len, args_fallback);
            }
            var name_info2: *NameInfo = generic_get_or_create_instance(tpl_ptr2, bindings2);
            var args_new3: *Vec<*AstNode> = new Vec<*AstNode>(4);
            var an3: u64 = call.args_vec.len();
            for (var i3: u64 = 0; i3 < an3; i3++) {
                args_new3.push(generic_process_expr(call.args_vec.get(i3), symtab));
            }
            return ast_call(name_info2.ptr, name_info2.len, args_new3);
        case AST_BINARY:
            var bin: *AstBinary = (*AstBinary)expr;
            bin.left = generic_process_expr(bin.left, symtab);
            bin.right = generic_process_expr(bin.right, symtab);
            return expr;
        case AST_UNARY:
            var un: *AstUnary = (*AstUnary)expr;
            un.operand = generic_process_expr(un.operand, symtab);
            return expr;
        case AST_ADDR_OF:
            var ao: *AstAddrOf = (*AstAddrOf)expr;
            ao.operand = generic_process_expr(ao.operand, symtab);
            return expr;
        case AST_DEREF:
            var dr: *AstDeref = (*AstDeref)expr;
            dr.operand = generic_process_expr(dr.operand, symtab);
            return expr;
        case AST_DEREF8:
            var dr8: *AstDeref8 = (*AstDeref8)expr;
            dr8.operand = generic_process_expr(dr8.operand, symtab);
            return expr;
        case AST_CAST:
            var cs: *AstCast = (*AstCast)expr;
            cs.expr = generic_process_expr(cs.expr, symtab);
            return expr;
        case AST_MEMBER_ACCESS:
            var ma: *AstMemberAccess = (*AstMemberAccess)expr;
            ma.object = generic_process_expr(ma.object, symtab);
            return expr;
        case AST_SAFE_MEMBER_ACCESS:
            var sma: *AstMemberAccess = (*AstMemberAccess)expr;
            sma.object = generic_process_expr(sma.object, symtab);
            return expr;
        case AST_TRY:
            var tr2: *AstTry = (*AstTry)expr;
            tr2.operand = generic_process_expr(tr2.operand, symtab);
            return expr;
        case AST_FLOAT:
            return expr;
        case AST_METHOD_CALL:
            var mc: *AstMethodCall = (*AstMethodCall)expr;
            mc.receiver = generic_process_expr(mc.receiver, symtab);
            var args: *Vec<*AstNode> = new Vec<*AstNode>(4);
            var an4: u64 = mc.args_vec.len();
            for (var i4: u64 = 0; i4 < an4; i4++) {
                args.push(generic_process_expr(mc.args_vec.get(i4), symtab));
            }
            mc.args_vec = args;
            var recv_ti: *TypeInfo = generic_infer_expr_type(mc.receiver, symtab);
            if (recv_ti != 0) {
                if (recv_ti.type_kind == TYPE_STRUCT) {
                    var struct_ptr: u64 = recv_ti.struct_name_ptr;
                    var struct_len: u64 = recv_ti.struct_name_len;
                    var base_len: u64 = compiler_find_generic_suffix_index(struct_ptr, struct_len);
                    var full_len2: u64 = base_len + 1 + mc.method_len;
                    var full_ptr2: u64 = heap_alloc((full_len2 + 1) * sizeof(u8));
                    var full_u8: []u8 = slice(full_ptr2, full_len2 + 1);
                    var struct_u8: []u8 = slice(struct_ptr, struct_len);
                    var method_u8: []u8 = slice(mc.method_ptr, mc.method_len);
                    for (var bi: u64 = 0; bi < base_len; bi++) {
                        full_u8[bi] = struct_u8[bi];
                    }
                    full_u8[base_len] = 95;
                    for (var mj: u64 = 0; mj < mc.method_len; mj++) {
                        full_u8[base_len + 1 + mj] = method_u8[mj];
                    }
                    full_u8[full_len2] = 0;

                    var tpl_ptr3: *GenericFuncTemplate = compiler_find_generic_template_by_name(full_ptr2, full_len2);
                    if (tpl_ptr3 == 0) {
                        var base_u8: []u8 = slice(struct_ptr, base_len);
                        var last_sep: u64 = base_len;
                        for (var si: u64 = 0; si + 1 < base_len; si++) {
                            if (base_u8[si] == 95 && base_u8[si + 1] == 95) { last_sep = si + 2; }
                        }
                        if (last_sep < base_len) {
                            var short_base_len: u64 = base_len - last_sep;
                            var short_base_ptr: u64 = struct_ptr + last_sep;
                            var alt_len: u64 = short_base_len + 1 + mc.method_len;
                            var alt_ptr: u64 = heap_alloc((alt_len + 1) * sizeof(u8));
                            var alt_u8: []u8 = slice(alt_ptr, alt_len + 1);
                            var short_u8: []u8 = slice(short_base_ptr, short_base_len);
                            for (var ai0: u64 = 0; ai0 < short_base_len; ai0++) {
                                alt_u8[ai0] = short_u8[ai0];
                            }
                            alt_u8[short_base_len] = 95;
                            for (var ai1: u64 = 0; ai1 < mc.method_len; ai1++) {
                                alt_u8[short_base_len + 1 + ai1] = method_u8[ai1];
                            }
                            alt_u8[alt_len] = 0;
                            tpl_ptr3 = compiler_find_generic_template_by_name(alt_ptr, alt_len);
                        }
                    }
                    if (tpl_ptr3 != 0) {
                        var bindings3: *Vec<*GenericBinding> = 0;
                        if (base_len != struct_len) {
                            bindings3 = compiler_get_generic_struct_bindings(struct_ptr, struct_len);
                        }
                        if (bindings3 == 0) {
                            var infer_args: *Vec<*AstNode> = new Vec<*AstNode>(an4 + 1);
                            if (recv_ti.ptr_depth > 0) { infer_args.push(mc.receiver); }
                            else { infer_args.push(ast_addr_of(mc.receiver)); }
                            for (var ai: u64 = 0; ai < an4; ai++) {
                                infer_args.push(args.get(ai));
                            }
                            bindings3 = generic_build_bindings_by_infer(tpl_ptr3, infer_args, symtab);
                        }
                        if (bindings3 != 0) {
                            generic_get_or_create_instance(tpl_ptr3, bindings3);
                        }
                    }
                }
            }
            return expr;
        case AST_SAFE_METHOD_CALL:
            var smc: *AstMethodCall = (*AstMethodCall)expr;
            smc.receiver = generic_process_expr(smc.receiver, symtab);
            var sargs: *Vec<*AstNode> = new Vec<*AstNode>(4);
            var san: u64 = smc.args_vec.?len();
            for (var si: u64 = 0; si < san; si++) {
                sargs.push(generic_process_expr(smc.args_vec.get(si), symtab));
            }
            smc.args_vec = sargs;
            var srecv_ti: *TypeInfo = generic_infer_expr_type(smc.receiver, symtab);
            if (srecv_ti != 0) {
                if (srecv_ti.type_kind == TYPE_STRUCT) {
                    var sstruct_ptr: u64 = srecv_ti.struct_name_ptr;
                    var sstruct_len: u64 = srecv_ti.struct_name_len;
                    var sbase_len: u64 = compiler_find_generic_suffix_index(sstruct_ptr, sstruct_len);
                    var sfull_len: u64 = sbase_len + 1 + smc.method_len;
                    var sfull_ptr: u64 = heap_alloc((sfull_len + 1) * sizeof(u8));
                    var sfull_u8: []u8 = slice(sfull_ptr, sfull_len + 1);
                    var sstruct_u8: []u8 = slice(sstruct_ptr, sstruct_len);
                    var smethod_u8: []u8 = slice(smc.method_ptr, smc.method_len);
                    for (var sbi: u64 = 0; sbi < sbase_len; sbi++) {
                        sfull_u8[sbi] = sstruct_u8[sbi];
                    }
                    sfull_u8[sbase_len] = 95;
                    for (var smj: u64 = 0; smj < smc.method_len; smj++) {
                        sfull_u8[sbase_len + 1 + smj] = smethod_u8[smj];
                    }
                    sfull_u8[sfull_len] = 0;

                    var tpl_ptr4: *GenericFuncTemplate = compiler_find_generic_template_by_name(sfull_ptr, sfull_len);
                    if (tpl_ptr4 == 0) {
                        var sbase_u8: []u8 = slice(sstruct_ptr, sbase_len);
                        var slast_sep: u64 = sbase_len;
                        for (var ssi: u64 = 0; ssi + 1 < sbase_len; ssi++) {
                            if (sbase_u8[ssi] == 95 && sbase_u8[ssi + 1] == 95) { slast_sep = ssi + 2; }
                        }
                        if (slast_sep < sbase_len) {
                            var sshort_base_len: u64 = sbase_len - slast_sep;
                            var sshort_base_ptr: u64 = sstruct_ptr + slast_sep;
                            var salt_len: u64 = sshort_base_len + 1 + smc.method_len;
                            var salt_ptr: u64 = heap_alloc((salt_len + 1) * sizeof(u8));
                            var salt_u8: []u8 = slice(salt_ptr, salt_len + 1);
                            var sshort_u8: []u8 = slice(sshort_base_ptr, sshort_base_len);
                            for (var sai0: u64 = 0; sai0 < sshort_base_len; sai0++) {
                                salt_u8[sai0] = sshort_u8[sai0];
                            }
                            salt_u8[sshort_base_len] = 95;
                            for (var sai1: u64 = 0; sai1 < smc.method_len; sai1++) {
                                salt_u8[sshort_base_len + 1 + sai1] = smethod_u8[sai1];
                            }
                            salt_u8[salt_len] = 0;
                            tpl_ptr4 = compiler_find_generic_template_by_name(salt_ptr, salt_len);
                        }
                    }
                    if (tpl_ptr4 != 0) {
                        var bindings4: *Vec<*GenericBinding> = 0;
                        if (sbase_len != sstruct_len) {
                            bindings4 = compiler_get_generic_struct_bindings(sstruct_ptr, sstruct_len);
                        }
                        if (bindings4 == 0) {
                            var infer_args4: *Vec<*AstNode> = new Vec<*AstNode>(san + 1);
                            if (srecv_ti.ptr_depth > 0) { infer_args4.push(smc.receiver); }
                            else { infer_args4.push(ast_addr_of(smc.receiver)); }
                            for (var sai2: u64 = 0; sai2 < san; sai2++) {
                                infer_args4.push(sargs.get(sai2));
                            }
                            bindings4 = generic_build_bindings_by_infer(tpl_ptr4, infer_args4, symtab);
                        }
                        if (bindings4 != 0) {
                            generic_get_or_create_instance(tpl_ptr4, bindings4);
                        }
                    }
                }
            }
            return expr;
        case AST_NEW:
            var nw: *AstNew = (*AstNew)expr;
            if (nw.literal_expr != 0) {
                nw.literal_expr = generic_process_expr(nw.literal_expr, symtab);
            }
            if (nw.ctor_args_vec != 0) {
                var ctor_args: *Vec<*AstNode> = new Vec<*AstNode>(4);
                var cn: u64 = nw.ctor_args_vec.len();
                for (var ci: u64 = 0; ci < cn; ci++) {
                    ctor_args.push(generic_process_expr(nw.ctor_args_vec.get(ci), symtab));
                }
                nw.ctor_args_vec = ctor_args;
            }
            if (nw.ctor_args_vec != 0 && nw.type_kind == TYPE_STRUCT) {
                var struct_base_len: u64 = compiler_find_generic_suffix_index(nw.struct_name_ptr, nw.struct_name_len);
                var ctor_name: *NameInfo = _compiler_build_constructor_name(nw.struct_name_ptr, struct_base_len);
                var tpl_ptr4: *GenericFuncTemplate = compiler_find_generic_template_by_name(ctor_name.ptr, ctor_name.len);
                if (tpl_ptr4 != 0 && tpl_ptr4.params_vec != 0 && tpl_ptr4.params_vec.len() > 0) {
                    var ctor_bindings2: *Vec<*GenericBinding> = compiler_get_generic_struct_bindings(nw.struct_name_ptr, nw.struct_name_len);
                    if (ctor_bindings2 != 0) {
                        generic_get_or_create_instance(tpl_ptr4, ctor_bindings2);
                    }
                }
            }
            return expr;
        case AST_STACK_CTOR:
            var sc2: *AstStackCtor = (*AstStackCtor)expr;
            if (sc2.ctor_args_vec != 0) {
                var ctor_args_sc: *Vec<*AstNode> = new Vec<*AstNode>(4);
                var scn: u64 = sc2.ctor_args_vec.len();
                for (var sci: u64 = 0; sci < scn; sci++) {
                    ctor_args_sc.push(generic_process_expr(sc2.ctor_args_vec.get(sci), symtab));
                }
                sc2.ctor_args_vec = ctor_args_sc;
            }
            if (sc2.ctor_args_vec != 0 && sc2.type_kind == TYPE_STRUCT) {
                var struct_base_len_sc2: u64 = compiler_find_generic_suffix_index(sc2.struct_name_ptr, sc2.struct_name_len);
                var ctor_name_sc2: *NameInfo = _compiler_build_constructor_name(sc2.struct_name_ptr, struct_base_len_sc2);
                var tpl_ptr_sc2: *GenericFuncTemplate = compiler_find_generic_template_by_name(ctor_name_sc2.ptr, ctor_name_sc2.len);
                if (tpl_ptr_sc2 != 0 && tpl_ptr_sc2.params_vec != 0 && tpl_ptr_sc2.params_vec.len() > 0) {
                    var ctor_bindings_sc2: *Vec<*GenericBinding> = compiler_get_generic_struct_bindings(sc2.struct_name_ptr, sc2.struct_name_len);
                    if (ctor_bindings_sc2 != 0) {
                        generic_get_or_create_instance(tpl_ptr_sc2, ctor_bindings_sc2);
                    }
                }
            }
            return expr;
        case AST_INDEX:
            var ix: *AstIndex = (*AstIndex)expr;
            ix.base = generic_process_expr(ix.base, symtab);
            ix.index = generic_process_expr(ix.index, symtab);
            return expr;
        case AST_SLICE:
            var sl: *AstSlice = (*AstSlice)expr;
            sl.ptr_expr = generic_process_expr(sl.ptr_expr, symtab);
            sl.len_expr = generic_process_expr(sl.len_expr, symtab);
            return expr;
        case AST_CALL_PTR:
            var cp: *AstCallPtr = (*AstCallPtr)expr;
            cp.callee = generic_process_expr(cp.callee, symtab);
            var args5: *Vec<*AstNode> = new Vec<*AstNode>(4);
            var an5: u64 = cp.args_vec.len();
            for (var i5: u64 = 0; i5 < an5; i5++) {
                args5.push(generic_process_expr(cp.args_vec.get(i5), symtab));
            }
            cp.args_vec = args5;
            return expr;
        case AST_SIZEOF_EXPR:
            var se: *AstSizeofExpr = (*AstSizeofExpr)expr;
            se.expr = generic_process_expr(se.expr, symtab);
            return expr;
        default:
            return expr;
    }
}

func generic_process_stmt(stmt: *AstNode, symtab: *HashMap<u64, *TypeInfo>) -> u64 {
    if (stmt == 0) { return 0; }
    var kind: u64 = ast_kind(stmt);
    switch (kind) {
        case AST_RETURN:
            var r: *AstReturn = (*AstReturn)stmt;
            r.expr = generic_process_expr(r.expr, symtab);
            return stmt;
        case AST_VAR_DECL:
            var vd: *AstVarDecl = (*AstVarDecl)stmt;
            vd.init_expr = generic_process_expr(vd.init_expr, symtab);
            return stmt;
        case AST_ASSIGN:
            var assign_stmt: *AstAssign = (*AstAssign)stmt;
            assign_stmt.target = generic_process_expr(assign_stmt.target, symtab);
            assign_stmt.value = generic_process_expr(assign_stmt.value, symtab);
            return stmt;
        case AST_EXPR_STMT:
            var es: *AstExprStmt = (*AstExprStmt)stmt;
            es.expr = generic_process_expr(es.expr, symtab);
            return stmt;
        case AST_IF:
            var ifs: *AstIf = (*AstIf)stmt;
            ifs.cond = generic_process_expr(ifs.cond, symtab);
            generic_process_stmt(ifs.then_block, symtab);
            generic_process_stmt(ifs.else_block, symtab);
            return stmt;
        case AST_WHILE:
            var wl: *AstWhile = (*AstWhile)stmt;
            wl.cond = generic_process_expr(wl.cond, symtab);
            generic_process_stmt(wl.body, symtab);
            return stmt;
        case AST_FOR:
            var fr: *AstFor = (*AstFor)stmt;
            generic_process_stmt(fr.init, symtab);
            fr.cond = generic_process_expr(fr.cond, symtab);
            fr.update = generic_process_expr(fr.update, symtab);
            generic_process_stmt(fr.body, symtab);
            return stmt;
        case AST_SWITCH:
            var sw: *AstSwitch = (*AstSwitch)stmt;
            sw.expr = generic_process_expr(sw.expr, symtab);
            var cases: *Vec<*AstNode> = sw.cases_vec;
            var cn: u64 = cases.len();
            for (var i: u64 = 0; i < cn; i++) {
                generic_process_stmt(cases.get(i), symtab);
            }
            return stmt;
        case AST_CASE:
            var cs: *AstCase = (*AstCase)stmt;
            generic_process_stmt(cs.body, symtab);
            return stmt;
        case AST_BLOCK:
            var blk: *AstBlock = (*AstBlock)stmt;
            var stmts: *Vec<*AstNode> = blk.stmts_vec;
            var n: u64 = stmts.len();
            for (var i2: u64 = 0; i2 < n; i2++) {
                generic_process_stmt(stmts.get(i2), symtab);
            }
            return stmt;
        default:
            return stmt;
    }
}

func compiler_is_generic_template(fn: *AstFunc) -> u64 {
    if (fn == 0) { return false; }
    if (compiler_is_generic_func_ptr(fn) != 0) { return true; }
    if (fn.ret_type == TYPE_GENERIC) { return true; }

    var params: *Vec<*Param> = fn.params_vec;
    if (params == 0) { return false; }

    var n: u64 = params.len();
    for (var i: u64 = 0; i < n; i++) {
        var p: *Param = params.get(i);
        if (p.type_kind == TYPE_GENERIC) { return true; }
        if (p.elem_type_kind == TYPE_GENERIC) { return true; }
        if (p.array_len_is_param != 0) { return true; }
    }
    return false;
}

func compiler_monomorphize_generics() -> u64 {
    if (g_generic_func_ptrs == 0 || g_generic_func_ptrs.len() == 0) {
        return 0;
    }
    if (g_all_funcs == 0) { return 0; }
    for (var i2: u64 = 0; i2 < g_all_funcs.len(); i2++) {
        var fn: *AstFunc = g_all_funcs.get(i2);
        if (compiler_is_generic_template(fn) != 0) { continue; }
        set_current_module_for_func(fn.name_ptr, fn.name_len);
        var symtab: *HashMap<u64, *TypeInfo> = generic_build_symtab_for_func(fn);
        generic_process_stmt(fn.body, symtab);
    }

    if (g_all_globals != 0) {
        var gn: u64 = g_all_globals.len();
        for (var gi: u64 = 0; gi < gn; gi++) {
            var ginfo: *GlobalInfo = g_all_globals.get(gi);
            if (ginfo == 0) { continue; }
            if (ginfo.init_expr == 0) { continue; }
            set_current_module_for_global(ginfo.name_ptr, ginfo.name_len);
            var gsymtab: *HashMap<u64, *TypeInfo> = new HashMap<u64, *TypeInfo>(64);
            var init_node: *AstNode = (*AstNode)ginfo.init_expr;
            var new_init: *AstNode = generic_process_expr(init_node, gsymtab);
            ginfo.init_expr = (u64)new_init;
        }
    }

    var filtered_funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(g_all_funcs.len());
    var total_funcs: u64 = g_all_funcs.len();
    for (var fi: u64 = 0; fi < total_funcs; fi++) {
        var fn2: *AstFunc = g_all_funcs.get(fi);
        if (compiler_is_generic_template(fn2) != 0) { continue; }
        filtered_funcs.push(fn2);
    }
    g_all_funcs = filtered_funcs;
    return 0;
}

// ============================================
// Driver helpers
// ============================================

func compiler_has_runtime_global_init() -> u64 {
    if (g_all_globals == 0) { return false; }
    var n: u64 = g_all_globals.len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = g_all_globals.get(i);
        if (ginfo.init_kind == GLOBAL_INIT_RUNTIME) { return true; }
    }
    return false;
}

func _compiler_make_self_param(struct_name_ptr: u64, struct_name_len: u64) -> *Param {
    var p: *Param = new Param();
    p.name_ptr = (u64)"self";
    p.name_len = 4;
    p.type_kind = TYPE_STRUCT;
    p.ptr_depth = 1;
    p.is_tagged = 0;
    p.struct_name_ptr = struct_name_ptr;
    p.struct_name_len = struct_name_len;
    p.tag_layout_ptr = 0;
    p.tag_layout_len = 0;
    p.elem_type_kind = 0;
    p.elem_ptr_depth = 0;
    p.array_len = 0;
    p.array_len_is_param = 0;
    p.array_len_param_ptr = 0;
    p.array_len_param_len = 0;
    return p;
}

func _compiler_build_constructor_name(struct_name_ptr: u64, struct_name_len: u64) -> *NameInfo {
    var method_ptr: u64 = (u64)"constructor";
    var method_len: u64 = 11;
    return compiler_build_method_name(struct_name_ptr, struct_name_len, method_ptr, method_len);
}

func compiler_build_method_name(struct_name_ptr: u64, struct_name_len: u64, method_ptr: u64, method_len: u64) -> *NameInfo {
    var base_len: u64 = compiler_find_generic_suffix_index(struct_name_ptr, struct_name_len);
    var suffix_len: u64 = struct_name_len - base_len;
    return compiler_build_method_name_base(struct_name_ptr, base_len, method_ptr, method_len, suffix_len);
}

func compiler_build_method_name_base(struct_name_ptr: u64, base_len: u64, method_ptr: u64, method_len: u64, suffix_len: u64) -> *NameInfo {
    var full_len: u64 = base_len + 1 + method_len + suffix_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    var struct_u8: []u8 = slice(struct_name_ptr, base_len + suffix_len);
    var method_u8: []u8 = slice(method_ptr, method_len);
    for (var i: u64 = 0; i < base_len; i++) {
        full_u8[i] = struct_u8[i];
    }
    full_u8[base_len] = 95;
    for (var j: u64 = 0; j < method_len; j++) {
        full_u8[base_len + 1 + j] = method_u8[j];
    }
    for (var k: u64 = 0; k < suffix_len; k++) {
        full_u8[base_len + 1 + method_len + k] = struct_u8[base_len + k];
    }
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func compiler_build_scoped_name(base_ptr: u64, base_len: u64, member_ptr: u64, member_len: u64) -> *NameInfo {
    var full_len: u64 = base_len + 1 + member_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    var base_u8: []u8 = slice(base_ptr, base_len);
    var member_u8: []u8 = slice(member_ptr, member_len);
    for (var i: u64 = 0; i < base_len; i++) {
        full_u8[i] = base_u8[i];
    }
    full_u8[base_len] = 95;
    for (var j: u64 = 0; j < member_len; j++) {
        full_u8[base_len + 1 + j] = member_u8[j];
    }
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

// ============================================
// Trait Helpers and VTable Generation
// ============================================

func compiler_is_vptr_field_name(name_ptr: u64, name_len: u64) -> u64 {
    if (name_len < 7) { return false; }
    if (str_eq(name_ptr, 7, "__vptr_", 7) == 0) { return false; }
    return true;
}

func compiler_build_vptr_field_name(trait_ptr: u64, trait_len: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__vptr_";
    var prefix_len: u64 = 7;
    var full_len: u64 = prefix_len + trait_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    var prefix_u8: []u8 = slice(prefix_ptr, prefix_len);
    var trait_u8: []u8 = slice(trait_ptr, trait_len);
    for (var i: u64 = 0; i < prefix_len; i++) { full_u8[i] = prefix_u8[i]; }
    for (var j: u64 = 0; j < trait_len; j++) { full_u8[prefix_len + j] = trait_u8[j]; }
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func compiler_build_vtable_struct_name(trait_ptr: u64, trait_len: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__VTable_";
    var prefix_len: u64 = 9;
    var full_len: u64 = prefix_len + trait_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    var prefix_u8: []u8 = slice(prefix_ptr, prefix_len);
    var trait_u8: []u8 = slice(trait_ptr, trait_len);
    for (var i: u64 = 0; i < prefix_len; i++) { full_u8[i] = prefix_u8[i]; }
    for (var j: u64 = 0; j < trait_len; j++) { full_u8[prefix_len + j] = trait_u8[j]; }
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func compiler_build_vtable_global_name(trait_ptr: u64, trait_len: u64, struct_ptr: u64, struct_len: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__vtable_";
    var prefix_len: u64 = 9;
    var sep_ptr: u64 = (u64)"__";
    var sep_len: u64 = 2;
    var full_len: u64 = prefix_len + trait_len + sep_len + struct_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    var prefix_u8: []u8 = slice(prefix_ptr, prefix_len);
    var trait_u8: []u8 = slice(trait_ptr, trait_len);
    var sep_u8: []u8 = slice(sep_ptr, sep_len);
    var struct_u8: []u8 = slice(struct_ptr, struct_len);
    for (var i: u64 = 0; i < prefix_len; i++) { full_u8[i] = prefix_u8[i]; }
    for (var j: u64 = 0; j < trait_len; j++) { full_u8[prefix_len + j] = trait_u8[j]; }
    for (var k: u64 = 0; k < sep_len; k++) { full_u8[prefix_len + trait_len + k] = sep_u8[k]; }
    for (var m: u64 = 0; m < struct_len; m++) { full_u8[prefix_len + trait_len + sep_len + m] = struct_u8[m]; }
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func compiler_build_trait_thunk_name(trait_ptr: u64, trait_len: u64, struct_ptr: u64, struct_len: u64, method_ptr: u64, method_len: u64) -> *NameInfo {
    var prefix_ptr: u64 = (u64)"__thunk_";
    var prefix_len: u64 = 8;
    var sep_ptr: u64 = (u64)"__";
    var sep_len: u64 = 2;
    var full_len: u64 = prefix_len + trait_len + sep_len + struct_len + sep_len + method_len;
    var full_ptr: u64 = heap_alloc((full_len + 1) * sizeof(u8));
    var full_u8: []u8 = slice(full_ptr, full_len + 1);
    var prefix_u8: []u8 = slice(prefix_ptr, prefix_len);
    var trait_u8: []u8 = slice(trait_ptr, trait_len);
    var sep_u8: []u8 = slice(sep_ptr, sep_len);
    var struct_u8: []u8 = slice(struct_ptr, struct_len);
    var method_u8: []u8 = slice(method_ptr, method_len);
    for (var i: u64 = 0; i < prefix_len; i++) { full_u8[i] = prefix_u8[i]; }
    for (var j: u64 = 0; j < trait_len; j++) { full_u8[prefix_len + j] = trait_u8[j]; }
    for (var k: u64 = 0; k < sep_len; k++) { full_u8[prefix_len + trait_len + k] = sep_u8[k]; }
    for (var m: u64 = 0; m < struct_len; m++) { full_u8[prefix_len + trait_len + sep_len + m] = struct_u8[m]; }
    for (var n: u64 = 0; n < sep_len; n++) { full_u8[prefix_len + trait_len + sep_len + struct_len + n] = sep_u8[n]; }
    for (var p: u64 = 0; p < method_len; p++) { full_u8[prefix_len + trait_len + sep_len + struct_len + sep_len + p] = method_u8[p]; }
    full_u8[full_len] = 0;
    return new NameInfo{full_ptr, full_len};
}

func compiler_find_trait_impl(trait_ptr: u64, trait_len: u64, struct_ptr: u64, struct_len: u64) -> *TraitImpl {
    if (g_all_trait_impls_vec == 0) { return 0; }
    var n: u64 = g_all_trait_impls_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var ti: *TraitImpl = g_all_trait_impls_vec.get(i);
        if (str_eq(ti.trait_ptr, ti.trait_len, trait_ptr, trait_len) &&
            str_eq(ti.struct_ptr, ti.struct_len, struct_ptr, struct_len)) {
            return ti;
        }
    }
    return 0;
}

func compiler_find_trait_impl_method(impl_info: *TraitImpl, name_ptr: u64, name_len: u64) -> *TraitImplMethod {
    if (impl_info == 0 || impl_info.methods_vec == 0) { return 0; }
    var n: u64 = impl_info.methods_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var m: *TraitImplMethod = impl_info.methods_vec.get(i);
        if (str_eq(m.name_ptr, m.name_len, name_ptr, name_len)) { return m; }
    }
    return 0;
}

func compiler_find_trait_method_index(trait_ptr: u64, trait_len: u64, name_ptr: u64, name_len: u64) -> u64 {
    var td: *TraitDef = compiler_get_trait_def(trait_ptr, trait_len);
    if (td == 0 || td.methods_vec == 0) {
        emit_stderr("[DEBUG] Trait def missing for: ");
        emit_stderr_len(trait_ptr, trait_len);
        emit_stderr("\n");
        return 9223372036854775807;
    }
    var n: u64 = td.methods_vec.len();
    for (var i: u64 = 0; i < n; i++) {
        var tm: *TraitMethod = td.methods_vec.get(i);
        if (str_eq(tm.name_ptr, tm.name_len, name_ptr, name_len)) { return tm.index; }
    }
    if (name_len > 1) {
        var name_u8: []u8 = slice(name_ptr, name_len);
        if (name_u8[0] == 109) {
            var alt_ptr: u64 = name_ptr + 1;
            var alt_len: u64 = name_len - 1;
            for (var j: u64 = 0; j < n; j++) {
                var tm2: *TraitMethod = td.methods_vec.get(j);
                if (str_eq(tm2.name_ptr, tm2.name_len, alt_ptr, alt_len)) { return tm2.index; }
            }
        }
    }
    emit_stderr("[DEBUG] Trait method lookup failed. Trait=");
    emit_stderr_len(trait_ptr, trait_len);
    emit_stderr(" name=");
    emit_stderr_len(name_ptr, name_len);
    emit_stderr("\n");
    for (var k: u64 = 0; k < n; k++) {
        var tm3: *TraitMethod = td.methods_vec.get(k);
        emit_stderr("[DEBUG] Trait method: ");
        emit_stderr_len(tm3.name_ptr, tm3.name_len);
        emit_stderr("\n");
    }
    return 9223372036854775807;
}

func compiler_sizeof_type(type_kind: u64, ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    if (ptr_depth > 0) { return 8; }
    switch (type_kind) {
        case TYPE_U8: return 1;
        case TYPE_U16: return 2;
        case TYPE_U32: return 4;
        case TYPE_U64: return 8;
        case TYPE_I64: return 8;
        case TYPE_F64: return 8;
        case TYPE_SLICE: return 16;
        case TYPE_STRUCT:
            var sd: *AstStructDef = get_struct_def(struct_name_ptr, struct_name_len);
            if (sd == 0) { return 8; }
            return compiler_struct_size_internal(sd, 0);
        case TYPE_TRAIT:
            return 8;
    }
    return 8;
}

func compiler_sizeof_field_desc(field: *FieldDesc) -> u64 {
    if (field.bit_width > 0) {
        return (field.bit_width + 7) / 8;
    }
    if (field.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = compiler_sizeof_type(field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len);
        return elem_size * field.array_len;
    }
    if (field.type_kind == TYPE_SLICE) { return 16; }
    return compiler_sizeof_type(field.type_kind, field.ptr_depth, field.struct_name_ptr, field.struct_name_len);
}

func compiler_struct_size_internal(struct_info: *AstStructDef, depth: u64) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n");
        panic("TypeInfo error");
    }
    if (struct_info.is_packed == 1) {
        emit_stderr("[ERROR] packed struct cannot use trait vptr layout\n");
        panic("TypeInfo error");
    }
    var total_size: u64 = 0;
    if (struct_info.parents_vec != 0) {
        var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
        var pn: u64 = parents.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = parents.get(pi);
            var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "TypeInfo error");
            total_size = total_size + compiler_struct_size_internal(parent_def, depth + 1);
        }
    }
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    for (var i: u64 = 0; i < num_fields; i++) {
        var field: *FieldDesc = fields.get(i);
        total_size = total_size + compiler_sizeof_field_desc(field);
    }
    return total_size;
}

func compiler_struct_find_field_offset(struct_def: *AstStructDef, field_ptr: u64, field_len: u64) -> u64 {
    var parent_total: u64 = 0;
    if (struct_def.parents_vec != 0) {
        var parents: *Vec<*ParentDesc> = struct_def.parents_vec;
        var pn: u64 = parents.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = parents.get(pi);
            var parent_def: *AstStructDef = compiler_resolve_parent_def(parent_desc, "TypeInfo error");
            parent_total = parent_total + compiler_struct_size_internal(parent_def, 0);
        }
    }
    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var num_fields: u64 = fields.len();
    var offset: u64 = parent_total;
    for (var i: u64 = 0; i < num_fields; i++) {
        var field: *FieldDesc = fields.get(i);
        if (str_eq(field.name_ptr, field.name_len, field_ptr, field_len)) { return offset; }
        offset = offset + compiler_sizeof_field_desc(field);
    }
    return 9223372036854775807;
}

func compiler_insert_vptr_field(struct_def: *AstStructDef, trait_ptr: u64, trait_len: u64, vtable_struct_ptr: u64, vtable_struct_len: u64) -> u64 {
    if (struct_def == 0) { return 0; }
    if (struct_def.fields_vec == 0) {
        struct_def.fields_vec = new Vec<*FieldDesc>(1);
    }
    var vptr_name: *NameInfo = compiler_build_vptr_field_name(trait_ptr, trait_len);
    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var n: u64 = fields.len();
    for (var i: u64 = 0; i < n; i++) {
        var f: *FieldDesc = fields.get(i);
        if (str_eq(f.name_ptr, f.name_len, vptr_name.ptr, vptr_name.len)) { return 0; }
    }
    var new_field: *FieldDesc = new FieldDesc();
    new_field.name_ptr = vptr_name.ptr;
    new_field.name_len = vptr_name.len;
    new_field.type_kind = TYPE_STRUCT;
    new_field.struct_name_ptr = vtable_struct_ptr;
    new_field.struct_name_len = vtable_struct_len;
    new_field.ptr_depth = 1;
    new_field.is_tagged = 0;
    new_field.tag_layout_ptr = 0;
    new_field.tag_layout_len = 0;
    new_field.bit_width = 0;
    new_field.elem_type_kind = 0;
    new_field.elem_ptr_depth = 0;
    new_field.array_len = 0;

    fields.push(new_field);
    return 0;
}

func compiler_clone_param(src: *Param) -> *Param {
    var p: *Param = new Param();
    p.name_ptr = src.name_ptr;
    p.name_len = src.name_len;
    p.type_kind = src.type_kind;
    p.ptr_depth = src.ptr_depth;
    p.is_tagged = src.is_tagged;
    p.struct_name_ptr = src.struct_name_ptr;
    p.struct_name_len = src.struct_name_len;
    p.tag_layout_ptr = src.tag_layout_ptr;
    p.tag_layout_len = src.tag_layout_len;
    p.elem_type_kind = src.elem_type_kind;
    p.elem_ptr_depth = src.elem_ptr_depth;
    p.array_len = src.array_len;
    p.array_len_is_param = src.array_len_is_param;
    p.array_len_param_ptr = src.array_len_param_ptr;
    p.array_len_param_len = src.array_len_param_len;
    return p;
}

func compiler_is_self_type(type_kind: u64, struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    if (type_kind != TYPE_STRUCT) { return false; }
    if (struct_name_ptr == 0 || struct_name_len == 0) { return false; }
    if (str_eq(struct_name_ptr, struct_name_len, "Self", 4) != 0) { return true; }
    return false;
}

func compiler_build_trait_thunk_func(thunk_name_ptr: u64, thunk_name_len: u64, trait_def: *TraitDef, trait_method: *TraitMethod, impl_method: *TraitImplMethod, struct_ptr: u64, struct_len: u64, vptr_offset: u64) -> *AstFunc {
    var trait_sig: *AstFunc = trait_method.sig;
    var params_in: *Vec<*Param> = trait_sig.params_vec;
    var param_count: u64 = params_in.len();
    var params_out: *Vec<*Param> = new Vec<*Param>(param_count);

    for (var i: u64 = 0; i < param_count; i++) {
        var src: *Param = params_in.get(i);
        var dst: *Param = compiler_clone_param(src);
        if (i == 0) {
            dst.type_kind = TYPE_TRAIT;
            dst.ptr_depth = 1;
            dst.is_tagged = 0;
            dst.struct_name_ptr = trait_def.name_ptr;
            dst.struct_name_len = trait_def.name_len;
            dst.tag_layout_ptr = 0;
            dst.tag_layout_len = 0;
        }
        params_out.push(dst);
    }

    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(2);

    var self_param: *Param = params_out.get(0);
    var self_ident: *AstNode = (*AstNode)ast_ident(self_param.name_ptr, self_param.name_len);
    var casted: *AstNode = (*AstNode)ast_cast_ex(self_ident, TYPE_STRUCT, 1, 0, struct_ptr, struct_len, 0, 0);

    var call_args: *Vec<*AstNode> = new Vec<*AstNode>(param_count);
    call_args.push(casted);
    for (var j: u64 = 1; j < param_count; j++) {
        var p: *Param = params_out.get(j);
        call_args.push((*AstNode)ast_ident(p.name_ptr, p.name_len));
    }

    var call_node: *AstNode = (*AstNode)ast_call(impl_method.func_def.name_ptr, impl_method.func_def.name_len, call_args);
    if (trait_sig.ret_type == TYPE_VOID) {
        stmts.push((*AstNode)ast_expr_stmt(call_node));
    } else {
        stmts.push((*AstNode)ast_return(call_node));
    }

    var body: *AstNode = (*AstNode)ast_block(stmts);
    return ast_func_ex(thunk_name_ptr, thunk_name_len, params_out,
                       trait_sig.ret_type, trait_sig.ret_ptr_depth, trait_sig.ret_is_tagged,
                       trait_sig.ret_struct_name_ptr, trait_sig.ret_struct_name_len,
                       trait_sig.ret_tag_layout_ptr, trait_sig.ret_tag_layout_len, body);
}

func compiler_finalize_traits() -> u64 {
    if (g_all_structs_vec != 0) {
        var sn: u64 = g_all_structs_vec.len();
        for (var si: u64 = 0; si < sn; si++) {
            var sd: *AstStructDef = g_all_structs_vec.get(si);
            if (sd == 0 || sd.traits_vec == 0) { continue; }
            var tn: u64 = sd.traits_vec.len();
            for (var ti: u64 = 0; ti < tn; ti++) {
                var tref: *TraitRef = sd.traits_vec.get(ti);
                var tdef: *TraitDef = compiler_get_trait_def(tref.name_ptr, tref.name_len);
                if (tdef == 0) {
                    emit_stderr("[ERROR] Trait not found for struct inheritance: ");
                    emit_stderr_len(tref.name_ptr, tref.name_len);
                    emit_stderr("\n");
                    panic("Parse error");
                }
                var impl_info: *TraitImpl = compiler_find_trait_impl(tref.name_ptr, tref.name_len, sd.name_ptr, sd.name_len);
                if (impl_info == 0) {
                    emit_stderr("[ERROR] Trait impl missing for struct inheritance: ");
                    emit_stderr_len(sd.name_ptr, sd.name_len);
                    emit_stderr(" -> ");
                    emit_stderr_len(tref.name_ptr, tref.name_len);
                    emit_stderr("\n");
                    panic("Parse error");
                }
            }
        }
    }

    if (g_all_trait_impls_vec == 0 || g_all_trait_impls_vec.len() == 0) { return 0; }

    var num_impls: u64 = g_all_trait_impls_vec.len();
    for (var ii: u64 = 0; ii < num_impls; ii++) {
        var impl_info: *TraitImpl = g_all_trait_impls_vec.get(ii);
        var trait_def: *TraitDef = compiler_get_trait_def(impl_info.trait_ptr, impl_info.trait_len);
        if (trait_def == 0) {
            emit_stderr("[ERROR] Trait not found for impl: ");
            emit_stderr_len(impl_info.trait_ptr, impl_info.trait_len);
            emit_stderr("\n");
            panic("Parse error");
        }

        var struct_def: *AstStructDef = get_struct_def(impl_info.struct_ptr, impl_info.struct_len);
        if (struct_def == 0) {
            emit_stderr("[ERROR] Struct not found for trait impl: ");
            emit_stderr_len(impl_info.struct_ptr, impl_info.struct_len);
            emit_stderr("\n");
            panic("Parse error");
        }
        if (struct_def.is_packed == 1) {
            emit_stderr("[ERROR] packed struct cannot implement traits\n");
            panic("Parse error");
        }

        var vtable_name: *NameInfo = compiler_build_vtable_struct_name(impl_info.trait_ptr, impl_info.trait_len);
        var vtable_struct_def: *AstStructDef = get_struct_def(vtable_name.ptr, vtable_name.len);
        if (vtable_struct_def == 0) {
            var vtable_fields: *Vec<*FieldDesc> = new Vec<*FieldDesc>(trait_def.methods_vec.len());
            var mcount: u64 = trait_def.methods_vec.len();
            for (var mi: u64 = 0; mi < mcount; mi++) {
                var tm: *TraitMethod = trait_def.methods_vec.get(mi);
                var f: *FieldDesc = new FieldDesc();
                f.name_ptr = tm.name_ptr;
                f.name_len = tm.name_len;
                f.type_kind = TYPE_U64;
                f.ptr_depth = 0;
                f.is_tagged = 0;
                f.struct_name_ptr = 0;
                f.struct_name_len = 0;
                f.tag_layout_ptr = 0;
                f.tag_layout_len = 0;
                f.bit_width = 0;
                f.elem_type_kind = 0;
                f.elem_ptr_depth = 0;
                f.array_len = 0;
                vtable_fields.push(f);
            }
            vtable_struct_def = ast_struct_def(vtable_name.ptr, vtable_name.len, 0, vtable_fields, 0, 0);
            register_struct_type(vtable_struct_def);
        }

        impl_info.vtable_struct_def = vtable_struct_def;

        compiler_insert_vptr_field(struct_def, impl_info.trait_ptr, impl_info.trait_len, vtable_name.ptr, vtable_name.len);

        var vptr_name: *NameInfo = compiler_build_vptr_field_name(impl_info.trait_ptr, impl_info.trait_len);
        var vptr_offset: u64 = compiler_struct_find_field_offset(struct_def, vptr_name.ptr, vptr_name.len);
        if (vptr_offset == 9223372036854775807) {
            emit_stderr("[ERROR] vptr field not found for trait impl: ");
            emit_stderr_len(impl_info.struct_ptr, impl_info.struct_len);
            emit_stderr("\n");
            panic("Parse error");
        }

        var values: *Vec<*AstNode> = new Vec<*AstNode>(trait_def.methods_vec.len());
        var method_count: u64 = trait_def.methods_vec.len();
        for (var m: u64 = 0; m < method_count; m++) {
            var trait_method: *TraitMethod = trait_def.methods_vec.get(m);
            var trait_sig: *AstFunc = trait_method.sig;
            if (trait_sig.params_vec == 0 || trait_sig.params_vec.len() == 0) {
                emit_stderr("[ERROR] Trait method must have self parameter: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }
            var self_param: *Param = trait_sig.params_vec.get(0);
            if (compiler_is_self_type(self_param.type_kind, self_param.struct_name_ptr, self_param.struct_name_len) == 0 || self_param.ptr_depth == 0) {
                emit_stderr("[ERROR] Trait method self must be *Self: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }
            if (trait_sig.ret_type == TYPE_STRUCT && trait_sig.ret_ptr_depth == 0) {
                emit_stderr("[ERROR] Trait method cannot return struct by value: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }
            if (compiler_is_self_type(trait_sig.ret_type, trait_sig.ret_struct_name_ptr, trait_sig.ret_struct_name_len) != 0) {
                emit_stderr("[ERROR] Trait method cannot return Self type: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }

            var impl_method: *TraitImplMethod = compiler_find_trait_impl_method(impl_info, trait_method.name_ptr, trait_method.name_len);
            if (impl_method == 0) {
                emit_stderr("[ERROR] Trait method not implemented: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }

            var impl_sig: *AstFunc = impl_method.func_def;
            if (impl_sig.params_vec.len() != trait_sig.params_vec.len()) {
                emit_stderr("[ERROR] Trait method param count mismatch: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }

            var impl_self: *Param = impl_sig.params_vec.get(0);
            if (impl_self.ptr_depth == 0 || impl_self.type_kind != TYPE_STRUCT) {
                emit_stderr("[ERROR] Trait impl self must be struct pointer: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }
            if (!(str_eq(impl_self.struct_name_ptr, impl_self.struct_name_len, impl_info.struct_ptr, impl_info.struct_len) ||
                  compiler_is_self_type(impl_self.type_kind, impl_self.struct_name_ptr, impl_self.struct_name_len) != 0)) {
                emit_stderr("[ERROR] Trait impl self type mismatch: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }

            for (var pi: u64 = 1; pi < trait_sig.params_vec.len(); pi++) {
                var tp: *Param = trait_sig.params_vec.get(pi);
                if (compiler_is_self_type(tp.type_kind, tp.struct_name_ptr, tp.struct_name_len) != 0) {
                    emit_stderr("[ERROR] Trait method params cannot use Self type: ");
                    emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                    emit_stderr("\n");
                    panic("Parse error");
                }
                var ip: *Param = impl_sig.params_vec.get(pi);
                if (tp.type_kind != ip.type_kind || tp.ptr_depth != ip.ptr_depth) {
                    emit_stderr("[ERROR] Trait impl param type mismatch: ");
                    emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                    emit_stderr("\n");
                    panic("Parse error");
                }
                if (tp.type_kind == TYPE_STRUCT) {
                    if (!str_eq(tp.struct_name_ptr, tp.struct_name_len, ip.struct_name_ptr, ip.struct_name_len)) {
                        emit_stderr("[ERROR] Trait impl struct param mismatch: ");
                        emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                        emit_stderr("\n");
                        panic("Parse error");
                    }
                }
            }

            if (trait_sig.ret_type != impl_sig.ret_type || trait_sig.ret_ptr_depth != impl_sig.ret_ptr_depth) {
                emit_stderr("[ERROR] Trait impl return type mismatch: ");
                emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                emit_stderr("\n");
                panic("Parse error");
            }
            if (trait_sig.ret_type == TYPE_STRUCT) {
                if (!str_eq(trait_sig.ret_struct_name_ptr, trait_sig.ret_struct_name_len, impl_sig.ret_struct_name_ptr, impl_sig.ret_struct_name_len)) {
                    emit_stderr("[ERROR] Trait impl return struct mismatch: ");
                    emit_stderr_len(trait_method.name_ptr, trait_method.name_len);
                    emit_stderr("\n");
                    panic("Parse error");
                }
            }

            var thunk_name: *NameInfo = compiler_build_trait_thunk_name(impl_info.trait_ptr, impl_info.trait_len, impl_info.struct_ptr, impl_info.struct_len, trait_method.name_ptr, trait_method.name_len);
            var thunk_fn: *AstFunc = compiler_build_trait_thunk_func(thunk_name.ptr, thunk_name.len, trait_def, trait_method, impl_method, impl_info.struct_ptr, impl_info.struct_len, vptr_offset);
            g_all_funcs.push(thunk_fn);
            g_all_func_sigs.push(thunk_fn);

            values.push((*AstNode)ast_ident(thunk_name.ptr, thunk_name.len));
        }

        var vtable_global: *NameInfo = compiler_build_vtable_global_name(impl_info.trait_ptr, impl_info.trait_len, impl_info.struct_ptr, impl_info.struct_len);
        impl_info.vtable_global_ptr = vtable_global.ptr;
        impl_info.vtable_global_len = vtable_global.len;

        var vtable_lit: *AstStructLiteral = ast_struct_literal(vtable_struct_def, values);
        var vtable_type: *TypeInfo = compiler_typeinfo_new(TYPE_STRUCT, 0);
        vtable_type.struct_name_ptr = vtable_name.ptr;
        vtable_type.struct_name_len = vtable_name.len;
        vtable_type.struct_def = vtable_struct_def;

        var ginfo: *GlobalInfo = new GlobalInfo();
        ginfo.name_ptr = vtable_global.ptr;
        ginfo.name_len = vtable_global.len;
        ginfo.typeinfo_ptr = vtable_type;
        ginfo.init_kind = GLOBAL_INIT_EXPR;
        ginfo.init_expr = (u64)vtable_lit;
        g_all_globals.push(ginfo);
    }
    return 0;
}

func compiler_collect_abst_methods_recursive(struct_def: *AstStructDef, out: *Vec<*NameInfo>) -> u64 {
    if (struct_def == 0 || out == 0) { return 0; }
    if (struct_def.parents_vec != 0) {
        var pn: u64 = struct_def.parents_vec.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = struct_def.parents_vec.get(pi);
            var parent_def: *AstStructDef = parent_desc.struct_def;
            if (parent_def == 0) {
                parent_def = get_struct_def(parent_desc.name_ptr, parent_desc.name_len);
            }
            if (parent_def != 0) {
                compiler_collect_abst_methods_recursive(parent_def, out);
                var list: *Vec<*NameInfo> = compiler_get_abst_methods(parent_def.name_ptr, parent_def.name_len);
                if (list != 0) {
                    var n: u64 = list.len();
                    for (var i: u64 = 0; i < n; i++) {
                        var mi: *NameInfo = list.get(i);
                        var exists: u64 = 0;
                        var on: u64 = out.len();
                        for (var oi: u64 = 0; oi < on; oi++) {
                            var om: *NameInfo = out.get(oi);
                            if (str_eq(om.ptr, om.len, mi.ptr, mi.len)) { exists = 1; break; }
                        }
                        if (exists == 0) { out.push(mi); }
                    }
                }
            }
        }
    }
    return 0;
}

func compiler_finalize_abst_methods() -> u64 {
    if (g_all_structs_vec == 0) { return 0; }
    var sn: u64 = g_all_structs_vec.len();
    for (var si: u64 = 0; si < sn; si++) {
        var sd: *AstStructDef = g_all_structs_vec.get(si);
        if (sd == 0 || sd.parents_vec == 0) { continue; }
        var required: *Vec<*NameInfo> = new Vec<*NameInfo>(8);
        compiler_collect_abst_methods_recursive(sd, required);
        var rn: u64 = required.len();
        for (var ri: u64 = 0; ri < rn; ri++) {
            var mi: *NameInfo = required.get(ri);
            if (compiler_is_abst_method(sd.name_ptr, sd.name_len, mi.ptr, mi.len) != 0) {
                emit_stderr("[ERROR] Abstract method must be implemented in child: ");
                emit_stderr_len(sd.name_ptr, sd.name_len);
                emit_stderr(".");
                emit_stderr_len(mi.ptr, mi.len);
                emit_stderr("\n");
                panic("Parse error");
            }
            var method_name: *NameInfo = compiler_build_method_name(sd.name_ptr, sd.name_len, mi.ptr, mi.len);
            if (compiler_is_impl_method(method_name.ptr, method_name.len) == 0) {
                emit_stderr("[ERROR] Missing abstract method implementation in child: ");
                emit_stderr_len(sd.name_ptr, sd.name_len);
                emit_stderr(".");
                emit_stderr_len(mi.ptr, mi.len);
                emit_stderr("\n");
                panic("Parse error");
            }
        }
    }
    return 0;
}

func compiler_insert_default_constructor(struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    if (g_all_funcs == 0 || g_all_func_sigs == 0) { return 0; }
    var ctor_name: *NameInfo = _compiler_build_constructor_name(struct_name_ptr, struct_name_len);
    if (compiler_func_exists(ctor_name.ptr, ctor_name.len) != 0) { return 0; }

    var params: *Vec<*Param> = new Vec<*Param>(1);
    params.push(_compiler_make_self_param(struct_name_ptr, struct_name_len));
    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(0);
    var body: *AstNode = (*AstNode)ast_block(stmts);
    var fn: *AstFunc = ast_func_ex(ctor_name.ptr, ctor_name.len, params, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
    g_all_funcs.push(fn);
    g_all_func_sigs.push(fn);
    return 0;
}

func compiler_insert_default_constructors() -> u64 {
    var n: u64 = g_all_structs_vec.?len();
    if (n == 0) { return 0; }
    for (var i: u64 = 0; i < n; i++) {
        var def: *AstStructDef = g_all_structs_vec.get(i);
        if (def == 0) { continue; }
        if (compiler_is_generic_struct_def(def) != 0) { continue; }
        compiler_insert_default_constructor(def.name_ptr, def.name_len);
    }
    return 0;
}

func compiler_insert_global_init_func() -> u64 {
    if (compiler_has_runtime_global_init() == 0) { return 0; }
    if (compiler_func_exists("__global_init", 13)) { return 0; }

    var stmts: *Vec<*AstNode> = new Vec<*AstNode>(8);
    var n: u64 = g_all_globals.len();
    for (var i: u64 = 0; i < n; i++) {
        var ginfo: *GlobalInfo = g_all_globals.get(i);
        if (ginfo.init_kind != GLOBAL_INIT_RUNTIME) { continue; }
        var init_expr: *AstNode = (*AstNode)ginfo.init_expr;
        if (init_expr == 0) {
            emit_stderr("[ERROR] runtime global init expr missing\n");
            panic("Parse error");
        }
        var target: *AstNode = (*AstNode)ast_ident(ginfo.name_ptr, ginfo.name_len);
        var assign: *AstAssign = ast_assign(target, init_expr);
        stmts.push((*AstNode)assign);
    }

    if (stmts.len() == 0) { return 0; }

    var block: *AstNode = (*AstNode)ast_block(stmts);
    var params: *Vec<*Param> = new Vec<*Param>(0);
    var fn: *AstFunc = ast_func("__global_init", 13, params, TYPE_VOID, block);
    g_all_funcs.push(fn);
    g_all_func_sigs.push(fn);
    return 0;
}

func setup_paths(filename: u64, filename_len: u64) -> u64 {
    return setup_paths_with_compiler(0, 0, filename, filename_len);
}

func extract_version_from_compiler_path(path: u64, path_len: u64) -> *NameInfo {
    if (path == 0 || path_len == 0) { return 0; }
    var base: u64 = path_basename_noext(path, path_len);
    var base_len: u64 = str_len(base);
    var needle: u64 = "_stage";
    for (var i: u64 = 0; i + 6 <= base_len; i++) {
        if (str_eq(base + i, 6, needle, 6)) {
            var vlen: u64 = i;
            if (vlen == 0) { return 0; }
            var vptr: u64 = heap_alloc((vlen + 1) * sizeof(u8));
            str_copy(vptr, base, vlen);
            var vptr_u8: []u8 = slice(vptr, vlen + 1);
            vptr_u8[vlen] = 0;
            var out: *NameInfo = new NameInfo{vptr, vlen};
            return out;
        }
    }
    // Fallback: accept direct version name (e.g., v3_20.out -> v3_20)
    if (base_len >= 2) {
        var base_u8: []u8 = slice(base, base_len);
        var c0: u64 = base_u8[0];
        var c1: u64 = base_u8[1];
        if (c0 == 118 && c1 >= 48 && c1 <= 57) { // 'v' + digit
            var vptr2: u64 = heap_alloc((base_len + 1) * sizeof(u8));
            str_copy(vptr2, base, base_len);
            var vptr2_u8: []u8 = slice(vptr2, base_len + 1);
            vptr2_u8[base_len] = 0;
            var out2: *NameInfo = new NameInfo{vptr2, base_len};
            return out2;
        }
    }
    return 0;
}

func setup_paths_with_compiler(compiler_path: u64, compiler_len: u64, filename: u64, filename_len: u64) -> u64 {
    g_base_dir = path_dirname(filename, filename_len);
    g_base_dir_len = str_len(g_base_dir);

    // Find version directory by going up from base_dir
    // src: B/v3_XX/src -> up 1 = B/v3_XX
    // test: B/v3_XX/test/b -> up 2 = B/v3_XX
    var up_one: u64 = path_dirname(g_base_dir, g_base_dir_len);
    var up_one_len: u64 = str_len(up_one);
    var version_dir2: u64 = path_dirname(up_one, up_one_len);
    var version_dir_len2: u64 = str_len(version_dir2);
    var slash_config: u64 = "/config.ini";
    var config_path1: u64 = str_concat(up_one, up_one_len, slash_config, 11);
    var version2: u64 = read_version_from_config(config_path1);

    if (version2 == 0) {
        var config_path2: u64 = str_concat(version_dir2, version_dir_len2, slash_config, 11);
        version2 = read_version_from_config(config_path2);
    }

    if (version2 == 0) {
        version2 = "v3_15";  // Fallback to hardcoded default
    }

    // Build lib_dir path: prefer base_dir parent when filename is in src/
    var use_up_one: u64 = 0;
    if (g_base_dir_len >= 4) {
        var base_dir_u8: []u8 = slice(g_base_dir, g_base_dir_len);
        var c0: u64 = base_dir_u8[g_base_dir_len - 4];
        var c1: u64 = base_dir_u8[g_base_dir_len - 3];
        var c2: u64 = base_dir_u8[g_base_dir_len - 2];
        var c3: u64 = base_dir_u8[g_base_dir_len - 1];
        if (c0 == 47 && c1 == 115 && c2 == 114 && c3 == 99) { // "/src"
            use_up_one = 1;
        }
    }

    var lib_root: u64 = version_dir2;
    var lib_root_len: u64 = version_dir_len2;
    if (use_up_one != 0) {
        lib_root = up_one;
        lib_root_len = up_one_len;
    }

    var src_suffix2: u64 = "/src";
    g_lib_dir = str_concat(lib_root, lib_root_len, src_suffix2, 4);
    g_lib_dir_len = str_len(g_lib_dir);
    return 0;
}

func build_merged_program() -> *AstProgram {
    var dummy_imports: *Vec<u64> = new Vec<u64>(1);
    var merged_prog: *AstProgram = ast_program(g_all_funcs, g_all_consts, dummy_imports);
    merged_prog.globals_vec = g_all_globals;
    merged_prog.structs_vec = g_all_structs_vec;
    return merged_prog;
}

func get_func_sigs() -> *Vec<*AstFunc> {
    return g_all_func_sigs;
}
