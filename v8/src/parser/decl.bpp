// parse_decl.b - Declaration parsing
//
// Parses top-level declarations:
// - const declarations
// - import declarations
// - function declarations (parameters, return types, body)
// - struct definitions
// - enum definitions
// - impl blocks
// - parse_program (entry point)

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import lexer;
import ast;
import compiler;
import parser.util;
import parser.type;
import parser.expr;
import parser.stmt;

// ============================================
// Vec<*AstFunc> Helpers (bootstrap-safe)
// ============================================

func parser_vec_astfunc_push(vec: *Vec<*AstFunc>, item: *AstFunc) -> u64 {
    var len: u64 = vec.length;
    var cap: u64 = vec.capacity;
    var elem_size: u64 = sizeof(*AstFunc);

    if (len >= cap) {
        var new_cap: u64 = cap * 2;
        if (new_cap < 4) { new_cap = 4; }
        var new_buf: u64 = heap_alloc(new_cap * elem_size);
        var old_buf: u64 = vec.data_ptr;
        for (var i: u64 = 0; i < len; i++) {
            var src: u64 = old_buf + i * elem_size;
            var dst: u64 = new_buf + i * elem_size;
            var src_u8: *u8 = (*u8)src;
            var dst_u8: *u8 = (*u8)dst;
            for (var j: u64 = 0; j < elem_size; j++) {
                dst_u8[j] = src_u8[j];
            }
        }
        vec.data_ptr = new_buf;
        vec.capacity = new_cap;
    }

    var buf: u64 = vec.data_ptr;
    var dst2: u64 = buf + len * elem_size;
    var src2: u64 = (u64)&item;
    var dst2_u8: *u8 = (*u8)dst2;
    var src2_u8: *u8 = (*u8)src2;
    for (var k: u64 = 0; k < elem_size; k++) {
        dst2_u8[k] = src2_u8[k];
    }
    vec.length = len + 1;
    return 0;
}

// ============================================
// Const Declaration
// ============================================

func parse_const_decl(p: *Parser) -> *AstConstDecl {
    parse_consume(p, TOKEN_CONST);
    
    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;

    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_EQ);
    
    var value: u64 = 0;
    var neg: u64 = 0;
    
    // Handle negative numbers
    if (parse_match(p, TOKEN_MINUS)) {
        neg = 1;
    }
    
    if (parse_peek_kind(p) == TOKEN_NUMBER) {
        var val_tok: *Token = parse_peek(p);
        value = parse_num_val(val_tok);
        parse_consume(p, TOKEN_NUMBER);
    } else if (parse_peek_kind(p) == TOKEN_CHAR) {
        var char_tok: *Token = parse_peek(p);
        var char_ptr: u64 = char_tok.ptr;
        var char_len: u64 = char_tok.len;
        var char_u8: []u8 = slice(char_ptr, char_len);
        value = char_u8[1];
        // Handle escape sequences
        if (char_u8[1] == 92) {
            var escape_char: u64 = char_u8[2];
            if (escape_char == 110) { value = 10; }       // \n
            else if (escape_char == 116) { value = 9; }   // \t
            else if (escape_char == 114) { value = 13; }  // \r
            else if (escape_char == 48) { value = 0; }    // \0
            else if (escape_char == 92) { value = 92; }   // \\
            else if (escape_char == 39) { value = 39; }   // \'
            else { value = escape_char; }
        }
        parse_consume(p, TOKEN_CHAR);
    } else {
        emit_stderr("[ERROR] Expected number or char in const\n");
        parse_panic_here(p, "Parse error");
    }
    
    if (neg) { value = 0 - value; }
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    return ast_const_decl(name_ptr, name_len, value);
}

// ============================================
// Import Declaration
// ============================================

func parse_import_decl(p: *Parser) -> *AstImport {
    parse_consume(p, TOKEN_IMPORT);
    
    var first_tok: *Token = parse_peek(p);
    var first_kind: u64 = parse_peek_kind(p);
    if (first_kind != TOKEN_IDENTIFIER && first_kind != TOKEN_CHAR) {
        emit_stderr("[ERROR] Expected module identifier in import\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);

    // Selective import: import <symbol> [as <alias>] from <module>
    if (parse_peek_kind(p) == TOKEN_AS || parse_peek_kind(p) == TOKEN_FROM) {
        var symbol_ptr: u64 = first_tok.ptr;
        var symbol_len: u64 = first_tok.len;
        var alias_ptr: u64 = symbol_ptr;
        var alias_len: u64 = symbol_len;

        if (parse_match(p, TOKEN_AS)) {
            var alias_tok: *Token = parse_peek(p);
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] Expected alias identifier in import\n");
                parse_panic_here(p, "Parse error");
            }
            alias_ptr = alias_tok.ptr;
            alias_len = alias_tok.len;
            parse_consume(p, TOKEN_IDENTIFIER);
        }

        parse_consume(p, TOKEN_FROM);

        var mod_tok: *Token = parse_peek(p);
        var mod_kind: u64 = parse_peek_kind(p);
        if (mod_kind != TOKEN_IDENTIFIER && mod_kind != TOKEN_CHAR) {
            emit_stderr("[ERROR] Expected module identifier in import\n");
            parse_panic_here(p, "Parse error");
        }
        parse_adv(p);

        var path_ptr: u64 = mod_tok.ptr;
        var path_len: u64 = mod_tok.len;

        while (parse_match(p, TOKEN_DOT)) {
            var next_tok: *Token = parse_peek(p);
            var next_kind: u64 = parse_peek_kind(p);
            if (next_kind != TOKEN_IDENTIFIER && next_kind != TOKEN_CHAR) {
                emit_stderr("[ERROR] Expected module identifier in import\n");
                parse_panic_here(p, "Parse error");
            }
            parse_adv(p);

            var slash: u64 = heap_alloc(sizeof(u8));
            *(*u8)slash = 47;

            var joined_path: u64 = str_concat(path_ptr, path_len, slash, 1);
            path_ptr = str_concat(joined_path, path_len + 1, next_tok.ptr, next_tok.len);
            path_len = path_len + 1 + next_tok.len;
        }

        parse_consume(p, TOKEN_SEMICOLON);

        return ast_import(path_ptr, path_len, symbol_ptr, symbol_len, alias_ptr, alias_len);
    }

    // Import module: import <module>;
    var path_ptr: u64  = first_tok.ptr;
    var path_len: u64 = first_tok.len;
    
    while (parse_match(p, TOKEN_DOT)) {
        var next_tok: *Token = parse_peek(p);
        var next_kind: u64 = parse_peek_kind(p);
        if (next_kind != TOKEN_IDENTIFIER && next_kind != TOKEN_CHAR) {
            emit_stderr("[ERROR] Expected module identifier in import\n");
            parse_panic_here(p, "Parse error");
        }
        parse_adv(p);
        
        var slash2: u64 = heap_alloc(sizeof(u8));
        *(*u8)slash2 = 47;
        
        var joined_path2: u64 = str_concat(path_ptr, path_len, slash2, 1);
        path_ptr = str_concat(joined_path2, path_len + 1, next_tok.ptr, next_tok.len);
        path_len = path_len + 1 + next_tok.len;
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    return ast_import(path_ptr, path_len, 0, 0, 0, 0);
}

// ============================================
// Function Parsing
// ============================================

// Skip a block without parsing its contents
func parse_skip_block(p: *Parser) -> u64 {
    parse_consume(p, TOKEN_LBRACE);
    var depth: u64 = 1;
    while (depth > 0) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_EOF:
                emit_stderr("[ERROR] Unexpected EOF while skipping block\n");
                parse_panic_here(p, "Parse error");
                break;
            case TOKEN_LBRACE:
                depth = depth + 1;
                break;
            case TOKEN_RBRACE:
                depth = depth - 1;
            default:
                break;
        }
        parse_adv(p);
    }
    return 0;
}

func parse_is_generic_param_list(p: *Parser) -> u64 {
    if (parse_peek_kind(p) != TOKEN_LT) { return false; }
    var saved: u64 = parser_pos(p);
    parse_adv(p);
    var depth: u64 = 1;
    while (1) {
        var k: u64 = parse_peek_kind(p);
        if (k == TOKEN_EOF) {
            parser_set_pos(p, saved);
            return false;
        }
        if (k == TOKEN_LPAREN) {
            parser_set_pos(p, saved);
            return false;
        }
        if (k == TOKEN_LT) { depth = depth + 1; }
        if (k == TOKEN_GT) {
            depth = depth - 1;
            if (depth == 0) {
                var saved2: u64 = parser_pos(p);
                parse_adv(p);
                var next_kind: u64 = parse_peek_kind(p);
                parser_set_pos(p, saved2);
                parser_set_pos(p, saved);
                if (next_kind == TOKEN_LPAREN) { return true; }
                return false;
            }
        }
        if (k == TOKEN_RSHIFT) {
            if (depth < 2) {
                parser_set_pos(p, saved);
                return false;
            }
            depth = depth - 2;
            if (depth == 0) {
                var saved3: u64 = parser_pos(p);
                parse_adv(p);
                var next_kind2: u64 = parse_peek_kind(p);
                parser_set_pos(p, saved3);
                parser_set_pos(p, saved);
                if (next_kind2 == TOKEN_LPAREN) { return true; }
                return false;
            }
        }
        parse_adv(p);
    }
}

func parse_is_generic_param_list_any(p: *Parser) -> u64 {
    if (parse_peek_kind(p) != TOKEN_LT) { return false; }
    var saved: u64 = parser_pos(p);
    parse_adv(p);
    var depth: u64 = 1;
    while (1) {
        var k: u64 = parse_peek_kind(p);
        if (k == TOKEN_EOF) {
            parser_set_pos(p, saved);
            return false;
        }
        if (k == TOKEN_LT) { depth = depth + 1; }
        if (k == TOKEN_GT) {
            depth = depth - 1;
            if (depth == 0) {
                parser_set_pos(p, saved);
                return true;
            }
        }
        if (k == TOKEN_RSHIFT) {
            if (depth < 2) {
                parser_set_pos(p, saved);
                return false;
            }
            depth = depth - 2;
            if (depth == 0) {
                parser_set_pos(p, saved);
                return true;
            }
        }
        parse_adv(p);
    }
}

func parse_is_impl_trait_block(p: *Parser) -> u64 {
    if (parse_peek_kind(p) != TOKEN_IMPL) { return false; }
    var saved: u64 = parser_pos(p);
    parse_adv(p);
    if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
        parser_set_pos(p, saved);
        return false;
    }
    parse_adv(p);
    var k: u64 = parse_peek_kind(p);
    parser_set_pos(p, saved);
    if (k == TOKEN_FOR) { return true; }
    return false;
}

// Parse generic parameter list for structs: <T, U, const N: u64>
func parse_generic_params_any(p: *Parser) -> *Vec<*GenericParam> {
    push_trace("parse_generic_params_any", "parser/decl.b", __LINE__);
    defer pop_trace();
    var tok: *Token = parse_peek(p);
    if (tok == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_LT) { return 0; }
    if (parse_is_generic_param_list_any(p) == 0) { return 0; }
    parse_consume(p, TOKEN_LT);

    var params: *Vec<*GenericParam> = new Vec<*GenericParam>(4);
    while (1) {
        var is_value: u64 = 0;
        if (parse_match(p, TOKEN_CONST)) { is_value = 1; }

        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected generic parameter name\n");
            parse_panic_here(p, "Parse error");
        }

        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok.ptr;
        var name_len: u64 = name_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);

        var value_type_kind: u64 = 0;
        if (parse_match(p, TOKEN_COLON)) {
            value_type_kind = parse_base_type(p);
            if (value_type_kind == TYPE_STRUCT || value_type_kind == TYPE_VOID) {
                emit_stderr("[ERROR] Invalid value generic type\n");
                parse_panic_here(p, "Parse error");
            }
            if (value_type_kind != TYPE_U64) {
                emit_stderr("[ERROR] Value generic type must be u64\n");
                parse_panic_here(p, "Parse error");
            }
            is_value = 1;
        } else if (is_value == 1) {
            emit_stderr("[ERROR] const generic requires type annotation\n");
            parse_panic_here(p, "Parse error");
        }

        var gp: *GenericParam = new GenericParam();
        if (is_value == 1) { gp.kind = GENERIC_KIND_VALUE; }
        else { gp.kind = GENERIC_KIND_TYPE; }
        gp.name_ptr = name_ptr;
        gp.name_len = name_len;
        gp.value_type_kind = value_type_kind;
        params.push(gp);

        if (parse_match(p, TOKEN_COMMA)) { continue; }
        break;
    }

    parse_consume_generic_gt(p);
    return params;
}

// Parse generic parameter list: <T, U, const N: u64>
func parse_generic_params(p: *Parser) -> *Vec<*GenericParam> {
    var tok: *Token = parse_peek(p);
    if (tok == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_LT) { return 0; }
    if (parse_is_generic_param_list(p) == 0) { return 0; }
    parse_consume(p, TOKEN_LT);

    var params: *Vec<*GenericParam> = new Vec<*GenericParam>(4);
    while (1) {
        var is_value: u64 = 0;
        if (parse_match(p, TOKEN_CONST)) { is_value = 1; }

        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected generic parameter name\n");
            parse_panic_here(p, "Parse error");
        }

        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok.ptr;
        var name_len: u64 = name_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);

        var value_type_kind: u64 = 0;
        if (parse_match(p, TOKEN_COLON)) {
            value_type_kind = parse_base_type(p);
            if (value_type_kind == TYPE_STRUCT || value_type_kind == TYPE_VOID) {
                emit_stderr("[ERROR] Invalid value generic type\n");
                parse_panic_here(p, "Parse error");
            }
            if (value_type_kind != TYPE_U64) {
                emit_stderr("[ERROR] Value generic type must be u64\n");
                parse_panic_here(p, "Parse error");
            }
            is_value = 1;
        } else if (is_value == 1) {
            emit_stderr("[ERROR] const generic requires type annotation\n");
            parse_panic_here(p, "Parse error");
        }

        var gp: *GenericParam = new GenericParam();
        if (is_value == 1) { gp.kind = GENERIC_KIND_VALUE; }
        else { gp.kind = GENERIC_KIND_TYPE; }
        gp.name_ptr = name_ptr;
        gp.name_len = name_len;
        gp.value_type_kind = value_type_kind;
        params.push(gp);

        if (parse_match(p, TOKEN_COMMA)) { continue; }
        break;
    }

    parse_consume_generic_gt(p);
    return params;
}

func parse_param(p: *Parser) -> *Param {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }
    
    var type_kind: u64 = 0;
    var ptr_depth: u64 = 0;
    var is_tagged: u64 = 0;
    var struct_name_ptr: u64 = 0;
    var struct_name_len: u64 = 0;
    var tag_layout_ptr: u64 = 0;
    var tag_layout_len: u64 = 0;
    var elem_type_kind: u64 = 0;
    var elem_ptr_depth: u64 = 0;
    var array_len: u64 = 0;
    var array_len_is_param: u64 = 0;
    var array_len_param_ptr: u64 = 0;
    var array_len_param_len: u64 = 0;
    
    if (parse_match(p, TOKEN_COLON)) {
        var ty: *TypeInfo = parse_type_ex(p);
        type_kind = ty.type_kind;
        ptr_depth = ty.ptr_depth;
        is_tagged = ty.is_tagged;
        struct_name_ptr = ty.struct_name_ptr;
        struct_name_len = ty.struct_name_len;
        tag_layout_ptr = ty.tag_layout_ptr;
        tag_layout_len = ty.tag_layout_len;
        elem_type_kind = ty.elem_type_kind;
        elem_ptr_depth = ty.elem_ptr_depth;
        array_len = ty.array_len;
        array_len_is_param = ty.array_len_is_param;
        array_len_param_ptr = ty.array_len_param_ptr;
        array_len_param_len = ty.array_len_param_len;
        if (type_kind == TYPE_ARRAY) {
            // Array parameter decays to pointer to first element
            type_kind = elem_type_kind;
            ptr_depth = elem_ptr_depth + 1;
            is_tagged = 0;
            tag_layout_ptr = 0;
            tag_layout_len = 0;
            array_len_is_param = 0;
            array_len_param_ptr = 0;
            array_len_param_len = 0;
        }
    }
    
    var param: *Param = new Param();
    param.name_ptr = name_tok.ptr;
    param.name_len = name_tok.len;
    param.type_kind = type_kind;
    param.ptr_depth = ptr_depth;
    param.is_tagged = is_tagged;
    param.struct_name_ptr = struct_name_ptr;
    param.struct_name_len = struct_name_len;
    param.tag_layout_ptr = tag_layout_ptr;
    param.tag_layout_len = tag_layout_len;
    param.elem_type_kind = elem_type_kind;
    param.elem_ptr_depth = elem_ptr_depth;
    param.array_len = array_len;
    param.array_len_is_param = array_len_is_param;
    param.array_len_param_ptr = array_len_param_ptr;
    param.array_len_param_len = array_len_param_len;
    return param;
}

func parse_func_decl(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl", "parser/decl.b", __LINE__);
    defer pop_trace();
    
    parse_consume(p, TOKEN_FUNC);
    
    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER && name_kind != TOKEN_NEW && name_kind != TOKEN_DELETE) {
        emit_stderr("[ERROR] Expected function name identifier\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }
    
    // Set parsing context for better error messages
    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);
    
    parse_consume(p, TOKEN_LPAREN);
    
    var params: *Vec<*Param> = new Vec<*Param>(8);
    
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    
    parse_consume(p, TOKEN_RPAREN);
    
    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;
    
    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            // Array return decays to pointer to first element
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }
    
    var body: *AstNode = parse_block(p);

    var func_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, body);

    if (generic_params != 0) {
        type_parser_clear_generic_params();
        compiler_register_generic_func_def(name_tok.ptr, name_tok.len, generic_params, func_node);
    }
    return func_node;
}

// Parse function signature only (skip body)
func parse_func_decl_signature(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl_signature", "parser/decl.b", __LINE__);
    defer pop_trace();

    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER && name_kind != TOKEN_NEW && name_kind != TOKEN_DELETE) {
        emit_stderr("[ERROR] Expected function name identifier\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);

    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    // Skip function body
    parse_skip_block(p);

    var func_sig: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, 0);

    if (generic_params != 0) {
        type_parser_clear_generic_params();
        compiler_register_generic_func_sig(name_tok.ptr, name_tok.len, generic_params, func_sig);
    }
    return func_sig;
}

// Parse abstract function signature (no body, ends with ';')
func parse_func_decl_abst_signature(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl_abst_signature", "parser/decl.b", __LINE__);
    defer pop_trace();

    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER && name_kind != TOKEN_NEW && name_kind != TOKEN_DELETE) {
        emit_stderr("[ERROR] Expected function name identifier\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);

    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    parse_consume(p, TOKEN_SEMICOLON);

    var func_sig: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, 0);

    if (generic_params != 0) {
        type_parser_clear_generic_params();
        compiler_register_generic_func_sig(name_tok.ptr, name_tok.len, generic_params, func_sig);
    }
    return func_sig;
}

// ============================================
// Struct Parsing
// ============================================

func parse_uwidth_from_ident(ptr: u64, len: u64) -> u64 {
    if (len < 2) { return 0; }
    var ptr_u8: *u8 = (*u8)ptr;
    var first: u64 = ptr_u8[0];
    if (first != 117) { return 0; }
    var value: u64 = 0;
    for (var i: u64 = 1; i < len; i++) {
        var c: u64 = ptr_u8[i];
        if (c < 48 || c > 57) { return 0; }
        value = value * 10 + (c - 48);
    }
    return value;
}

func parse_struct_def(p: *Parser) -> *AstStructDef {
    push_trace("parse_struct_def", "parser/decl.b", __LINE__);
    defer pop_trace();
    var is_packed: u64 = 0;
    if (parse_match(p, TOKEN_PACKED)) {
        is_packed = 1;
    }
    parse_consume(p, TOKEN_STRUCT);
    
    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }

    var parents: *Vec<*ParentDesc> = 0;
    var traits: *Vec<*TraitRef> = 0;
    if (parse_match(p, TOKEN_COLON)) {
        parents = new Vec<*ParentDesc>(4);
        while (1) {
            var parent_tok: *Token = parse_peek(p);
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] Expected parent struct name after ':'\n");
                parse_panic_here(p, "Parse error");
            }
            parse_adv(p);
            if (str_eq(parent_tok.ptr, parent_tok.len, name_ptr, name_len)) {
                emit_stderr("[ERROR] Struct cannot inherit from itself\n");
                parse_panic_here(p, "Parse error");
            }
            if (compiler_is_trait_name(parent_tok.ptr, parent_tok.len) != 0) {
                if (traits == 0) { traits = new Vec<*TraitRef>(4); }
                var tref: *TraitRef = new TraitRef();
                tref.name_ptr = parent_tok.ptr;
                tref.name_len = parent_tok.len;
                tref.trait_def = compiler_get_trait_def(parent_tok.ptr, parent_tok.len);
                traits.push(tref);
                if (!parse_match(p, TOKEN_COMMA)) { break; }
                continue;
            }
            var parent_desc: *ParentDesc = new ParentDesc();
            parent_desc.name_ptr = parent_tok.ptr;
            parent_desc.name_len = parent_tok.len;
            parents.push(parent_desc);
            if (!parse_match(p, TOKEN_COMMA)) { break; }
        }
    }
    
    if (is_packed == 1 && parents != 0 && parents.len() > 0) {
        emit_stderr("[ERROR] packed struct cannot use inheritance\n");
        parse_panic_here(p, "Parse error");
    }
    if (is_packed == 1 && traits != 0 && traits.len() > 0) {
        emit_stderr("[ERROR] packed struct cannot use trait inheritance\n");
        parse_panic_here(p, "Parse error");
    }

    parse_consume(p, TOKEN_LBRACE);
    
    var fields: *Vec<*FieldDesc> = new Vec<*FieldDesc>(8);
    
    // Parse fields: field_name : type ;
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        var field_name_tok: *Token = parse_peek(p);
        var field_name_ptr: u64 = field_name_tok.ptr;
        var field_name_len: u64 = field_name_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);
        
        parse_consume(p, TOKEN_COLON);
        
        var field_type_kind: u64 = 0;
        var field_ptr_depth: u64 = 0;
        var field_struct_name_ptr: u64 = 0;
        var field_struct_name_len: u64 = 0;
        var field_tag_layout_ptr: u64 = 0;
        var field_tag_layout_len: u64 = 0;
        var field_elem_type_kind: u64 = 0;
        var field_elem_ptr_depth: u64 = 0;
        var field_array_len: u64 = 0;
        var field_is_tagged: u64 = 0;
        var field_bit_width: u64 = 0;

        if (is_packed == 1) {
            var k: u64 = parse_peek_kind(p);
            switch (k) {
                case TOKEN_U8:
                    parse_adv(p);
                    field_type_kind = TYPE_U8;
                    field_bit_width = 8;
                    break;
                case TOKEN_U16:
                    parse_adv(p);
                    field_type_kind = TYPE_U16;
                    field_bit_width = 16;
                    break;
                case TOKEN_U32:
                    parse_adv(p);
                    field_type_kind = TYPE_U32;
                    field_bit_width = 32;
                    break;
                case TOKEN_U64:
                    parse_adv(p);
                    field_type_kind = TYPE_U64;
                    field_bit_width = 64;
                    break;
                case TOKEN_IDENTIFIER:
                    var bw_tok: *Token = parse_peek(p);
                    var bw_ptr: u64 = bw_tok.ptr;
                    var bw_len: u64 = bw_tok.len;
                    parse_adv(p);
                    var bw: u64 = parse_uwidth_from_ident(bw_ptr, bw_len);
                    if (bw == 0 || bw > 64) {
                        emit_stderr("[ERROR] packed field must be u1..u64\n");
                        parse_panic_here(p, "Parse error");
                    }
                    field_type_kind = TYPE_U64;
                    field_bit_width = bw;
                    break;
                default:
                    emit_stderr("[ERROR] packed field must be u1..u64\n");
                    parse_panic_here(p, "Parse error");
            }
        } else {
            var field_type: *TypeInfo = parse_type_ex(p);
            field_type_kind = field_type.type_kind;
            field_struct_name_ptr = field_type.struct_name_ptr;
            field_struct_name_len = field_type.struct_name_len;
            field_tag_layout_ptr = field_type.tag_layout_ptr;
            field_tag_layout_len = field_type.tag_layout_len;
            field_ptr_depth = field_type.ptr_depth;
            field_is_tagged = field_type.is_tagged;
            field_elem_type_kind = field_type.elem_type_kind;
            field_elem_ptr_depth = field_type.elem_ptr_depth;
            field_array_len = field_type.array_len;
        }
        
        parse_consume(p, TOKEN_SEMICOLON);
        
        var field_desc: *FieldDesc = new FieldDesc();
        field_desc.name_ptr = field_name_ptr;
        field_desc.name_len = field_name_len;
        field_desc.type_kind =  field_type_kind;
        field_desc.struct_name_ptr = field_struct_name_ptr;
        field_desc.struct_name_len = field_struct_name_len;
        field_desc.ptr_depth = field_ptr_depth;
        field_desc.is_tagged = field_is_tagged;
        field_desc.tag_layout_ptr = field_tag_layout_ptr;
        field_desc.tag_layout_len = field_tag_layout_len;
        field_desc.bit_width = field_bit_width;
        field_desc.elem_type_kind = field_elem_type_kind;
        field_desc.elem_ptr_depth = field_elem_ptr_depth;
        field_desc.array_len = field_array_len;
        
        fields.push(field_desc);
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    var struct_def: *AstStructDef = ast_struct_def(name_ptr, name_len, parents, fields, is_packed, traits);
    if (generic_params != 0) {
        type_parser_clear_generic_params();
        compiler_register_generic_struct_def(name_ptr, name_len, generic_params, struct_def);
    }
    return struct_def;
}

// ============================================
// Enum Parsing
// ============================================

func parse_enum_def(p: *Parser) -> *Vec<*AstConstDecl> {
    parse_consume(p, TOKEN_ENUM);
    
    var enum_name_tok: *Token = parse_peek(p);
    var enum_name_ptr: u64 = enum_name_tok.ptr;
    var enum_name_len: u64 = enum_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_LBRACE);
    
    var consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(16);
    var current_value: u64 = 0;
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        
        var member_tok: *Token = parse_peek(p);
        var member_ptr: u64 = member_tok.ptr;
        var member_len: u64 = member_tok.len;
        parse_consume(p, TOKEN_IDENTIFIER);
        
        // Check for explicit value
        if (parse_match(p, TOKEN_EQ)) {
            var val_tok: *Token = parse_peek(p);
            parse_consume(p, TOKEN_NUMBER);
            current_value = parse_num_val(val_tok);
        }
        
        // Create EnumName_MemberName
        var name_info: *NameInfo = compiler_build_scoped_name(enum_name_ptr, enum_name_len, member_ptr, member_len);
        var const_node: *AstConstDecl = ast_const_decl(name_info.ptr, name_info.len, current_value);
        consts.push(const_node);
        
        current_value = current_value + 1;
        
        // Optional comma
        if (parse_peek_kind(p) == TOKEN_COMMA) {
            parse_consume(p, TOKEN_COMMA);
        }
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return consts;
}

// ============================================
// Impl Block Parsing
// ============================================

// ============================================
// Trait Parsing
// ============================================

func parse_trait_method_signature(p: *Parser) -> *AstFunc {
    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER) {
        emit_stderr("[ERROR] Expected trait method name identifier\n");
        parse_panic_here(p, "Parse error");
    }
    parse_adv(p);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty.type_kind;
        ret_ptr_depth = ty.ptr_depth;
        ret_is_tagged = ty.is_tagged;
        ret_struct_name_ptr = ty.struct_name_ptr;
        ret_struct_name_len = ty.struct_name_len;
        ret_tag_layout_ptr = ty.tag_layout_ptr;
        ret_tag_layout_len = ty.tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty.elem_type_kind;
            ret_ptr_depth = ty.elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty.struct_name_ptr;
            ret_struct_name_len = ty.struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    parse_consume(p, TOKEN_SEMICOLON);
    return ast_func_ex(name_tok.ptr, name_tok.len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, 0);
}

func parse_trait_def(p: *Parser) -> *TraitDef {
    parse_consume(p, TOKEN_TRAIT);

    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok.ptr;
    var name_len: u64 = name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var methods: *Vec<*TraitMethod> = new Vec<*TraitMethod>(8);
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        if (parse_peek_kind(p) != TOKEN_FUNC) {
            emit_stderr("[ERROR] trait block can only contain method signatures\n");
            parse_panic_here(p, "Parse error");
        }
        var sig: *AstFunc = parse_trait_method_signature(p);
        var tm: *TraitMethod = new TraitMethod();
        tm.name_ptr = sig.name_ptr;
        tm.name_len = sig.name_len;
        tm.sig = sig;
        tm.index = methods.len();
        methods.push(tm);
    }

    parse_consume(p, TOKEN_RBRACE);

    var td: *TraitDef = new TraitDef();
    td.name_ptr = name_ptr;
    td.name_len = name_len;
    td.methods_vec = methods;
    compiler_register_trait_def(td);
    return td;
}

func _make_self_param(struct_name_ptr: u64, struct_name_len: u64) -> *Param {
    var p: *Param = new Param();
    p.name_ptr = (u64)"self";
    p.name_len = 4;
    p.type_kind = TYPE_STRUCT;
    p.ptr_depth = 1;
    p.is_tagged = 0;
    p.struct_name_ptr = struct_name_ptr;
    p.struct_name_len = struct_name_len;
    p.tag_layout_ptr = 0;
    p.tag_layout_len = 0;
    p.elem_type_kind = 0;
    p.elem_ptr_depth = 0;
    p.array_len = 0;
    p.array_len_is_param = 0;
    p.array_len_param_ptr = 0;
    p.array_len_param_len = 0;
    return p;
}

func parse_constructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_CONSTRUCTOR);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = new Vec<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params.push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params.push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    if (parse_peek_kind(p) == TOKEN_ARROW) {
        emit_stderr("[ERROR] constructor cannot specify return type\n");
        parse_panic_here(p, "Parse error");
    }

    var params_out: *Vec<*Param> = new Vec<*Param>(params.len() + 1);
    params_out.push(_make_self_param(struct_name_ptr, struct_name_len));
    for (var i: u64 = 0; i < params.len(); i++) {
        params_out.push(params.get(i));
    }

    if (sig_only != 0) {
        parse_skip_block(p);
        var sig_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
        compiler_register_generic_func_sig(name_tok.ptr, name_tok.len, 0, sig_node);
        return sig_node;
    }

    var body: *AstNode = parse_block(p);
    var func_node: *AstFunc = ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
    compiler_register_generic_func_def(name_tok.ptr, name_tok.len, 0, func_node);
    return func_node;
}

func parse_destructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_DESTRUCTOR);

    set_parsing_context(name_tok.ptr, name_tok.len, name_tok.line);

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        parse_adv(p);
        if (parse_peek_kind(p) != TOKEN_RPAREN) {
            emit_stderr("[ERROR] destructor cannot take parameters\n");
            parse_panic_here(p, "Parse error");
        }
        parse_consume(p, TOKEN_RPAREN);
    }

    var params_out: *Vec<*Param> = new Vec<*Param>(1);
    params_out.push(_make_self_param(struct_name_ptr, struct_name_len));

    if (sig_only != 0) {
        parse_skip_block(p);
        return ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
    }

    var body: *AstNode = parse_block(p);
    return ast_func_ex(name_tok.ptr, name_tok.len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
}

func parse_impl_block(p: *Parser) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);
    
    // Get struct name
    var struct_name_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_name_tok.ptr;
    var struct_name_len: u64 = struct_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_LBRACE);
    
    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);
    
    // Parse all functions in impl block
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        
        // Check for static/abst keyword
        var is_static: u64 = 0;
        var is_abst: u64 = 0;
        if (parse_peek_kind(p) == TOKEN_STATIC) {
            is_static = 1;
            parse_adv(p);  // consume 'static'
        }
        if (parse_peek_kind(p) == TOKEN_ABST) {
            is_abst = 1;
            parse_adv(p);  // consume 'abst'
        }
        if (is_static != 0 && is_abst != 0) {
            emit_stderr("[ERROR] abstract method cannot be static\n");
            parse_panic_here(p, "Parse error");
        }
        
        if (parse_peek_kind(p) == TOKEN_CONSTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] constructor cannot be static\n");
                parse_panic_here(p, "Parse error");
            }
            if (is_abst != 0) {
                emit_stderr("[ERROR] constructor cannot be abstract\n");
                parse_panic_here(p, "Parse error");
            }
            var ctor_node: *AstFunc = parse_constructor_decl(p, struct_name_ptr, struct_name_len, 0);

            // Rename function: constructor -> StructName_constructor
            var original_name_ptr2: u64 = ctor_node.name_ptr;
            var original_name_len2: u64 = ctor_node.name_len;
            var name_info2: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr2, original_name_len2);

            ctor_node.name_ptr = name_info2.ptr;
            ctor_node.name_len = name_info2.len;
            compiler_register_impl_method(name_info2.ptr, name_info2.len);
            compiler_alias_generic_template_by_func_ptr(ctor_node, name_info2.ptr, name_info2.len);
            var resolved_ctor: *NameInfo = resolve_name(name_info2.ptr, name_info2.len);
            if (resolved_ctor != 0) {
                compiler_alias_generic_template_by_func_ptr(ctor_node, resolved_ctor.ptr, resolved_ctor.len);
            }
            parser_vec_astfunc_push(funcs, ctor_node);
        } else if (parse_peek_kind(p) == TOKEN_DESTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] destructor cannot be static\n");
                parse_panic_here(p, "Parse error");
            }
            if (is_abst != 0) {
                emit_stderr("[ERROR] destructor cannot be abstract\n");
                parse_panic_here(p, "Parse error");
            }
            var dtor_node: *AstFunc = parse_destructor_decl(p, struct_name_ptr, struct_name_len, 0);

            var original_name_ptr3: u64 = dtor_node.name_ptr;
            var original_name_len3: u64 = dtor_node.name_len;
            var name_info3: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr3, original_name_len3);

            dtor_node.name_ptr = name_info3.ptr;
            dtor_node.name_len = name_info3.len;
            compiler_register_impl_method(name_info3.ptr, name_info3.len);
            compiler_alias_generic_template_by_func_ptr(dtor_node, name_info3.ptr, name_info3.len);
            var resolved_dtor: *NameInfo = resolve_name(name_info3.ptr, name_info3.len);
            if (resolved_dtor != 0) {
                compiler_alias_generic_template_by_func_ptr(dtor_node, resolved_dtor.ptr, resolved_dtor.len);
            }
            parser_vec_astfunc_push(funcs, dtor_node);
        } else if (parse_peek_kind(p) == TOKEN_FUNC) {
            if (is_abst != 0) {
                var abst_sig: *AstFunc = parse_func_decl_abst_signature(p);
                compiler_register_abst_method(struct_name_ptr, struct_name_len, abst_sig.name_ptr, abst_sig.name_len);
                continue;
            }
            var func_node: *AstFunc = parse_func_decl(p);
            
            // Rename function: methodName -> StructName_methodName
            var original_name_ptr: u64 = func_node.name_ptr;
            var original_name_len: u64 = func_node.name_len;
            var name_info: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr, original_name_len);

            // Update function name
            func_node.name_ptr = name_info.ptr;
            func_node.name_len = name_info.len;

            compiler_register_impl_method(name_info.ptr, name_info.len);
            compiler_alias_generic_template_by_func_ptr(func_node, name_info.ptr, name_info.len);
            var resolved_method: *NameInfo = resolve_name(name_info.ptr, name_info.len);
            if (resolved_method != 0) {
                compiler_alias_generic_template_by_func_ptr(func_node, resolved_method.ptr, resolved_method.len);
            }

            parser_vec_astfunc_push(funcs, func_node);
        } else {
            emit_stderr("[ERROR] impl block can only contain functions\n");
            break;
        }
    }
    
    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();
    
    return funcs;
}

func parse_impl_trait_block(p: *Parser) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var trait_tok: *Token = parse_peek(p);
    var trait_ptr: u64 = trait_tok.ptr;
    var trait_len: u64 = trait_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_FOR);

    var struct_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_tok.ptr;
    var struct_name_len: u64 = struct_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    var impl_methods: *Vec<*TraitImplMethod> = new Vec<*TraitImplMethod>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        if (parse_peek_kind(p) == TOKEN_STATIC) {
            emit_stderr("[ERROR] trait impl methods cannot be static\n");
            parse_panic_here(p, "Parse error");
        }

        if (parse_peek_kind(p) == TOKEN_ABST) {
            emit_stderr("[ERROR] trait impl methods cannot be abstract\n");
            parse_panic_here(p, "Parse error");
        }

        if (parse_peek_kind(p) == TOKEN_FUNC) {
            var func_node: *AstFunc = parse_func_decl(p);

            var original_name_ptr: u64 = func_node.name_ptr;
            var original_name_len: u64 = func_node.name_len;
            var name_info: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr, original_name_len);

            func_node.name_ptr = name_info.ptr;
            func_node.name_len = name_info.len;

            compiler_register_impl_method(name_info.ptr, name_info.len);
            compiler_alias_generic_template_by_func_ptr(func_node, name_info.ptr, name_info.len);
            var resolved_method: *NameInfo = resolve_name(name_info.ptr, name_info.len);
            if (resolved_method != 0) {
                compiler_alias_generic_template_by_func_ptr(func_node, resolved_method.ptr, resolved_method.len);
            }

            var impl_method: *TraitImplMethod = new TraitImplMethod();
            impl_method.name_ptr = original_name_ptr;
            impl_method.name_len = original_name_len;
            impl_method.func_def = func_node;
            impl_methods.push(impl_method);

            parser_vec_astfunc_push(funcs, func_node);
        } else {
            emit_stderr("[ERROR] impl Trait for Type block can only contain functions\n");
            parse_panic_here(p, "Parse error");
        }
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();

    var impl_info: *TraitImpl = new TraitImpl();
    impl_info.trait_ptr = trait_ptr;
    impl_info.trait_len = trait_len;
    impl_info.struct_ptr = struct_name_ptr;
    impl_info.struct_len = struct_name_len;
    impl_info.methods_vec = impl_methods;
    impl_info.vtable_struct_def = 0;
    impl_info.vtable_global_ptr = 0;
    impl_info.vtable_global_len = 0;
    compiler_register_trait_impl(impl_info);

    return funcs;
}

// Impl block parsing for signature-only pass
func parse_impl_block_signature(p: *Parser) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var struct_name_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_name_tok.ptr;
    var struct_name_len: u64 = struct_name_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        var is_static: u64 = 0;
        var is_abst: u64 = 0;
        if (parse_peek_kind(p) == TOKEN_STATIC) {
            is_static = 1;
            parse_adv(p);
        }
        if (parse_peek_kind(p) == TOKEN_ABST) {
            is_abst = 1;
            parse_adv(p);
        }
        if (is_static != 0 && is_abst != 0) {
            emit_stderr("[ERROR] abstract method cannot be static\n");
            parse_panic_here(p, "Parse error");
        }

        if (parse_peek_kind(p) == TOKEN_CONSTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] constructor cannot be static\n");
                parse_panic_here(p, "Parse error");
            }
            if (is_abst != 0) {
                emit_stderr("[ERROR] constructor cannot be abstract\n");
                parse_panic_here(p, "Parse error");
            }
            var ctor_sig: *AstFunc = parse_constructor_decl(p, struct_name_ptr, struct_name_len, 1);

            var original_name_ptr2: u64 = ctor_sig.name_ptr;
            var original_name_len2: u64 = ctor_sig.name_len;
            var name_info2: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr2, original_name_len2);

            ctor_sig.name_ptr = name_info2.ptr;
            ctor_sig.name_len = name_info2.len;
            compiler_register_impl_method(name_info2.ptr, name_info2.len);
            compiler_alias_generic_template_by_func_ptr(ctor_sig, name_info2.ptr, name_info2.len);
            var resolved_ctor_sig: *NameInfo = resolve_name(name_info2.ptr, name_info2.len);
            if (resolved_ctor_sig != 0) {
                compiler_alias_generic_template_by_func_ptr(ctor_sig, resolved_ctor_sig.ptr, resolved_ctor_sig.len);
            }
            parser_vec_astfunc_push(funcs, ctor_sig);
        } else if (parse_peek_kind(p) == TOKEN_DESTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] destructor cannot be static\n");
                parse_panic_here(p, "Parse error");
            }
            if (is_abst != 0) {
                emit_stderr("[ERROR] destructor cannot be abstract\n");
                parse_panic_here(p, "Parse error");
            }
            var dtor_sig: *AstFunc = parse_destructor_decl(p, struct_name_ptr, struct_name_len, 1);

            var original_name_ptr3: u64 = dtor_sig.name_ptr;
            var original_name_len3: u64 = dtor_sig.name_len;
            var name_info3: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr3, original_name_len3);

            dtor_sig.name_ptr = name_info3.ptr;
            dtor_sig.name_len = name_info3.len;
            compiler_register_impl_method(name_info3.ptr, name_info3.len);
            compiler_alias_generic_template_by_func_ptr(dtor_sig, name_info3.ptr, name_info3.len);
            var resolved_dtor_sig: *NameInfo = resolve_name(name_info3.ptr, name_info3.len);
            if (resolved_dtor_sig != 0) {
                compiler_alias_generic_template_by_func_ptr(dtor_sig, resolved_dtor_sig.ptr, resolved_dtor_sig.len);
            }
            parser_vec_astfunc_push(funcs, dtor_sig);
        } else if (parse_peek_kind(p) == TOKEN_FUNC) {
            if (is_abst != 0) {
                var abst_sig: *AstFunc = parse_func_decl_abst_signature(p);
                compiler_register_abst_method(struct_name_ptr, struct_name_len, abst_sig.name_ptr, abst_sig.name_len);
                continue;
            }
            var func_ptr: *AstFunc = parse_func_decl_signature(p);
            if (func_ptr == 0) {
                continue;
            }
            var func_node: *AstFunc = func_ptr;

            var original_name_ptr: u64 = func_node.name_ptr;
            var original_name_len: u64 = func_node.name_len;
            var name_info: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr, original_name_len);

            func_node.name_ptr = name_info.ptr;
            func_node.name_len = name_info.len;

            compiler_register_impl_method(name_info.ptr, name_info.len);
            compiler_alias_generic_template_by_func_ptr(func_node, name_info.ptr, name_info.len);
            var resolved_method_sig: *NameInfo = resolve_name(name_info.ptr, name_info.len);
            if (resolved_method_sig != 0) {
                compiler_alias_generic_template_by_func_ptr(func_node, resolved_method_sig.ptr, resolved_method_sig.len);
            }

            parser_vec_astfunc_push(funcs, func_node);
        } else {
            emit_stderr("[ERROR] impl block can only contain functions\n");
            break;
        }
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();

    return funcs;
}

func parse_impl_trait_block_signature(p: *Parser) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var trait_tok: *Token = parse_peek(p);
    var trait_ptr: u64 = trait_tok.ptr;
    var trait_len: u64 = trait_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_FOR);

    var struct_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_tok.ptr;
    var struct_name_len: u64 = struct_tok.len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        if (parse_peek_kind(p) == TOKEN_STATIC) {
            emit_stderr("[ERROR] trait impl methods cannot be static\n");
            parse_panic_here(p, "Parse error");
        }

        if (parse_peek_kind(p) == TOKEN_ABST) {
            emit_stderr("[ERROR] trait impl methods cannot be abstract\n");
            parse_panic_here(p, "Parse error");
        }

        if (parse_peek_kind(p) == TOKEN_FUNC) {
            var func_sig: *AstFunc = parse_func_decl_signature(p);

            var original_name_ptr: u64 = func_sig.name_ptr;
            var original_name_len: u64 = func_sig.name_len;
            var name_info: *NameInfo = compiler_build_method_name(struct_name_ptr, struct_name_len, original_name_ptr, original_name_len);

            func_sig.name_ptr = name_info.ptr;
            func_sig.name_len = name_info.len;
            compiler_register_impl_method(name_info.ptr, name_info.len);
            compiler_alias_generic_template_by_func_ptr(func_sig, name_info.ptr, name_info.len);
            var resolved_method: *NameInfo = resolve_name(name_info.ptr, name_info.len);
            if (resolved_method != 0) {
                compiler_alias_generic_template_by_func_ptr(func_sig, resolved_method.ptr, resolved_method.len);
            }

            parser_vec_astfunc_push(funcs, func_sig);
        } else {
            emit_stderr("[ERROR] impl Trait for Type block can only contain functions\n");
            parse_panic_here(p, "Parse error");
        }
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();
    return funcs;
}

// ============================================
// Program Parsing (Entry Point)
// ============================================

func parse_program(p: *Parser) -> *AstProgram {
    push_trace("parse_program", "parser/decl.b", __LINE__);
    defer pop_trace();
    
    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(16);
    var consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(64);
    var imports: *Vec<*AstImport> = new Vec<*AstImport>(16);
    var globals: *Vec<*GlobalInfo> = new Vec<*GlobalInfo>(32);
    var structs: *Vec<*AstStructDef> = new Vec<*AstStructDef>(16);
    
    while (parse_peek_kind(p) != TOKEN_EOF) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_FUNC:
                var fn_ptr: *AstFunc = parse_func_decl(p);
                if (fn_ptr != 0) {
                    parser_vec_astfunc_push(funcs, fn_ptr);
                }
                break;
            case TOKEN_CONST:
                consts.push(parse_const_decl(p));
                break;
            case TOKEN_ENUM:
                // Enum  const 
                var enum_consts: *Vec<*AstConstDecl> = parse_enum_def(p);
                var num_enum_consts: u64 = enum_consts.len();
                for (var i: u64 = 0; i < num_enum_consts; i++) {
                    consts.push(enum_consts.get(i));
                }
                break;
            case TOKEN_STRUCT:
            case TOKEN_PACKED:
                var struct_def: *AstStructDef = parse_struct_def(p);
                if (compiler_is_generic_struct_def(struct_def) == 0) {
                    structs.push(struct_def);
                }
                register_struct_type(struct_def);  // Register immediately for type checking/sizeof
                break;
            case TOKEN_TRAIT:
                parse_trait_def(p);
                break;
            case TOKEN_IMPL:
                // impl :   StructName_methodName 
                var impl_funcs: *Vec<*AstFunc> = 0;
                if (parse_is_impl_trait_block(p) != 0) {
                    impl_funcs = parse_impl_trait_block(p);
                } else {
                    impl_funcs = parse_impl_block(p);
                }
                var num_impl_funcs: u64 = impl_funcs.len();
                for (var i: u64 = 0; i < num_impl_funcs; i++) {
                    parser_vec_astfunc_push(funcs, impl_funcs.get(i));
                }
                break;
            case TOKEN_VAR:
                parse_consume(p, TOKEN_VAR);
                var tok: *Token = parse_peek(p);

                parse_consume(p, TOKEN_IDENTIFIER);
                var gtype: *TypeInfo = 0;
                if (parse_match(p, TOKEN_COLON)) {
                    // Allow typed globals; preserve type info for codegen.
                    gtype = parse_type_ex(p);
                } else {
                    gtype = parse_typeinfo_new(TYPE_U64, 0);
                }

                var init_kind: u64 = GLOBAL_INIT_NONE;
                var init_value: u64 = 0;
                var init_name_ptr: u64 = 0;
                var init_name_len: u64 = 0;
                var init_expr: *AstNode = 0;

                if (parse_match(p, TOKEN_EQ)) {
                    init_expr = parse_expr(p);
                    if (init_expr == 0) {
                        emit_stderr("[ERROR] Global init expression missing\n");
                        parse_panic_here(p, "Parse error");
                    }
                    var init_expr_kind: u64 = ast_kind(init_expr);
                    if (init_expr_kind == AST_LITERAL) {
                        var lit: *AstLiteral = (*AstLiteral)init_expr;
                        init_kind = GLOBAL_INIT_VALUE;
                        init_value = lit.value;
                    } else if (init_expr_kind == AST_IDENT) {
                        var id: *AstIdent = (*AstIdent)init_expr;
                        init_name_ptr = id.name_ptr;
                        init_name_len = id.name_len;
                        // Try to resolve const immediately if available
                        var resolved_value: u64 = 0;
                        var found_const: u64 = 0;
                        if (consts != 0) {
                            var cn: u64 = consts.len();
                            for (var ci: u64 = 0; ci < cn; ci++) {
                                var cdecl: *AstConstDecl = consts.get(ci);
                                if (str_eq(cdecl.name_ptr, cdecl.name_len, init_name_ptr, init_name_len)) {
                                    resolved_value = cdecl.value;
                                    found_const = 1;
                                    break;
                                }
                            }
                        }
                        if (found_const != 0) {
                            init_kind = GLOBAL_INIT_VALUE;
                            init_value = resolved_value;
                            init_name_ptr = 0;
                            init_name_len = 0;
                        } else {
                            init_kind = GLOBAL_INIT_CONST;
                        }
                    } else if (init_expr_kind == AST_STRUCT_LITERAL) {
                        if (gtype.type_kind != TYPE_STRUCT || gtype.ptr_depth != 0) {
                            emit_stderr("[ERROR] Global struct literal requires struct type\n");
                            parse_panic_here(p, "Parse error");
                        }
                        init_kind = GLOBAL_INIT_EXPR;
                    } else if (init_expr_kind == AST_CALL || init_expr_kind == AST_METHOD_CALL || init_expr_kind == AST_CALL_PTR || init_expr_kind == AST_GENERIC_CALL || init_expr_kind == AST_NEW || init_expr_kind == AST_STACK_CTOR) {
                        init_kind = GLOBAL_INIT_RUNTIME;
                    } else {
                        emit_stderr("[ERROR] Unsupported global init expression\n");
                        parse_panic_here(p, "Parse error");
                    }
                }

                parse_consume(p, TOKEN_SEMICOLON);
                var ginfo: *GlobalInfo = new GlobalInfo();
                ginfo.name_ptr = tok.ptr;
                ginfo.name_len = tok.len;
                ginfo.typeinfo_ptr = gtype;
                ginfo.init_kind = init_kind;
                ginfo.init_value = init_value;
                ginfo.init_name_ptr = init_name_ptr;
                ginfo.init_name_len = init_name_len;
                ginfo.init_expr = (u64)init_expr;
                globals.push(ginfo);
                break;
            case TOKEN_IMPORT:
                imports.push(parse_import_decl(p));
                break;
            default:
                var err_tok: *Token = parse_peek(p);
                var err_ptr: u64 = err_tok.ptr;
                var err_len: u64 = err_tok.len;
                emit_stderr("[ERROR] Expected function, const, or import. Got token kind=");
                print_u64(parse_peek_kind(p));
                emit_stderr(" text=");
                emit_stderr_len(err_ptr, err_len);
                emit_stderr("\n");
                parse_adv(p);
                break;
        }
    }
    
    var prog: *AstProgram = ast_program(funcs, consts, imports);
    prog.globals_vec = globals;
    prog.structs_vec = structs;
    return prog;
}

// ============================================
// Program Parsing (Signature Pass)
// ============================================

func parse_program_pass1(p: *Parser) -> *AstProgram {
    push_trace("parse_program_pass1", "parser/decl.b", __LINE__);
    defer pop_trace();

    var funcs: *Vec<*AstFunc> = new Vec<*AstFunc>(16);
    var consts: *Vec<*AstConstDecl> = new Vec<*AstConstDecl>(1);
    var imports: *Vec<*AstImport> = new Vec<*AstImport>(1);

    while (parse_peek_kind(p) != TOKEN_EOF) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_FUNC:
                var sig_ptr: *AstFunc = parse_func_decl_signature(p);
                if (sig_ptr != 0 && compiler_is_generic_template(sig_ptr) == 0) {
                    parser_vec_astfunc_push(funcs, sig_ptr);
                }
                break;
            case TOKEN_IMPL:
                var impl_funcs: *Vec<*AstFunc> = 0;
                if (parse_is_impl_trait_block(p) != 0) {
                    impl_funcs = parse_impl_trait_block_signature(p);
                } else {
                    impl_funcs = parse_impl_block_signature(p);
                }
                var num_impl_funcs: u64 = impl_funcs.len();
                for (var i: u64 = 0; i < num_impl_funcs; i++) {
                    var impl_fn_ptr: *AstFunc = impl_funcs.get(i);
                    if (impl_fn_ptr != 0) {
                        parser_vec_astfunc_push(funcs, impl_fn_ptr);
                    }
                }
                break;
            case TOKEN_TRAIT:
                parse_trait_def(p);
                break;
            case TOKEN_STRUCT:
            case TOKEN_PACKED:
                parse_struct_def(p);
                break;
            case TOKEN_ENUM:
                parse_consume(p, TOKEN_ENUM);
                parse_consume(p, TOKEN_IDENTIFIER);
                parse_skip_block(p);
                break;
            case TOKEN_CONST:
                // const  ;  
                parse_consume(p, TOKEN_CONST);
                parse_consume(p, TOKEN_IDENTIFIER);
                if (parse_match(p, TOKEN_EQ)) {
                    while (parse_peek_kind(p) != TOKEN_SEMICOLON && parse_peek_kind(p) != TOKEN_EOF) {
                        parse_adv(p);
                    }
                }
                parse_consume(p, TOKEN_SEMICOLON);
                break;
            case TOKEN_IMPORT:
                imports.push(parse_import_decl(p));
                break;
            case TOKEN_VAR:
                //  var  ;  
                parse_consume(p, TOKEN_VAR);
                parse_consume(p, TOKEN_IDENTIFIER);
                if (parse_match(p, TOKEN_COLON)) {
                    parse_type_ex(p);
                }
                if (parse_match(p, TOKEN_EQ)) {
                    while (parse_peek_kind(p) != TOKEN_SEMICOLON && parse_peek_kind(p) != TOKEN_EOF) {
                        parse_adv(p);
                    }
                }
                parse_consume(p, TOKEN_SEMICOLON);
                break;
            default:
                var err_tok2: *Token = parse_peek(p);
                var err_ptr2: u64 = err_tok2.ptr;
                var err_len2: u64 = err_tok2.len;
                emit_stderr("[ERROR] Expected function, const, or import. Got token kind=");
                print_u64(parse_peek_kind(p));
                emit_stderr(" text=");
                emit_stderr_len(err_ptr2, err_len2);
                emit_stderr("\n");
                parse_adv(p);
                break;
        }
    }

    var prog: *AstProgram = ast_program(funcs, consts, imports);
    return prog;
}

// ============================================
// Program Parsing (Imports Only)
// ============================================

func parse_program_imports_only(p: *Parser) -> *Vec<*AstImport> {
    push_trace("parse_program_imports_only", "parser/decl.b", __LINE__);
    defer pop_trace();

    var imports: *Vec<*AstImport> = new Vec<*AstImport>(8);
    while (parse_peek_kind(p) != TOKEN_EOF) {
        if (parse_peek_kind(p) == TOKEN_IMPORT) {
            imports.push(parse_import_decl(p));
        } else {
            parse_adv(p);
        }
    }

    return imports;
}
