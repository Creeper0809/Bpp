// parse_util.b - Parser utility functions
//
// Core parser operations:
// - Parser state management (new, peek, advance, prev)
// - Token matching and consuming
// - Error reporting

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import lexer;
import compiler;

var g_pending_gt_active;
var g_pending_gt_tok: *Token;
var g_parse_peek_cache_valid: u64;
var g_parse_peek_cache_parser: *Parser;
var g_parse_peek_cache_pos: u64;
var g_parse_peek_cache_tok: *Token;

// ============================================
// Error Reporting Helpers
// ============================================

func token_kind_name(kind: u64) -> u64 {
    switch (kind) {
        case TOKEN_EOF: return "EOF";
        case TOKEN_NUMBER: return "number";
        case TOKEN_FLOAT: return "float";
        case TOKEN_IDENTIFIER: return "identifier";
        case TOKEN_STRING: return "string";
        case TOKEN_LPAREN: return "'('";
        case TOKEN_RPAREN: return "')'";
        case TOKEN_LBRACE: return "'{'";
        case TOKEN_RBRACE: return "'}'";
        case TOKEN_LBRACKET: return "'['";
        case TOKEN_RBRACKET: return "']'";
        case TOKEN_SEMICOLON: return "';'";
        case TOKEN_COLON: return "':'";
        case TOKEN_COMMA: return "','";
        case TOKEN_DOT: return "'.'";
        case TOKEN_DOT_Q: return "'.?'";
        case TOKEN_ARROW: return "'.'";
        case TOKEN_QUESTION: return "'?'";
        case TOKEN_PLUS: return "'+'";
        case TOKEN_MINUS: return "'-'";
        case TOKEN_STAR: return "'*'";
        case TOKEN_SLASH: return "'/'";
        case TOKEN_PERCENT: return "'%'";
        case TOKEN_EQ: return "'='";
        case TOKEN_EQEQ: return "'=='";
        case TOKEN_BANGEQ: return "'!='";
        case TOKEN_LT: return "'<'";
        case TOKEN_LE: return "'<='";
        case TOKEN_GT: return "'>'";
        case TOKEN_GE: return "'>='";
        case TOKEN_AMPERSAND: return "'&'";
        case TOKEN_PIPE: return "'|'";
        case TOKEN_CARET: return "'^'";
        case TOKEN_ANDAND: return "'&&'";
        case TOKEN_OROR: return "'||'";
        case TOKEN_BANG: return "'!'";
        case TOKEN_PLUSPLUS: return "'++'";
        case TOKEN_MINUSMINUS: return "'--'";
        case TOKEN_PLUS_EQ: return "'+='";
        case TOKEN_MINUS_EQ: return "'-='";
        case TOKEN_STAR_EQ: return "'*='";
        case TOKEN_SLASH_EQ: return "'/='";
        case TOKEN_PERCENT_EQ: return "'%='";
        case TOKEN_TILDE: return "'~'";
        case TOKEN_VAR: return "'var'";
        case TOKEN_FUNC: return "'func'";
        case TOKEN_RETURN: return "'return'";
        case TOKEN_IF: return "'if'";
        case TOKEN_ELSE: return "'else'";
        case TOKEN_WHILE: return "'while'";
        case TOKEN_FOR: return "'for'";
        case TOKEN_BREAK: return "'break'";
        case TOKEN_CONTINUE: return "'continue'";
        case TOKEN_ALIAS: return "'alias'";
        case TOKEN_DEFER: return "'defer'";
        case TOKEN_NEW: return "'new'";
        case TOKEN_DELETE: return "'delete'";
        case TOKEN_ABST: return "'abst'";
        case TOKEN_ASSERT: return "'assert'";
        case TOKEN_TODO: return "'todo'";
        case TOKEN_UNREACHABLE: return "'unreachable'";
        case TOKEN_F64: return "'f64'";
        case TOKEN_CONSTRUCTOR: return "'constructor'";
        case TOKEN_DESTRUCTOR: return "'destructor'";
        case TOKEN_IMPORT: return "'import'";
        case TOKEN_STRUCT: return "'struct'";
        case TOKEN_ENUM: return "'enum'";
        case TOKEN_CONST: return "'const'";
        case TOKEN_TRUE: return "'true'";
        case TOKEN_FALSE: return "'false'";
        case TOKEN_SIZEOF: return "'sizeof'";
        case TOKEN_CHAR: return "'char'";
    }
    return "unknown token";
}

func token_kind_name_len(kind: u64) -> u64 {
    return str_len(token_kind_name(kind));
}

func get_source_ptr() -> u64 {
    return compiler_get_source_ptr();
}

func get_source_len() -> u64 {
    return compiler_get_source_len();
}

func parse_panic_at_tok(tok: *Token, msg: u64) -> u64 {
    begin_error_capture();
    set_error_context(msg, str_len(msg));

    emit_stderr("[ERROR] ");
    emit_stderr_len(msg, str_len(msg));
    if (tok != 0) {
        emit_stderr(" at ");
        emit_u64_stderr(tok.line);
        emit_stderr(":");
        emit_u64_stderr(tok.col);
        if (tok.kind != TOKEN_EOF && tok.ptr != 0 && tok.len != 0) {
            emit_stderr(" token=");
            emit_stderr_len(tok.ptr, tok.len);
        }
    }
    emit_stderr_nl();
    panic(msg);
    return 0;
}

func parse_panic_here(p: *Parser, msg: u64) -> u64 {
    var tok: *Token = parse_peek(p);
    if (tok == 0) { tok = parse_prev(p); }
    return parse_panic_at_tok(tok, msg);
}

func report_parse_error(expected_kind: u64, actual_kind: u64, tok: *Token) -> u64 {
    begin_error_capture();
    set_error_context("Token mismatch", 14);
    
    emit_stderr("\n[ERROR] Parse error at line ");
    if (tok != 0) {
        emit_u64_stderr(tok.line);
        emit_stderr(", column ");
        emit_u64_stderr(tok.col);
    }
    emit_stderr_nl();
    
    emit_stderr("  Expected: ");
    emit_stderr_len(token_kind_name(expected_kind), token_kind_name_len(expected_kind));
    emit_stderr_nl();
    emit_stderr("  Expected kind id: ");
    emit_u64_stderr(expected_kind);
    emit_stderr_nl();
    
    emit_stderr("  Got:      ");
    emit_stderr_len(token_kind_name(actual_kind), token_kind_name_len(actual_kind));
    
    if (tok != 0) {
        if (actual_kind != TOKEN_EOF) {
            emit_stderr(" ");
            emit_stderr_len(tok.ptr, tok.len);
        }
    }
    emit_stderr_nl();
    emit_stderr("  Got kind id: ");
    emit_u64_stderr(actual_kind);
    emit_stderr_nl();
    parse_panic_at_tok(tok, "Parse error");
    return 0;
}

func report_integer_overflow_error(tok: *Token) -> u64 {
    set_error_context("Integer overflow", 16);
    emit_stderr("[ERROR] Integer literal overflow at ");
    emit_u64_stderr(tok.line);
    emit_stderr(":");
    emit_u64_stderr(tok.col);
    emit_stderr(" literal=");
    emit_stderr_len(tok.ptr, tok.len);
    emit_nl();
    parse_panic_at_tok(tok, "Parse error");
    return 0;
}

// Parser structure: [tokens_vec, cur]

func parse_new(tokens: *Vec<*Token>) -> *Parser {
    var p: *Parser = new Parser();
    p.tokens_vec = tokens;
    p.cur = 0;
    g_pending_gt_active = 0;
    g_pending_gt_tok = 0;
    g_parse_peek_cache_valid = 0;
    g_parse_peek_cache_parser = 0;
    g_parse_peek_cache_pos = 0;
    g_parse_peek_cache_tok = 0;
    return p;
}

func parse_peek(p: *Parser) -> *Token {
    var parser: *Parser = p;
    if (g_pending_gt_active != 0) { return g_pending_gt_tok; }
    if (g_parse_peek_cache_valid != 0 &&
        g_parse_peek_cache_parser == parser &&
        g_parse_peek_cache_pos == parser.cur) {
        return g_parse_peek_cache_tok;
    }
    if (parser.cur >= parser.tokens_vec.len()) { return 0; }
    var tok: *Token = parser.tokens_vec.get(parser.cur);
    g_parse_peek_cache_valid = 1;
    g_parse_peek_cache_parser = parser;
    g_parse_peek_cache_pos = parser.cur;
    g_parse_peek_cache_tok = tok;
    return tok;
}

func parse_peek_kind(p: *Parser) -> u64 {
    var tok: *Token = parse_peek(p);
    if (tok == 0) { return TOKEN_EOF; }
    return tok.kind;
}

func parse_adv(p: *Parser) -> u64 {
    if (g_pending_gt_active != 0) {
        g_pending_gt_active = 0;
        g_pending_gt_tok = 0;
        g_parse_peek_cache_valid = 0;
        return 0;
    }
    var parser: *Parser = p;
    parser.cur = parser.cur + 1;
    g_parse_peek_cache_valid = 0;
}

func parser_pos(p: *Parser) -> u64 {
    var parser: *Parser = p;
    return parser.cur;
}

func parser_set_pos(p: *Parser, pos: u64) {
    var parser: *Parser = p;
    parser.cur = pos;
    g_pending_gt_active = 0;
    g_pending_gt_tok = 0;
    g_parse_peek_cache_valid = 0;
}

func parse_prev(p: *Parser) -> *Token {
    var parser: *Parser = p;
    if (parser.cur == 0) { return 0; }
    return parser.tokens_vec.get(parser.cur - 1);
}

func parse_match(p: *Parser, kind: u64) -> u64 {
    if (parse_peek_kind(p) == kind) {
        parse_adv(p);
        return true;
    }
    return false;
}

func parse_consume(p: *Parser, kind: u64) -> u64 {
    if (!parse_match(p, kind)) {
        var tok: *Token = parse_peek(p);
        var got: u64 = parse_peek_kind(p);
        report_parse_error(kind, got, tok);
    }
}

func parse_consume_generic_gt(p: *Parser) -> u64 {
    var k: u64 = parse_peek_kind(p);
    if (k == TOKEN_GT) {
        parse_adv(p);
        return 0;
    }
    if (k == TOKEN_RSHIFT) {
        var t: *Token = parse_peek(p);
        var pending: *Token = tok_new(TOKEN_GT, t.ptr + 1, 1, t.line, t.col + 1);
        g_pending_gt_active = 1;
        g_pending_gt_tok = pending;
        var parser: *Parser = p;
        parser.cur = parser.cur + 1;
        g_parse_peek_cache_valid = 0;
        return 0;
    }
    var tok2: *Token = parse_peek(p);
    report_parse_error(TOKEN_GT, k, tok2);
}

// ============================================
// Number parsing helper
// ============================================

func parse_num_val(tok: *Token) -> u64 {
    var t: *Token = tok;
    var ptr: u64 = t.ptr;
    var len: u64 = t.len;
    var val: u64 = 0;
    var ptr_u8: *u8 = (*u8)ptr;

    // u64 max = 18446744073709551615
    var max_u64: u64 = 0 - 1;
    var max_div10: u64 = max_u64 / 10;
    var max_mod10: u64 = max_u64 % 10;

    for (var i: u64 = 0; i < len; i++) {
        var c: u64 = ptr_u8[i];
        var digit: u64 = c - 48;

        if (val > max_div10) {
            report_integer_overflow_error(t);
        }
        if (val == max_div10) {
            if (digit > max_mod10) {
                report_integer_overflow_error(t);
            }
        }

        val = val * 10 + digit;
    }
    return val;
}
