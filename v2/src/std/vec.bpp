// vec.b - Dynamic array implementation (pointer arithmetic for bootstrap)

import std.io;

// Vec<T> structure: [data_ptr, length, capacity] (24 bytes)
// Storage is u64-based for bootstrap; T is treated as a u64-sized value.
struct Vec<T> {
    data_ptr: u64;
    length: u64;
    capacity: u64;
}

impl Vec {
    func new<T>(cap: u64) -> u64 {
        var vec: *Vec<T> = (*Vec<T>)heap_alloc(sizeof(Vec));
        var buf: u64 = heap_alloc(cap * sizeof(u64));
        vec->data_ptr = buf;
        vec->length = 0;
        vec->capacity = cap;
        return (u64)vec;
    }

    func len<T>(self: *Vec<T>) -> u64 {
        return self->length;
    }

    func cap<T>(self: *Vec<T>) -> u64 {
        return self->capacity;
    }

    func push<T>(self: *Vec<T>, item: T) -> u64 {
        var len: u64 = self->length;
        var cap: u64 = self->capacity;

        // Grow if needed
        if (len >= cap) {
            var new_cap: u64 = cap * 2;
            if (new_cap < 4) { new_cap = 4; }
            var new_buf: u64 = heap_alloc(new_cap * sizeof(u64));
            var old_buf: u64 = self->data_ptr;
            // Copy old data
            for (var i: u64 = 0; i < len; i++) {
                *(new_buf + i * sizeof(u64)) = *(old_buf + i * sizeof(u64));
            }
            self->data_ptr = new_buf;
            self->capacity = new_cap;
        }

        var buf: u64 = self->data_ptr;
        *(buf + len * sizeof(u64)) = item;
        self->length = len + 1;
        return 0;
    }

    func get<T>(self: *Vec<T>, i: u64) -> T {
        var buf: u64 = self->data_ptr;
        return *(buf + i * sizeof(u64));
    }

    func set<T>(self: *Vec<T>, i: u64, val: T) -> u64 {
        var buf: u64 = self->data_ptr;
        *(buf + i * sizeof(u64)) = val;
        return 0;
    }

    func pop<T>(self: *Vec<T>) -> T {
        var len: u64 = self->length;
        if (len == 0) {
            return 0;
        }
        self->length = len - 1;
        var buf: u64 = self->data_ptr;
        return *(buf + (len - 1) * sizeof(u64));
    }

    static func force_instantiations_u64() -> u64 {
        var dummy_vec: *Vec<u64> = 0;
        dummy_vec->len();
        dummy_vec->cap();
        dummy_vec->push(0);
        dummy_vec->get(0);
        dummy_vec->set(0, 0);
        dummy_vec->pop();
        return 0;
    }
}

// Compatibility wrappers (u64 Vec)
func vec_new(cap) { return Vec.new<u64>(cap); }
func vec_len(v) { return ((*Vec<u64>)v)->len(); }
func vec_cap(v) { return ((*Vec<u64>)v)->cap(); }
func vec_push(v, item) { return ((*Vec<u64>)v)->push(item); }
func vec_get(v, i) { return ((*Vec<u64>)v)->get(i); }
func vec_set(v, i, val) { return ((*Vec<u64>)v)->set(i, val); }
func vec_pop(v) { return ((*Vec<u64>)v)->pop(); }

