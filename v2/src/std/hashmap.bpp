// hashmap.b - Hash map implementation for v3.8

import std.io;
import std.str;

// HashMap<K, V> structure: [entries_ptr, capacity, count]
// Entry: [key_ptr, key_len, value, hash, used]

struct HashMap<K, V> {
    entries_ptr: u64;
    capacity: u64;
    count: u64;
}

struct HashEntry {
    key_ptr: u64;
    key_len: u64;
    value: u64;
    hash: u64;
    used: u64;
}

impl HashMap {
    func hash(key_ptr: u64, key_len: u64) -> u64 {
        var hash: u64 = 0;
        for (var i: u64 = 0; i < key_len; i++) {
            hash = hash ^ *(*u8)(key_ptr + i);
            hash = hash * 31;
        }
        return hash;
    }

    func new<K, V>(capacity: u64) -> u64 {
        var cap: u64 = 16;
        for (; cap < capacity; cap = cap * 2) {
        }
        var map: *HashMap<K, V> = (*HashMap<K, V>)heap_alloc(sizeof(HashMap));
        var bytes: u64 = cap * sizeof(HashEntry);
        var entries: u64 = heap_alloc(cap * sizeof(HashEntry));

        for (var i: u64 = 0; i < bytes; i++) {
            *(*u8)(entries + i) = 0;
        }

        map->entries_ptr = entries;
        map->capacity = cap;
        map->count = 0;
        return (u64)map;
    }

    func entry_ptr<K, V>(entries: u64, idx: u64) -> *HashEntry {
        return (*HashEntry)(entries + idx * sizeof(HashEntry));
    }

    func put_internal<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                entry->key_ptr = key_ptr;
                entry->key_len = key_len;
                entry->value = value;
                entry->hash = hash;
                entry->used = 1;
                self->count = self->count + 1;
                return 0;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func grow<K, V>(self: *HashMap<K, V>) -> u64 {
        var old_entries: u64 = self->entries_ptr;
        var old_cap: u64 = self->capacity;

        var new_cap: u64 = old_cap * 2;
        var new_bytes: u64 = new_cap * sizeof(HashEntry);
        var new_entries: u64 = heap_alloc(new_cap * sizeof(HashEntry));

        for (var i: u64 = 0; i < new_bytes; i++) {
            *(*u8)(new_entries + i) = 0;
        }

        self->entries_ptr = new_entries;
        self->capacity = new_cap;
        self->count = 0;

        for (var i: u64 = 0; i < old_cap; i++) {
            var entry: *HashEntry = HashMap.entry_ptr<K, V>(old_entries, i);
            var used: u64 = entry->used;
            if (used != 0) {
                var kp: u64 = entry->key_ptr;
                var kl: u64 = entry->key_len;
                var val: V = entry->value;
                self->put_internal(kp, kl, val);
            }
        }
        return 0;
    }

    func put<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var count: u64 = self->count;

        if (count * 10 >= cap * 7) {
            self->grow();
            entries = self->entries_ptr;
            cap = self->capacity;
        }

        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                entry->key_ptr = key_ptr;
                entry->key_len = key_len;
                entry->value = value;
                entry->hash = hash;
                entry->used = 1;
                self->count = self->count + 1;
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                entry->value = value;
                return 0;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func get<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> V {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                return entry->value;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func has<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> u64 {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                return 1;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    static func force_instantiations_u64() -> u64 {
        var dummy_map: *HashMap<u64, u64> = 0;
        var dummy_key_ptr: u64 = 0;
        var dummy_key_len: u64 = 0;
        dummy_map->put(dummy_key_ptr, dummy_key_len, 0);
        dummy_map->get(dummy_key_ptr, dummy_key_len);
        dummy_map->has(dummy_key_ptr, dummy_key_len);
        return 0;
    }
}

// Compatibility wrappers (u64 HashMap)
func hashmap_new(capacity) { return HashMap.new<u64, u64>(capacity); }
func hashmap_put(map, key_ptr, key_len, value) { return ((*HashMap<u64, u64>)map)->put(key_ptr, key_len, value); }
func hashmap_get(map, key_ptr, key_len) { return ((*HashMap<u64, u64>)map)->get(key_ptr, key_len); }
func hashmap_has(map, key_ptr, key_len) { return ((*HashMap<u64, u64>)map)->has(key_ptr, key_len); }

