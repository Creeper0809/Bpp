// Covers: stack constructor sugar in args/returns/nested calls (old 38, 41)
// Expect exit code: 0

struct Pair {
    public a: u64;
    public b: u64;
}

struct Triple {
    public a: u64;
    public b: u64;
    public c: u64;
}

struct Vec2 {
    public x: u64;
    public y: u64;
}

struct Box2 {
    public min: Vec2;
    public max: Vec2;
    public area: u64;
}

var g_last_area: u64 = 0;

impl Pair {
    public constructor(a: u64, b: u64) {
        self.a = a;
        self.b = b;
    }
}

impl Triple {
    public constructor(a: u64, b: u64, c: u64) {
        self.a = a;
        self.b = b;
        self.c = c;
    }
}

impl Vec2 {
    public constructor(x: u64, y: u64) {
        self.x = x;
        self.y = y;
    }

    public func sum(self: *Vec2) -> u64 {
        return self.x + self.y;
    }
}

impl Box2 {
    public constructor(a: Vec2, b: Vec2) {
        self.min = a;
        self.max = b;
        self.area = (b.x - a.x) * (b.y - a.y);
    }

    public func calc(self: *Box2) -> u64 {
        return self.area + self.min.sum() + self.max.sum();
    }
}

func make_pair(base: u64) -> Pair {
    return Pair(base, base + 1);
}

func make_triple(base: u64) -> Triple {
    return Triple(base, base + 1, base + 2);
}

func sum_pair(p: Pair) -> u64 {
    return p.a + p.b;
}

func sum_triple(t: Triple) -> u64 {
    return t.a + t.b + t.c;
}

func mix(p: Pair, t: Triple) -> u64 {
    return p.a + p.b + t.a + t.b + t.c;
}

func make_box(offset: u64) -> Box2 {
    var a: Vec2 = Vec2(1 + offset, 2 + offset);
    var b: Vec2 = Vec2(6 + offset, 8 + offset);
    var box: Box2 = Box2(a, b);
    g_last_area = box.area;
    return box;
}

func main() -> u64 {
    // Old 38 path
    var p0: Pair = Pair(10, 20);
    var t0: Triple = Triple(1, 2, 3);
    var p1: Pair = make_pair(100);
    var t1: Triple = make_triple(200);
    var acc0: u64 = 0;

    acc0 = acc0 + sum_pair(Pair(3, 4));
    acc0 = acc0 + sum_triple(Triple(5, 6, 7));
    acc0 = acc0 + mix(Pair(1, 2), Triple(3, 4, 5));

    p0 = Pair(11, 22);
    t0 = Triple(7, 8, 9);

    var p2: Pair = make_pair(7);
    var t2: Triple = make_triple(9);
    var m2: u64 = mix(p2, t2);

    if (p0.a != 11 || p0.b != 22) { return 10; }
    if (t0.a != 7 || t0.b != 8 || t0.c != 9) { return 11; }
    if (p1.a != 100 || p1.b != 101) { return 12; }
    if (t1.a != 200 || t1.b != 201 || t1.c != 202) { return 13; }
    if (acc0 != 40) { return 20; }
    if (m2 != 45) { return 21; }

    // Old 41 path
    var b0: Box2 = make_box(0);
    var v1: Vec2 = Vec2(3, 4);
    var v2: Vec2 = Vec2(9, 12);
    var b1: Box2 = Box2(v1, v2);
    var acc1: u64 = 0;

    if (v1.x != 3 || v1.y != 4) { return 101; }
    if (v2.x != 9 || v2.y != 12) { return 102; }
    if (b1.min.x != 3 || b1.min.y != 4) { return 103; }
    if (b1.max.x != 9 || b1.max.y != 12) { return 104; }
    if (b1.area != 48) { return 105; }
    if (g_last_area != 30) { return 106; }

    for (var i: u64 = 0; i < 3; i = i + 1) {
        var tmp: Box2 = make_box(i);
        acc1 = acc1 + tmp.calc();
    }

    var sum0: u64 = b0.calc();
    var sum1: u64 = b1.calc();

    if (b0.min.x != 1 || b0.min.y != 2) { return 120; }
    if (b0.max.x != 6 || b0.max.y != 8) { return 121; }
    if (b0.area != 30) { return 122; }
    if (sum0 != 47) { return 123; }
    if (sum1 != 76) { return 124; }
    if (acc1 != 153) { return 125; }

    return 0;
}
