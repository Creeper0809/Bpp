# Type System

이 페이지는 Bpp v11 타입 시스템의 지원 범위와 제약을 정리합니다.

## Why It Exists

- 코드 생성기와 ABI 정합성은 타입 정보에 의존합니다.
- 타입 규칙을 명확히 해야 "컴파일은 되지만 런타임이 깨지는" 문제를 줄일 수 있습니다.

## How to Use

타입 설계는 "저장 방식"과 "호출 경계"를 먼저 고정한 뒤, 그에 맞춰 선택하는 것이 안전합니다.

1. 값 타입으로 충분한지 판단 (`u64`, `struct`)
2. 공유/변경이 필요한지 판단 (`*T`)
3. 길이 정보가 필요한지 판단 (`[]T`)
4. 컴파일 타임 크기 보장이 필요한지 판단 (`[N]T`)

### Primitive Types

```bpp
var a: u64 = 1;
var b: i32 = (i32)10;
var c: f64 = 3.14;
var ok: bool = true;
```

지원 기본형:

- `u8`, `u16`, `u32`, `u64`
- `i8`, `i16`, `i32`, `i64`
- `f64`
- `bool`
- `char` (문자 리터럴 문맥)

사용 기준:

- 계산/카운터: `u64`
- 음수/차분이 필요한 값: `i64` 또는 `i32`
- 메모리/프로토콜 단위 값: `u8/u16/u32`
- 실수 연산: `f64`
- 조건값: `bool`

### Pointer Types

```bpp
var p: *u64;
var pp: **u8;
```

- 주소 취득: `&x`
- 역참조: `*p`

권장 패턴:

```bpp
var x: u64 = 10;
var p: *u64 = &x;
*p = *p + 1;
```

포인터는 "소유권/수명"을 런타임이 추적하지 않으므로, null/해제 후 접근을 직접 방지해야 합니다.

### Arrays and Slices

```bpp
var arr: [4]u64;
var s: []u64;
var sv: []u8 = slice(ptr, len);
```

- 고정 배열: `[N]T`
- 슬라이스: `[]T`

사용 판단:

- 크기 고정/스택 로컬: 배열
- 범위 전달/뷰: 슬라이스

예시:

```bpp
var arr: [8]u64;
var view: []u64 = slice(&arr[0], 8);
```

### Tagged Pointer

```bpp
var t: *tagged u64;
var t2: *tagged(MyLayout) u64;
```

사용 목적:

- 포인터 하위 비트를 태그로 재사용하는 저수준 패턴 표현
- 런타임에서 태그 마스킹 규칙을 정확히 유지해야 함

## Constraints (v11)

- 타입 조합에 따라 아직 제약이 있습니다.
  - tagged + 특정 복합 타입
  - 구조체/배열/슬라이스의 일부 중첩 형태
- 함수 파라미터에서 배열이 포인터로 다뤄지는 경로가 존재합니다.
- nested array 관련 일부 문법은 허용되지만 길이 표현식 형태에 제한이 있을 수 있습니다.

### Invalid Examples

```bpp
// 잘못된 예: 타입 경계가 불명확한 과도한 cast 체인
var x: u64 = (u64)(i64)(u64)ptr;
```

```bpp
// 잘못된 예: 길이 없는 배열 선언
var bad: [] []u64;
```

## Cautions

- 타입 캐스팅이 가능하다고 안전한 것은 아닙니다.
- 구조체/트레잇 관련 타입은 이름 해석(module prefix/mangling)의 영향을 받습니다.
- 포인터 연산은 타입검사가 통과해도 런타임 안전을 보장하지 않습니다.

## Best Practices

- API 경계에서는 `u64` 만능 타입 대신 구체 타입을 유지합니다.
- 포인터-정수 캐스팅은 최소화하고, 필요한 경우 문서화합니다.
- 실패 케이스 테스트를 함께 추가해 타입 회귀를 방지합니다.
