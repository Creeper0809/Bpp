// parse_decl.b - Declaration parsing
//
// Parses top-level declarations:
// - const declarations
// - import declarations
// - function declarations (parameters, return types, body)
// - struct definitions
// - enum definitions
// - impl blocks
// - parse_program (entry point)

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import lexer;
import ast;
import compiler;
import parser.util;
import parser.type;
import parser.expr;
import parser.stmt;

// ============================================
// Const Declaration
// ============================================

func parse_const_decl(p: *Parser) -> *AstConstDecl {
    parse_consume(p, TOKEN_CONST);
    
    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok->ptr;
    var name_len: u64 = name_tok->len;

    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_EQ);
    
    var value: u64 = 0;
    var neg: u64 = 0;
    
    // Handle negative numbers
    if (parse_match(p, TOKEN_MINUS)) {
        neg = 1;
    }
    
    if (parse_peek_kind(p) == TOKEN_NUMBER) {
        var val_tok: *Token = parse_peek(p);
        value = parse_num_val(val_tok);
        parse_consume(p, TOKEN_NUMBER);
    } else if (parse_peek_kind(p) == TOKEN_CHAR) {
        var char_tok: *Token = parse_peek(p);
        var char_ptr: u64 = char_tok->ptr;
        var char_u8: *u8 = (*u8)char_ptr;
        value = char_u8[1];
        // Handle escape sequences
        if (char_u8[1] == 92) {
            var escape_char: u64 = char_u8[2];
            if (escape_char == 110) { value = 10; }       // \n
            else if (escape_char == 116) { value = 9; }   // \t
            else if (escape_char == 114) { value = 13; }  // \r
            else if (escape_char == 48) { value = 0; }    // \0
            else if (escape_char == 92) { value = 92; }   // \\
            else if (escape_char == 39) { value = 39; }   // \'
            else { value = escape_char; }
        }
        parse_consume(p, TOKEN_CHAR);
    } else {
        emit_stderr("[ERROR] Expected number or char in const\n", 42);
        panic("Parse error");
    }
    
    if (neg) { value = 0 - value; }
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    return ast_const_decl(name_ptr, name_len, value);
}

// ============================================
// Import Declaration
// ============================================

func parse_import_decl(p: *Parser) -> *AstImport {
    parse_consume(p, TOKEN_IMPORT);
    
    var first_tok: *Token = parse_peek(p);
    var first_kind: u64 = parse_peek_kind(p);
    if (first_kind != TOKEN_IDENTIFIER && first_kind != TOKEN_CHAR) {
        emit_stderr("[ERROR] Expected module identifier in import\n", 45);
        panic("Parse error");
    }
    parse_adv(p);

    // Selective import: import <symbol> [as <alias>] from <module>
    if (parse_peek_kind(p) == TOKEN_AS || parse_peek_kind(p) == TOKEN_FROM) {
        var symbol_ptr: u64 = first_tok->ptr;
        var symbol_len: u64 = first_tok->len;
        var alias_ptr: u64 = symbol_ptr;
        var alias_len: u64 = symbol_len;

        if (parse_match(p, TOKEN_AS)) {
            var alias_tok: *Token = parse_peek(p);
            if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
                emit_stderr("[ERROR] Expected alias identifier in import\n", 47);
                panic("Parse error");
            }
            alias_ptr = alias_tok->ptr;
            alias_len = alias_tok->len;
            parse_consume(p, TOKEN_IDENTIFIER);
        }

        parse_consume(p, TOKEN_FROM);

        var mod_tok: *Token = parse_peek(p);
        var mod_kind: u64 = parse_peek_kind(p);
        if (mod_kind != TOKEN_IDENTIFIER && mod_kind != TOKEN_CHAR) {
            emit_stderr("[ERROR] Expected module identifier in import\n", 45);
            panic("Parse error");
        }
        parse_adv(p);

        var path_ptr: u64 = mod_tok->ptr;
        var path_len: u64 = mod_tok->len;

        while (parse_match(p, TOKEN_DOT)) {
            var next_tok: *Token = parse_peek(p);
            var next_kind: u64 = parse_peek_kind(p);
            if (next_kind != TOKEN_IDENTIFIER && next_kind != TOKEN_CHAR) {
                emit_stderr("[ERROR] Expected module identifier in import\n", 45);
                panic("Parse error");
            }
            parse_adv(p);

            var slash: u64 = heap_alloc(sizeof(u8));
            *(*u8)slash = 47;

            var joined_path: u64 = str_concat(path_ptr, path_len, slash, 1);
            path_ptr = str_concat(joined_path, path_len + 1, next_tok->ptr, next_tok->len);
            path_len = path_len + 1 + next_tok->len;
        }

        parse_consume(p, TOKEN_SEMICOLON);

        return ast_import(path_ptr, path_len, symbol_ptr, symbol_len, alias_ptr, alias_len);
    }

    // Import module: import <module>;
    var path_ptr: u64  = first_tok->ptr;
    var path_len: u64 = first_tok->len;
    
    while (parse_match(p, TOKEN_DOT)) {
        var next_tok: *Token = parse_peek(p);
        var next_kind: u64 = parse_peek_kind(p);
        if (next_kind != TOKEN_IDENTIFIER && next_kind != TOKEN_CHAR) {
            emit_stderr("[ERROR] Expected module identifier in import\n", 45);
            panic("Parse error");
        }
        parse_adv(p);
        
        var slash2: u64 = heap_alloc(sizeof(u8));
        *(*u8)slash2 = 47;
        
        var joined_path2: u64 = str_concat(path_ptr, path_len, slash2, 1);
        path_ptr = str_concat(joined_path2, path_len + 1, next_tok->ptr, next_tok->len);
        path_len = path_len + 1 + next_tok->len;
    }
    
    parse_consume(p, TOKEN_SEMICOLON);
    
    return ast_import(path_ptr, path_len, 0, 0, 0, 0);
}

// ============================================
// Function Parsing
// ============================================

// Skip a block without parsing its contents
func parse_skip_block(p: *Parser) -> u64 {
    parse_consume(p, TOKEN_LBRACE);
    var depth: u64 = 1;
    while (depth > 0) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_EOF:
                emit_stderr("[ERROR] Unexpected EOF while skipping block\n", 46);
                panic("Parse error");
                break;
            case TOKEN_LBRACE:
                depth = depth + 1;
                break;
            case TOKEN_RBRACE:
                depth = depth - 1;
                break;
            default:
                break;
        }
        parse_adv(p);
    }
    return 0;
}

func parse_is_generic_param_list(p: *Parser) -> u64 {
    if (parse_peek_kind(p) != TOKEN_LT) { return false; }
    var saved: u64 = parser_pos(p);
    parse_adv(p);
    var depth: u64 = 1;
    while (1) {
        var k: u64 = parse_peek_kind(p);
        if (k == TOKEN_EOF) {
            parser_set_pos(p, saved);
            return false;
        }
        if (k == TOKEN_LPAREN) {
            parser_set_pos(p, saved);
            return false;
        }
        if (k == TOKEN_LT) { depth = depth + 1; }
        if (k == TOKEN_GT) {
            depth = depth - 1;
            if (depth == 0) {
                var saved2: u64 = parser_pos(p);
                parse_adv(p);
                var next_kind: u64 = parse_peek_kind(p);
                parser_set_pos(p, saved2);
                parser_set_pos(p, saved);
                if (next_kind == TOKEN_LPAREN) { return true; }
                return false;
            }
        }
        if (k == TOKEN_RSHIFT) {
            if (depth < 2) {
                parser_set_pos(p, saved);
                return false;
            }
            depth = depth - 2;
            if (depth == 0) {
                var saved3: u64 = parser_pos(p);
                parse_adv(p);
                var next_kind2: u64 = parse_peek_kind(p);
                parser_set_pos(p, saved3);
                parser_set_pos(p, saved);
                if (next_kind2 == TOKEN_LPAREN) { return true; }
                return false;
            }
        }
        parse_adv(p);
    }
}

func parse_is_generic_param_list_any(p: *Parser) -> u64 {
    if (parse_peek_kind(p) != TOKEN_LT) { return false; }
    var saved: u64 = parser_pos(p);
    parse_adv(p);
    var depth: u64 = 1;
    while (1) {
        var k: u64 = parse_peek_kind(p);
        if (k == TOKEN_EOF) {
            parser_set_pos(p, saved);
            return false;
        }
        if (k == TOKEN_LT) { depth = depth + 1; }
        if (k == TOKEN_GT) {
            depth = depth - 1;
            if (depth == 0) {
                parser_set_pos(p, saved);
                return true;
            }
        }
        if (k == TOKEN_RSHIFT) {
            if (depth < 2) {
                parser_set_pos(p, saved);
                return false;
            }
            depth = depth - 2;
            if (depth == 0) {
                parser_set_pos(p, saved);
                return true;
            }
        }
        parse_adv(p);
    }
}

// Parse generic parameter list for structs: <T, U, const N: u64>
func parse_generic_params_any(p: *Parser) -> *Vec<*GenericParam> {
    push_trace("parse_generic_params_any", "parser/decl.b", __LINE__);
    var tok: *Token = parse_peek(p);
    if (tok == 0) { pop_trace(); return 0; }
    if (parse_peek_kind(p) != TOKEN_LT) { pop_trace(); return 0; }
    if (parse_is_generic_param_list_any(p) == 0) { pop_trace(); return 0; }
    parse_consume(p, TOKEN_LT);

    var params: *Vec<*GenericParam> = Vec.new<*GenericParam>(4);
    while (1) {
        var is_value: u64 = 0;
        if (parse_match(p, TOKEN_CONST)) { is_value = 1; }

        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected generic parameter name\n", 43);
            panic("Parse error");
        }

        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok->ptr;
        var name_len: u64 = name_tok->len;
        parse_consume(p, TOKEN_IDENTIFIER);

        var value_type_kind: u64 = 0;
        if (parse_match(p, TOKEN_COLON)) {
            value_type_kind = parse_base_type(p);
            if (value_type_kind == TYPE_STRUCT || value_type_kind == TYPE_VOID) {
                emit_stderr("[ERROR] Invalid value generic type\n", 40);
                panic("Parse error");
            }
            if (value_type_kind != TYPE_U64) {
                emit_stderr("[ERROR] Value generic type must be u64\n", 44);
                panic("Parse error");
            }
            is_value = 1;
        } else if (is_value == 1) {
            emit_stderr("[ERROR] const generic requires type annotation\n", 50);
            panic("Parse error");
        }

        var gp: *GenericParam = new GenericParam{};
        if (is_value == 1) { gp->kind = GENERIC_KIND_VALUE; }
        else { gp->kind = GENERIC_KIND_TYPE; }
        gp->name_ptr = name_ptr;
        gp->name_len = name_len;
        gp->value_type_kind = value_type_kind;
        params->push(gp);

        if (parse_match(p, TOKEN_COMMA)) { continue; }
        break;
    }

    parse_consume_generic_gt(p);
    pop_trace();
    return params;
}

// Parse generic parameter list: <T, U, const N: u64>
func parse_generic_params(p: *Parser) -> *Vec<*GenericParam> {
    var tok: *Token = parse_peek(p);
    if (tok == 0) { return 0; }
    if (parse_peek_kind(p) != TOKEN_LT) { return 0; }
    if (parse_is_generic_param_list(p) == 0) { return 0; }
    parse_consume(p, TOKEN_LT);

    var params: *Vec<*GenericParam> = Vec.new<*GenericParam>(4);
    while (1) {
        var is_value: u64 = 0;
        if (parse_match(p, TOKEN_CONST)) { is_value = 1; }

        if (parse_peek_kind(p) != TOKEN_IDENTIFIER) {
            emit_stderr("[ERROR] Expected generic parameter name\n", 43);
            panic("Parse error");
        }

        var name_tok: *Token = parse_peek(p);
        var name_ptr: u64 = name_tok->ptr;
        var name_len: u64 = name_tok->len;
        parse_consume(p, TOKEN_IDENTIFIER);

        var value_type_kind: u64 = 0;
        if (parse_match(p, TOKEN_COLON)) {
            value_type_kind = parse_base_type(p);
            if (value_type_kind == TYPE_STRUCT || value_type_kind == TYPE_VOID) {
                emit_stderr("[ERROR] Invalid value generic type\n", 40);
                panic("Parse error");
            }
            if (value_type_kind != TYPE_U64) {
                emit_stderr("[ERROR] Value generic type must be u64\n", 44);
                panic("Parse error");
            }
            is_value = 1;
        } else if (is_value == 1) {
            emit_stderr("[ERROR] const generic requires type annotation\n", 50);
            panic("Parse error");
        }

        var gp: *GenericParam = new GenericParam{};
        if (is_value == 1) { gp->kind = GENERIC_KIND_VALUE; }
        else { gp->kind = GENERIC_KIND_TYPE; }
        gp->name_ptr = name_ptr;
        gp->name_len = name_len;
        gp->value_type_kind = value_type_kind;
        params->push(gp);

        if (parse_match(p, TOKEN_COMMA)) { continue; }
        break;
    }

    parse_consume_generic_gt(p);
    return params;
}

func parse_param(p: *Parser) -> *Param {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }
    
    var type_kind: u64 = 0;
    var ptr_depth: u64 = 0;
    var is_tagged: u64 = 0;
    var struct_name_ptr: u64 = 0;
    var struct_name_len: u64 = 0;
    var tag_layout_ptr: u64 = 0;
    var tag_layout_len: u64 = 0;
    var elem_type_kind: u64 = 0;
    var elem_ptr_depth: u64 = 0;
    var array_len: u64 = 0;
    var array_len_is_param: u64 = 0;
    var array_len_param_ptr: u64 = 0;
    var array_len_param_len: u64 = 0;
    
    if (parse_match(p, TOKEN_COLON)) {
        var ty: *TypeInfo = parse_type_ex(p);
        type_kind = ty->type_kind;
        ptr_depth = ty->ptr_depth;
        is_tagged = ty->is_tagged;
        struct_name_ptr = ty->struct_name_ptr;
        struct_name_len = ty->struct_name_len;
        tag_layout_ptr = ty->tag_layout_ptr;
        tag_layout_len = ty->tag_layout_len;
        elem_type_kind = ty->elem_type_kind;
        elem_ptr_depth = ty->elem_ptr_depth;
        array_len = ty->array_len;
        array_len_is_param = ty->array_len_is_param;
        array_len_param_ptr = ty->array_len_param_ptr;
        array_len_param_len = ty->array_len_param_len;
        if (type_kind == TYPE_ARRAY) {
            // Array parameter decays to pointer to first element
            type_kind = elem_type_kind;
            ptr_depth = elem_ptr_depth + 1;
            is_tagged = 0;
            tag_layout_ptr = 0;
            tag_layout_len = 0;
            array_len_is_param = 0;
            array_len_param_ptr = 0;
            array_len_param_len = 0;
        }
    }
    
    var param: *Param = new Param{};
    param->name_ptr = name_tok->ptr;
    param->name_len = name_tok->len;
    param->type_kind = type_kind;
    param->ptr_depth = ptr_depth;
    param->is_tagged = is_tagged;
    param->struct_name_ptr = struct_name_ptr;
    param->struct_name_len = struct_name_len;
    param->tag_layout_ptr = tag_layout_ptr;
    param->tag_layout_len = tag_layout_len;
    param->elem_type_kind = elem_type_kind;
    param->elem_ptr_depth = elem_ptr_depth;
    param->array_len = array_len;
    param->array_len_is_param = array_len_is_param;
    param->array_len_param_ptr = array_len_param_ptr;
    param->array_len_param_len = array_len_param_len;
    return param;
}

func parse_func_decl(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl", "parser/decl.b", __LINE__);
    
    parse_consume(p, TOKEN_FUNC);
    
    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER && name_kind != TOKEN_NEW && name_kind != TOKEN_DELETE) {
        emit_stderr("[ERROR] Expected function name identifier\n", 45);
        panic("Parse error");
    }
    parse_adv(p);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }
    
    // Set parsing context for better error messages
    set_parsing_context(name_tok->ptr, name_tok->len, name_tok->line);
    
    parse_consume(p, TOKEN_LPAREN);
    
    var params: *Vec<*Param> = Vec.new<*Param>(8);
    
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params->push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params->push(parse_param(p));
        }
    }
    
    parse_consume(p, TOKEN_RPAREN);
    
    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;
    
    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty->type_kind;
        ret_ptr_depth = ty->ptr_depth;
        ret_is_tagged = ty->is_tagged;
        ret_struct_name_ptr = ty->struct_name_ptr;
        ret_struct_name_len = ty->struct_name_len;
        ret_tag_layout_ptr = ty->tag_layout_ptr;
        ret_tag_layout_len = ty->tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            // Array return decays to pointer to first element
            ret_type = ty->elem_type_kind;
            ret_ptr_depth = ty->elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty->struct_name_ptr;
            ret_struct_name_len = ty->struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }
    
    var body: *AstNode = parse_block(p);

    var func_node: *AstFunc = ast_func_ex(name_tok->ptr, name_tok->len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, body);

    if (generic_params != 0) {
        type_parser_clear_generic_params();
        compiler_register_generic_func_def(name_tok->ptr, name_tok->len, generic_params, func_node);
    }

    pop_trace();
    return func_node;
}

// Parse function signature only (skip body)
func parse_func_decl_signature(p: *Parser) -> *AstFunc {
    push_trace("parse_func_decl_signature", "parser/decl.b", __LINE__);

    parse_consume(p, TOKEN_FUNC);

    var name_tok: *Token = parse_peek(p);
    var name_kind: u64 = parse_peek_kind(p);
    if (name_kind != TOKEN_IDENTIFIER && name_kind != TOKEN_NEW && name_kind != TOKEN_DELETE) {
        emit_stderr("[ERROR] Expected function name identifier\n", 45);
        panic("Parse error");
    }
    parse_adv(p);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }

    set_parsing_context(name_tok->ptr, name_tok->len, name_tok->line);

    parse_consume(p, TOKEN_LPAREN);

    var params: *Vec<*Param> = Vec.new<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params->push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params->push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    var ret_type: u64 = TYPE_VOID;
    var ret_ptr_depth: u64 = 0;
    var ret_is_tagged: u64 = 0;
    var ret_struct_name_ptr: u64 = 0;
    var ret_struct_name_len: u64 = 0;
    var ret_tag_layout_ptr: u64 = 0;
    var ret_tag_layout_len: u64 = 0;

    if (parse_match(p, TOKEN_ARROW)) {
        var ty: *TypeInfo = parse_type_ex(p);
        ret_type = ty->type_kind;
        ret_ptr_depth = ty->ptr_depth;
        ret_is_tagged = ty->is_tagged;
        ret_struct_name_ptr = ty->struct_name_ptr;
        ret_struct_name_len = ty->struct_name_len;
        ret_tag_layout_ptr = ty->tag_layout_ptr;
        ret_tag_layout_len = ty->tag_layout_len;
        if (ret_type == TYPE_ARRAY) {
            ret_type = ty->elem_type_kind;
            ret_ptr_depth = ty->elem_ptr_depth + 1;
            ret_is_tagged = 0;
            ret_struct_name_ptr = ty->struct_name_ptr;
            ret_struct_name_len = ty->struct_name_len;
            ret_tag_layout_ptr = 0;
            ret_tag_layout_len = 0;
        }
    }

    // Skip function body
    parse_skip_block(p);

    var func_sig: *AstFunc = ast_func_ex(name_tok->ptr, name_tok->len, params, ret_type, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len, 0);

    if (generic_params != 0) {
        type_parser_clear_generic_params();
        compiler_register_generic_func_sig(name_tok->ptr, name_tok->len, generic_params, func_sig);
    }

    pop_trace();
    return func_sig;
}

// ============================================
// Struct Parsing
// ============================================

func parse_uwidth_from_ident(ptr: u64, len: u64) -> u64 {
    if (len < 2) { return 0; }
    var ptr_u8: *u8 = (*u8)ptr;
    var first: u64 = ptr_u8[0];
    if (first != 117) { return 0; }
    var value: u64 = 0;
    for (var i: u64 = 1; i < len; i++) {
        var c: u64 = ptr_u8[i];
        if (c < 48 || c > 57) { return 0; }
        value = value * 10 + (c - 48);
    }
    return value;
}

func parse_struct_def(p: *Parser) -> *AstStructDef {
    push_trace("parse_struct_def", "parser/decl.b", __LINE__);
    var is_packed: u64 = 0;
    if (parse_match(p, TOKEN_PACKED)) {
        is_packed = 1;
    }
    parse_consume(p, TOKEN_STRUCT);
    
    var name_tok: *Token = parse_peek(p);
    var name_ptr: u64 = name_tok->ptr;
    var name_len: u64 = name_tok->len;
    parse_consume(p, TOKEN_IDENTIFIER);

    var generic_params: *Vec<*GenericParam> = parse_generic_params_any(p);
    if (generic_params != 0) {
        type_parser_set_generic_params(generic_params);
    }
    
    parse_consume(p, TOKEN_LBRACE);
    
    var fields: *Vec<*FieldDesc> = Vec.new<*FieldDesc>(8);
    
    // Parse fields: field_name : type ;
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        var field_name_tok: *Token = parse_peek(p);
        var field_name_ptr: u64 = field_name_tok->ptr;
        var field_name_len: u64 = field_name_tok->len;
        parse_consume(p, TOKEN_IDENTIFIER);
        
        parse_consume(p, TOKEN_COLON);
        
        var field_type_kind: u64 = 0;
        var field_ptr_depth: u64 = 0;
        var field_struct_name_ptr: u64 = 0;
        var field_struct_name_len: u64 = 0;
        var field_tag_layout_ptr: u64 = 0;
        var field_tag_layout_len: u64 = 0;
        var field_elem_type_kind: u64 = 0;
        var field_elem_ptr_depth: u64 = 0;
        var field_array_len: u64 = 0;
        var field_is_tagged: u64 = 0;
        var field_bit_width: u64 = 0;

        if (is_packed == 1) {
            var k: u64 = parse_peek_kind(p);
            switch (k) {
                case TOKEN_U8:
                    parse_adv(p);
                    field_type_kind = TYPE_U8;
                    field_bit_width = 8;
                    break;
                case TOKEN_U16:
                    parse_adv(p);
                    field_type_kind = TYPE_U16;
                    field_bit_width = 16;
                    break;
                case TOKEN_U32:
                    parse_adv(p);
                    field_type_kind = TYPE_U32;
                    field_bit_width = 32;
                    break;
                case TOKEN_U64:
                    parse_adv(p);
                    field_type_kind = TYPE_U64;
                    field_bit_width = 64;
                    break;
                case TOKEN_IDENTIFIER:
                    var bw_tok: *Token = parse_peek(p);
                    var bw_ptr: u64 = bw_tok->ptr;
                    var bw_len: u64 = bw_tok->len;
                    parse_adv(p);
                    var bw: u64 = parse_uwidth_from_ident(bw_ptr, bw_len);
                    if (bw == 0 || bw > 64) {
                        emit_stderr("[ERROR] packed field must be u1..u64\n", 43);
                        panic("Parse error");
                    }
                    field_type_kind = TYPE_U64;
                    field_bit_width = bw;
                    break;
                default:
                    emit_stderr("[ERROR] packed field must be u1..u64\n", 43);
                    panic("Parse error");
            }
        } else {
            var field_type: *TypeInfo = parse_type_ex(p);
            field_type_kind = field_type->type_kind;
            field_struct_name_ptr = field_type->struct_name_ptr;
            field_struct_name_len = field_type->struct_name_len;
            field_tag_layout_ptr = field_type->tag_layout_ptr;
            field_tag_layout_len = field_type->tag_layout_len;
            field_ptr_depth = field_type->ptr_depth;
            field_is_tagged = field_type->is_tagged;
            field_elem_type_kind = field_type->elem_type_kind;
            field_elem_ptr_depth = field_type->elem_ptr_depth;
            field_array_len = field_type->array_len;
        }
        
        parse_consume(p, TOKEN_SEMICOLON);
        
        var field_desc: *FieldDesc = new FieldDesc{};
        field_desc->name_ptr = field_name_ptr;
        field_desc->name_len = field_name_len;
        field_desc->type_kind =  field_type_kind;
        field_desc->struct_name_ptr = field_struct_name_ptr;
        field_desc->struct_name_len = field_struct_name_len;
        field_desc->ptr_depth = field_ptr_depth;
        field_desc->is_tagged = field_is_tagged;
        field_desc->tag_layout_ptr = field_tag_layout_ptr;
        field_desc->tag_layout_len = field_tag_layout_len;
        field_desc->bit_width = field_bit_width;
        field_desc->elem_type_kind = field_elem_type_kind;
        field_desc->elem_ptr_depth = field_elem_ptr_depth;
        field_desc->array_len = field_array_len;
        
        fields->push(field_desc);
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    var struct_def: *AstStructDef = ast_struct_def(name_ptr, name_len, fields, is_packed);
    if (generic_params != 0) {
        type_parser_clear_generic_params();
        compiler_register_generic_struct_def(name_ptr, name_len, generic_params, struct_def);
    }
    pop_trace();
    return struct_def;
}

// ============================================
// Enum Parsing
// ============================================

func parse_enum_def(p: *Parser) -> *Vec<*AstConstDecl> {
    parse_consume(p, TOKEN_ENUM);
    
    var enum_name_tok: *Token = parse_peek(p);
    var enum_name_ptr: u64 = enum_name_tok->ptr;
    var enum_name_len: u64 = enum_name_tok->len;
    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_LBRACE);
    
    var consts: *Vec<*AstConstDecl> = Vec.new<*AstConstDecl>(16);
    var current_value: u64 = 0;
    var enum_name_u8: *u8 = (*u8)enum_name_ptr;
    
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        
        var member_tok: *Token = parse_peek(p);
        var member_ptr: u64 = member_tok->ptr;
        var member_len: u64 = member_tok->len;
        parse_consume(p, TOKEN_IDENTIFIER);
        
        // Check for explicit value
        if (parse_match(p, TOKEN_EQ)) {
            var val_tok: *Token = parse_peek(p);
            parse_consume(p, TOKEN_NUMBER);
            current_value = parse_num_val(val_tok);
        }
        
        // Create EnumName_MemberName
        var full_name: *Vec<u64> = Vec.new<u64>(64);
        for (var i: u64 = 0; i < enum_name_len; i++) {
            full_name->push(enum_name_u8[i]);
        }
        full_name->push(95);  // '_'
        var member_u8: *u8 = (*u8)member_ptr;
        for (var i: u64 = 0; i < member_len; i++) {
            full_name->push(member_u8[i]);
        }
        
        // Copy to permanent heap storage
        var full_name_len: u64 = full_name->len();
        var full_name_ptr: u64 = heap_alloc((full_name_len + 1) * sizeof(u8));
        var full_name_u8: *u8 = (*u8)full_name_ptr;
        var full_name_buf: u64 = *(full_name);  // vec buf_ptr (array of i64)
        for (var i: u64 = 0; i < full_name_len; i++) {
            var ch: u64 = full_name->get(i);  // Get i64 value
            full_name_u8[i] = ch;  // Store as u8
        }
        full_name_u8[full_name_len] = 0;
        
        var const_node: *AstConstDecl = ast_const_decl(full_name_ptr, full_name_len, current_value);
        consts->push(const_node);
        
        current_value = current_value + 1;
        
        // Optional comma
        if (parse_peek_kind(p) == TOKEN_COMMA) {
            parse_consume(p, TOKEN_COMMA);
        }
    }
    
    parse_consume(p, TOKEN_RBRACE);
    
    return consts;
}

// ============================================
// Impl Block Parsing
// ============================================

func _make_self_param(struct_name_ptr: u64, struct_name_len: u64) -> *Param {
    var p: *Param = new Param{};
    p->name_ptr = (u64)"self";
    p->name_len = 4;
    p->type_kind = TYPE_STRUCT;
    p->ptr_depth = 1;
    p->is_tagged = 0;
    p->struct_name_ptr = struct_name_ptr;
    p->struct_name_len = struct_name_len;
    p->tag_layout_ptr = 0;
    p->tag_layout_len = 0;
    p->elem_type_kind = 0;
    p->elem_ptr_depth = 0;
    p->array_len = 0;
    p->array_len_is_param = 0;
    p->array_len_param_ptr = 0;
    p->array_len_param_len = 0;
    return p;
}

func parse_constructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_CONSTRUCTOR);

    set_parsing_context(name_tok->ptr, name_tok->len, name_tok->line);

    parse_consume(p, TOKEN_LPAREN);
    var params: *Vec<*Param> = Vec.new<*Param>(8);
    if (parse_peek_kind(p) != TOKEN_RPAREN) {
        params->push(parse_param(p));
        while (parse_match(p, TOKEN_COMMA)) {
            params->push(parse_param(p));
        }
    }
    parse_consume(p, TOKEN_RPAREN);

    if (parse_peek_kind(p) == TOKEN_ARROW) {
        emit_stderr("[ERROR] constructor cannot specify return type\n", 54);
        panic("Parse error");
    }

    var params_out: *Vec<*Param> = Vec.new<*Param>(params->len() + 1);
    params_out->push(_make_self_param(struct_name_ptr, struct_name_len));
    for (var i: u64 = 0; i < params->len(); i++) {
        params_out->push(params->get(i));
    }

    if (sig_only != 0) {
        parse_skip_block(p);
        return ast_func_ex(name_tok->ptr, name_tok->len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
    }

    var body: *AstNode = parse_block(p);
    return ast_func_ex(name_tok->ptr, name_tok->len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
}

func parse_destructor_decl(p: *Parser, struct_name_ptr: u64, struct_name_len: u64, sig_only: u64) -> *AstFunc {
    var name_tok: *Token = parse_peek(p);
    parse_consume(p, TOKEN_DESTRUCTOR);

    set_parsing_context(name_tok->ptr, name_tok->len, name_tok->line);

    if (parse_peek_kind(p) == TOKEN_LPAREN) {
        parse_adv(p);
        if (parse_peek_kind(p) != TOKEN_RPAREN) {
            emit_stderr("[ERROR] destructor cannot take parameters\n", 49);
            panic("Parse error");
        }
        parse_consume(p, TOKEN_RPAREN);
    }

    var params_out: *Vec<*Param> = Vec.new<*Param>(1);
    params_out->push(_make_self_param(struct_name_ptr, struct_name_len));

    if (sig_only != 0) {
        parse_skip_block(p);
        return ast_func_ex(name_tok->ptr, name_tok->len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, 0);
    }

    var body: *AstNode = parse_block(p);
    return ast_func_ex(name_tok->ptr, name_tok->len, params_out, TYPE_VOID, 0, 0, 0, 0, 0, 0, body);
}

func parse_impl_block(p: *Parser) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);
    
    // Get struct name
    var struct_name_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_name_tok->ptr;
    var struct_name_len: u64 = struct_name_tok->len;
    parse_consume(p, TOKEN_IDENTIFIER);
    
    parse_consume(p, TOKEN_LBRACE);
    
    var funcs: *Vec<*AstFunc> = Vec.new<*AstFunc>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);
    
    // Parse all functions in impl block
    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }
        
        // Check for static keyword
        var is_static: u64 = 0;
        if (parse_peek_kind(p) == TOKEN_STATIC) {
            is_static = 1;
            parse_adv(p);  // consume 'static'
        }
        
        if (parse_peek_kind(p) == TOKEN_CONSTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] constructor cannot be static\n", 41);
                panic("Parse error");
            }
            var ctor_node: *AstFunc = parse_constructor_decl(p, struct_name_ptr, struct_name_len, 0);

            // Rename function: constructor -> StructName_constructor
            var original_name_ptr2: u64 = ctor_node->name_ptr;
            var original_name_len2: u64 = ctor_node->name_len;

            var new_name2: *Vec<u64> = Vec.new<u64>(64);
            var struct_name_u82: *u8 = (*u8)struct_name_ptr;
            for (var i2: u64 = 0; i2 < struct_name_len; i2++) {
                new_name2->push(struct_name_u82[i2]);
            }
            new_name2->push(95);
            var original_name_u82: *u8 = (*u8)original_name_ptr2;
            for (var j2: u64 = 0; j2 < original_name_len2; j2++) {
                new_name2->push(original_name_u82[j2]);
            }

            var new_name_len2: u64 = new_name2->len();
            var new_name_ptr2: u64 = heap_alloc((new_name_len2 + 1) * sizeof(u8));
            var new_name_u82: *u8 = (*u8)new_name_ptr2;
            for (var k2: u64 = 0; k2 < new_name_len2; k2++) {
                var ch2: u64 = new_name2->get(k2);
                new_name_u82[k2] = ch2;
            }
            new_name_u82[new_name_len2] = 0;

            ctor_node->name_ptr = new_name_ptr2;
            ctor_node->name_len = new_name_len2;
            compiler_register_impl_method(new_name_ptr2, new_name_len2);
            funcs->push(ctor_node);
        } else if (parse_peek_kind(p) == TOKEN_DESTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] destructor cannot be static\n", 40);
                panic("Parse error");
            }
            var dtor_node: *AstFunc = parse_destructor_decl(p, struct_name_ptr, struct_name_len, 0);

            var original_name_ptr3: u64 = dtor_node->name_ptr;
            var original_name_len3: u64 = dtor_node->name_len;

            var new_name3: *Vec<u64> = Vec.new<u64>(64);
            var struct_name_u83: *u8 = (*u8)struct_name_ptr;
            for (var i3: u64 = 0; i3 < struct_name_len; i3++) {
                new_name3->push(struct_name_u83[i3]);
            }
            new_name3->push(95);
            var original_name_u83: *u8 = (*u8)original_name_ptr3;
            for (var j3: u64 = 0; j3 < original_name_len3; j3++) {
                new_name3->push(original_name_u83[j3]);
            }

            var new_name_len3: u64 = new_name3->len();
            var new_name_ptr3: u64 = heap_alloc((new_name_len3 + 1) * sizeof(u8));
            var new_name_u83: *u8 = (*u8)new_name_ptr3;
            for (var k3: u64 = 0; k3 < new_name_len3; k3++) {
                var ch3: u64 = new_name3->get(k3);
                new_name_u83[k3] = ch3;
            }
            new_name_u83[new_name_len3] = 0;

            dtor_node->name_ptr = new_name_ptr3;
            dtor_node->name_len = new_name_len3;
            compiler_register_impl_method(new_name_ptr3, new_name_len3);
            funcs->push(dtor_node);
        } else if (parse_peek_kind(p) == TOKEN_FUNC) {
            var func_node: *AstFunc = parse_func_decl(p);
            
            // Rename function: methodName -> StructName_methodName
            var original_name_ptr: u64 = func_node->name_ptr;
            var original_name_len: u64 = func_node->name_len;
            
            // Create new name: StructName_methodName
            var new_name: *Vec<u64> = Vec.new<u64>(64);
            var struct_name_u8: *u8 = (*u8)struct_name_ptr;
            for (var i: u64 = 0; i < struct_name_len; i++) {
                new_name->push(struct_name_u8[i]);
            }
            new_name->push(95);  // '_'
            var original_name_u8: *u8 = (*u8)original_name_ptr;
            for (var i: u64 = 0; i < original_name_len; i++) {
                new_name->push(original_name_u8[i]);
            }
            
            // Copy to permanent heap storage
            var new_name_len: u64 = new_name->len();
            var new_name_ptr: u64 = heap_alloc((new_name_len + 1) * sizeof(u8));
            var new_name_u8: *u8 = (*u8)new_name_ptr;
            for (var i: u64 = 0; i < new_name_len; i++) {
                var ch: u64 = new_name->get(i);
                new_name_u8[i] = ch;
            }
            new_name_u8[new_name_len] = 0;
            
            // Update function name
            func_node->name_ptr = new_name_ptr;
            func_node->name_len = new_name_len;

            compiler_register_impl_method(new_name_ptr, new_name_len);
            
            funcs->push(func_node);
        } else {
            emit_stderr("[ERROR] impl block can only contain functions\n", 48);
            break;
        }
    }
    
    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();
    
    return funcs;
}

// Impl block parsing for signature-only pass
func parse_impl_block_signature(p: *Parser) -> *Vec<*AstFunc> {
    parse_consume(p, TOKEN_IMPL);

    var struct_name_tok: *Token = parse_peek(p);
    var struct_name_ptr: u64 = struct_name_tok->ptr;
    var struct_name_len: u64 = struct_name_tok->len;
    parse_consume(p, TOKEN_IDENTIFIER);

    parse_consume(p, TOKEN_LBRACE);

    var funcs: *Vec<*AstFunc> = Vec.new<*AstFunc>(8);
    compiler_set_impl_prefix(struct_name_ptr, struct_name_len);

    while (parse_peek_kind(p) != TOKEN_RBRACE) {
        if (parse_peek_kind(p) == TOKEN_EOF) { break; }

        var is_static: u64 = 0;
        if (parse_peek_kind(p) == TOKEN_STATIC) {
            is_static = 1;
            parse_adv(p);
        }

        if (parse_peek_kind(p) == TOKEN_CONSTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] constructor cannot be static\n", 41);
                panic("Parse error");
            }
            var ctor_sig: *AstFunc = parse_constructor_decl(p, struct_name_ptr, struct_name_len, 1);

            var original_name_ptr2: u64 = ctor_sig->name_ptr;
            var original_name_len2: u64 = ctor_sig->name_len;

            var new_name2: *Vec<u64> = Vec.new<u64>(64);
            var struct_name_u82: *u8 = (*u8)struct_name_ptr;
            for (var i2: u64 = 0; i2 < struct_name_len; i2++) {
                new_name2->push(struct_name_u82[i2]);
            }
            new_name2->push(95);
            var original_name_u82: *u8 = (*u8)original_name_ptr2;
            for (var j2: u64 = 0; j2 < original_name_len2; j2++) {
                new_name2->push(original_name_u82[j2]);
            }

            var new_name_len2: u64 = new_name2->len();
            var new_name_ptr2: u64 = heap_alloc((new_name_len2 + 1) * sizeof(u8));
            var new_name_u82: *u8 = (*u8)new_name_ptr2;
            for (var k2: u64 = 0; k2 < new_name_len2; k2++) {
                var ch2: u64 = new_name2->get(k2);
                new_name_u82[k2] = ch2;
            }
            new_name_u82[new_name_len2] = 0;

            ctor_sig->name_ptr = new_name_ptr2;
            ctor_sig->name_len = new_name_len2;
            compiler_register_impl_method(new_name_ptr2, new_name_len2);
            funcs->push(ctor_sig);
        } else if (parse_peek_kind(p) == TOKEN_DESTRUCTOR) {
            if (is_static != 0) {
                emit_stderr("[ERROR] destructor cannot be static\n", 40);
                panic("Parse error");
            }
            var dtor_sig: *AstFunc = parse_destructor_decl(p, struct_name_ptr, struct_name_len, 1);

            var original_name_ptr3: u64 = dtor_sig->name_ptr;
            var original_name_len3: u64 = dtor_sig->name_len;

            var new_name3: *Vec<u64> = Vec.new<u64>(64);
            var struct_name_u83: *u8 = (*u8)struct_name_ptr;
            for (var i3: u64 = 0; i3 < struct_name_len; i3++) {
                new_name3->push(struct_name_u83[i3]);
            }
            new_name3->push(95);
            var original_name_u83: *u8 = (*u8)original_name_ptr3;
            for (var j3: u64 = 0; j3 < original_name_len3; j3++) {
                new_name3->push(original_name_u83[j3]);
            }

            var new_name_len3: u64 = new_name3->len();
            var new_name_ptr3: u64 = heap_alloc((new_name_len3 + 1) * sizeof(u8));
            var new_name_u83: *u8 = (*u8)new_name_ptr3;
            for (var k3: u64 = 0; k3 < new_name_len3; k3++) {
                var ch3: u64 = new_name3->get(k3);
                new_name_u83[k3] = ch3;
            }
            new_name_u83[new_name_len3] = 0;

            dtor_sig->name_ptr = new_name_ptr3;
            dtor_sig->name_len = new_name_len3;
            compiler_register_impl_method(new_name_ptr3, new_name_len3);
            funcs->push(dtor_sig);
        } else if (parse_peek_kind(p) == TOKEN_FUNC) {
            var func_ptr: *AstFunc = parse_func_decl_signature(p);
            if (func_ptr == 0) {
                continue;
            }
            var func_node: *AstFunc = func_ptr;

            var original_name_ptr: u64 = func_node->name_ptr;
            var original_name_len: u64 = func_node->name_len;

            var new_name: *Vec<u64> = Vec.new<u64>(64);
            var struct_name_u8: *u8 = (*u8)struct_name_ptr;
            for (var i: u64 = 0; i < struct_name_len; i++) {
                new_name->push(struct_name_u8[i]);
            }
            new_name->push(95);
            var original_name_u8: *u8 = (*u8)original_name_ptr;
            for (var i: u64 = 0; i < original_name_len; i++) {
                new_name->push(original_name_u8[i]);
            }

            var new_name_len: u64 = new_name->len();
            var new_name_ptr: u64 = heap_alloc((new_name_len + 1) * sizeof(u8));
            var new_name_u8: *u8 = (*u8)new_name_ptr;
            for (var i: u64 = 0; i < new_name_len; i++) {
                var ch: u64 = new_name->get(i);
                new_name_u8[i] = ch;
            }
            new_name_u8[new_name_len] = 0;

            func_node->name_ptr = new_name_ptr;
            func_node->name_len = new_name_len;

            compiler_register_impl_method(new_name_ptr, new_name_len);

            funcs->push(func_node);
        } else {
            emit_stderr("[ERROR] impl block can only contain functions\n", 48);
            break;
        }
    }

    parse_consume(p, TOKEN_RBRACE);
    compiler_clear_impl_prefix();

    return funcs;
}

// ============================================
// Program Parsing (Entry Point)
// ============================================

func parse_program(p: *Parser) -> *AstProgram {
    push_trace("parse_program", "parser/decl.b", __LINE__);
    
    var funcs: *Vec<*AstFunc> = Vec.new<*AstFunc>(16);
    var consts: *Vec<*AstConstDecl> = Vec.new<*AstConstDecl>(64);
    var imports: *Vec<*AstImport> = Vec.new<*AstImport>(16);
    var globals: *Vec<*GlobalInfo> = Vec.new<*GlobalInfo>(32);
    var structs: *Vec<*AstStructDef> = Vec.new<*AstStructDef>(16);
    
    while (parse_peek_kind(p) != TOKEN_EOF) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_FUNC:
                var fn_ptr: *AstFunc = parse_func_decl(p);
                if (fn_ptr != 0) {
                    funcs->push(fn_ptr);
                }
                break;
            case TOKEN_CONST:
                consts->push(parse_const_decl(p));
                break;
            case TOKEN_ENUM:
                // Enum을 여러 const로 변환
                var enum_consts: *Vec<*AstConstDecl> = parse_enum_def(p);
                var num_enum_consts: u64 = enum_consts->len();
                for (var i: u64 = 0; i < num_enum_consts; i++) {
                    consts->push(enum_consts->get(i));
                }
                break;
            case TOKEN_STRUCT:
            case TOKEN_PACKED:
                var struct_def: *AstStructDef = parse_struct_def(p);
                if (compiler_is_generic_struct_def(struct_def) == 0) {
                    structs->push(struct_def);
                }
                register_struct_type(struct_def);  // Register immediately for type checking/sizeof
                break;
            case TOKEN_IMPL:
                // impl 블록: 내부 함수들을 StructName_methodName으로 변환
                var impl_funcs: *Vec<*AstFunc> = parse_impl_block(p);
                var num_impl_funcs: u64 = impl_funcs->len();
                for (var i: u64 = 0; i < num_impl_funcs; i++) {
                    funcs->push(impl_funcs->get(i));
                }
                break;
            case TOKEN_VAR:
                parse_consume(p, TOKEN_VAR);
                var tok: *Token = parse_peek(p);

                parse_consume(p, TOKEN_IDENTIFIER);
                var gtype: *TypeInfo = 0;
                if (parse_match(p, TOKEN_COLON)) {
                    // Allow typed globals; preserve type info for codegen.
                    gtype = parse_type_ex(p);
                } else {
                    var ti_default: *TypeInfo = new TypeInfo{};
                    ti_default->type_kind = TYPE_U64;
                    ti_default->ptr_depth = 0;
                    ti_default->is_tagged = 0;
                    ti_default->struct_name_ptr = 0;
                    ti_default->struct_name_len = 0;
                    ti_default->tag_layout_ptr = 0;
                    ti_default->tag_layout_len = 0;
                    ti_default->struct_def = 0;
                    ti_default->elem_type_kind = 0;
                    ti_default->elem_ptr_depth = 0;
                    ti_default->array_len = 0;
                    ti_default->array_len_is_param = 0;
                    ti_default->array_len_param_ptr = 0;
                    ti_default->array_len_param_len = 0;
                    gtype = ti_default;
                }

                var init_kind: u64 = GLOBAL_INIT_NONE;
                var init_value: u64 = 0;
                var init_name_ptr: u64 = 0;
                var init_name_len: u64 = 0;
                var init_expr: *AstNode = 0;

                if (parse_match(p, TOKEN_EQ)) {
                    init_expr = parse_expr(p);
                    if (init_expr == 0) {
                        emit_stderr("[ERROR] Global init expression missing\n", 48);
                        panic("Parse error");
                    }
                    var init_expr_kind: u64 = ast_kind(init_expr);
                    if (init_expr_kind == AST_LITERAL) {
                        var lit: *AstLiteral = (*AstLiteral)init_expr;
                        init_kind = GLOBAL_INIT_VALUE;
                        init_value = lit->value;
                    } else if (init_expr_kind == AST_IDENT) {
                        var id: *AstIdent = (*AstIdent)init_expr;
                        init_name_ptr = id->name_ptr;
                        init_name_len = id->name_len;
                        // Try to resolve const immediately if available
                        var resolved_value: u64 = 0;
                        var found_const: u64 = 0;
                        if (consts != 0) {
                            var cn: u64 = consts->len();
                            for (var ci: u64 = 0; ci < cn; ci++) {
                                var cdecl: *AstConstDecl = consts->get(ci);
                                if (str_eq(cdecl->name_ptr, cdecl->name_len, init_name_ptr, init_name_len)) {
                                    resolved_value = cdecl->value;
                                    found_const = 1;
                                    break;
                                }
                            }
                        }
                        if (found_const != 0) {
                            init_kind = GLOBAL_INIT_VALUE;
                            init_value = resolved_value;
                            init_name_ptr = 0;
                            init_name_len = 0;
                        } else {
                            init_kind = GLOBAL_INIT_CONST;
                        }
                    } else if (init_expr_kind == AST_STRUCT_LITERAL) {
                        if (gtype->type_kind != TYPE_STRUCT || gtype->ptr_depth != 0) {
                            emit_stderr("[ERROR] Global struct literal requires struct type\n", 58);
                            panic("Parse error");
                        }
                        init_kind = GLOBAL_INIT_EXPR;
                    } else {
                        emit_stderr("[ERROR] Unsupported global init expression\n", 50);
                        panic("Parse error");
                    }
                }

                parse_consume(p, TOKEN_SEMICOLON);
                var ginfo: *GlobalInfo = new GlobalInfo{};
                ginfo->name_ptr = tok->ptr;
                ginfo->name_len = tok->len;
                ginfo->typeinfo_ptr = gtype;
                ginfo->init_kind = init_kind;
                ginfo->init_value = init_value;
                ginfo->init_name_ptr = init_name_ptr;
                ginfo->init_name_len = init_name_len;
                ginfo->init_expr = (u64)init_expr;
                globals->push(ginfo);
                break;
            case TOKEN_IMPORT:
                imports->push(parse_import_decl(p));
                break;
            default:
                var err_tok: *Token = parse_peek(p);
                var err_ptr: u64 = err_tok->ptr;
                var err_len: u64 = err_tok->len;
                emit_stderr("[ERROR] Expected function, const, or import. Got token kind=", 67);
                print_u64(parse_peek_kind(p));
                emit_stderr(" text=", 6);
                emit_stderr(err_ptr, err_len);
                emit_stderr("\n", 1);
                parse_adv(p);
                break;
        }
    }
    
    var prog: *AstProgram = ast_program(funcs, consts, imports);
    prog->globals_vec = globals;
    prog->structs_vec = structs;
    
    pop_trace();
    return prog;
}

// ============================================
// Program Parsing (Signature Pass)
// ============================================

func parse_program_pass1(p: *Parser) -> *AstProgram {
    push_trace("parse_program_pass1", "parser/decl.b", __LINE__);

    var funcs: *Vec<*AstFunc> = Vec.new<*AstFunc>(16);
    var consts: *Vec<*AstConstDecl> = Vec.new<*AstConstDecl>(1);
    var imports: *Vec<*AstImport> = Vec.new<*AstImport>(1);

    while (parse_peek_kind(p) != TOKEN_EOF) {
        var k: u64 = parse_peek_kind(p);
        switch (k) {
            case TOKEN_FUNC:
                var sig_ptr: *AstFunc = parse_func_decl_signature(p);
                if (sig_ptr != 0 && compiler_is_generic_template(sig_ptr) == 0) {
                    funcs->push(sig_ptr);
                }
                break;
            case TOKEN_IMPL:
                var impl_funcs: *Vec<*AstFunc> = parse_impl_block_signature(p);
                var num_impl_funcs: u64 = impl_funcs->len();
                for (var i: u64 = 0; i < num_impl_funcs; i++) {
                    var impl_fn_ptr: *AstFunc = impl_funcs->get(i);
                    if (impl_fn_ptr != 0) {
                        funcs->push(impl_fn_ptr);
                    }
                }
                break;
            case TOKEN_STRUCT:
            case TOKEN_PACKED:
                parse_struct_def(p);
                break;
            case TOKEN_ENUM:
                parse_consume(p, TOKEN_ENUM);
                parse_consume(p, TOKEN_IDENTIFIER);
                parse_skip_block(p);
                break;
            case TOKEN_CONST:
                // const 선언은 ; 까지 스킵
                parse_consume(p, TOKEN_CONST);
                parse_consume(p, TOKEN_IDENTIFIER);
                if (parse_match(p, TOKEN_EQ)) {
                    while (parse_peek_kind(p) != TOKEN_SEMICOLON && parse_peek_kind(p) != TOKEN_EOF) {
                        parse_adv(p);
                    }
                }
                parse_consume(p, TOKEN_SEMICOLON);
                break;
            case TOKEN_IMPORT:
                imports->push(parse_import_decl(p));
                break;
            case TOKEN_VAR:
                // 전역 var 선언은 ; 까지 스킵
                parse_consume(p, TOKEN_VAR);
                parse_consume(p, TOKEN_IDENTIFIER);
                if (parse_match(p, TOKEN_COLON)) {
                    parse_type_ex(p);
                }
                if (parse_match(p, TOKEN_EQ)) {
                    while (parse_peek_kind(p) != TOKEN_SEMICOLON && parse_peek_kind(p) != TOKEN_EOF) {
                        parse_adv(p);
                    }
                }
                parse_consume(p, TOKEN_SEMICOLON);
                break;
            default:
                var err_tok2: *Token = parse_peek(p);
                var err_ptr2: u64 = err_tok2->ptr;
                var err_len2: u64 = err_tok2->len;
                emit_stderr("[ERROR] Expected function, const, or import. Got token kind=", 67);
                print_u64(parse_peek_kind(p));
                emit_stderr(" text=", 6);
                emit_stderr(err_ptr2, err_len2);
                emit_stderr("\n", 1);
                parse_adv(p);
                break;
        }
    }

    var prog: *AstProgram = ast_program(funcs, consts, imports);
    pop_trace();
    return prog;
}

// ============================================
// Program Parsing (Imports Only)
// ============================================

func parse_program_imports_only(p: *Parser) -> *Vec<*AstImport> {
    push_trace("parse_program_imports_only", "parser/decl.b", __LINE__);

    var imports: *Vec<*AstImport> = Vec.new<*AstImport>(8);
    while (parse_peek_kind(p) != TOKEN_EOF) {
        if (parse_peek_kind(p) == TOKEN_IMPORT) {
            imports->push(parse_import_decl(p));
        } else {
            parse_adv(p);
        }
    }

    pop_trace();
    return imports;
}
