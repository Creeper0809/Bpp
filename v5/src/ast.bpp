// ast.b - AST node constructors for v3.8

import std.io;
import types;

// Base AST node header
struct AstNode {
    kind: u64;
}

// ============================================
// Expression Nodes
// ============================================

// AST Literal node layout (16 bytes)
struct AstLiteral {
    kind: u64;
    value: u64;
}

// AST Identifier node layout (24 bytes)
struct AstIdent {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
}

// AST String node layout (24 bytes)
struct AstString {
    kind: u64;
    str_ptr: u64;
    str_len: u64;
}

// AST Binary operation node layout (32 bytes)
struct AstBinary {
    kind: u64;
    op: u64;
    left: *AstNode;
    right: *AstNode;
}

// AST Unary operation node layout (24 bytes)
struct AstUnary {
    kind: u64;
    op: u64;
    operand: *AstNode;
}

// AST Function call node layout (32 bytes)
struct AstCall {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    args_vec: *Vec<*AstNode>;
}

// AST Generic call node layout (40 bytes)
struct AstGenericCall {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    generic_args_vec: *Vec<*GenericArg>;
    args_vec: *Vec<*AstNode>;
}

// AST Function pointer call node layout (24 bytes)
struct AstCallPtr {
    kind: u64;
    callee: *AstNode;
    args_vec: *Vec<*AstNode>;
}

// AST_LITERAL: [kind, value]
func ast_literal(val: u64) -> *AstLiteral {
    var n: *AstLiteral = new AstLiteral{};
    n->kind = AST_LITERAL;
    n->value = val;
    return n;
}

// AST_IDENT: [kind, name_ptr, name_len]
func ast_ident(name_ptr: u64, name_len: u64) -> *AstIdent {
    var n: *AstIdent = new AstIdent{};
    n->kind = AST_IDENT;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    return n;
}

// AST_STRING: [kind, str_ptr, str_len]
func ast_string(str_ptr: u64, str_len: u64) -> *AstString {
    var n: *AstString = new AstString{};
    n->kind = AST_STRING;
    n->str_ptr = str_ptr;
    n->str_len = str_len;
    return n;
}

// AST_BINARY: [kind, op, left, right]
func ast_binary(op: u64, left: *AstNode, right: *AstNode) -> *AstBinary {
    var n: *AstBinary = new AstBinary{};
    n->kind = AST_BINARY;
    n->op = op;
    n->left = left;
    n->right = right;
    return n;
}

// AST_UNARY: [kind, op, operand]
func ast_unary(op: u64, operand: *AstNode) -> *AstUnary {
    var n: *AstUnary = new AstUnary{};
    n->kind = AST_UNARY;
    n->op = op;
    n->operand = operand;
    return n;
}

// AST_CALL: [kind, name_ptr, name_len, args_vec]
func ast_call(name_ptr: u64, name_len: u64, args: *Vec<*AstNode>) -> *AstCall {
    var n: *AstCall = new AstCall{};
    n->kind = AST_CALL;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    n->args_vec = args;
    return n;
}

// AST_GENERIC_CALL: [kind, name_ptr, name_len, generic_args_vec, args_vec]
func ast_generic_call(name_ptr: u64, name_len: u64, generic_args: *Vec<*GenericArg>, args: *Vec<*AstNode>) -> *AstGenericCall {
    var n: *AstGenericCall = new AstGenericCall{};
    n->kind = AST_GENERIC_CALL;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    n->generic_args_vec = generic_args;
    n->args_vec = args;
    return n;
}

// AST Address-of node layout (16 bytes)
struct AstAddrOf {
    kind: u64;
    operand: *AstNode;
}

// AST Dereference node layout (16 bytes)
struct AstDeref {
    kind: u64;
    operand: *AstNode;
}

// AST Byte dereference node layout (16 bytes)
struct AstDeref8 {
    kind: u64;
    operand: *AstNode;
}

// AST Index node layout (24 bytes)
struct AstIndex {
    kind: u64;
    base: *AstNode;
    index: *AstNode;
}

// AST Slice literal node layout (24 bytes)
struct AstSlice {
    kind: u64;
    ptr_expr: *AstNode;
    len_expr: *AstNode;
}

// AST Cast node layout (72 bytes)
struct AstCast {
    kind: u64;
    expr: *AstNode;
    target_type: u64;
    target_ptr_depth: u64;
    target_is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
}

// AST Sizeof node layout (88 bytes)
struct AstSizeof {
    kind: u64;
    type_kind: u64;
    ptr_depth: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
}

// AST Sizeof Expr node layout (16 bytes)
struct AstSizeofExpr {
    kind: u64;
    expr: *AstNode;
}

// AST New expression node layout (152 bytes)
struct AstNew {
    kind: u64;
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
    literal_expr: *AstNode;
    ctor_args_vec: *Vec<*AstNode>;
}

// AST_ADDR_OF: [kind, operand]
func ast_addr_of(operand: *AstNode) -> *AstAddrOf {
    var n: *AstAddrOf = new AstAddrOf{};
    n->kind = AST_ADDR_OF;
    n->operand = operand;
    return n;
}

// AST_DEREF: [kind, operand]
func ast_deref(operand: *AstNode) -> *AstDeref {
    var n: *AstDeref = new AstDeref{};
    n->kind = AST_DEREF;
    n->operand = operand;
    return n;
}

// AST_DEREF8: [kind, operand] - byte dereference
func ast_deref8(operand: *AstNode) -> *AstDeref8 {
    var n: *AstDeref8 = new AstDeref8{};
    n->kind = AST_DEREF8;
    n->operand = operand;
    return n;
}

// AST_INDEX: [kind, base, index]
func ast_index(base: *AstNode, index: *AstNode) -> *AstIndex {
    var n: *AstIndex = new AstIndex{};
    n->kind = AST_INDEX;
    n->base = base;
    n->index = index;
    return n;
}

// AST_SLICE: [kind, ptr_expr, len_expr]
func ast_slice(ptr_expr: *AstNode, len_expr: *AstNode) -> *AstSlice {
    var n: *AstSlice = new AstSlice{};
    n->kind = AST_SLICE;
    n->ptr_expr = ptr_expr;
    n->len_expr = len_expr;
    return n;
}

// AST_CAST: [kind, expr, target_type, target_ptr_depth, target_is_tagged, struct_name_ptr, struct_name_len, tag_layout_ptr, tag_layout_len]
func ast_cast(expr: *AstNode, target_type: u64, ptr_depth: u64) -> *AstCast {
    var n: *AstCast = new AstCast{};
    n->kind = AST_CAST;
    n->expr = expr;
    n->target_type = target_type;
    n->target_ptr_depth = ptr_depth;
    n->target_is_tagged = 0;
    n->struct_name_ptr = 0;
    n->struct_name_len = 0;
    n->tag_layout_ptr = 0;
    n->tag_layout_len = 0;
    return n;
}

func ast_cast_ex(expr: *AstNode, target_type: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64) -> *AstCast {
    var n: *AstCast = new AstCast{};
    n->kind = AST_CAST;
    n->expr = expr;
    n->target_type = target_type;
    n->target_ptr_depth = ptr_depth;
    n->target_is_tagged = is_tagged;
    n->struct_name_ptr = struct_name_ptr;
    n->struct_name_len = struct_name_len;
    n->tag_layout_ptr = tag_layout_ptr;
    n->tag_layout_len = tag_layout_len;
    return n;
}

// AST_SIZEOF: [kind, type_kind, ptr_depth, struct_name_ptr, struct_name_len, elem_type_kind, elem_ptr_depth, array_len, array_len_is_param, array_len_param_ptr, array_len_param_len]
func ast_sizeof(type_kind: u64, ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64, elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64) -> *AstSizeof {
    var n: *AstSizeof = new AstSizeof{};
    n->kind = AST_SIZEOF;
    n->type_kind = type_kind;
    n->ptr_depth = ptr_depth;
    n->struct_name_ptr = struct_name_ptr;
    n->struct_name_len = struct_name_len;
    n->elem_type_kind = elem_type_kind;
    n->elem_ptr_depth = elem_ptr_depth;
    n->array_len = array_len;
    n->array_len_is_param = array_len_is_param;
    n->array_len_param_ptr = array_len_param_ptr;
    n->array_len_param_len = array_len_param_len;
    return n;
}

// AST_SIZEOF_EXPR: [kind, expr]
func ast_sizeof_expr(expr: *AstNode) -> *AstSizeofExpr {
    var n: *AstSizeofExpr = new AstSizeofExpr{};
    n->kind = AST_SIZEOF_EXPR;
    n->expr = expr;
    return n;
}

// AST_NEW: [kind, type info..., literal_expr, ctor_args_vec]
func ast_new(type_kind: u64, ptr_depth: u64, is_tagged: u64, struct_name_ptr: u64, struct_name_len: u64, tag_layout_ptr: u64, tag_layout_len: u64,
             elem_type_kind: u64, elem_ptr_depth: u64, array_len: u64, array_len_is_param: u64, array_len_param_ptr: u64, array_len_param_len: u64,
             literal_expr: *AstNode, ctor_args_vec: *Vec<*AstNode>) -> *AstNew {
    var n: *AstNew = new AstNew{};
    n->kind = AST_NEW;
    n->type_kind = type_kind;
    n->ptr_depth = ptr_depth;
    n->is_tagged = is_tagged;
    n->struct_name_ptr = struct_name_ptr;
    n->struct_name_len = struct_name_len;
    n->tag_layout_ptr = tag_layout_ptr;
    n->tag_layout_len = tag_layout_len;
    n->elem_type_kind = elem_type_kind;
    n->elem_ptr_depth = elem_ptr_depth;
    n->array_len = array_len;
    n->array_len_is_param = array_len_is_param;
    n->array_len_param_ptr = array_len_param_ptr;
    n->array_len_param_len = array_len_param_len;
    n->literal_expr = literal_expr;
    n->ctor_args_vec = ctor_args_vec;
    return n;
}

// ============================================
// Statement Nodes
// ============================================

// AST Return statement node layout (16 bytes)
struct AstReturn {
    kind: u64;
    expr: *AstNode;
}

// AST Variable declaration node layout (136 bytes)
struct AstVarDecl {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    init_expr: *AstNode;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
}

// AST Constant declaration node layout (32 bytes)
struct AstConstDecl {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    value: u64;
}

// AST Assignment node layout (24 bytes)
struct AstAssign {
    kind: u64;
    target: *AstNode;
    value: *AstNode;
}

// AST_RETURN: [kind, expr]
func ast_return(expr: *AstNode) -> *AstReturn {
    var n: *AstReturn = new AstReturn{};
    n->kind = AST_RETURN;
    n->expr = expr;
    return n;
}

// AST_VAR_DECL: [kind, name_ptr, name_len, type_kind, ptr_depth, init_expr]
func ast_var_decl(name_ptr: u64, name_len: u64, type_kind: u64, ptr_depth: u64, init: *AstNode) -> *AstVarDecl {
    var n: *AstVarDecl = new AstVarDecl{};
    n->kind = AST_VAR_DECL;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    n->type_kind = type_kind;
    n->ptr_depth = ptr_depth;
    n->is_tagged = 0;
    n->init_expr = init;
    n->struct_name_ptr = 0;
    n->struct_name_len = 0;
    n->tag_layout_ptr = 0;
    n->tag_layout_len = 0;
    n->elem_type_kind = 0;
    n->elem_ptr_depth = 0;
    n->array_len = 0;
    n->array_len_is_param = 0;
    n->array_len_param_ptr = 0;
    n->array_len_param_len = 0;
    return n;
}

// AST_CONST_DECL: [kind, name_ptr, name_len, value]
func ast_const_decl(name_ptr: u64, name_len: u64, value: u64) -> *AstConstDecl {
    var n: *AstConstDecl = new AstConstDecl{};
    n->kind = AST_CONST_DECL;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    n->value = value;
    return n;
}

// AST_ASSIGN: [kind, target, value]
func ast_assign(target: *AstNode, value: *AstNode) -> *AstAssign {
    var n: *AstAssign = new AstAssign{};
    n->kind = AST_ASSIGN;
    n->target = target;
    n->value = value;
    return n;
}

// AST Expression statement node layout (16 bytes)
struct AstExprStmt {
    kind: u64;
    expr: *AstNode;
}

// AST If statement node layout (32 bytes)
struct AstIf {
    kind: u64;
    cond: *AstNode;
    then_block: *AstNode;
    else_block: *AstNode;
}

// AST While loop node layout (24 bytes)
struct AstWhile {
    kind: u64;
    cond: *AstNode;
    body: *AstNode;
}

// AST For loop node layout (40 bytes)
struct AstFor {
    kind: u64;
    init: *AstNode;
    cond: *AstNode;
    update: *AstNode;
    body: *AstNode;
}

// AST_EXPR_STMT: [kind, expr]
func ast_expr_stmt(expr: *AstNode) -> *AstExprStmt {
    var n: *AstExprStmt = new AstExprStmt{};
    n->kind = AST_EXPR_STMT;
    n->expr = expr;
    return n;
}

// AST_IF: [kind, cond, then_block, else_block]
func ast_if(cond: *AstNode, then_blk: *AstNode, else_blk: *AstNode) -> *AstIf {
    var n: *AstIf = new AstIf{};
    n->kind = AST_IF;
    n->cond = cond;
    n->then_block = then_blk;
    n->else_block = else_blk;
    return n;
}

// AST_WHILE: [kind, cond, body]
func ast_while(cond: *AstNode, body: *AstNode) -> *AstWhile {
    var n: *AstWhile = new AstWhile{};
    n->kind = AST_WHILE;
    n->cond = cond;
    n->body = body;
    return n;
}

// AST_FOR: [kind, init, cond, update, body]
func ast_for(init: *AstNode, cond: *AstNode, update: *AstNode, body: *AstNode) -> *AstFor {
    var n: *AstFor = new AstFor{};
    n->kind = AST_FOR;
    n->init = init;
    n->cond = cond;
    n->update = update;
    n->body = body;
    return n;
}

// AST Switch statement node layout (24 bytes)
struct AstSwitch {
    kind: u64;
    expr: *AstNode;
    cases_vec: *Vec<*AstNode>;
}

// AST Case node layout (32 bytes)
struct AstCase {
    kind: u64;
    value: *AstNode;
    body: *AstNode;
    is_default: u64;
}

// AST Break statement node layout (8 bytes)
struct AstBreak {
    kind: u64;
}

// AST Continue statement node layout (8 bytes)
struct AstContinue {
    kind: u64;
}

// AST Inline assembly node layout (16 bytes)
struct AstAsm {
    kind: u64;
    text_vec: *Vec<u64>;
}

// AST Alias statement node layout (40 bytes)
struct AstAlias {
    kind: u64;
    reg_ptr: u64;
    reg_len: u64;
    name_ptr: u64;
    name_len: u64;
}

// AST Defer statement node layout (16 bytes)
struct AstDefer {
    kind: u64;
    stmt: *AstNode;
}

// AST Delete statement node layout (16 bytes)
struct AstDelete {
    kind: u64;
    expr: *AstNode;
}

// AST Block node layout (16 bytes)
struct AstBlock {
    kind: u64;
    stmts_vec: *Vec<*AstNode>;
}

// AST_SWITCH: [kind, expr, cases_vec]
func ast_switch(expr: *AstNode, cases: *Vec<*AstNode>) -> *AstSwitch {
    var n: *AstSwitch = new AstSwitch{};
    n->kind = AST_SWITCH;
    n->expr = expr;
    n->cases_vec = cases;
    return n;
}

// AST_CASE: [kind, value, body, is_default]
func ast_case(value: *AstNode, body: *AstNode, is_default: u64) -> *AstCase {
    var n: *AstCase = new AstCase{};
    n->kind = AST_CASE;
    n->value = value;
    n->body = body;
    n->is_default = is_default;
    return n;
}

// AST_BREAK: [kind]
func ast_break() -> *AstBreak {
    var n: *AstBreak = new AstBreak{};
    n->kind = AST_BREAK;
    return n;
}

// AST_CONTINUE: [kind]
func ast_continue() -> *AstContinue {
    var n: *AstContinue = new AstContinue{};
    n->kind = AST_CONTINUE;
    return n;
}

// AST_ASM: [kind, text_vec]
func ast_asm(text_vec: *Vec<u64>) -> *AstAsm {
    var n: *AstAsm = new AstAsm{};
    n->kind = AST_ASM;
    n->text_vec = text_vec;
    return n;
}

// AST_ALIAS: [kind, reg_ptr, reg_len, name_ptr, name_len]
func ast_alias(reg_ptr: u64, reg_len: u64, name_ptr: u64, name_len: u64) -> *AstAlias {
    var n: *AstAlias = new AstAlias{};
    n->kind = AST_ALIAS;
    n->reg_ptr = reg_ptr;
    n->reg_len = reg_len;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    return n;
}

// AST_DEFER: [kind, stmt]
func ast_defer(stmt: *AstNode) -> *AstDefer {
    var n: *AstDefer = new AstDefer{};
    n->kind = AST_DEFER;
    n->stmt = stmt;
    return n;
}

// AST_DELETE: [kind, expr]
func ast_delete(expr: *AstNode) -> *AstDelete {
    var n: *AstDelete = new AstDelete{};
    n->kind = AST_DELETE;
    n->expr = expr;
    return n;
}

// AST_BLOCK: [kind, stmts_vec]
func ast_block(stmts: *Vec<*AstNode>) -> *AstBlock {
    var n: *AstBlock = new AstBlock{};
    n->kind = AST_BLOCK;
    n->stmts_vec = stmts;
    return n;
}

// ============================================
// Top-level Nodes
// ============================================

// AST Function definition node layout (96 bytes)
struct AstFunc {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    params_vec: *Vec<*Param>;
    ret_type: u64;
    body: *AstNode;
    ret_ptr_depth: u64;
    ret_is_tagged: u64;
    ret_struct_name_ptr: u64;
    ret_struct_name_len: u64;
    ret_tag_layout_ptr: u64;
    ret_tag_layout_len: u64;
}

// AST Program node layout (48 bytes)
struct AstProgram {
    kind: u64;
    funcs_vec: *Vec<*AstFunc>;
    consts_vec: *Vec<*AstConstDecl>;
    imports_vec: *Vec<*AstImport>;
    globals_vec: *Vec<*GlobalInfo>;
    structs_vec: *Vec<*AstStructDef>;
}

// AST Import statement node layout (56 bytes)
struct AstImport {
    kind: u64;
    path_ptr: u64;
    path_len: u64;
    symbol_ptr: u64;
    symbol_len: u64;
    alias_ptr: u64;
    alias_len: u64;
}

// AST Struct definition node layout (40 bytes)
struct AstStructDef {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    fields_vec: *Vec<*FieldDesc>;
    is_packed: u64;
}

// AST Member access node layout (32 bytes)
struct AstMemberAccess {
    kind: u64;
    object: *AstNode;
    member_ptr: u64;
    member_len: u64;
}

// AST Method call node layout (40 bytes)
struct AstMethodCall {
    kind: u64;
    receiver: *AstNode;
    method_ptr: u64;
    method_len: u64;
    args_vec: *Vec<*AstNode>;
}

// AST Struct literal node layout (24 bytes)
struct AstStructLiteral {
    kind: u64;
    struct_def: *AstStructDef;
    values_vec: *Vec<*AstNode>;
}

// AST_FUNC: [kind, name_ptr, name_len, params_vec, ret_type, body]
// Legacy ast_func() now creates 72-byte nodes with extra fields zeroed for compatibility
func ast_func(name_ptr: u64, name_len: u64, params: *Vec<*Param>, ret_type: u64, body: *AstNode) -> *AstFunc {
    var n: *AstFunc = new AstFunc{};
    n->kind = AST_FUNC;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    n->params_vec = params;
    n->ret_type = ret_type;
    n->body = body;
    n->ret_ptr_depth = 0;
    n->ret_is_tagged = 0;
    n->ret_struct_name_ptr = 0;
    n->ret_struct_name_len = 0;
    n->ret_tag_layout_ptr = 0;
    n->ret_tag_layout_len = 0;
    return n;
}

// AST_FUNC (extended): [kind, name_ptr, name_len, params, ret_type, body, ret_ptr_depth, ret_is_tagged, ret_struct_name_ptr, ret_struct_name_len, ret_tag_layout_ptr, ret_tag_layout_len]
func ast_func_ex(name_ptr: u64, name_len: u64, params: *Vec<*Param>, ret_type: u64, ret_ptr_depth: u64, ret_is_tagged: u64, ret_struct_name_ptr: u64, ret_struct_name_len: u64, ret_tag_layout_ptr: u64, ret_tag_layout_len: u64, body: *AstNode) -> *AstFunc {
    var n: *AstFunc = new AstFunc{};
    n->kind = AST_FUNC;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    n->params_vec = params;
    n->ret_type = ret_type;
    n->body = body;
    n->ret_ptr_depth = ret_ptr_depth;
    n->ret_is_tagged = ret_is_tagged;
    n->ret_struct_name_ptr = ret_struct_name_ptr;
    n->ret_struct_name_len = ret_struct_name_len;
    n->ret_tag_layout_ptr = ret_tag_layout_ptr;
    n->ret_tag_layout_len = ret_tag_layout_len;
    return n;
}

// AST_PROGRAM: [kind, funcs_vec, consts_vec, imports_vec, globals_vec]
func ast_program(funcs: *Vec<*AstFunc>, consts: *Vec<*AstConstDecl>, imports: *Vec<*AstImport>) -> *AstProgram {
    var n: *AstProgram = new AstProgram{};
    n->kind = AST_PROGRAM;
    n->funcs_vec = funcs;
    n->consts_vec = consts;
    n->imports_vec = imports;
    n->globals_vec = 0;
    n->structs_vec = 0;
    return n;
}

// AST_IMPORT: [kind, path_ptr, path_len, symbol_ptr, symbol_len, alias_ptr, alias_len]
func ast_import(path_ptr: u64, path_len: u64, symbol_ptr: u64, symbol_len: u64, alias_ptr: u64, alias_len: u64) -> *AstImport {
    var n: *AstImport = new AstImport{};
    n->kind = AST_IMPORT;
    n->path_ptr = path_ptr;
    n->path_len = path_len;
    n->symbol_ptr = symbol_ptr;
    n->symbol_len = symbol_len;
    n->alias_ptr = alias_ptr;
    n->alias_len = alias_len;
    return n;
}

// AST_STRUCT_DEF: [kind, name_ptr, name_len, fields_vec, is_packed]
func ast_struct_def(name_ptr: u64, name_len: u64, fields: *Vec<*FieldDesc>, is_packed: u64) -> *AstStructDef {
    var n: *AstStructDef = new AstStructDef{};
    n->kind = AST_STRUCT_DEF;
    n->name_ptr = name_ptr;
    n->name_len = name_len;
    n->fields_vec = fields;
    n->is_packed = is_packed;
    return n;
}

// AST_MEMBER_ACCESS: [kind, object, member_ptr, member_len]
func ast_member_access(object: *AstNode, member_ptr: u64, member_len: u64) -> *AstMemberAccess {
    var n: *AstMemberAccess = new AstMemberAccess{};
    n->kind = AST_MEMBER_ACCESS;
    n->object = object;
    n->member_ptr = member_ptr;
    n->member_len = member_len;
    return n;
}

// AST_METHOD_CALL: [kind, receiver, method_ptr, method_len, args_vec]
func ast_method_call(receiver: *AstNode, method_ptr: u64, method_len: u64, args: *Vec<*AstNode>) -> *AstMethodCall {
    var n: *AstMethodCall = new AstMethodCall{};
    n->kind = AST_METHOD_CALL;
    n->receiver = receiver;
    n->method_ptr = method_ptr;
    n->method_len = method_len;
    n->args_vec = args;
    return n;
}

// AST_CALL_PTR: [kind, callee, args_vec]
func ast_call_ptr(callee: *AstNode, args: *Vec<*AstNode>) -> *AstCallPtr {
    var n: *AstCallPtr = new AstCallPtr{};
    n->kind = AST_CALL_PTR;
    n->callee = callee;
    n->args_vec = args;
    return n;
}

// AST_STRUCT_LITERAL: struct_def_ptr, values (vec of exprs)
// Layout: [kind:8][struct_def:8][values:8]
func ast_struct_literal(struct_def: *AstStructDef, values: *Vec<*AstNode>) -> *AstStructLiteral {
    var n: *AstStructLiteral = new AstStructLiteral{};
    n->kind = AST_STRUCT_LITERAL;
    n->struct_def = struct_def;
    n->values_vec = values;
    return n;
}

// ============================================
// AST Accessors
// ============================================

func ast_kind(n: *AstNode) -> u64 { return *(n); }
