// hashmap.b - Hash map implementation for v3.8

import std.io;
import std.str;

// HashMap<K, V> structure: [entries_ptr, capacity, count]
// Entry: [key_ptr, key_len, hash, used, value]

struct HashMap<K, V> {
    entries_ptr: u64;
    capacity: u64;
    count: u64;
}

struct HashEntry<V> {
    key_ptr: u64;
    key_len: u64;
    hash: u64;
    used: u64;
    value: V;
}

impl HashMap {
    func entry_size<K, V>() -> u64 {
        var base_size: u64 = 4 * sizeof(u64);
        return base_size + sizeof(V);
    }

    func hash(key_ptr: u64, key_len: u64) -> u64 {
        var hash: u64 = 0;
        for (var i: u64 = 0; i < key_len; i++) {
            hash = hash ^ *(*u8)(key_ptr + i);
            hash = hash * 31;
        }
        return hash;
    }

    func new<K, V>(capacity: u64) -> u64 {
        var cap: u64 = 16;
        for (; cap < capacity; cap = cap * 2) {
        }
        var map: *HashMap<K, V> = (*HashMap<K, V>)heap_alloc(sizeof(HashMap));
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var bytes: u64 = cap * entry_bytes;
        var entries: u64 = heap_alloc(bytes);

        for (var i: u64 = 0; i < bytes; i++) {
            *(*u8)(entries + i) = 0;
        }

        map->entries_ptr = entries;
        map->capacity = cap;
        map->count = 0;
        return (u64)map;
    }

    func entry_ptr<K, V>(entries: u64, idx: u64) -> *HashEntry<V> {
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        return (*HashEntry<V>)(entries + idx * entry_bytes);
    }

    func put_internal<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                entry->key_ptr = key_ptr;
                entry->key_len = key_len;
                entry->hash = hash;
                entry->used = 1;
                var dst: u64 = (u64)&entry->value;
                var src: u64 = (u64)&value;
                var elem_size: u64 = sizeof(V);
                for (var j: u64 = 0; j < elem_size; j++) {
                    *(*u8)(dst + j) = *(*u8)(src + j);
                }
                self->count = self->count + 1;
                return 0;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func grow<K, V>(self: *HashMap<K, V>) -> u64 {
        var old_entries: u64 = self->entries_ptr;
        var old_cap: u64 = self->capacity;

        var new_cap: u64 = old_cap * 2;
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var new_bytes: u64 = new_cap * entry_bytes;
        var new_entries: u64 = heap_alloc(new_bytes);

        for (var i: u64 = 0; i < new_bytes; i++) {
            *(*u8)(new_entries + i) = 0;
        }

        self->entries_ptr = new_entries;
        self->capacity = new_cap;
        self->count = 0;

        for (var i: u64 = 0; i < old_cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(old_entries, i);
            var used: u64 = entry->used;
            if (used != 0) {
                var kp: u64 = entry->key_ptr;
                var kl: u64 = entry->key_len;
                var val: V;
                var srcv: u64 = (u64)&entry->value;
                var dstv: u64 = (u64)&val;
                var elem_size: u64 = sizeof(V);
                for (var j: u64 = 0; j < elem_size; j++) {
                    *(*u8)(dstv + j) = *(*u8)(srcv + j);
                }
                self->put_internal(kp, kl, val);
            }
        }
        return 0;
    }

    func put<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var count: u64 = self->count;

        if (count * 10 >= cap * 7) {
            self->grow();
            entries = self->entries_ptr;
            cap = self->capacity;
        }

        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                entry->key_ptr = key_ptr;
                entry->key_len = key_len;
                entry->hash = hash;
                entry->used = 1;
                var dst2: u64 = (u64)&entry->value;
                var src2: u64 = (u64)&value;
                var elem_size2: u64 = sizeof(V);
                for (var j2: u64 = 0; j2 < elem_size2; j2++) {
                    *(*u8)(dst2 + j2) = *(*u8)(src2 + j2);
                }
                self->count = self->count + 1;
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                var dst3: u64 = (u64)&entry->value;
                var src3: u64 = (u64)&value;
                var elem_size3: u64 = sizeof(V);
                for (var j3: u64 = 0; j3 < elem_size3; j3++) {
                    *(*u8)(dst3 + j3) = *(*u8)(src3 + j3);
                }
                return 0;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func get<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> V {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                var out: V;
                var src4: u64 = (u64)&entry->value;
                var dst4: u64 = (u64)&out;
                var elem_size4: u64 = sizeof(V);
                for (var j4: u64 = 0; j4 < elem_size4; j4++) {
                    *(*u8)(dst4 + j4) = *(*u8)(src4 + j4);
                }
                return out;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func has<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> u64 {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                return 1;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    static func force_instantiations_u64() -> u64 {
        var dummy_map: *HashMap<u64, u64> = 0;
        var dummy_key_ptr: u64 = 0;
        var dummy_key_len: u64 = 0;
        dummy_map->put(dummy_key_ptr, dummy_key_len, 0);
        dummy_map->get(dummy_key_ptr, dummy_key_len);
        dummy_map->has(dummy_key_ptr, dummy_key_len);
        return 0;
    }
}

// Compatibility wrappers (u64 HashMap)
func hashmap_new(capacity) { return HashMap.new<u64, u64>(capacity); }
func hashmap_put(map, key_ptr, key_len, value) { return ((*HashMap<u64, u64>)map)->put(key_ptr, key_len, value); }
func hashmap_get(map, key_ptr, key_len) { return ((*HashMap<u64, u64>)map)->get(key_ptr, key_len); }
func hashmap_has(map, key_ptr, key_len) { return ((*HashMap<u64, u64>)map)->has(key_ptr, key_len); }

