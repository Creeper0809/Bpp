// vec.b - Dynamic array implementation (pointer arithmetic for bootstrap)

import std.io;

// Vec<T> structure: [data_ptr, length, capacity] (24 bytes)
// Storage is byte-based; element stride is sizeof(T).
struct Vec<T> {
    data_ptr: u64;
    length: u64;
    capacity: u64;
}

impl Vec {
    static func new<T>(cap: u64) -> *Vec<T> {
        var vec: *Vec<T> = (*Vec<T>)heap_alloc(sizeof(Vec));
        var elem_size: u64 = sizeof(T);
        var buf: u64 = heap_alloc(cap * elem_size);
        vec->data_ptr = buf;
        vec->length = 0;
        vec->capacity = cap;
        return vec;
    }

    func len<T>(self: *Vec<T>) -> u64 {
        return self->length;
    }

    func cap<T>(self: *Vec<T>) -> u64 {
        return self->capacity;
    }

    func push<T>(self: *Vec<T>, item: T) -> u64 {
        var len: u64 = self->length;
        var cap: u64 = self->capacity;
        var elem_size: u64 = sizeof(T);

        // Grow if needed
        if (len >= cap) {
            var new_cap: u64 = cap * 2;
            if (new_cap < 4) { new_cap = 4; }
            var new_buf: u64 = heap_alloc(new_cap * elem_size);
            var old_buf: u64 = self->data_ptr;
            // Copy old data (byte-wise)
            for (var i: u64 = 0; i < len; i++) {
                var src: u64 = old_buf + i * elem_size;
                var dst: u64 = new_buf + i * elem_size;
                for (var j: u64 = 0; j < elem_size; j++) {
                    *(*u8)(dst + j) = *(*u8)(src + j);
                }
            }
            self->data_ptr = new_buf;
            self->capacity = new_cap;
        }

        var buf: u64 = self->data_ptr;
        var dst2: u64 = buf + len * elem_size;
        var src2: u64 = (u64)&item;
        for (var k: u64 = 0; k < elem_size; k++) {
            *(*u8)(dst2 + k) = *(*u8)(src2 + k);
        }
        self->length = len + 1;
        return 0;
    }

    func get<T>(self: *Vec<T>, i: u64) -> T {
        var buf: u64 = self->data_ptr;
        var elem_size: u64 = sizeof(T);
        var out: T;
        var src: u64 = buf + i * elem_size;
        var dst: u64 = (u64)&out;
        for (var j: u64 = 0; j < elem_size; j++) {
            *(*u8)(dst + j) = *(*u8)(src + j);
        }
        return out;
    }

    func set<T>(self: *Vec<T>, i: u64, val: T) -> u64 {
        var buf: u64 = self->data_ptr;
        var elem_size: u64 = sizeof(T);
        var dst: u64 = buf + i * elem_size;
        var src: u64 = (u64)&val;
        for (var j: u64 = 0; j < elem_size; j++) {
            *(*u8)(dst + j) = *(*u8)(src + j);
        }
        return 0;
    }

    func pop<T>(self: *Vec<T>) -> T {
        var len: u64 = self->length;
        if (len == 0) {
            return 0;
        }
        var buf: u64 = self->data_ptr;
        var elem_size: u64 = sizeof(T);
        var out: T;
        var src: u64 = buf + (len - 1) * elem_size;
        var dst: u64 = (u64)&out;
        for (var j: u64 = 0; j < elem_size; j++) {
            *(*u8)(dst + j) = *(*u8)(src + j);
        }
        self->length = len - 1;
        return out;
    }

    static func force_instantiations_u64() -> u64 {
        var dummy_vec: *Vec<u64> = 0;
        dummy_vec->len();
        dummy_vec->cap();
        dummy_vec->push(0);
        dummy_vec->get(0);
        dummy_vec->set(0, 0);
        dummy_vec->pop();
        return 0;
    }
}


