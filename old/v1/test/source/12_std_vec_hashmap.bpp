// Covers: stdlib vec/hashmap/str (stress)
// Expect exit code: 0

import std.vec;
import std.hashmap;
import std.str;

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var vec_handle = vec_new(4);
    var map_handle = hashmap_new(8);
    var vec_sum: i64 = 0;

    // Execution
    vec_push(vec_handle, 10);
    vec_push(vec_handle, 20);
    vec_push(vec_handle, 12);
    if (vec_len(vec_handle) != 3) { return 1; }
    if (vec_get(vec_handle, 1) != 20) { return 2; }

    // Stress: 대량 push + 합산
    for (var i: i64 = 0; i < 256; i = i + 1) {
        vec_push(vec_handle, i * 3);
    }
    if (vec_len(vec_handle) != 259) { return 3; }
    for (var j: i64 = 0; j < 256; j = j + 1) {
        vec_sum = vec_sum + vec_get(vec_handle, j + 3);
    }
    if (vec_sum != 97920) { return 4; }

    hashmap_put(map_handle, "key", str_len("key"), 42);
    if (!hashmap_has(map_handle, "key", 3)) { return 5; }
    if (hashmap_get(map_handle, "key", 3) != 42) { return 6; }

    // Stress: 동일 키 반복 업데이트
    for (var k: i64 = 0; k < 100; k = k + 1) {
        hashmap_put(map_handle, "key", 3, 1000 + k);
    }
    if (hashmap_get(map_handle, "key", 3) != 1099) { return 7; }

    // Complex: conditional vec push + reverse aggregation
    var base_len: i64 = vec_len(vec_handle);
    for (var m: i64 = 0; m < 32; m = m + 1) {
        var v: i64 = m * 5;
        if ((m & 3) == 0) {
            vec_push(vec_handle, v);
        } else {
            vec_push(vec_handle, v + 1);
        }
    }
    var mix_total: i64 = 0;
    for (var n: i64 = 0; n < 32; n = n + 1) {
        var val: i64 = vec_get(vec_handle, base_len + 31 - n);
        if ((val & 1) == 0) {
            mix_total = mix_total + val;
        } else {
            mix_total = mix_total - val;
        }
    }
    if (mix_total != 1208) { return 8; }

    // Complex: multiple key updates
    hashmap_put(map_handle, "a", 1, 1);
    hashmap_put(map_handle, "b", 1, 2);
    for (var t: i64 = 0; t < 6; t = t + 1) {
        if ((t & 1) == 0) {
            hashmap_put(map_handle, "a", 1, 10 + t);
        } else {
            hashmap_put(map_handle, "b", 1, 20 + t);
        }
    }
    var map_sum: i64 = hashmap_get(map_handle, "a", 1) + hashmap_get(map_handle, "b", 1);
    if (map_sum != 39) { return 9; }

    // Assertion
    return 0;
}
