// ssa_mem2reg_df.b - Dominance Frontier computation (v3_17)
//
// DF 계산: 다중 predecessor 블록 b에 대해,
// 각 pred에서 idom[b]까지 거슬러 올라가며 runner의 DF에 b를 추가.

import std.io;
import std.util;
import ssa.datastruct;
import ssa.core;

const MEM2REG_DF_DEBUG = 0;

func ssa_mem2reg_compute_df(fn: *SSAFunction) -> u64 {
    push_trace("ssa_mem2reg_compute_df", "ssa_mem2reg_df.b", __LINE__);
    defer pop_trace();
    if (fn == 0) { return 0; }

    var blocks: []*SSABlock = fn->blocks;
    var n: u64 = ssa_slice_len(blocks);
    for (var i: u64 = 0; i < n; i++) {
        var b: *SSABlock = blocks[i];

        if (ssa_slice_len(b->preds) < 2) {
            continue;
        }

        var idom_b: *SSABlock = b->dom_parent;
        var preds: []*SSABlock = b->preds;
        var pcount: u64 = ssa_slice_len(preds);
        for (var j: u64 = 0; j < pcount; j++) {
            var runner: *SSABlock = preds[j];

            while (runner != 0 && runner != idom_b) {
                ssa_block_add_df(runner, b);
                runner = runner->dom_parent;
            }
        }
    }

    if (MEM2REG_DF_DEBUG != 0) {
        println("[DEBUG] ssa_mem2reg_compute_df: done", 41);
    }
    return 0;
}

func ssa_mem2reg_run_df(ctx: *SSAContext) -> u64 {
    push_trace("ssa_mem2reg_run_df", "ssa_mem2reg_df.b", __LINE__);
    defer pop_trace();
    if (ctx == 0) { return 0; }
    var funcs: []*SSAFunction = ctx->funcs;
    var n: u64 = ssa_slice_len(funcs);
    for (var i: u64 = 0; i < n; i++) {
        ssa_mem2reg_compute_df(funcs[i]);
    }
    return 0;
}
