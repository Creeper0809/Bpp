// ssa_dump.b - SSA/3addr 텍스트 덤프 (v3_17)

import std.io;
import std.util;
import std.vec;
import ssa.datastruct;
import ssa.core;

func _ssa_dump_op_name(op: u64) -> u64 {
    push_trace("_ssa_dump_op_name", "ssa_dump.b", __LINE__);
    defer pop_trace();
    switch (op) {
        case SSA_OP_NOP: emit("nop"); return 0;
        case SSA_OP_ENTRY: emit("entry"); return 0;
        case SSA_OP_PHI: emit("phi"); return 0;
        case SSA_OP_CONST: emit("const"); return 0;
        case SSA_OP_FCONST: emit("fconst"); return 0;
        case SSA_OP_ADD: emit("add"); return 0;
        case SSA_OP_SUB: emit("sub"); return 0;
        case SSA_OP_MUL: emit("mul"); return 0;
        case SSA_OP_DIV: emit("div"); return 0;
        case SSA_OP_FADD: emit("fadd"); return 0;
        case SSA_OP_FSUB: emit("fsub"); return 0;
        case SSA_OP_FMUL: emit("fmul"); return 0;
        case SSA_OP_FDIV: emit("fdiv"); return 0;
        case SSA_OP_FNEG: emit("fneg"); return 0;
        case SSA_OP_FEQ: emit("feq"); return 0;
        case SSA_OP_FNE: emit("fne"); return 0;
        case SSA_OP_FLT: emit("flt"); return 0;
        case SSA_OP_FGT: emit("fgt"); return 0;
        case SSA_OP_FLE: emit("fle"); return 0;
        case SSA_OP_FGE: emit("fge"); return 0;
        case SSA_OP_EQ: emit("eq"); return 0;
        case SSA_OP_NE: emit("ne"); return 0;
        case SSA_OP_LT: emit("lt"); return 0;
        case SSA_OP_GT: emit("gt"); return 0;
        case SSA_OP_LE: emit("le"); return 0;
        case SSA_OP_GE: emit("ge"); return 0;
        case SSA_OP_MOD: emit("mod"); return 0;
        case SSA_OP_AND: emit("and"); return 0;
        case SSA_OP_OR: emit("or"); return 0;
        case SSA_OP_XOR: emit("xor"); return 0;
        case SSA_OP_SHL: emit("shl"); return 0;
        case SSA_OP_SHR: emit("shr"); return 0;
        case SSA_OP_LOAD: emit("load"); return 0;
        case SSA_OP_STORE: emit("store"); return 0;
        case SSA_OP_PARAM: emit("param"); return 0;
        case SSA_OP_CALL: emit("call"); return 0;
        case SSA_OP_CALL_PTR: emit("call_ptr"); return 0;
        case SSA_OP_JMP: emit("jmp"); return 0;
        case SSA_OP_BR: emit("br"); return 0;
        case SSA_OP_RET: emit("ret"); return 0;
        case SSA_OP_RET_SLICE_HEAP: emit("ret_slice_heap"); return 0;
        case SSA_OP_COPY: emit("copy"); return 0;
        case SSA_OP_LEA_STR: emit("lea_str"); return 0;
        case SSA_OP_LEA_LOCAL: emit("lea_local"); return 0;
        case SSA_OP_LEA_GLOBAL: emit("lea_global"); return 0;
        case SSA_OP_LEA_FUNC: emit("lea_func"); return 0;
        case SSA_OP_LOAD8: emit("load8"); return 0;
        case SSA_OP_LOAD16: emit("load16"); return 0;
        case SSA_OP_LOAD32: emit("load32"); return 0;
        case SSA_OP_LOAD64: emit("load64"); return 0;
        case SSA_OP_STORE8: emit("store8"); return 0;
        case SSA_OP_STORE16: emit("store16"); return 0;
        case SSA_OP_STORE32: emit("store32"); return 0;
        case SSA_OP_STORE64: emit("store64"); return 0;
        case SSA_OP_STORE_SLICE: emit("store_slice"); return 0;
        case SSA_OP_ASM: emit("asm"); return 0;
        case SSA_OP_CALL_SLICE_STORE: emit("call_slice_store"); return 0;
    }
    emit("op");
    return 0;
}

func _ssa_dump_operand(opr: u64) -> u64 {
    push_trace("_ssa_dump_operand", "ssa_dump.b", __LINE__);
    defer pop_trace();
    if (ssa_operand_is_const(opr) != 0) {
        emit("#");
        emit_u64(ssa_operand_value(opr));
        return 0;
    }
    emit("r");
    emit_u64(ssa_operand_value(opr));
    return 0;
}

func _ssa_dump_inst(inst: *SSAInstruction) -> u64 {
    push_trace("_ssa_dump_inst", "ssa_dump.b", __LINE__);
    defer pop_trace();
    var op: u64 = ssa_inst_get_op(inst);
    if (op == SSA_OP_NOP || op == SSA_OP_ENTRY) { return 0; }

    if (op == SSA_OP_RET) {
        emit("  ret ");
        if (inst.src1 != 0) {
            _ssa_dump_operand(inst.src1);
        }
        if (inst.src2 != 0) {
            emit(", ");
            _ssa_dump_operand(inst.src2);
        }
        emit_nl();
        return 0;
    }
    if (op == SSA_OP_RET_SLICE_HEAP) {
        emit("  ret_slice_heap ");
        if (inst.dest != 0) {
            _ssa_dump_operand(inst.dest);
        }
        emit(", ");
        _ssa_dump_operand(inst.src1);
        emit(", ");
        _ssa_dump_operand(inst.src2);
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_JMP) {
        emit("  jmp b");
        emit_u64(ssa_operand_value(inst.src1));
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_BR) {
        emit("  br ");
        _ssa_dump_operand(inst.src1);
        emit(" ? b");
        emit_u64(ssa_operand_value(inst.src2));
        emit(" : b");
        emit_u64(ssa_operand_value(inst.dest));
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_CALL_PTR) {
        var info_ptr2: u64 = ssa_operand_value(inst.src1);
        var info2: *SSACallPtrInfo = (*SSACallPtrInfo)info_ptr2;
        var callee_reg: u64 = info2.callee_reg;
        var args_vec2: *Vec<u64> = info2.args_vec;
        var nargs2: u64 = info2.nargs;
        if (nargs2 == 0 && args_vec2 != 0) { nargs2 = args_vec2.len(); }
        emit("  r");
        emit_u64(inst.dest);
        if (inst.src2 != 0 && ssa_operand_is_const(inst.src2) == 0) {
            emit(", r");
            emit_u64(ssa_operand_value(inst.src2));
        }
        emit(" = call_ptr r");
        emit_u64(callee_reg);
        emit("(");
        for (var i2: u64 = 0; i2 < nargs2; i2++) {
            if (i2 > 0) { emit(", "); }
            emit("r");
            emit_u64(args_vec2.get(i2));
        }
        emit(")\n");
        return 0;
    }

    if (op == SSA_OP_CALL_SLICE_STORE) {
        var info_ptrs: u64 = ssa_operand_value(inst.src1);
        var info_s: *SSACallSliceStoreInfo = (*SSACallSliceStoreInfo)info_ptrs;
        if (info_s.is_ptr > 1) {
            var info_call: *SSACallInfo = (*SSACallInfo)info_ptrs;
            var name_ptrs: u64 = info_call.name_ptr;
            var name_lens: u64 = info_call.name_len;
            var args_vecs: *Vec<u64> = info_call.args_vec;
            var nargss: u64 = info_call.nargs;
            if (nargss == 0 && args_vecs != 0) { nargss = args_vecs.len(); }
            emit("  call_slice_store ");
            print(name_ptrs, name_lens);
            emit("(");
            for (var is: u64 = 0; is < nargss; is++) {
                if (is > 0) { emit(", "); }
                emit("r");
                emit_u64(args_vecs.get(is));
            }
            emit(")\n");
        } else {
            var args_vecs2: *Vec<u64> = info_s.args_vec;
            var nargss2: u64 = info_s.nargs;
            if (nargss2 == 0 && args_vecs2 != 0) { nargss2 = args_vecs2.len(); }
            emit("  call_slice_store ");
            if (info_s.is_ptr != 0) {
                emit("r");
                emit_u64(info_s.callee_reg);
            } else {
                print(info_s.name_ptr, info_s.name_len);
            }
            emit("(");
            for (var is2: u64 = 0; is2 < nargss2; is2++) {
                if (is2 > 0) { emit(", "); }
                emit("r");
                emit_u64(args_vecs2.get(is2));
            }
            emit(")\n");
        }
        return 0;
    }

    if (op == SSA_OP_CALL) {
        var info_ptr: u64 = ssa_operand_value(inst.src1);
        var info: *SSACallInfo = (*SSACallInfo)info_ptr;
        var name_ptr: u64 = info.name_ptr;
        var name_len: u64 = info.name_len;
        var args_vec: *Vec<u64> = info.args_vec;
        var nargs: u64 = info.nargs;
        if (nargs == 0 && args_vec != 0) { nargs = args_vec.len(); }
        emit("  r");
        emit_u64(inst.dest);
        if (inst.src2 != 0 && ssa_operand_is_const(inst.src2) == 0) {
            emit(", r");
            emit_u64(ssa_operand_value(inst.src2));
        }
        emit(" = call ");
        print(name_ptr, name_len);
        emit("(");
        for (var i: u64 = 0; i < nargs; i++) {
            if (i > 0) { emit(", "); }
            emit("r");
            emit_u64(args_vec.get(i));
        }
        emit(")\n");
        return 0;
    }

    emit("  r");
    emit_u64(inst.dest);
    emit(" = ");
    _ssa_dump_op_name(op);

    if (op == SSA_OP_CONST || op == SSA_OP_COPY || op == SSA_OP_PARAM) {
        emit(" ");
        _ssa_dump_operand(inst.src1);
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_LOAD || op == SSA_OP_STORE) {
        emit(" ");
        _ssa_dump_operand(inst.src1);
        if (op == SSA_OP_STORE) {
            emit(", ");
            _ssa_dump_operand(inst.src2);
        }
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_STORE_SLICE) {
        emit(" ");
        _ssa_dump_operand(inst.src1);
        emit_nl();
        return 0;
    }

    emit(" ");
    _ssa_dump_operand(inst.src1);
    emit(", ");
    _ssa_dump_operand(inst.src2);
    emit_nl();
    return 0;
}

func _ssa_dump_phi(phi: *SSAInstruction) -> u64 {
    push_trace("_ssa_dump_phi", "ssa_dump.b", __LINE__);
    defer pop_trace();
    emit("  r");
    emit_u64(phi.dest);
    emit(" = phi");
    var arg: *SSAPhiArg = (*SSAPhiArg)phi.src1;
    while (arg != 0) {
        emit(" (b");
        emit_u64(arg.block_id);
        emit(", r");
        emit_u64(arg.val);
        emit(")");
        arg = arg.next;
    }
    emit_nl();
    return 0;
}

func ssa_dump_ctx(ctx: *SSAContext, with_phi: u64) -> u64 {
    push_trace("ssa_dump_ctx", "ssa_dump.b", __LINE__);
    defer pop_trace();
    if (ctx == 0) { return 0; }
    var funcs: []*SSAFunction = ctx.funcs;
    var n: u64 = ssa_slice_len(funcs);
    for (var i: u64 = 0; i < n; i++) {
        var fn: *SSAFunction = funcs[i];

        emit("func ");
        print(fn.name_ptr, fn.name_len);
        emit_nl();

        var blocks: []*SSABlock = fn.blocks;
        var bcount: u64 = ssa_slice_len(blocks);
        for (var bi: u64 = 0; bi < bcount; bi++) {
            var b: *SSABlock = blocks[bi];

            emit("b");
            emit_u64(b.id);
            emit(":\n");

            if (with_phi != 0) {
                var phi: *SSAInstruction = b.phi_head;
                while (phi != 0) {
                    _ssa_dump_phi(phi);
                    phi = phi.next;
                }
            }

            var cur: *SSAInstruction = b.inst_head;
            while (cur != 0) {
                _ssa_dump_inst(cur);
                cur = cur.next;
            }

        }
    }
    return 0;
}
