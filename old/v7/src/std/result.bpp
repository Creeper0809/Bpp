// result.bpp - Result<T, E>
//
// Provides a minimal Result<T, E> type for error propagation.
// Layout: [is_ok: u64][ok: T][err: E]
//
// Notes:
// - When is_ok == 1, err must not be read.
// - When is_ok == 0, ok must not be read.

import std.io;

struct Result<T, E> {
    is_ok: u64;
    ok: T;
    err: E;
}

func Result_ok<T, E>(val: T) -> Result<T, E> {
    var r: Result<T, E>;
    r.is_ok = 1;
    r.ok = val;
    return r;
}

func Result_err<T, E>(err_val: E) -> Result<T, E> {
    var r: Result<T, E>;
    r.is_ok = 0;
    r.err = err_val;
    return r;
}

impl Result {
    func is_ok<T, E>(self: *Result<T, E>) -> u64 {
        return self.is_ok;
    }

    func is_err<T, E>(self: *Result<T, E>) -> u64 {
        if (self.is_ok == 0) { return true; }
        return false;
    }

    func unwrap<T, E>(self: *Result<T, E>) -> T {
        if (self.is_ok == 0) {
            emit_stderr_len("[ERROR] Result.unwrap on Err\n", 32);
            panic("Result unwrap");
        }
        return self.ok;
    }

    func unwrap_err<T, E>(self: *Result<T, E>) -> E {
        if (self.is_ok != 0) {
            emit_stderr_len("[ERROR] Result.unwrap_err on Ok\n", 35);
            panic("Result unwrap_err");
        }
        return self.err;
    }

    func unwrap_or<T, E>(self: *Result<T, E>, default_val: T) -> T {
        if (self.is_ok == 0) { return default_val; }
        return self.ok;
    }
}
