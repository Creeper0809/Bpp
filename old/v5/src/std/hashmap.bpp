// hashmap.b - Hash map implementation for v3.8

import std.io;
import std.str;

// HashMap<K, V> structure: [entries_ptr, capacity, count]
// Entry: [key_ptr, key_len, hash, used, value]

struct HashMap<K, V> {
    entries_ptr: u64;
    capacity: u64;
    count: u64;
}

struct HashEntry<V> {
    key_ptr: u64;
    key_len: u64;
    hash: u64;
    used: u64;
    value: V;
}

impl HashMap {
    func entry_size<K, V>() -> u64 {
        var base_size: u64 = 4 * sizeof(u64);
        return base_size + sizeof(V);
    }

    func ensure_capacity<K, V>(self: *HashMap<K, V>, min_cap: u64) -> u64 {
        // Defensive guard for bootstrap runtimes: ensure capacity is non-zero
        // before any hash/modulo operation is performed.
        if (self->capacity != 0) { return 0; }

        var cap: u64 = 16;
        for (; cap < min_cap; cap = cap * 2) {
        }
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var bytes: u64 = cap * entry_bytes;
        var entries: u64 = heap_alloc(bytes);
        var entries_u8: *u8 = (*u8)entries;

        for (var i: u64 = 0; i < bytes; i++) {
            entries_u8[i] = 0;
        }

        self->entries_ptr = entries;
        self->capacity = cap;
        self->count = 0;
        return 0;
    }

    func hash(key_ptr: u64, key_len: u64) -> u64 {
        var hash: u64 = 0;
        var key_u8: *u8 = (*u8)key_ptr;
        for (var i: u64 = 0; i < key_len; i++) {
            hash = hash ^ key_u8[i];
            hash = hash * 31;
        }
        return hash;
    }

    static func new<K, V>(capacity: u64) -> *HashMap<K, V> {
        var cap: u64 = 16;
        for (; cap < capacity; cap = cap * 2) {
        }
        var map: *HashMap<K, V> = new HashMap<K, V>{};
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var bytes: u64 = cap * entry_bytes;
        var entries: u64 = heap_alloc(bytes);
        var entries_u8: *u8 = (*u8)entries;

        for (var i: u64 = 0; i < bytes; i++) {
            entries_u8[i] = 0;
        }

        map->entries_ptr = entries;
        map->capacity = cap;
        map->count = 0;
        return map;
    }

    func entry_ptr<K, V>(entries: u64, idx: u64) -> *HashEntry<V> {
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        return (*HashEntry<V>)(entries + idx * entry_bytes);
    }

    func put_internal<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        if (self->capacity == 0) {
            self->ensure_capacity(16);
        }
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                entry->key_ptr = key_ptr;
                entry->key_len = key_len;
                entry->hash = hash;
                entry->used = 1;
                var dst: u64 = (u64)&entry->value;
                var src: u64 = (u64)&value;
                var elem_size: u64 = sizeof(V);
                var dst_u8: *u8 = (*u8)dst;
                var src_u8: *u8 = (*u8)src;
                for (var j: u64 = 0; j < elem_size; j++) {
                    dst_u8[j] = src_u8[j];
                }
                self->count = self->count + 1;
                return 0;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func grow<K, V>(self: *HashMap<K, V>) -> u64 {
        var old_entries: u64 = self->entries_ptr;
        var old_cap: u64 = self->capacity;

        if (old_cap == 0) {
            self->ensure_capacity(16);
            return 0;
        }

        var new_cap: u64 = old_cap * 2;
        var entry_bytes: u64 = HashMap.entry_size<K, V>();
        var new_bytes: u64 = new_cap * entry_bytes;
        var new_entries: u64 = heap_alloc(new_bytes);
        var new_entries_u8: *u8 = (*u8)new_entries;

        for (var i: u64 = 0; i < new_bytes; i++) {
            new_entries_u8[i] = 0;
        }

        self->entries_ptr = new_entries;
        self->capacity = new_cap;
        self->count = 0;

        for (var i: u64 = 0; i < old_cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(old_entries, i);
            var used: u64 = entry->used;
            if (used != 0) {
                var kp: u64 = entry->key_ptr;
                var kl: u64 = entry->key_len;
                var val: V;
                var srcv: u64 = (u64)&entry->value;
                var dstv: u64 = (u64)&val;
                var elem_size: u64 = sizeof(V);
                var srcv_u8: *u8 = (*u8)srcv;
                var dstv_u8: *u8 = (*u8)dstv;
                for (var j: u64 = 0; j < elem_size; j++) {
                    dstv_u8[j] = srcv_u8[j];
                }
                self->put_internal(kp, kl, val);
            }
        }
        return 0;
    }

    func put<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64, value: V) -> u64 {
        if (self->capacity == 0) {
            self->ensure_capacity(16);
        }
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        var count: u64 = self->count;

        if (count * 10 >= cap * 7) {
            self->grow();
            entries = self->entries_ptr;
            cap = self->capacity;
        }

        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                entry->key_ptr = key_ptr;
                entry->key_len = key_len;
                entry->hash = hash;
                entry->used = 1;
                var dst2: u64 = (u64)&entry->value;
                var src2: u64 = (u64)&value;
                var elem_size2: u64 = sizeof(V);
                var dst2_u8: *u8 = (*u8)dst2;
                var src2_u8: *u8 = (*u8)src2;
                for (var j2: u64 = 0; j2 < elem_size2; j2++) {
                    dst2_u8[j2] = src2_u8[j2];
                }
                self->count = self->count + 1;
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                var dst3: u64 = (u64)&entry->value;
                var src3: u64 = (u64)&value;
                var elem_size3: u64 = sizeof(V);
                var dst3_u8: *u8 = (*u8)dst3;
                var src3_u8: *u8 = (*u8)src3;
                for (var j3: u64 = 0; j3 < elem_size3; j3++) {
                    dst3_u8[j3] = src3_u8[j3];
                }
                return 0;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func get<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> V {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        if (cap == 0) { return 0; }
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                return 0;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                var out: V;
                var src4: u64 = (u64)&entry->value;
                var dst4: u64 = (u64)&out;
                var elem_size4: u64 = sizeof(V);
                var src4_u8: *u8 = (*u8)src4;
                var dst4_u8: *u8 = (*u8)dst4;
                for (var j4: u64 = 0; j4 < elem_size4; j4++) {
                    dst4_u8[j4] = src4_u8[j4];
                }
                return out;
            }

            idx = (idx + 1) % cap;
        }
        return 0;
    }

    func has<K, V>(self: *HashMap<K, V>, key_ptr: u64, key_len: u64) -> u64 {
        var entries: u64 = self->entries_ptr;
        var cap: u64 = self->capacity;
        if (cap == 0) { return false; }
        var hash: u64 = HashMap.hash(key_ptr, key_len);
        var idx: u64 = hash % cap;

        for (var i: u64 = 0; i < cap; i++) {
            var entry: *HashEntry<V> = HashMap.entry_ptr<K, V>(entries, idx);
            var used: u64 = entry->used;

            if (used == 0) {
                return false;
            }

            var kp: u64 = entry->key_ptr;
            var kl: u64 = entry->key_len;
            if (str_eq(kp, kl, key_ptr, key_len)) {
                return true;
            }

            idx = (idx + 1) % cap;
        }
        return false;
    }
}

