// Covers: functions, recursion, function pointer (stress)
// Expect exit code: 0

func add(a: i64, b: i64) -> i64 {
    return a + b;
}

func sub(a: i64, b: i64) -> i64 {
    return a - b;
}

func fib(n: i64) -> i64 {
    if (n <= 1) { return n; }
    return fib(n - 1) + fib(n - 2);
}

func tri(n: i64) -> i64 {
    if (n <= 0) { return 0; }
    return n + tri(n - 1);
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var fp: u64 = &add;
    var stress_sum: i64 = 0;

    // Execution
    var direct: i64 = add(7, 8);
    if (direct != 15) { return 1; }

    var via_ptr: i64 = fp(9, 1);
    if (via_ptr != 10) { return 2; }

    var recur: i64 = fib(6);
    if (recur != 8) { return 3; }

    var forward: i64 = forward_sum(20, 22);
    if (forward != 42) { return 4; }

    // Stress: 반복 함수 포인터 호출
    for (var i: i64 = 0; i < 1000; i = i + 1) {
        stress_sum = stress_sum + fp(1, 2);
    }
    if (stress_sum != 3000) { return 5; }

    // Stress: 재귀 깊이 확인
    var recur_big: i64 = fib(10);
    if (recur_big != 55) { return 6; }

    // Complex: function pointer selection + recursion mix
    var fp_add: u64 = &add;
    var fp_sub: u64 = &sub;
    var combo: i64 = 0;
    for (var i: i64 = 0; i < 10; i = i + 1) {
        var op: u64 = fp_add;
        if ((i & 1) == 1) { op = fp_sub; }
        combo = combo + op(i, 2);
        if (i == 5) { combo = combo + fib(5); }
    }
    if (combo != 50) { return 7; }

    var tri_sum: i64 = tri(8);
    if (tri_sum != 36) { return 8; }

    // Assertion
    return 0;
}

func forward_sum(a: i64, b: i64) -> i64 {
    return a + b;
}
