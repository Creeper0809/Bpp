// Covers: defer block order + break/continue/return paths
// Expect exit code: 0

func test_block_order() -> i64 {
    // Setup
    var x: i64 = 0;

    // Execution
    if (1) {
        defer x = x + 1;
        defer x = x + 2;
        x = x + 3;
    }

    // Assertion
    return x;
}

func test_continue_path() -> i64 {
    // Setup
    var sum: i64 = 0;

    // Execution
    for (var i: i64 = 0; i < 4; i = i + 1) {
        defer sum = sum + 10;
        if (i == 1) {
            continue;
        }
        sum = sum + 1;
    }

    // Assertion
    return sum;
}

func test_break_path() -> i64 {
    // Setup
    var sum: i64 = 0;

    // Execution
    for (var i: i64 = 0; i < 4; i = i + 1) {
        defer sum = sum + 10;
        if (i == 2) {
            break;
        }
        sum = sum + 1;
    }

    // Assertion
    return sum;
}

func test_return_path() -> i64 {
    // Setup
    var sum: i64 = 0;

    // Execution
    if (1) {
        defer sum = sum + 5;
        return sum;
    }

    // Assertion
    return sum;
}

func add_to(sum: *i64, v: i64) -> i64 {
    // Setup

    // Execution
    *sum = *sum + v;

    // Assertion
    return 0;
}

func test_defer_call() -> i64 {
    // Setup
    var sum: i64 = 1;

    // Execution
    if (1) {
        defer add_to(&sum, 7);
        sum = sum + 2;
    }

    // Assertion
    return sum;
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var v0: i64 = test_block_order();
    var v1: i64 = test_continue_path();
    var v2: i64 = test_break_path();
    var v3: i64 = test_return_path();
    var v4: i64 = test_defer_call();

    // Assertion
    if (v0 != 6) { return 1; }
    if (v1 != 43) { return 2; }
    if (v2 != 32) { return 3; }
    if (v3 != 5) { return 4; }
    if (v4 != 10) { return 5; }
    return 0;
}
