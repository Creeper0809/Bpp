// ssa_destroy.b - SSA destruction (v3_17)
//
// Phi 제거: 각 Phi의 인자를 predecessor에 COPY로 낮추고, Phi 리스트를 제거합니다.

import std.vec;
import std.util;
import ssa.datastruct;
import ssa.core;

func _ssa_destroy_find_pred(block: *SSABlock, pred_id: u64) -> *SSABlock {
    push_trace("_ssa_destroy_find_pred", "ssa_destroy.b", __LINE__);
    var preds: []*SSABlock = block->preds;
    var n: u64 = ssa_slice_len(preds);
    for (var i: u64 = 0; i < n; i++) {
        var p: *SSABlock = preds[i];
        if (p->id == pred_id) { pop_trace(); return p; }
    }
    pop_trace();
    return 0;
}

func _ssa_destroy_get_split(map_pred: *Vec<*SSABlock>, map_block: *Vec<*SSABlock>, pred: *SSABlock, block: *SSABlock) -> *SSABlock {
    push_trace("_ssa_destroy_get_split", "ssa_destroy.b", __LINE__);
    var n: u64 = map_pred->len();
    for (var i: u64 = 0; i < n; i++) {
        var p_ptr: *SSABlock = map_pred->get(i);
        if (p_ptr == pred) {
            var b_ptr: *SSABlock = map_block->get(i);
            pop_trace();
            return b_ptr;
        }
    }
    pop_trace();
    return 0;
}

func ssa_destroy_block(ctx: *SSAContext, fn: *SSAFunction, block: *SSABlock) -> u64 {
    push_trace("ssa_destroy_block", "ssa_destroy.b", __LINE__);
    var split_pred: *Vec<*SSABlock> = Vec.new<*SSABlock>(4);
    var split_block: *Vec<*SSABlock> = Vec.new<*SSABlock>(4);

    var phi: *SSAInstruction = block->phi_head;
    while (phi != 0) {
        var args: *SSAPhiArg = (*SSAPhiArg)phi->src1;
        while (args != 0) {
            var pred: *SSABlock = _ssa_destroy_find_pred(block, args->block_id);
            if (pred != 0) {
                var critical: u64 = 0;
                if (ssa_slice_len(pred->succs) >= 2 && ssa_slice_len(block->preds) >= 2) { critical = 1; }

                if (critical == 1) {
                    var split: *SSABlock = _ssa_destroy_get_split(split_pred, split_block, pred, block);
                    if (split == 0) {
                        split = ssa_new_block(ctx, fn);

                        ssa_block_replace_succ(pred, block, split);
                        ssa_block_replace_pred(block, pred, split);
                        ssa_block_add_pred(split, pred);
                        ssa_block_add_succ(split, block);

                        split_pred->push(pred);
                        split_block->push(split);
                    }

                    var inst_ptr: *SSAInstruction = ssa_new_inst(ctx, SSA_OP_COPY, phi->dest, ssa_operand_reg(args->val), 0);
                    ssa_inst_insert_before_terminator(split, inst_ptr);
                } else {
                    var inst_ptr2: *SSAInstruction = ssa_new_inst(ctx, SSA_OP_COPY, phi->dest, ssa_operand_reg(args->val), 0);
                    ssa_inst_insert_before_terminator(pred, inst_ptr2);
                }
            }
            args = args->next;
        }
        phi = phi->next;
    }

    block->phi_head = 0;
    pop_trace();
    return 0;
}

func ssa_destroy_run(ctx: *SSAContext) -> u64 {
    push_trace("ssa_destroy_run", "ssa_destroy.b", __LINE__);
    if (ctx == 0) { pop_trace(); return 0; }
    var funcs: []*SSAFunction = ctx->funcs;
    var n: u64 = ssa_slice_len(funcs);
    for (var i: u64 = 0; i < n; i++) {
        var fn: *SSAFunction = funcs[i];

        var blocks: []*SSABlock = fn->blocks;
        var bcount: u64 = ssa_slice_len(blocks);
        for (var bi: u64 = 0; bi < bcount; bi++) {
            ssa_destroy_block(ctx, fn, blocks[bi]);
        }
    }
    pop_trace();
    return 0;
}
