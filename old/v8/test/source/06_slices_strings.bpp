// Covers: slices, indexing, assignment, string literal, slice return (stress)
// Expect exit code: 0

func make_slice() -> []u8 {
    return slice("XYZ", 3);
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var slice_data: []u8 = slice("ABCD", 4);
    var slice_alias: []u8 = slice_data;
    var sum: i64 = 0;
    var ret_slice: []u8 = make_slice();

    // Execution
    if (slice_data[0] != 65) { return 1; }
    if (slice_data[1] != 66) { return 2; }
    if (slice_data[2] != 67) { return 3; }
    if (slice_data[3] != 68) { return 4; }

    if (slice_alias[2] != 67) { return 5; }
    if (ret_slice[0] != 88) { return 6; }
    if (ret_slice[1] != 89) { return 7; }
    if (ret_slice[2] != 90) { return 8; }

    // Stress: 반복 인덱싱 합산
    for (var i: i64 = 0; i < 4; i = i + 1) {
        sum = sum + slice_data[i];
    }
    if (sum != 266) { return 9; }

    // Complex: mixed indexing + conditional aggregation
    var complex_sum: i64 = 0;
    for (var i: i64 = 0; i < 4; i = i + 1) {
        var v: i64 = slice_data[i];
        if ((i & 1) == 0) {
            complex_sum = complex_sum + v;
        } else {
            complex_sum = complex_sum - v;
        }
        if (i < 3) {
            complex_sum = complex_sum + ret_slice[i];
        }
    }
    if (complex_sum != 265) { return 10; }

    var alias_sum: i64 = 0;
    for (var j: i64 = 0; j < 3; j = j + 1) {
        if (slice_alias[j] > 66) {
            alias_sum = alias_sum + 1;
        } else {
            alias_sum = alias_sum + 2;
        }
    }
    if (alias_sum != 5) { return 11; }

    // Assertion
    return 0;
}
