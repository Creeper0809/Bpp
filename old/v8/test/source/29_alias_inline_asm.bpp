// Covers: inline asm register alias (basic + stress + complex)
// Expect exit code: 0

func asm_alias_basic() -> i64 {
    // Setup
    var out: i64 = 0;
    alias rax: result;

    // Execution
    asm {
        mov result, 7
        mov [rbp-8], result
    }

    // Assertion
    return out;
}

func asm_alias_scratch() -> i64 {
    // Setup
    var out: i64 = 0;
    alias r10: scratch;

    // Execution
    asm {
        mov scratch, 3
        mov [rbp-8], scratch
    }

    // Assertion
    return out;
}

func asm_alias_work() -> i64 {
    // Setup
    var out: i64 = 0;
    alias r11: work;

    // Execution
    asm {
        mov work, 5
        mov [rbp-8], work
    }

    // Assertion
    return out;
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var v: i64 = 0;
    var sum: i64 = 0;

    // Execution
    v = asm_alias_basic();
    if (v != 7) { return 1; }

    // Stress: 반복 인라인 asm 호출
    for (var i: i64 = 0; i < 1000; i = i + 1) {
        sum = sum + asm_alias_scratch();
    }
    if (sum != 3000) { return 2; }

    // Complex: branch-dependent aggregation with alias values
    var complex_sum: i64 = 0;
    for (var k: i64 = 0; k < 20; k = k + 1) {
        var v0: i64 = asm_alias_work();
        if ((k & 1) == 0) {
            complex_sum = complex_sum + v0;
        } else {
            complex_sum = complex_sum - (v0 - 2);
        }
    }
    if (complex_sum != 20) { return 3; }

    // Assertion
    return 0;
}
