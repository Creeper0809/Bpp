// ssa_dump.b - SSA/3addr 텍스트 덤프 (v3_17)

import std.io;
import std.util;
import std.vec;
import ssa.datastruct;
import ssa.core;

func _ssa_dump_op_name(op: u64) -> u64 {
    push_trace("_ssa_dump_op_name", "ssa_dump.b", __LINE__);
    defer pop_trace();
    switch (op) {
        case SSA_OP_NOP: emit("nop"); return 0;
        case SSA_OP_ENTRY: emit("entry"); return 0;
        case SSA_OP_PHI: emit("phi"); return 0;
        case SSA_OP_CONST: emit("const"); return 0;
        case SSA_OP_FCONST: emit("fconst"); return 0;
        case SSA_OP_ADD: emit("add"); return 0;
        case SSA_OP_SUB: emit("sub"); return 0;
        case SSA_OP_MUL: emit("mul"); return 0;
        case SSA_OP_DIV: emit("div"); return 0;
        case SSA_OP_FADD: emit("fadd"); return 0;
        case SSA_OP_FSUB: emit("fsub"); return 0;
        case SSA_OP_FMUL: emit("fmul"); return 0;
        case SSA_OP_FDIV: emit("fdiv"); return 0;
        case SSA_OP_FNEG: emit("fneg"); return 0;
        case SSA_OP_FEQ: emit("feq"); return 0;
        case SSA_OP_FNE: emit("fne"); return 0;
        case SSA_OP_FLT: emit("flt"); return 0;
        case SSA_OP_FGT: emit("fgt"); return 0;
        case SSA_OP_FLE: emit("fle"); return 0;
        case SSA_OP_FGE: emit("fge"); return 0;
        case SSA_OP_UDIV: emit("udiv"); return 0;
        case SSA_OP_UMOD: emit("umod"); return 0;
        case SSA_OP_ULT: emit("ult"); return 0;
        case SSA_OP_UGT: emit("ugt"); return 0;
        case SSA_OP_ULE: emit("ule"); return 0;
        case SSA_OP_UGE: emit("uge"); return 0;
        case SSA_OP_I2F: emit("i2f"); return 0;
        case SSA_OP_U2F: emit("u2f"); return 0;
        case SSA_OP_F2I: emit("f2i"); return 0;
        case SSA_OP_F2U: emit("f2u"); return 0;
        case SSA_OP_EQ: emit("eq"); return 0;
        case SSA_OP_NE: emit("ne"); return 0;
        case SSA_OP_LT: emit("lt"); return 0;
        case SSA_OP_GT: emit("gt"); return 0;
        case SSA_OP_LE: emit("le"); return 0;
        case SSA_OP_GE: emit("ge"); return 0;
        case SSA_OP_MOD: emit("mod"); return 0;
        case SSA_OP_AND: emit("and"); return 0;
        case SSA_OP_OR: emit("or"); return 0;
        case SSA_OP_XOR: emit("xor"); return 0;
        case SSA_OP_SHL: emit("shl"); return 0;
        case SSA_OP_SHR: emit("shr"); return 0;
        case SSA_OP_SAR: emit("sar"); return 0;
        case SSA_OP_LOAD: emit("load"); return 0;
        case SSA_OP_STORE: emit("store"); return 0;
        case SSA_OP_PARAM: emit("param"); return 0;
        case SSA_OP_CALL: emit("call"); return 0;
        case SSA_OP_CALL_PTR: emit("call_ptr"); return 0;
        case SSA_OP_JMP: emit("jmp"); return 0;
        case SSA_OP_BR: emit("br"); return 0;
        case SSA_OP_RET: emit("ret"); return 0;
        case SSA_OP_RET_SLICE_HEAP: emit("ret_slice_heap"); return 0;
        case SSA_OP_COPY: emit("copy"); return 0;
        case SSA_OP_LEA_STR: emit("lea_str"); return 0;
        case SSA_OP_LEA_LOCAL: emit("lea_local"); return 0;
        case SSA_OP_LEA_GLOBAL: emit("lea_global"); return 0;
        case SSA_OP_LEA_FUNC: emit("lea_func"); return 0;
        case SSA_OP_LOAD8: emit("load8"); return 0;
        case SSA_OP_LOAD16: emit("load16"); return 0;
        case SSA_OP_LOAD32: emit("load32"); return 0;
        case SSA_OP_LOAD64: emit("load64"); return 0;
        case SSA_OP_STORE8: emit("store8"); return 0;
        case SSA_OP_STORE16: emit("store16"); return 0;
        case SSA_OP_STORE32: emit("store32"); return 0;
        case SSA_OP_STORE64: emit("store64"); return 0;
        case SSA_OP_STORE_SLICE: emit("store_slice"); return 0;
        case SSA_OP_ASM: emit("asm"); return 0;
        case SSA_OP_CALL_SLICE_STORE: emit("call_slice_store"); return 0;
    }
    emit("op");
    return 0;
}

func _ssa_dump_operand(opr: u64) -> u64 {
    push_trace("_ssa_dump_operand", "ssa_dump.b", __LINE__);
    defer pop_trace();
    if (ssa_operand_is_const(opr) != 0) {
        emit("#");
        emit_u64(ssa_operand_value(opr));
        return 0;
    }
    emit("r");
    emit_u64(ssa_operand_value(opr));
    return 0;
}

func _ssa_dump_call_ret_regs(inst: *SSAInstruction) -> u64 {
    emit("  r");
    emit_u64(inst.dest);
    if (inst.src2 != 0 && ssa_operand_is_const(inst.src2) == 0) {
        emit(", r");
        emit_u64(ssa_operand_value(inst.src2));
    }
    return 0;
}

func _ssa_dump_call_arg_regs(args_vec: *Vec<u64>, nargs: u64) -> u64 {
    var n: u64 = nargs;
    if (n == 0 && args_vec != 0) { n = args_vec.len(); }
    for (var i: u64 = 0; i < n; i++) {
        if (i > 0) { emit(", "); }
        emit("r");
        emit_u64(args_vec.get(i));
    }
    return 0;
}

func _ssa_dump_inst_call(inst: *SSAInstruction) -> u64 {
    var info_ptr: u64 = ssa_operand_value(inst.src1);
    var info: *SSACallInfo = (*SSACallInfo)info_ptr;
    _ssa_dump_call_ret_regs(inst);
    emit(" = call ");
    emit_len(info.name_ptr, info.name_len);
    emit("(");
    _ssa_dump_call_arg_regs(info.args_vec, info.nargs);
    emit(")\n");
    return 0;
}

func _ssa_dump_inst_call_ptr(inst: *SSAInstruction) -> u64 {
    var info_ptr: u64 = ssa_operand_value(inst.src1);
    var info: *SSACallPtrInfo = (*SSACallPtrInfo)info_ptr;
    _ssa_dump_call_ret_regs(inst);
    emit(" = call_ptr r");
    emit_u64(info.callee_reg);
    emit("(");
    _ssa_dump_call_arg_regs(info.args_vec, info.nargs);
    emit(")\n");
    return 0;
}

func _ssa_dump_slice_store_head(is_ptr: u64, name_ptr: u64, name_len: u64, callee_reg: u64) -> u64 {
    emit("  call_slice_store ");
    if (is_ptr != 0) {
        emit("r");
        emit_u64(callee_reg);
    } else {
        emit_len(name_ptr, name_len);
    }
    emit("(");
    return 0;
}

func _ssa_dump_inst_call_slice_store(inst: *SSAInstruction) -> u64 {
    var info_ptr: u64 = ssa_operand_value(inst.src1);
    var info: *SSACallSliceStoreInfo = (*SSACallSliceStoreInfo)info_ptr;
    if (info.is_ptr > 1) {
        var info_call: *SSACallInfo = (*SSACallInfo)info_ptr;
        _ssa_dump_slice_store_head(0, info_call.name_ptr, info_call.name_len, 0);
        _ssa_dump_call_arg_regs(info_call.args_vec, info_call.nargs);
        emit(")\n");
        return 0;
    }
    _ssa_dump_slice_store_head(info.is_ptr, info.name_ptr, info.name_len, info.callee_reg);
    _ssa_dump_call_arg_regs(info.args_vec, info.nargs);
    emit(")\n");
    return 0;
}

func _ssa_dump_inst_simple(inst: *SSAInstruction, op: u64) -> u64 {
    emit("  r");
    emit_u64(inst.dest);
    emit(" = ");
    _ssa_dump_op_name(op);

    if (op == SSA_OP_CONST || op == SSA_OP_COPY || op == SSA_OP_PARAM) {
        emit(" ");
        _ssa_dump_operand(inst.src1);
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_LOAD || op == SSA_OP_STORE) {
        emit(" ");
        _ssa_dump_operand(inst.src1);
        if (op == SSA_OP_STORE) {
            emit(", ");
            _ssa_dump_operand(inst.src2);
        }
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_STORE_SLICE) {
        emit(" ");
        _ssa_dump_operand(inst.src1);
        emit_nl();
        return 0;
    }

    emit(" ");
    _ssa_dump_operand(inst.src1);
    emit(", ");
    _ssa_dump_operand(inst.src2);
    emit_nl();
    return 0;
}

func _ssa_dump_inst(inst: *SSAInstruction) -> u64 {
    push_trace("_ssa_dump_inst", "ssa_dump.b", __LINE__);
    defer pop_trace();
    var op: u64 = ssa_inst_get_op(inst);
    if (op == SSA_OP_NOP || op == SSA_OP_ENTRY) { return 0; }

    if (op == SSA_OP_RET) {
        emit("  ret ");
        if (inst.src1 != 0) {
            _ssa_dump_operand(inst.src1);
        }
        if (inst.src2 != 0) {
            emit(", ");
            _ssa_dump_operand(inst.src2);
        }
        emit_nl();
        return 0;
    }
    if (op == SSA_OP_RET_SLICE_HEAP) {
        emit("  ret_slice_heap ");
        if (inst.dest != 0) {
            _ssa_dump_operand(inst.dest);
        }
        emit(", ");
        _ssa_dump_operand(inst.src1);
        emit(", ");
        _ssa_dump_operand(inst.src2);
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_JMP) {
        emit("  jmp b");
        emit_u64(ssa_operand_value(inst.src1));
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_BR) {
        emit("  br ");
        _ssa_dump_operand(inst.src1);
        emit(" ? b");
        emit_u64(ssa_operand_value(inst.src2));
        emit(" : b");
        emit_u64(ssa_operand_value(inst.dest));
        emit_nl();
        return 0;
    }

    if (op == SSA_OP_CALL_PTR) { return _ssa_dump_inst_call_ptr(inst); }
    if (op == SSA_OP_CALL_SLICE_STORE) { return _ssa_dump_inst_call_slice_store(inst); }
    if (op == SSA_OP_CALL) { return _ssa_dump_inst_call(inst); }

    return _ssa_dump_inst_simple(inst, op);
}

func _ssa_dump_phi(phi: *SSAInstruction) -> u64 {
    push_trace("_ssa_dump_phi", "ssa_dump.b", __LINE__);
    defer pop_trace();
    emit("  r");
    emit_u64(phi.dest);
    emit(" = phi");
    var arg: *SSAPhiArg = (*SSAPhiArg)phi.src1;
    while (arg != 0) {
        emit(" (b");
        emit_u64(arg.block_id);
        emit(", r");
        emit_u64(arg.val);
        emit(")");
        arg = arg.next;
    }
    emit_nl();
    return 0;
}

func ssa_dump_ctx(ctx: *SSAContext, with_phi: u64) -> u64 {
    push_trace("ssa_dump_ctx", "ssa_dump.b", __LINE__);
    defer pop_trace();
    if (ctx == 0) { return 0; }
    var funcs: []*SSAFunction = ctx.funcs;
    var n: u64 = ssa_slice_len(funcs);
    for (var i: u64 = 0; i < n; i++) {
        var fn: *SSAFunction = funcs[i];

        emit("func ");
        emit_len(fn.name_ptr, fn.name_len);
        emit_nl();

        var blocks: []*SSABlock = fn.blocks;
        var bcount: u64 = ssa_slice_len(blocks);
        for (var bi: u64 = 0; bi < bcount; bi++) {
            var b: *SSABlock = blocks[bi];

            emit("b");
            emit_u64(b.id);
            emit(":\n");

            if (with_phi != 0) {
                var phi: *SSAInstruction = b.phi_head;
                while (phi != 0) {
                    _ssa_dump_phi(phi);
                    phi = phi.next;
                }
            }

            var cur: *SSAInstruction = b.inst_head;
            while (cur != 0) {
                _ssa_dump_inst(cur);
                cur = cur.next;
            }

        }
    }
    return 0;
}
