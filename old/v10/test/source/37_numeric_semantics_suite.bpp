// Covers: float arithmetic + signed/unsigned shift/compare semantics (old 37, 44)
// Mode: ssa|nossa
// Opt: O0|O1
// Expect exit code: 0

func add(a: f64, b: f64) -> f64 {
    return a + b;
}

func main() -> u64 {
    // old 37 path
    var a: f64 = 1.5;
    var b: f64 = 2.25;

    var c: f64 = add(a, b);
    if (c == 3.75) { }
    else { return 1; }

    var d: f64 = c * 2.0;
    if (d > 7.0) { }
    else { return 2; }

    var e: f64 = d / 2.0;
    if (e < 3.0) { return 3; }

    var f: f64 = -e;
    if (f >= 0.0) { return 4; }

    // old 44 path
    var u0: u64 = 0;
    if (u0 < 0) { return 101; }
    if (!(u0 >= 0)) { return 102; }

    var s0: i64 = -1;
    if (!(s0 < 0)) { return 103; }
    if (s0 >= 0) { return 104; }

    var s1: i64 = -8;
    var s1r: i64 = s1 >> 1;
    if (s1r != -4) { return 105; }

    var u1: u64 = 0 - 8;
    var u1r: u64 = u1 >> 1;
    if (u1r != (u1 / 2)) { return 106; }

    var folded_signed: i64 = -8 >> 1;
    if (folded_signed != -4) { return 107; }

    // Corner: cast boundary and truncation semantics.
    var hi: u64 = 9223372036854775808;
    var hi_f: f64 = (f64)hi;
    var hi_back: u64 = (u64)hi_f;
    if (hi_back != hi) { return 108; }

    var neg: i64 = -9;
    var neg_f: f64 = (f64)neg;
    if (neg_f != -9.0) { return 109; }

    var trunc8: u8 = (u8)511;
    if (trunc8 != 255) { return 110; }

    var sar_all_ones: i64 = ((i64)-1) >> 63;
    if (sar_all_ones != -1) { return 111; }
    var shr_all_ones: u64 = ((u64)-1) >> 63;
    if (shr_all_ones != 1) { return 112; }

    var frac: f64 = 5.99;
    var frac_i: u64 = (u64)frac;
    if (frac_i != 5) { return 113; }

    return 0;
}
