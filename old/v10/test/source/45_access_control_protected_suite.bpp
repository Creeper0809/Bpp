// Covers: private/public/protected access + super usage (old 45, 59)
// Expect exit code: 0

struct Vault {
    private secret: i64;
    public opened: i64;
}

impl Vault {
    public func touch_private(self: *Vault) -> i64 {
        return self.secret + 1;
    }

    private func read_secret(self: *Vault) -> i64 {
        return self.secret;
    }

    public func set_secret(self: *Vault, v: i64) {
        self.secret = v;
    }

    public func open(self: *Vault) -> i64 {
        self.opened = self.read_secret();
        return self.touch_private() - 1;
    }
}

struct Base {
    protected value: i64;
}

impl Base {
    public func init(self: *Base, v: i64) {
        self.value = v;
    }

    protected func bump(self: *Base, d: i64) -> i64 {
        self.value = self.value + d;
        return self.value;
    }
}

struct Child : Base {
    public extra: i64;
}

impl Child {
    public func init_child(self: *Child, v: i64, e: i64) {
        super.init(v);
        self.extra = e;
    }

    public func bump_and_sum(self: *Child) -> i64 {
        var v: i64 = super.bump(5);
        return v + super.value + self.extra;
    }

    public func bump_n(self: *Child, n: i64) -> i64 {
        var acc: i64 = 0;
        for (var i: i64 = 0; i < n; i = i + 1) {
            acc = acc + super.bump(1);
        }
        return acc;
    }
}

func main() -> i64 {
    // old 45 path
    var v: Vault;
    v.opened = 0;
    v.set_secret(123);

    var r: i64 = v.open();
    if (r != 123) { return 1; }
    if (v.opened != 123) { return 2; }

    v.opened = v.opened + 10;
    if (v.opened != 133) { return 3; }

    // old 59 path
    var c: Child;
    c.init_child(7, 9);
    var out: i64 = c.bump_and_sum();
    if (out != 33) { return 101; }

    var sum_steps: i64 = c.bump_n(3);
    if (sum_steps != 42) { return 102; }

    var out2: i64 = c.bump_and_sum();
    if (out2 != 49) { return 103; }

    // Corner: second instance must keep independent protected state.
    var c2: Child;
    c2.init_child(1, 2);
    if (c2.bump_n(4) != 14) { return 104; }
    if (c2.bump_and_sum() != 22) { return 105; }
    if (c.bump_n(1) != 21) { return 106; }

    return 0;
}
