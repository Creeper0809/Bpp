// Covers: inline asm basic + register alias variants (old 13, 29)
// Expect exit code: 0

func asm_get_constant() -> i64 {
    var asm_result: i64 = 0;
    asm {
        mov rax, 7
        mov [rbp-8], rax
    }
    return asm_result;
}

func asm_alias_basic() -> i64 {
    var out: i64 = 0;
    alias rax: result;
    asm {
        mov result, 7
        mov [rbp-8], result
    }
    return out;
}

func asm_alias_scratch() -> i64 {
    var out: i64 = 0;
    alias r10: scratch;
    asm {
        mov scratch, 3
        mov [rbp-8], scratch
    }
    return out;
}

func asm_alias_work() -> i64 {
    var out: i64 = 0;
    alias r11: work;
    asm {
        mov work, 5
        mov [rbp-8], work
    }
    return out;
}

func main(argc: i64, argv: *u64) -> i64 {
    var v: i64 = asm_get_constant();
    if (v != 7) { return 1; }

    var sum0: i64 = 0;
    for (var i: i64 = 0; i < 1000; i = i + 1) {
        sum0 = sum0 + asm_get_constant();
    }
    if (sum0 != 7000) { return 2; }

    var complex_sum0: i64 = 0;
    var flip: i64 = 0;
    for (var k: i64 = 0; k < 20; k = k + 1) {
        var v0: i64 = asm_get_constant();
        if ((k & 3) == 0) {
            complex_sum0 = complex_sum0 + v0;
        } else {
            complex_sum0 = complex_sum0 - (v0 - 3);
        }
        if ((k == 7) || (k == 13)) { flip = flip ^ 1; }
        if (flip == 1) { complex_sum0 = complex_sum0 + 1; }
    }
    if (complex_sum0 != -19) { return 3; }

    var v2: i64 = asm_alias_basic();
    if (v2 != 7) { return 101; }

    var sum1: i64 = 0;
    for (var j: i64 = 0; j < 1000; j = j + 1) {
        sum1 = sum1 + asm_alias_scratch();
    }
    if (sum1 != 3000) { return 102; }

    var complex_sum1: i64 = 0;
    for (var m: i64 = 0; m < 20; m = m + 1) {
        var v1: i64 = asm_alias_work();
        if ((m & 1) == 0) {
            complex_sum1 = complex_sum1 + v1;
        } else {
            complex_sum1 = complex_sum1 - (v1 - 2);
        }
    }
    if (complex_sum1 != 20) { return 103; }

    return 0;
}
