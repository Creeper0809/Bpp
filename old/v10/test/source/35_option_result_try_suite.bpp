// Covers: Option/Result basic semantics + try propagation (old 35, 36)
// Mode: ssa|nossa
// Opt: O0|O1
// Expect exit code: 0

import std.option;
import std.result;

struct Pair {
    public a: u64;
    public b: u64;
}

func opt_inc(x: Option<u64>) -> Option<u64> {
    var v: u64 = x?;
    return Option_some<u64>(v + 1);
}

func res_inc(x: Result<u64, u64>) -> Result<u64, u64> {
    var v: u64 = x?;
    return Result_ok<u64, u64>(v + 1);
}

func opt_chain(x: Option<u64>) -> Option<u64> {
    var v0: u64 = x?;
    var v1: u64 = opt_inc(Option_some<u64>(v0))?;
    return Option_some<u64>(v1 + 2);
}

func res_chain(x: Result<u64, u64>) -> Result<u64, u64> {
    var v0: u64 = x?;
    var v1: u64 = res_inc(Result_ok<u64, u64>(v0))?;
    return Result_ok<u64, u64>(v1 + 2);
}

func main() -> u64 {
    var p: Pair;
    p.a = 1;
    p.b = 2;

    var opt1: Option<u64> = Option_some<u64>(10);
    if (opt1.is_some() == 0) { return 1; }
    if (opt1.unwrap() != 10) { return 2; }

    var opt2: Option<u64> = Option_none<u64>();
    if (opt2.is_none() == 0) { return 3; }
    if (opt2.unwrap_or(7) != 7) { return 4; }

    var opt3: Option<Pair> = Option_some<Pair>(p);
    var p2: Pair = opt3.unwrap();
    if (p2.a != 1) { return 5; }
    if (p2.b != 2) { return 6; }

    var ok: Result<u64, u64> = Result_ok<u64, u64>(42);
    if (ok.is_ok() == 0) { return 7; }
    if (ok.unwrap() != 42) { return 8; }

    var err: Result<u64, u64> = Result_err<u64, u64>(9);
    if (err.is_err() == 0) { return 9; }
    if (err.unwrap_or(5) != 5) { return 10; }
    if (err.unwrap_err() != 9) { return 11; }

    var ok_opt: Option<u64> = Option_some<u64>(41);
    var none_opt: Option<u64> = Option_none<u64>();
    var ok_res: Result<u64, u64> = Result_ok<u64, u64>(41);
    var err_res: Result<u64, u64> = Result_err<u64, u64>(7);

    var o1: Option<u64> = opt_inc(ok_opt);
    if (o1.is_some() == 0) { return 101; }
    if (o1.unwrap() != 42) { return 102; }

    var o2: Option<u64> = opt_inc(none_opt);
    if (o2.is_none() == 0) { return 103; }

    var r1: Result<u64, u64> = res_inc(ok_res);
    if (r1.is_ok() == 0) { return 104; }
    if (r1.unwrap() != 42) { return 105; }

    var r2: Result<u64, u64> = res_inc(err_res);
    if (r2.is_err() == 0) { return 106; }
    if (r2.unwrap_err() != 7) { return 107; }

    var oc1: Option<u64> = opt_chain(Option_some<u64>(40));
    if (oc1.is_some() == 0) { return 108; }
    if (oc1.unwrap() != 43) { return 109; }

    var oc2: Option<u64> = opt_chain(Option_none<u64>());
    if (oc2.is_none() == 0) { return 110; }

    var rc1: Result<u64, u64> = res_chain(Result_ok<u64, u64>(40));
    if (rc1.is_ok() == 0) { return 111; }
    if (rc1.unwrap() != 43) { return 112; }

    var rc2: Result<u64, u64> = res_chain(Result_err<u64, u64>(13));
    if (rc2.is_err() == 0) { return 113; }
    if (rc2.unwrap_err() != 13) { return 114; }

    // Corner: unwrap of struct option should preserve original payload on repeat unwrap.
    var op_pair: Option<Pair> = Option_some<Pair>(p);
    var p3: Pair = op_pair.unwrap();
    p3.a = 99;
    var p4: Pair = op_pair.unwrap();
    if (p4.a != 1) { return 115; }

    return 0;
}
