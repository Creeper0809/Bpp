// Covers: override-related pass/fail suite

//=== CASE 70_override_attribute_basic
// Covers: override annotation, override without annotation, private shadow without override,
//         method overloading, auto super-constructor chaining, super overload resolution
// Expect exit code: 0

struct Base {
    public value: i64;
}

impl Base {
    public func inc(self: *Base, d: i64) -> i64 {
        self.value = self.value + d;
        return self.value;
    }
}

struct Child : Base {
    public bonus: i64;
}

impl Child {
    @[override]
    public func inc(self: *Child, d: i64) -> i64 {
        var base_v: i64 = super.inc(d);
        return base_v + self.bonus;
    }
}

struct ParentMissing {
    public v: i64;
}

impl ParentMissing {
    public abst func calc(self: *ParentMissing) -> i64;
}

struct ChildMissing : ParentMissing {
    public x: i64;
}

impl ChildMissing {
    public func calc(self: *ChildMissing) -> i64 {
        return self.v + self.x;
    }
}

struct BaseShadow {
    public v: i64;
}

impl BaseShadow {
    private func ping(self: *BaseShadow) -> i64 {
        return self.v + 1;
    }
}

struct ChildShadow : BaseShadow {
    public x: i64;
}

impl ChildShadow {
    public func ping(self: *ChildShadow) -> i64 {
        return self.v + self.x;
    }
}

struct Acc {
    public base: i64;
}

impl Acc {
    public func sum(self: *Acc, a: i64) -> i64 {
        return self.base + a;
    }

    public func sum(self: *Acc, a: i64, b: i64) -> i64 {
        return self.base + a + b;
    }
}

struct BaseCtor {
    public v: i64;
}

impl BaseCtor {
    public constructor() {
        self.v = 10;
    }
}

struct ChildCtor : BaseCtor {
    public x: i64;
}

impl ChildCtor {
    public constructor() {
        self.x = 7;
    }
}

struct ParentSuperOverload {
    public v: i64;
}

impl ParentSuperOverload {
    public func foo(self: *ParentSuperOverload, x: i64) -> i64 {
        return x + 10;
    }

    public func foo(self: *ParentSuperOverload, x: f64) -> i64 {
        return 77;
    }
}

struct ChildSuperOverload : ParentSuperOverload {
    public c: i64;
}

impl ChildSuperOverload {
    public func call_i(self: *ChildSuperOverload) -> i64 {
        return super.foo((i64)5);
    }

    public func call_f(self: *ChildSuperOverload) -> i64 {
        return super.foo(1.5);
    }
}

func case_override_annotation() -> u64 {
    var c: Child;
    c.value = 3;
    c.bonus = 7;

    if (c.inc(2) != 12) { return 1; }
    return 0;
}

func case_override_without_annotation() -> u64 {
    var c: ChildMissing;
    c.v = 9;
    c.x = 4;
    if (c.calc() != 13) { return 1; }
    return 0;
}

func case_private_shadow_without_override() -> u64 {
    var c: ChildShadow;
    c.v = 3;
    c.x = 4;
    if (c.ping() != 7) { return 1; }
    return 0;
}

func case_method_overloading() -> u64 {
    var acc: Acc;
    acc.base = 10;
    if (acc.sum(2) != 12) { return 1; }
    if (acc.sum(2, 3) != 15) { return 2; }
    return 0;
}

func case_auto_super_ctor_chain() -> u64 {
    var c: ChildCtor;
    c.constructor();
    if (c.v != 10) { return 1; }
    if (c.x != 7) { return 2; }
    return 0;
}

func case_super_overload_resolution() -> u64 {
    var x: ChildSuperOverload;
    if (x.call_i() != 15) { return 1; }
    if (x.call_f() != 77) { return 2; }
    return 0;
}

func main() -> i64 {
    var r: u64 = case_override_annotation();
    if (r != 0) { return 100 + r; }

    r = case_override_without_annotation();
    if (r != 0) { return 200 + r; }

    r = case_private_shadow_without_override();
    if (r != 0) { return 300 + r; }

    r = case_method_overloading();
    if (r != 0) { return 400 + r; }

    r = case_auto_super_ctor_chain();
    if (r != 0) { return 500 + r; }

    r = case_super_overload_resolution();
    if (r != 0) { return 600 + r; }

    return 0;
}
//=== END

//=== CASE 72_override_annotation_without_base_fail
// Covers: compile-fail when @[override] has no base method target
// Expect compile fail: 1
// Expect error contains: @[override] has no base method

struct ParentNoMethod {
    public v: i64;
}

struct ChildNoMethod : ParentNoMethod {
    public x: i64;
}

impl ChildNoMethod {
    @[override]
    public func calc(self: *ChildNoMethod) -> i64 {
        return self.v + self.x;
    }
}

func main() -> i64 {
    return 0;
}
//=== END

//=== CASE 73_trait_impl_override_forbidden_fail
// Covers: compile-fail when @[override] is used inside trait impl
// Expect compile fail: 1
// Expect error contains: trait impl methods cannot use @[override]

trait Runner {
    func run(self: *Self) -> i64;
}

struct Job {
    public x: i64;
}

impl Runner for Job {
    @[override]
    public func run(self: *Job) -> i64 {
        return self.x;
    }
}

func main() -> i64 {
    return 0;
}
//=== END
