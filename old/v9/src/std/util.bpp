// util.b - Utility functions for v3.8

import std.io;
import std.str;
import std.path;
import std.char;

// ============================================
// Stack Trace
// ============================================

// Stack frame: [func_name, func_name_len, file_name, file_name_len, line]
const STACK_TRACE_MAX_DEPTH = 128;

struct StackFrame {
	public func_name: u64;
	public func_name_len: u64;
	public file_name: u64;
	public file_name_len: u64;
	public line: u64;
}

var g_stack_frames;
var g_stack_depth;
var g_stack_initialized;

var g_last_error_msg;
var g_last_error_len;

var g_error_buffer;
var g_error_buffer_pos;
var g_capturing_error;

// Parsing context (for user-facing error messages)
var g_current_func_name;
var g_current_func_name_len;
var g_current_func_line;
var g_emit_char_buf;
var g_emit_u64_buf;
var g_emit_u64_stderr_buf;

func init_stack_trace() {
	if (g_stack_initialized) {
		return;
	}
	g_stack_frames = heap_alloc(STACK_TRACE_MAX_DEPTH * sizeof(StackFrame));
	g_stack_depth = 0;
	g_stack_initialized = 1;
}

func push_trace(func_name, file_name, line) {
	if (!g_stack_initialized || g_stack_frames == 0) {
		init_stack_trace();
	}
	if (g_stack_frames == 0) { return; }

	if (g_stack_depth >= STACK_TRACE_MAX_DEPTH) {
		return;
	}
    
	var func_name_len = str_len(func_name);
	var file_name_len = str_len(file_name);
    
	var frame_ptr: u64 = g_stack_frames + (g_stack_depth * sizeof(StackFrame));
	var frame: *StackFrame = (*StackFrame)frame_ptr;
	frame.func_name = func_name;
	frame.func_name_len = func_name_len;
	frame.file_name = file_name;
	frame.file_name_len = file_name_len;
	frame.line = line;
    
	g_stack_depth = g_stack_depth + 1;
}

func pop_trace() {
	if (!g_stack_initialized) { return; }
	if (g_stack_depth == 0) { return; }
	g_stack_depth = g_stack_depth - 1;
}

func print_stack_trace() {
	if (!g_stack_initialized) {
		emit_stderr("  (no stack trace available)");
		emit_stderr_nl();
		return;
	}
    
	if (g_stack_depth == 0) {
		emit_stderr("  (stack trace is empty)");
		emit_stderr_nl();
		return;
	}
    
	emit_stderr("Stack trace (most recent call first):");
	emit_stderr_nl();
    
	for (var i: u64 = g_stack_depth; i > 0; i = i - 1) {
		var frame_index: u64 = i - 1;
		var frame_ptr: u64 = g_stack_frames + (frame_index * sizeof(StackFrame));
		var frame: *StackFrame = (*StackFrame)frame_ptr;
		var func_name: u64 = frame.func_name;
		var func_name_len: u64 = frame.func_name_len;
		var file_name: u64 = frame.file_name;
		var file_name_len: u64 = frame.file_name_len;
		var line: u64 = frame.line;
        
		emit_stderr("  at ");
		emit_stderr_len(func_name, func_name_len);
		emit_stderr(" (");
		emit_stderr_len(file_name, file_name_len);
		emit_stderr(":");
		emit_i64_stderr(line);
		emit_stderr(")");
		emit_stderr_nl();
	}
}

// ============================================
// Error Handling
// ============================================

func set_parsing_context(func_name, func_name_len, line) {
	g_current_func_name = func_name;
	g_current_func_name_len = func_name_len;
	g_current_func_line = line;
}

func begin_error_capture() {
	if (g_error_buffer == 0) {
		g_error_buffer = heap_alloc(512 * sizeof(u8));
	}
	g_error_buffer_pos = 0;
	g_capturing_error = 1;
}

func end_error_capture() {
	g_capturing_error = 0;
}

func set_error_context(msg, len) {
	g_last_error_msg = msg;
	g_last_error_len = len;
}

func emit_error(msg, len) {
	emit_stderr("[ERROR] ");
	emit_stderr_len(msg, len);
	emit_stderr_nl();
	g_last_error_msg = msg;
	g_last_error_len = len;
}

func panic(msg) {
	end_error_capture();

	if (msg != 0) {
		emit_stderr("[PANIC] ");
		emit_stderr_len(msg, str_len(msg));
		emit_stderr_nl();
	}
    
	// Print user code context first
	if (g_current_func_name != 0) {
		emit_stderr_nl();
		emit_stderr("Parsing context:");
		emit_stderr_nl();
		emit_stderr("  -> In function: ");
		emit_stderr_len(g_current_func_name, g_current_func_name_len);
		emit_stderr(" (line ");
		emit_i64_stderr(g_current_func_line);
		emit_stderr(")");
		emit_stderr_nl();
	}
    
	// Print compiler trace
	emit_stderr_nl();
	emit_stderr("Compiler internal trace:");
	emit_stderr_nl();
	print_stack_trace();
    
	if (g_error_buffer_pos > 0) {
		emit_stderr_nl();
		emit_stderr("Error details:");
		emit_stderr_nl();
		sys_write(2, g_error_buffer, g_error_buffer_pos);
		emit_stderr_nl();
	}
	emit_stderr_nl();
	sys_exit(1);
}

// Debug failure entry point used by assert/todo/unreachable keywords.
// Emits a short message with line info and then traps immediately.
func debug_fail(msg, len, line) {
	emit_stderr("[DEBUG] ");
	emit_stderr_len(msg, len);
	emit_stderr(" at line ");
	emit_u64_stderr(line);
	emit_stderr_nl();
	print_stack_trace();
	sys_exit(1);
}

func emit_stderr(s) {
	if (s == 0) { return; }
	emit_stderr_len(s, str_len(s));
}

func emit_stderr_len(s, len) {
	if (g_capturing_error != 0) {
		if (g_error_buffer_pos + len < 512) {
			var buf_u8: *u8 = (*u8)g_error_buffer;
			var s_u8: *u8 = (*u8)s;
			for (var i: u64 = 0; i < len; i++) {
				buf_u8[g_error_buffer_pos] = s_u8[i];
				g_error_buffer_pos = g_error_buffer_pos + 1;
			}
		}
	} else {
		sys_write(2, s, len);
	}
}

func emit_stderr_nl() {
	sys_write(2, "\n", 1);
}

func warn(msg, len) {
	emit_stderr("[WARN] ");
	emit_stderr_len(msg, len);
	emit_stderr_nl();
}

// ============================================
// Output Utilities
// ============================================

func emit_char(c) {
	if (g_emit_char_buf == 0) {
		g_emit_char_buf = heap_alloc(sizeof(u8));
	}
	var buf_u8: *u8 = (*u8)g_emit_char_buf;
	buf_u8[0] = c;
	sys_write(1, g_emit_char_buf, 1);
}

func emit_u64(n: u64) {
	if (g_emit_u64_buf == 0) {
		g_emit_u64_buf = heap_alloc(32 * sizeof(u8));
	}
	var buf = g_emit_u64_buf;
	var i: u64 = io_u64_to_ascii(buf, n);
	sys_write(1, buf, i);
}

func emit_u64_stderr(n: u64) {
	if (g_emit_u64_stderr_buf == 0) {
		g_emit_u64_stderr_buf = heap_alloc(32 * sizeof(u8));
	}
	var buf = g_emit_u64_stderr_buf;
	var i: u64 = io_u64_to_ascii(buf, n);
	emit_stderr_len(buf, i);
}

func emit_i64(n: i64) {
	if (n < 0) {
		emit("-");
		emit_u64((u64)(0 - n));
	} else {
		emit_u64((u64)n);
	}
}

func emit_i64_stderr(n: i64) {
	if (n < 0) {
		emit_stderr("-");
		emit_u64_stderr((u64)(0 - n));
	} else {
		emit_u64_stderr((u64)n);
	}
}

func emit_nl() {
	sys_write(1, "\n", 1);
}
