// vec.b - Dynamic array implementation (pointer arithmetic for bootstrap)

import std.io;

func vec_memcpy(dst: u64, src: u64, size: u64) -> u64 {
    if (size == 0) { return 0; }
    if (size == 8) {
        var d1: *u64 = (*u64)dst;
        var s1: *u64 = (*u64)src;
        d1[0] = s1[0];
        return 0;
    }
    if (size == 16) {
        var d2: *u64 = (*u64)dst;
        var s2: *u64 = (*u64)src;
        d2[0] = s2[0];
        d2[1] = s2[1];
        return 0;
    }
    if (size == 24) {
        var d3: *u64 = (*u64)dst;
        var s3: *u64 = (*u64)src;
        d3[0] = s3[0];
        d3[1] = s3[1];
        d3[2] = s3[2];
        return 0;
    }
    if (size == 32) {
        var d4: *u64 = (*u64)dst;
        var s4: *u64 = (*u64)src;
        d4[0] = s4[0];
        d4[1] = s4[1];
        d4[2] = s4[2];
        d4[3] = s4[3];
        return 0;
    }
    if (size < 8) {
        var dst_s: *u8 = (*u8)dst;
        var src_s: *u8 = (*u8)src;
        for (var b: u64 = 0; b < size; b++) {
            dst_s[b] = src_s[b];
        }
        return 0;
    }

    var words: u64 = size / 8;
    var rem: u64 = size % 8;

    var dst_u64: *u64 = (*u64)dst;
    var src_u64: *u64 = (*u64)src;
    for (var i: u64 = 0; i < words; i++) {
        dst_u64[i] = src_u64[i];
    }

    if (rem != 0) {
        var base: u64 = words * 8;
        var dst_u8: *u8 = (*u8)(dst + base);
        var src_u8: *u8 = (*u8)(src + base);
        for (var j: u64 = 0; j < rem; j++) {
            dst_u8[j] = src_u8[j];
        }
    }
    return 0;
}

// Vec<T> structure: [data_ptr, length, capacity] (24 bytes)
// Storage is byte-based; element stride is sizeof(T).
struct Vec<T> {
    data_ptr: u64;
    length: u64;
    capacity: u64;
}

impl Vec {
    public constructor(cap: u64) {
        var elem_size: u64 = sizeof(T);
        var buf: u64 = heap_alloc(cap * elem_size);
        self.data_ptr = buf;
        self.length = 0;
        self.capacity = cap;
    }

    public func len<T>(self: *Vec<T>) -> u64 {
        return self.length;
    }

    public func cap<T>(self: *Vec<T>) -> u64 {
        return self.capacity;
    }

    public func push<T>(self: *Vec<T>, item: T) -> u64 {
        var len: u64 = self.length;
        var cap: u64 = self.capacity;
        var elem_size: u64 = sizeof(T);

        // Grow if needed
        if (len >= cap) {
            var new_cap: u64 = cap * 2;
            if (new_cap < 4) { new_cap = 4; }
            var new_buf: u64 = heap_alloc(new_cap * elem_size);
            var old_buf: u64 = self.data_ptr;
            var used_bytes: u64 = len * elem_size;
            if (used_bytes != 0) {
                vec_memcpy(new_buf, old_buf, used_bytes);
            }
            self.data_ptr = new_buf;
            self.capacity = new_cap;
        }

        var buf: u64 = self.data_ptr;
        var dst2: u64 = buf + len * elem_size;
        var src2: u64 = (u64)&item;
        if (elem_size == 8) {
            var d8: *u64 = (*u64)dst2;
            var s8: *u64 = (*u64)src2;
            d8[0] = s8[0];
        } else if (elem_size == 16) {
            var d16: *u64 = (*u64)dst2;
            var s16: *u64 = (*u64)src2;
            d16[0] = s16[0];
            d16[1] = s16[1];
        } else {
            vec_memcpy(dst2, src2, elem_size);
        }
        self.length = len + 1;
        return 0;
    }

    public func get<T>(self: *Vec<T>, i: u64) -> T {
        var buf: u64 = self.data_ptr;
        var elem_size: u64 = sizeof(T);
        var out: T;
        var src: u64 = buf + i * elem_size;
        var dst: u64 = (u64)&out;
        if (elem_size == 8) {
            var d8: *u64 = (*u64)dst;
            var s8: *u64 = (*u64)src;
            d8[0] = s8[0];
        } else if (elem_size == 16) {
            var d16: *u64 = (*u64)dst;
            var s16: *u64 = (*u64)src;
            d16[0] = s16[0];
            d16[1] = s16[1];
        } else {
            vec_memcpy(dst, src, elem_size);
        }
        return out;
    }

    public func set<T>(self: *Vec<T>, i: u64, val: T) -> u64 {
        var buf: u64 = self.data_ptr;
        var elem_size: u64 = sizeof(T);
        var dst: u64 = buf + i * elem_size;
        var src: u64 = (u64)&val;
        if (elem_size == 8) {
            var d8: *u64 = (*u64)dst;
            var s8: *u64 = (*u64)src;
            d8[0] = s8[0];
        } else if (elem_size == 16) {
            var d16: *u64 = (*u64)dst;
            var s16: *u64 = (*u64)src;
            d16[0] = s16[0];
            d16[1] = s16[1];
        } else {
            vec_memcpy(dst, src, elem_size);
        }
        return 0;
    }

    public func pop<T>(self: *Vec<T>) -> T {
        var len: u64 = self.length;
        if (len == 0) {
            return 0;
        }
        var buf: u64 = self.data_ptr;
        var elem_size: u64 = sizeof(T);
        var out: T;
        var src: u64 = buf + (len - 1) * elem_size;
        var dst: u64 = (u64)&out;
        if (elem_size == 8) {
            var d8: *u64 = (*u64)dst;
            var s8: *u64 = (*u64)src;
            d8[0] = s8[0];
        } else if (elem_size == 16) {
            var d16: *u64 = (*u64)dst;
            var s16: *u64 = (*u64)src;
            d16[0] = s16[0];
            d16[1] = s16[1];
        } else {
            vec_memcpy(dst, src, elem_size);
        }
        self.length = len - 1;
        return out;
    }

    public func clear<T>(self: *Vec<T>) -> u64 {
        self.length = 0;
        return 0;
    }
}
