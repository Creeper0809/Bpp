// Covers: Type(...) stack constructor sugar + nested constructor calls + method usage
// Expect exit code: 0

struct Vec2 {
    public x: u64;
    public y: u64;
}

struct Box2 {
    public min: Vec2;
    public max: Vec2;
    public area: u64;
}

var g_last_area: u64 = 0;

impl Vec2 {
    public constructor(x: u64, y: u64) {
        self.x = x;
        self.y = y;
    }

    public func sum(self: *Vec2) -> u64 {
        return self.x + self.y;
    }
}

impl Box2 {
    public constructor(a: Vec2, b: Vec2) {
        self.min = a;
        self.max = b;
        self.area = (b.x - a.x) * (b.y - a.y);
    }

    public func calc(self: *Box2) -> u64 {
        return self.area + self.min.sum() + self.max.sum();
    }
}

func make_box(offset: u64) -> Box2 {
    var a: Vec2 = Vec2(1 + offset, 2 + offset);
    var b: Vec2 = Vec2(6 + offset, 8 + offset);
    var box: Box2 = Box2(a, b);
    g_last_area = box.area;
    return box;
}

func main() -> u64 {
    // Import

    // Setup
    var b0: Box2 = make_box(0);
    var v1: Vec2 = Vec2(3, 4);
    var v2: Vec2 = Vec2(9, 12);
    var b1: Box2 = Box2(v1, v2);
    var acc: u64 = 0;

    if (v1.x != 3 || v1.y != 4) { return 10; }
    if (v2.x != 9 || v2.y != 12) { return 11; }
    if (b1.min.x != 3 || b1.min.y != 4) { return 12; }
    if (b1.max.x != 9 || b1.max.y != 12) { return 13; }
    if (b1.area != 48) { return 14; }
    if (g_last_area != 30) { return 15; }

    // Execution
    for (var i: u64 = 0; i < 3; i = i + 1) {
        var tmp: Box2 = make_box(i);
        acc = acc + tmp.calc();
    }

    var sum0: u64 = b0.calc();
    var sum1: u64 = b1.calc();

    // Assertion
    if (b0.min.x != 1 || b0.min.y != 2) { return 20; }
    if (b0.max.x != 6 || b0.max.y != 8) { return 21; }
    if (b0.area != 30) { return 22; }
    if (sum0 != 47) { return 1; }
    if (sum1 != 76) { return 2; }
    if (acc != 153) { return 3; }
    return 0;
}
