// emitter.b - ASM output helpers, labels, string/data tables, global state
//
// This module contains:
// - Global codegen state (symtab, label counter, strings, loops, etc.)
// - Label generation and emission
// - String literal table management
// - Global variable BSS emission
// - Constant lookup

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import ast;
import compiler;
import emitter.typeinfo;
import emitter.symtab;

// ============================================
// Global Codegen State
// ============================================

var g_symtab: *Symtab;                       // Symbol table for current function
var g_label_counter;                // Label counter for unique labels
var g_consts: *Vec<*ConstInfo>;                // Global constants table
var g_strings: *Vec<*StringEntry>;             // String literals table
var g_loop_labels: *Vec<u64>;                  // Stack of loop end labels for break
var g_loop_continue_labels: *Vec<u64>;         // Stack of loop continue labels
var g_globals: *Vec<*GlobalInfo>;              // Global variables list
var g_defer_stack: *Vec<*AstNode>;              // Stack of deferred statements
var g_defer_markers: *Vec<u64>;                 // Block scope markers for defer
var g_defer_loop_markers: *Vec<u64>;            // Loop/switch scope markers for defer

// Current function return type information (for struct return)
var g_current_func_ret_type;
var g_current_func_ret_ptr_depth;
var g_current_func_ret_struct_name_ptr;
var g_current_func_ret_struct_name_len;

// ============================================
// State Accessors
// ============================================

func emitter_get_symtab() -> *Symtab { return g_symtab; }
func emitter_set_symtab(s: *Symtab) -> u64 { g_symtab = s; }

func emitter_get_globals() -> *Vec<*GlobalInfo> { return g_globals; }
func emitter_set_globals(g: *Vec<*GlobalInfo>) -> u64 { g_globals = g; }

func emitter_get_consts() -> *Vec<*ConstInfo> { return g_consts; }
func emitter_set_consts(c: *Vec<*ConstInfo>) -> u64 { g_consts = c; }

func emitter_get_loop_labels() -> *Vec<u64> { return g_loop_labels; }
func emitter_get_continue_labels() -> *Vec<u64> { return g_loop_continue_labels; }
func emitter_get_defer_stack() -> *Vec<*AstNode> { return g_defer_stack; }
func emitter_get_defer_markers() -> *Vec<u64> { return g_defer_markers; }
func emitter_get_defer_loop_markers() -> *Vec<u64> { return g_defer_loop_markers; }

func emitter_set_ret_type(t: u64) -> u64 { g_current_func_ret_type = t; }
func emitter_set_ret_ptr_depth(d: u64) -> u64 { g_current_func_ret_ptr_depth = d; }
func emitter_set_ret_struct_name(ptr: u64, len: u64) -> u64 {
    g_current_func_ret_struct_name_ptr = ptr;
    g_current_func_ret_struct_name_len = len;
}

func emitter_get_ret_type() -> u64 { return g_current_func_ret_type; }
func emitter_get_ret_ptr_depth() -> u64 { return g_current_func_ret_ptr_depth; }
func emitter_get_ret_struct_name_ptr() -> u64 { return g_current_func_ret_struct_name_ptr; }
func emitter_get_ret_struct_name_len() -> u64 { return g_current_func_ret_struct_name_len; }

// ============================================
// Initialization
// ============================================

func emitter_init() -> u64 {
    // Create symtab via helper for consistent initialization
    // symtab = [names_vec, offsets_vec, types_vec, count, stack_offset]
    g_symtab = symtab_new();
    var symtab: *Symtab = g_symtab;
    symtab.stack_offset = -8;
    
    g_label_counter = 0;
    g_strings = new Vec<*StringEntry>(32);
    g_loop_labels = new Vec<u64>(16);
    g_loop_continue_labels = new Vec<u64>(16);
    g_consts = new Vec<*ConstInfo>(64);
    g_defer_stack = new Vec<*AstNode>(32);
    g_defer_markers = new Vec<u64>(32);
    g_defer_loop_markers = new Vec<u64>(16);
}

func emitter_set_globals_from_prog(globals: *Vec<*GlobalInfo>) -> u64 {
    if (globals == 0) {
        g_globals = new Vec<*GlobalInfo>(32);
    } else {
        g_globals = globals;
    }
}

func emitter_load_consts(consts: *Vec<*AstConstDecl>) -> u64 {
    g_consts = new Vec<*ConstInfo>(64);
    var clen: u64 = consts.len();
    for (var ci: u64 = 0; ci < clen; ci++) {
        var const_decl: *AstConstDecl = consts.get(ci);
        var cinfo_struct: *ConstInfo = new ConstInfo{const_decl.name_ptr, const_decl.name_len, const_decl.value};
        g_consts.push(cinfo_struct);
    }
}

// ============================================
// Global Variable Check
// ============================================

func is_global_var(name_ptr: u64, name_len: u64) -> u64 {
    var len: u64 = g_globals.len();
    for (var i: u64 = 0; i < len; i++) {
        var ginfo: *GlobalInfo = g_globals.get(i);
        if (str_eq(ginfo.name_ptr, ginfo.name_len, name_ptr, name_len)) {
            return true;
        }
    }
    return false;
}

// ============================================
// ASM Alias Emission
// ============================================

func emit_asm_text_with_alias(text_vec: *Vec<u64>) -> u64 {
    var asm_len: u64 = text_vec.?len();
    var i: u64 = 0;
    var at_line_start: u64 = 1;

    while (i < asm_len) {
        var ch: u64 = text_vec.get(i);
        if (ch == 10) {
            emit_nl();
            at_line_start = 1;
            i = i + 1;
            continue;
        }
        if (ch == 32) {
            if (at_line_start == 1) {
                emit("    ", 4);
                at_line_start = 0;
            }
            emit_char(ch);
            i = i + 1;
            continue;
        }

        var tok_start: u64 = i;
        while (i < asm_len) {
            var ch2: u64 = text_vec.get(i);
            if (ch2 == 10 || ch2 == 32) { break; }
            i = i + 1;
        }
        var tok_len: u64 = i - tok_start;
        if (tok_len == 0) { continue; }

        if (at_line_start == 1) {
            emit("    ", 4);
            at_line_start = 0;
        }

        var tok_ptr: u64 = heap_alloc((tok_len + 1) * sizeof(u8));
        var tok_u8: []u8 = slice(tok_ptr, tok_len + 1);
        for (var j: u64 = 0; j < tok_len; j++) {
            tok_u8[j] = (u8)text_vec.get(tok_start + j);
        }
        tok_u8[tok_len] = 0;

        var alias_info_ptr: *NameInfo = compiler_reg_alias_get(tok_ptr, tok_len);
        if (alias_info_ptr != 0) {
            emit(alias_info_ptr.ptr, alias_info_ptr.len);
        } else {
            emit(tok_ptr, tok_len);
        }
    }

    emit_nl();
    return 0;
}

// ============================================
// Constants Lookup
// ============================================

func const_find(name_ptr: u64, name_len: u64) -> ConstResult {
    var len: u64 = g_consts.len();
    for (var i: u64 = 0; i < len; i++) {
        var cinfo: *ConstInfo = g_consts.get(i);
        if (str_eq(cinfo.name_ptr, cinfo.name_len, name_ptr, name_len)) {
            return ConstResult{1, cinfo.value};
        }
    }
    return ConstResult{0, 0};
}

// ============================================
// Labels
// ============================================

func new_label() -> u64 {
    var l: u64 = g_label_counter;
    g_label_counter = g_label_counter + 1;
    return l;
}

func emit_label(n: u64) -> u64 {
    emit(".L", 2);
    emit_u64(n);
}

func emit_label_def(n: u64) -> u64 {
    emit_label(n);
    emit(":", 1);
    emit_nl();
}

// ============================================
// String Literals Table
// ============================================

func string_table_init() -> u64 {
    g_strings = new Vec<*StringEntry>(32);
}

func string_get_label(str_ptr: u64, str_len: u64) -> u64 {
    var count: u64 = g_strings.len();

    for (var i: u64 = 0; i < count; i++) {
        var str_entry: *StringEntry = g_strings.get(i);
        
        if (str_eq(str_entry.str_ptr, str_entry.str_len, str_ptr, str_len)) {
            return str_entry.label_id;
        }
    }
    
    var label_id: u64 = g_label_counter;
    g_label_counter = g_label_counter + 1;
    
    var str_entry: *StringEntry = new StringEntry{str_ptr, str_len, label_id};
    g_strings.push(str_entry);
    
    return label_id;
}

func string_emit_data() -> u64 {
    var count: u64 = g_strings.len();
    
    if (count == 0) { return; }
    
    emitln("\nsection .data");
    
    for (var i: u64 = 0; i < count; i++) {
        var str_entry: *StringEntry = g_strings.get(i);
        var str_ptr: u64 = str_entry.str_ptr;
        var str_len: u64 = str_entry.str_len;
        var label_id: u64 = str_entry.label_id;
        var str_u8: []u8 = slice(str_ptr, str_len);
        
        emit("_str", 4);
        emit_u64(label_id);
        emit(": db ", 5);
        
        for (var j: u64 = 1; j < str_len - 1; ) {
            var c: u64 = str_u8[j];
            
            if (c == 92) {  // backslash
                j = j + 1;
                if (j < str_len - 1) {
                    var ec: u64 = str_u8[j];
                    if (ec == 110) { emit("10", 2); }       // \n
                    else if (ec == 116) { emit("9", 1); }   // \t
                    else if (ec == 48) { emit("0", 1); }    // \0
                    else if (ec == 92) { emit("92", 2); }   // \\
                    else if (ec == 34) { emit("34", 2); }   // \"
                    else { emit_u64(ec); }
                }
            } else {
                emit_u64(c);
            }

            j = j + 1;
            if (j < str_len - 1) { emit(",", 1); }
        }
        
        emitln(",0");
    }
}

// ============================================
// Global Variables Data/BSS Emission
// ============================================

func _global_eval_const_value(name_ptr: u64, name_len: u64, out_value: *u64) -> u64 {
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    if (resolved_len > 6 && str_eq(resolved_ptr, 6, "_gvar_", 6)) {
        resolved_ptr = resolved_ptr + 6;
        resolved_len = resolved_len - 6;
    }
    var resolved: *NameInfo = resolve_name(resolved_ptr, resolved_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    var res: ConstResult = const_find(resolved_ptr, resolved_len);
    if (res.found != 0) {
        *(*u64)out_value = res.value;
        return true;
    }

    var res2: ConstResult = const_find(name_ptr, name_len);
    if (res2.found != 0) {
        *(*u64)out_value = res2.value;
        return true;
    }

    // Fallback: try unqualified name match for mangled consts (prefix__NAME)
    if (g_consts != 0) {
        var n: u64 = g_consts.len();
        for (var i: u64 = 0; i < n; i++) {
            var cinfo: *ConstInfo = g_consts.get(i);
            if (cinfo.name_len <= name_len + 2) { continue; }
            var suffix_pos: u64 = cinfo.name_len - name_len;
            var name_u8: []u8 = slice(cinfo.name_ptr, cinfo.name_len);
            if (name_u8[suffix_pos - 2] != 95 || name_u8[suffix_pos - 1] != 95) { continue; }
            if (str_eq(cinfo.name_ptr + suffix_pos, name_len, name_ptr, name_len)) {
                *(*u64)out_value = cinfo.value;
                return true;
            }
        }
    }
    return false;
}

func _global_eval_scalar_expr(expr: *AstNode, out_value: *u64) -> u64 {
    if (expr == 0) { return false; }
    var kind: u64 = ast_kind(expr);
    if (kind == AST_LITERAL) {
        var lit: *AstLiteral = (*AstLiteral)expr;
        *(*u64)out_value = lit.value;
        return true;
    }
    if (kind == AST_IDENT) {
        var id: *AstIdent = (*AstIdent)expr;
        return _global_eval_const_value(id.name_ptr, id.name_len, out_value);
    }
    if (kind == AST_UNARY) {
        var un: *AstUnary = (*AstUnary)expr;
        if (un.op == TOKEN_MINUS) {
            var inner_value: u64 = 0;
            if (_global_eval_scalar_expr(un.operand, &inner_value) == 0) { return false; }
            *(*u64)out_value = 0 - inner_value;
            return true;
        }
    }
    return false;
}

func _global_emit_padding(pad: u64) -> u64 {
    if (pad == 0) { return 0; }
    emit("    times ", 10);
    emit_u64(pad);
    emit(" db 0", 5);
    emit_nl();
    return 0;
}

func _global_emit_scalar_value(size: u64, value: u64) -> u64 {
    if (size == 1) {
        emit("    db ", 7);
        emit_u64(value & 255);
        emit_nl();
        return 0;
    }
    if (size == 2) {
        emit("    dw ", 7);
        emit_u64(value & 65535);
        emit_nl();
        return 0;
    }
    if (size == 4) {
        emit("    dd ", 7);
        emit_u64(value & 4294967295);
        emit_nl();
        return 0;
    }
    if (size == 8) {
        emit("    dq ", 7);
        emit_u64(value);
        emit_nl();
        return 0;
    }
    emit_stderr("[ERROR] Unsupported global init size\n", 44);
    panic("Parse error");
}

func _global_emit_struct_literal(ginfo: *GlobalInfo, lit: *AstStructLiteral) -> u64 {
    var struct_def: *AstStructDef = lit.struct_def;
    if (struct_def == 0 && ginfo.typeinfo_ptr != 0) {
        struct_def = get_struct_def(ginfo.typeinfo_ptr.struct_name_ptr, ginfo.typeinfo_ptr.struct_name_len);
    }
    if (struct_def == 0) {
        emit_stderr("[ERROR] Missing struct def for global init\n", 52);
        panic("Parse error");
    }

    var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
    var values: *Vec<*AstNode> = lit.values_vec;
    if (fields == 0 || values == 0) {
        emit_stderr("[ERROR] Global struct literal missing fields\n", 52);
        panic("Parse error");
    }
    var fn: u64 = fields.len();
    var vn: u64 = values.len();
    if (fn != vn) {
        emit_stderr("[ERROR] Global struct literal field count mismatch\n", 59);
        panic("Parse error");
    }

    emit("_gvar_", 6);
    emit(ginfo.name_ptr, ginfo.name_len);
    emit(":", 1);
    emit_nl();

    var cursor: u64 = 0;
    for (var i: u64 = 0; i < fn; i++) {
        var f: *FieldDesc = fields.get(i);
        if (f.type_kind == TYPE_STRUCT && f.ptr_depth == 0) {
            emit_stderr("[ERROR] Nested struct init not supported\n", 49);
            panic("Parse error");
        }
        if (f.type_kind == TYPE_ARRAY || f.type_kind == TYPE_SLICE) {
            emit_stderr("[ERROR] Array/slice struct init not supported\n", 54);
            panic("Parse error");
        }
        var field_size: u64 = sizeof_field_desc(f);
        if (field_size == 0) {
            emit_stderr("[ERROR] Global struct field size invalid\n", 48);
            panic("Parse error");
        }

        var val_expr: *AstNode = values.get(i);
        var value: u64 = 0;
        if (_global_eval_scalar_expr(val_expr, &value) == 0) {
            emit_stderr("[ERROR] Unsupported global struct literal value\n", 58);
            panic("Parse error");
        }
        _global_emit_scalar_value(field_size, value);
        cursor = cursor + field_size;
    }

    if (ginfo.typeinfo_ptr != 0) {
        var struct_size: u64 = sizeof_type_ex(ginfo.typeinfo_ptr);
        if (cursor < struct_size) {
            _global_emit_padding(struct_size - cursor);
        }
    }
    return 0;
}

func globals_emit_data() -> u64 {
    var count: u64 = g_globals.len();
    if (count == 0) { return; }

    var emitted: u64 = 0;
    for (var i: u64 = 0; i < count; i++) {
        var ginfo: *GlobalInfo = g_globals.get(i);
        if (ginfo.init_kind == GLOBAL_INIT_NONE || ginfo.init_kind == GLOBAL_INIT_RUNTIME) { continue; }

        set_current_module_for_global(ginfo.name_ptr, ginfo.name_len);

        if (emitted == 0) {
            emitln("\nsection .data");
            emitted = 1;
        }

        if (ginfo.init_kind == GLOBAL_INIT_EXPR) {
            var expr: *AstNode = (*AstNode)ginfo.init_expr;
            if (expr == 0) {
                emit_stderr("[ERROR] Global init expr missing\n", 44);
                panic("Parse error");
            }
            var ek: u64 = ast_kind(expr);
            if (ek == AST_STRUCT_LITERAL) {
                _global_emit_struct_literal(ginfo, (*AstStructLiteral)expr);
                continue;
            }
            emit_stderr("[ERROR] Unsupported global init expr kind\n", 50);
            panic("Parse error");
        }

        var size: u64 = 8;
        if (ginfo.typeinfo_ptr != 0) {
            size = sizeof_type_ex(ginfo.typeinfo_ptr);
        }
        if (size == 0) { size = 8; }

        var value: u64 = ginfo.init_value;
        if (ginfo.init_kind == GLOBAL_INIT_CONST) {
            var ok: u64 = _global_eval_const_value(ginfo.init_name_ptr, ginfo.init_name_len, &value);
            if (ok == 0) {
                emit_stderr("[ERROR] Global init const not found: ", 44);
                emit_stderr(ginfo.init_name_ptr, ginfo.init_name_len);
                emit_stderr("\n", 1);
                panic("Parse error");
            }
        }

        emit("_gvar_", 6);
        emit(ginfo.name_ptr, ginfo.name_len);
        emit(":", 1);
        emit_nl();
        _global_emit_scalar_value(size, value);
    }
}

func globals_emit_bss() -> u64 {
    var count: u64 = g_globals.len();
    
    if (count == 0) { return; }
    
    emitln("\nsection .bss");
    
    for (var i: u64 = 0; i < count; i++) {
        var ginfo: *GlobalInfo = g_globals.get(i);
        if (ginfo.init_kind != GLOBAL_INIT_NONE && ginfo.init_kind != GLOBAL_INIT_RUNTIME) { continue; }
        var size: u64 = 8;
        if (ginfo.typeinfo_ptr != 0) {
            size = sizeof_type_ex(ginfo.typeinfo_ptr);
        }
        if (size == 0) { size = 8; }
        
        emit("_gvar_", 6);
        emit(ginfo.name_ptr, ginfo.name_len);
        emit(": resb ", 7);
        emit_u64(size);
        emit_nl();
        
    }
}
