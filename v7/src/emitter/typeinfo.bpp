// typeinfo.b - Type size/compatibility calculations and struct layout
//
// This module handles type-related calculations:
// - Type size computation (primitives, pointers, structs)
// - Type compatibility checking
// - Struct field offset calculation
// - Expression type inference

import std.io;
import std.vec;
import std.util;
import std.str;
import types;
import ast;
import compiler;

func typeinfo_make(base_type: u64, ptr_depth: u64) -> *TypeInfo {
    var ti: *TypeInfo = new TypeInfo(base_type, ptr_depth);
    return ti;
}

func typeinfo_make_struct(ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64, struct_def: *AstStructDef) -> *TypeInfo {
    var ti: *TypeInfo = new TypeInfo(TYPE_STRUCT, ptr_depth);
    ti.struct_name_ptr = struct_name_ptr;
    ti.struct_name_len = struct_name_len;
    ti.struct_def = struct_def;
    return ti;
}

func typeinfo_make_array(ptr_depth: u64, elem_type_kind: u64, elem_ptr_depth: u64, elem_struct_name_ptr: u64, elem_struct_name_len: u64, elem_struct_def: *AstStructDef, array_len: u64) -> *TypeInfo {
    var ti: *TypeInfo = new TypeInfo(TYPE_ARRAY, ptr_depth);
    ti.struct_name_ptr = elem_struct_name_ptr;
    ti.struct_name_len = elem_struct_name_len;
    ti.struct_def = elem_struct_def;
    ti.elem_type_kind = elem_type_kind;
    ti.elem_ptr_depth = elem_ptr_depth;
    ti.array_len = array_len;
    return ti;
}

func typeinfo_make_slice(ptr_depth: u64, elem_type_kind: u64, elem_ptr_depth: u64, elem_struct_name_ptr: u64, elem_struct_name_len: u64, elem_struct_def: *AstStructDef) -> *TypeInfo {
    var ti: *TypeInfo = new TypeInfo(TYPE_SLICE, ptr_depth);
    ti.struct_name_ptr = elem_struct_name_ptr;
    ti.struct_name_len = elem_struct_name_len;
    ti.struct_def = elem_struct_def;
    ti.elem_type_kind = elem_type_kind;
    ti.elem_ptr_depth = elem_ptr_depth;
    return ti;
}

func typeinfo_make_trait(ptr_depth: u64, trait_ptr: u64, trait_len: u64) -> *TypeInfo {
    var ti: *TypeInfo = new TypeInfo(TYPE_TRAIT, ptr_depth);
    ti.struct_name_ptr = trait_ptr;
    ti.struct_name_len = trait_len;
    return ti;
}

// Global struct definitions (set by codegen before use)
var g_structs_vec: *Vec<*AstStructDef>;
// Global function definitions (set by codegen before use)
var g_funcs_vec: *Vec<*AstFunc>;

func typeinfo_set_structs(structs: *Vec<*AstStructDef>) -> u64 {
    g_structs_vec = structs;
    return 0;
}

func typeinfo_get_structs() -> *Vec<*AstStructDef> {
    return g_structs_vec;
}

func typeinfo_set_funcs(funcs: *Vec<*AstFunc>) -> u64 {
    g_funcs_vec = funcs;
    return 0;
}

func typeinfo_find_func(name_ptr: u64, name_len: u64) -> *AstFunc {
    if (g_funcs_vec == 0) { return 0; }
    var resolved_ptr: u64 = name_ptr;
    var resolved_len: u64 = name_len;
    var resolved: *NameInfo = resolve_name(name_ptr, name_len);
    if (resolved != 0) {
        resolved_ptr = resolved.ptr;
        resolved_len = resolved.len;
    }
    var num_funcs: u64 = g_funcs_vec.len();
    for (var i: u64 = 0; i < num_funcs; i++) {
        var fn: *AstFunc = g_funcs_vec.get(i);
        if (str_eq(fn.name_ptr, fn.name_len, resolved_ptr, resolved_len)) {
            return fn;
        }
        if (str_eq(fn.name_ptr, fn.name_len, name_ptr, name_len)) {
            return fn;
        }
    }
    return 0;
}

// ============================================
// Type Size Helpers
// ============================================

func get_type_size(base_type: u64, ptr_depth: u64) -> u64 {
    if (ptr_depth > 0) { return 8; }
    if (base_type == TYPE_U8) { return 1; }
    if (base_type == TYPE_U16) { return 2; }
    if (base_type == TYPE_U32) { return 4; }
    if (base_type == TYPE_U64) { return 8; }
    if (base_type == TYPE_I64) { return 8; }
    if (base_type == TYPE_F64) { return 8; }
    if (base_type == TYPE_SLICE) { return 16; }
    if (base_type == TYPE_TRAIT) { return 8; }
    return 8;
}

func get_pointee_size(base_type: u64, ptr_depth: u64) -> u64 {
    if (ptr_depth > 1) { return 8; }
    if (ptr_depth == 1) {
        if (base_type == TYPE_U8) { return 1; }
        if (base_type == TYPE_U16) { return 2; }
        if (base_type == TYPE_U32) { return 4; }
        if (base_type == TYPE_U64) { return 8; }
        if (base_type == TYPE_I64) { return 8; }
        if (base_type == TYPE_F64) { return 8; }
        if (base_type == TYPE_SLICE) { return 16; }
        if (base_type == TYPE_TRAIT) { return 8; }
    }
    return 8;
}

func sizeof_field_desc(field: *FieldDesc) -> u64 {
    if (field.bit_width > 0) {
        return (field.bit_width + 7) / 8;
    }
    if (field.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = sizeof_type(field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len);
        return elem_size * field.array_len;
    }
    if (field.type_kind == TYPE_SLICE) { return 16; }
    return sizeof_type(field.type_kind, field.ptr_depth, field.struct_name_ptr, field.struct_name_len);
}

func get_field_desc(struct_def: *AstStructDef, field_name_ptr: u64, field_name_len: u64) -> *FieldDesc {
    var field_desc: *FieldDesc = typeinfo_find_field_desc_scoped(struct_def, 0, 0, field_name_ptr, field_name_len);
    return field_desc;
}

func check_type_compat(from_base: u64, from_depth: u64, from_tagged: u64, from_layout_ptr: u64, from_layout_len: u64, to_base: u64, to_depth: u64, to_tagged: u64, to_layout_ptr: u64, to_layout_len: u64) -> u64 {
    if (from_base == TYPE_ARRAY || to_base == TYPE_ARRAY || from_base == TYPE_SLICE || to_base == TYPE_SLICE) {
        if (from_base == to_base && from_depth == to_depth) { return false; }
        return true;
    }
    if (from_base == to_base) {
        if (from_depth == to_depth) {
            if (from_depth > 0 && from_tagged != to_tagged) { return true; }
            if (from_depth > 0 && from_tagged == 1) {
                if (!str_eq(from_layout_ptr, from_layout_len, to_layout_ptr, to_layout_len)) { return true; }
            }
            return false;
        }
    }
    if (from_depth > 0) {
        if (to_depth > 0) { return true; }
    }
    if (from_depth == 0) {
        if (to_depth == 0) {
            var from_size: u64 = get_type_size(from_base, 0);
            var to_size: u64 = get_type_size(to_base, 0);
            if (from_size == to_size) { return false; }
            return true;
        }
    }
    if (from_depth == 0) {
        if (to_depth > 0) { return true; }
    }
    if (from_depth > 0) {
        if (to_depth == 0) { return true; }
    }
    return true;
}

// Calculate size of a type including structs
// Returns size in bytes for allocating on stack
func sizeof_type(type_kind: u64, ptr_depth: u64, struct_name_ptr: u64, struct_name_len: u64) -> u64 {
    // Pointers are always 8 bytes
    if (ptr_depth > 0) { return 8; }

    // Primitive types
    switch (type_kind) {
        case TYPE_U8: return 1;
        case TYPE_U16: return 2;
        case TYPE_U32: return 4;
        case TYPE_U64: return 8;
        case TYPE_I64: return 8;
        case TYPE_F64: return 8;
        case TYPE_SLICE: return 16;
        case TYPE_TRAIT: return 8;
        case TYPE_STRUCT:
            var struct_def: *AstStructDef = _typeinfo_find_struct_def(struct_name_ptr, struct_name_len);
            if (struct_def == 0) { return 8; }
            return _typeinfo_struct_size(struct_def);
    }

    // Default: 8 bytes
    return 8;
}

func _typeinfo_find_struct_def(struct_name_ptr: u64, struct_name_len: u64) -> *AstStructDef {
    var num_structs: u64 = g_structs_vec.?len();
    for (var si: u64 = 0; si < num_structs; si++) {
        var candidate: *AstStructDef = g_structs_vec.get(si);
        if (str_eq(candidate.name_ptr, candidate.name_len, struct_name_ptr, struct_name_len)) {
            return candidate;
        }
    }
    return 0;
}

func _typeinfo_packed_struct_size(struct_info: *AstStructDef) -> u64 {
    var fields_p: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields_p: u64 = fields_p.len();
    var total_bits: u64 = 0;
    for (var pi: u64 = 0; pi < num_fields_p; pi++) {
        var field_p: *FieldDesc = fields_p.get(pi);
        if (field_p.bit_width > 0) {
            total_bits = total_bits + field_p.bit_width;
        } else {
            var fsize: u64 = sizeof_field_desc(field_p);
            total_bits = total_bits + fsize * 8;
        }
    }
    return (total_bits + 7) / 8;
}

func _typeinfo_struct_size(struct_info: *AstStructDef) -> u64 {
    return _typeinfo_struct_size_internal(struct_info, 0);
}

// Sizeof helper for extended types (array/slice)
func sizeof_type_ex(info: *TypeInfo) -> u64 {
    if (info.ptr_depth > 0) { return 8; }
    if (info.type_kind == TYPE_STRUCT && info.ptr_depth == 0) {
        if (info.struct_name_ptr == 0 && info.struct_def != 0) {
            var struct_def: *AstStructDef = info.struct_def;
            return _typeinfo_struct_size_internal(struct_def, 0);
        }
    }
    if (info.type_kind == TYPE_ARRAY) {
        var elem_size: u64 = sizeof_type(info.elem_type_kind, info.elem_ptr_depth, info.struct_name_ptr, info.struct_name_len);
        return elem_size * info.array_len;
    }
    if (info.type_kind == TYPE_SLICE) { return 16; }
    if (info.type_kind == TYPE_TRAIT) { return 8; }
    return sizeof_type(info.type_kind, info.ptr_depth, info.struct_name_ptr, info.struct_name_len);
}

// ============================================
// Struct Helper Functions
// ============================================

func _typeinfo_resolve_parent_def(parent: *ParentDesc) -> *AstStructDef {
    if (parent.struct_def != 0) { return parent.struct_def; }
    var sd: *AstStructDef = get_struct_def(parent.name_ptr, parent.name_len);
    if (sd == 0) {
        emit_stderr("[ERROR] Parent struct not found: ", 34);
        emit_stderr(parent.name_ptr, parent.name_len);
        emit_stderr("\n", 1);
        panic("TypeInfo error");
    }
    parent.struct_def = sd;
    return sd;
}

func _typeinfo_struct_size_internal(struct_info: *AstStructDef, depth: u64) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n", 40);
        panic("TypeInfo error");
    }
    if (struct_info.is_packed == 1) {
        if (struct_info.parents_vec != 0 && struct_info.parents_vec.len() > 0) {
            emit_stderr("[ERROR] packed struct cannot use inheritance\n", 50);
            panic("TypeInfo error");
        }
        return _typeinfo_packed_struct_size(struct_info);
    }
    var total_size: u64 = 0;
    if (struct_info.parents_vec != 0) {
        var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
        var pn: u64 = parents.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = parents.get(pi);
            var parent_def: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc);
            var parent_size: u64 = _typeinfo_struct_size_internal(parent_def, depth + 1);
            total_size = total_size + parent_size;
        }
    }
    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    for (var i: u64 = 0; i < num_fields; i++) {
        var field: *FieldDesc = fields.get(i);
        var field_size: u64 = sizeof_field_desc(field);
        total_size = total_size + field_size;
    }
    return total_size;
}

func _typeinfo_find_parent_offset(struct_info: *AstStructDef, target_ptr: u64, target_len: u64, base_offset: u64, depth: u64, out_offset: *u64, out_def: **AstStructDef) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n", 40);
        panic("TypeInfo error");
    }
    if (str_eq(struct_info.name_ptr, struct_info.name_len, target_ptr, target_len)) {
        *out_offset = base_offset;
        *out_def = struct_info;
        return 1;
    }
    if (struct_info.parents_vec == 0) { return 0; }
    var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
    var pn: u64 = parents.len();
    var cumulative: u64 = 0;
    for (var i: u64 = 0; i < pn; i++) {
        var parent_desc: *ParentDesc = parents.get(i);
        var parent_def: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc);
        var found: u64 = _typeinfo_find_parent_offset(parent_def, target_ptr, target_len, base_offset + cumulative, depth + 1, out_offset, out_def);
        if (found != 0) { return 1; }
        var parent_size: u64 = _typeinfo_struct_size_internal(parent_def, depth + 1);
        cumulative = cumulative + parent_size;
    }
    return 0;
}

func _typeinfo_struct_find_field_internal(struct_info: *AstStructDef, field_ptr: u64, field_len: u64, depth: u64, out_offset: *u64, out_desc: **FieldDesc) -> u64 {
    if (struct_info == 0) { return 0; }
    if (depth > 64) {
        emit_stderr("[ERROR] Inheritance depth exceeded\n", 40);
        panic("TypeInfo error");
    }
    if (struct_info.is_packed == 1) {
        emit_stderr("[ERROR] Packed struct field address is not supported\n", 56);
        panic("TypeInfo error");
    }

    var parent_total: u64 = 0;
    if (struct_info.parents_vec != 0) {
        var parents: *Vec<*ParentDesc> = struct_info.parents_vec;
        var pn: u64 = parents.len();
        for (var pi: u64 = 0; pi < pn; pi++) {
            var parent_desc: *ParentDesc = parents.get(pi);
            var parent_def: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc);
            var parent_size: u64 = _typeinfo_struct_size_internal(parent_def, depth + 1);
            parent_total = parent_total + parent_size;
        }
    }

    var fields: *Vec<*FieldDesc> = struct_info.fields_vec;
    var num_fields: u64 = fields.len();
    var offset: u64 = parent_total;
    for (var i: u64 = 0; i < num_fields; i++) {
        var field: *FieldDesc = fields.get(i);
        if (str_eq(field.name_ptr, field.name_len, field_ptr, field_len)) {
            *out_offset = offset;
            *out_desc = field;
            return 1;
        }
        var field_size: u64 = sizeof_field_desc(field);
        offset = offset + field_size;
    }

    var match_count: u64 = 0;
    var match_offset: u64 = 0;
    var match_desc: *FieldDesc = 0;
    if (struct_info.parents_vec != 0) {
        var parents2: *Vec<*ParentDesc> = struct_info.parents_vec;
        var pn2: u64 = parents2.len();
        var cumulative: u64 = 0;
        for (var j: u64 = 0; j < pn2; j++) {
            var parent_desc2: *ParentDesc = parents2.get(j);
            var parent_def2: *AstStructDef = _typeinfo_resolve_parent_def(parent_desc2);
            var child_offset: u64 = 0;
            var child_desc: *FieldDesc = 0;
            var found: u64 = _typeinfo_struct_find_field_internal(parent_def2, field_ptr, field_len, depth + 1, &child_offset, &child_desc);
            if (found != 0) {
                match_count = match_count + 1;
                if (match_count == 1) {
                    match_offset = cumulative + child_offset;
                    match_desc = child_desc;
                }
            }
            var parent_size2: u64 = _typeinfo_struct_size_internal(parent_def2, depth + 1);
            cumulative = cumulative + parent_size2;
        }
    }
    if (match_count > 1) {
        emit_stderr("[ERROR] Ambiguous field access: ", 36);
        emit_stderr(struct_info.name_ptr, struct_info.name_len);
        emit_stderr(".", 1);
        emit_stderr(field_ptr, field_len);
        emit_stderr("\n", 1);
        panic("TypeInfo error");
    }
    if (match_count == 1) {
        *out_offset = match_offset;
        *out_desc = match_desc;
        return 1;
    }
    return 0;
}

    func struct_find_field_desc_scoped(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, field_ptr: u64, field_len: u64, out_offset: *u64, out_desc: **FieldDesc) -> u64 {
    if (struct_def == 0) { return 0; }
    if (parent_ptr != 0) {
        var parent_offset: u64 = 0;
        var parent_def: *AstStructDef = 0;
        var found_parent: u64 = _typeinfo_find_parent_offset(struct_def, parent_ptr, parent_len, 0, 0, &parent_offset, &parent_def);
        if (found_parent == 0 || parent_def == 0) {
            emit_stderr("[ERROR] Parent scope not found: ", 35);
            emit_stderr(parent_ptr, parent_len);
            emit_stderr("\n", 1);
            panic("TypeInfo error");
        }
        var field_offset: u64 = 0;
        var field_desc: *FieldDesc = 0;
        var found_field: u64 = _typeinfo_struct_find_field_internal(parent_def, field_ptr, field_len, 0, &field_offset, &field_desc);
        if (found_field == 0 || field_desc == 0) {
            emit_stderr("[ERROR] Field not found in parent scope: ", 44);
            emit_stderr(parent_ptr, parent_len);
            emit_stderr(".", 1);
            emit_stderr(field_ptr, field_len);
            emit_stderr("\n", 1);
            panic("TypeInfo error");
        }
        *out_offset = parent_offset + field_offset;
        *out_desc = field_desc;
        return 1;
    }
    return _typeinfo_struct_find_field_internal(struct_def, field_ptr, field_len, 0, out_offset, out_desc);
}

func typeinfo_find_field_desc_scoped(struct_def: *AstStructDef, parent_ptr: u64, parent_len: u64, field_ptr: u64, field_len: u64) -> *FieldDesc {
    if (struct_def == 0) { return 0; }
    if (struct_def.is_packed == 1) {
        if (parent_ptr != 0) {
            emit_stderr("[ERROR] Packed struct cannot use parent scope\n", 49);
            panic("TypeInfo error");
        }
        var fields: *Vec<*FieldDesc> = struct_def.fields_vec;
        var num_fields: u64 = fields.len();
        for (var i: u64 = 0; i < num_fields; i++) {
            var field: *FieldDesc = fields.get(i);
            if (str_eq(field.name_ptr, field.name_len, field_ptr, field_len)) {
                return field;
            }
        }
        return 0;
    }
    var field_offset: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found: u64 = struct_find_field_desc_scoped(struct_def, parent_ptr, parent_len, field_ptr, field_len, &field_offset, &field_desc);
    if (found == 0) { return 0; }
    return field_desc;
}

// Get field offset in bytes from struct definition
// Returns 0 if field not found (caller must handle)
func get_field_offset(struct_def: *AstStructDef, field_name_ptr: u64, field_name_len: u64) -> u64 {
    var field_offset: u64 = 0;
    var field_desc: *FieldDesc = 0;
    var found: u64 = struct_find_field_desc_scoped(struct_def, 0, 0, field_name_ptr, field_name_len, &field_offset, &field_desc);
    if (found == 0) { return 0; }
    return field_offset;
}

// ============================================
// Expression Type Inference
// ============================================

// Forward declarations for symtab functions (imported by codegen)
// We need g_symtab from emitter module

func get_expr_type_with_symtab(node: *AstNode, symtab: *Symtab) -> *TypeInfo {
    var kind: u64 = ast_kind(node);

    if (kind == AST_NEW) {
        var nw: *AstNew = (*AstNew)node;
        var out_ptr_depth: u64 = nw.ptr_depth + 1;
        if (nw.type_kind == TYPE_STRUCT) {
            var struct_def: *AstStructDef = get_struct_def(nw.struct_name_ptr, nw.struct_name_len);
            var ti_s: *TypeInfo = typeinfo_make_struct(out_ptr_depth, nw.struct_name_ptr, nw.struct_name_len, struct_def);
            ti_s.is_tagged = nw.is_tagged;
            return ti_s;
        }
        if (nw.type_kind == TYPE_ARRAY) {
            var elem_def: *AstStructDef = 0;
            if (nw.elem_type_kind == TYPE_STRUCT) {
                elem_def = get_struct_def(nw.struct_name_ptr, nw.struct_name_len);
            }
            return typeinfo_make_array(out_ptr_depth, nw.elem_type_kind, nw.elem_ptr_depth, nw.struct_name_ptr, nw.struct_name_len, elem_def, nw.array_len);
        }
        if (nw.type_kind == TYPE_SLICE) {
            var elem_def2: *AstStructDef = 0;
            if (nw.elem_type_kind == TYPE_STRUCT) {
                elem_def2 = get_struct_def(nw.struct_name_ptr, nw.struct_name_len);
            }
            return typeinfo_make_slice(out_ptr_depth, nw.elem_type_kind, nw.elem_ptr_depth, nw.struct_name_ptr, nw.struct_name_len, elem_def2);
        }
        var ti_p: *TypeInfo = typeinfo_make(nw.type_kind, out_ptr_depth);
        ti_p.is_tagged = nw.is_tagged;
        ti_p.struct_name_ptr = nw.struct_name_ptr;
        ti_p.struct_name_len = nw.struct_name_len;
        ti_p.tag_layout_ptr = nw.tag_layout_ptr;
        ti_p.tag_layout_len = nw.tag_layout_len;
        return ti_p;
    }

    if (kind == AST_STACK_CTOR) {
        var sc: *AstStackCtor = (*AstStackCtor)node;
        if (sc.type_kind == TYPE_STRUCT) {
            var struct_def_sc: *AstStructDef = get_struct_def(sc.struct_name_ptr, sc.struct_name_len);
            var ti_sc: *TypeInfo = typeinfo_make_struct(sc.ptr_depth, sc.struct_name_ptr, sc.struct_name_len, struct_def_sc);
            ti_sc.is_tagged = sc.is_tagged;
            return ti_sc;
        }
        var ti_sc2: *TypeInfo = typeinfo_make(sc.type_kind, sc.ptr_depth);
        ti_sc2.is_tagged = sc.is_tagged;
        ti_sc2.struct_name_ptr = sc.struct_name_ptr;
        ti_sc2.struct_name_len = sc.struct_name_len;
        ti_sc2.tag_layout_ptr = sc.tag_layout_ptr;
        ti_sc2.tag_layout_len = sc.tag_layout_len;
        return ti_sc2;
    }

    if (kind == AST_SIZEOF || kind == AST_SIZEOF_EXPR) {
        return typeinfo_make(TYPE_U64, 0);
    }

    if (kind == AST_CALL) {
        if (g_funcs_vec != 0) {
            var call: *AstCall = (*AstCall)node;
            var name_ptr: u64 = call.name_ptr;
            var name_len: u64 = call.name_len;
            var resolved_ptr: u64 = name_ptr;
            var resolved_len: u64 = name_len;
            var resolved: *NameInfo = resolve_name(name_ptr, name_len);
            if (resolved != 0) {
                resolved_ptr = resolved.ptr;
                resolved_len = resolved.len;
            }
            var num_funcs: u64 = g_funcs_vec.len();
            for (var i: u64 = 0; i < num_funcs; i++) {
                var fn: *AstFunc = g_funcs_vec.get(i);
                if (str_eq(fn.name_ptr, fn.name_len, resolved_ptr, resolved_len) ||
                    str_eq(fn.name_ptr, fn.name_len, name_ptr, name_len)) {

                    if (fn.ret_type == TYPE_STRUCT) {
                        var struct_def: *AstStructDef = get_struct_def(fn.ret_struct_name_ptr, fn.ret_struct_name_len);
                        var rs: *TypeInfo = typeinfo_make_struct(fn.ret_ptr_depth, fn.ret_struct_name_ptr, fn.ret_struct_name_len, struct_def);
                        rs.is_tagged = fn.ret_is_tagged;
                        return rs;
                    }
                    if (fn.ret_type == TYPE_SLICE) {
                        // Slice return type: element type info is not stored on AstFunc.
                        // Preserve slice shape (base kind + pointer depth) for codegen.
                        var rsl: *TypeInfo = typeinfo_make(fn.ret_type, fn.ret_ptr_depth);
                        rsl.is_tagged = fn.ret_is_tagged;
                        return rsl;
                    }
                    var rb: *TypeInfo = typeinfo_make(fn.ret_type, fn.ret_ptr_depth);
                    rb.is_tagged = fn.ret_is_tagged;
                    rb.struct_name_ptr = fn.ret_struct_name_ptr;
                    rb.struct_name_len = fn.ret_struct_name_len;
                    rb.tag_layout_ptr = fn.ret_tag_layout_ptr;
                    rb.tag_layout_len = fn.ret_tag_layout_len;
                    return rb;
                }
            }
        }
        return typeinfo_make(TYPE_I64, 0);
    }

    if (kind == AST_CALL_PTR) {
        if (g_funcs_vec != 0) {
            var cp: *AstCallPtr = (*AstCallPtr)node;
            var callee: u64 = cp.callee;
            var name_ptr2: u64 = 0;
            var name_len2: u64 = 0;
            var ck: u64 = ast_kind(callee);
            if (ck == AST_IDENT) {
                var idn: *AstIdent = (*AstIdent)callee;
                name_ptr2 = idn.name_ptr;
                name_len2 = idn.name_len;
            } else if (ck == AST_ADDR_OF) {
                var a: *AstAddrOf = (*AstAddrOf)callee;
                if (ast_kind(a.operand) == AST_IDENT) {
                    var idn2: *AstIdent = (*AstIdent)a.operand;
                    name_ptr2 = idn2.name_ptr;
                    name_len2 = idn2.name_len;
                }
            }

            if (name_ptr2 != 0) {
                var resolved_ptr2: u64 = name_ptr2;
                var resolved_len2: u64 = name_len2;
                var resolved2: *NameInfo = resolve_name(name_ptr2, name_len2);
                if (resolved2 != 0) {
                    resolved_ptr2 = resolved2.ptr;
                    resolved_len2 = resolved2.len;
                }
                var num_funcs2: u64 = g_funcs_vec.len();
                for (var j: u64 = 0; j < num_funcs2; j++) {
                    var fn2: *AstFunc = g_funcs_vec.get(j);
                    if (str_eq(fn2.name_ptr, fn2.name_len, resolved_ptr2, resolved_len2)) {
                        if (fn2.ret_type == TYPE_STRUCT) {
                            var struct_def2: *AstStructDef = get_struct_def(fn2.ret_struct_name_ptr, fn2.ret_struct_name_len);
                            var rs2: *TypeInfo = typeinfo_make_struct(fn2.ret_ptr_depth, fn2.ret_struct_name_ptr, fn2.ret_struct_name_len, struct_def2);
                            rs2.is_tagged = fn2.ret_is_tagged;
                            return rs2;
                        }
                        if (fn2.ret_type == TYPE_SLICE) {
                            var rsl2: *TypeInfo = typeinfo_make(fn2.ret_type, fn2.ret_ptr_depth);
                            rsl2.is_tagged = fn2.ret_is_tagged;
                            return rsl2;
                        }
                        var rb2: *TypeInfo = typeinfo_make(fn2.ret_type, fn2.ret_ptr_depth);
                        rb2.is_tagged = fn2.ret_is_tagged;
                        rb2.struct_name_ptr = fn2.ret_struct_name_ptr;
                        rb2.struct_name_len = fn2.ret_struct_name_len;
                        rb2.tag_layout_ptr = fn2.ret_tag_layout_ptr;
                        rb2.tag_layout_len = fn2.ret_tag_layout_len;
                        return rb2;
                    }
                }
            }
        }
        return typeinfo_make(TYPE_I64, 0);
    }

    if (kind == AST_METHOD_CALL) {
        if (g_funcs_vec != 0) {
            var mc: *AstMethodCall = (*AstMethodCall)node;
            var receiver: u64 = mc.receiver;
            var recv_ti: *TypeInfo = get_expr_type_with_symtab(receiver, symtab);
            if (recv_ti == 0) { return typeinfo_make(TYPE_I64, 0); }
            if (recv_ti.type_kind == TYPE_TRAIT || compiler_is_trait_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len) != 0) {
                var trait_def: *TraitDef = compiler_get_trait_def(recv_ti.struct_name_ptr, recv_ti.struct_name_len);
                if (trait_def == 0) { return typeinfo_make(TYPE_I64, 0); }
                var mcount: u64 = trait_def.methods_vec.len();
                for (var mi: u64 = 0; mi < mcount; mi++) {
                    var tm: *TraitMethod = trait_def.methods_vec.get(mi);
                    if (str_eq(tm.name_ptr, tm.name_len, mc.method_ptr, mc.method_len)) {
                        var sig: *AstFunc = tm.sig;
                        if (sig.ret_type == TYPE_STRUCT && sig.ret_ptr_depth == 0) { return typeinfo_make(TYPE_I64, 0); }
                        if (sig.ret_type == TYPE_STRUCT) {
                            var struct_def_t: *AstStructDef = get_struct_def(sig.ret_struct_name_ptr, sig.ret_struct_name_len);
                            var rs_t: *TypeInfo = typeinfo_make_struct(sig.ret_ptr_depth, sig.ret_struct_name_ptr, sig.ret_struct_name_len, struct_def_t);
                            rs_t.is_tagged = sig.ret_is_tagged;
                            return rs_t;
                        }
                        var rb_t: *TypeInfo = typeinfo_make(sig.ret_type, sig.ret_ptr_depth);
                        rb_t.is_tagged = sig.ret_is_tagged;
                        rb_t.struct_name_ptr = sig.ret_struct_name_ptr;
                        rb_t.struct_name_len = sig.ret_struct_name_len;
                        rb_t.tag_layout_ptr = sig.ret_tag_layout_ptr;
                        rb_t.tag_layout_len = sig.ret_tag_layout_len;
                        return rb_t;
                    }
                }
                return typeinfo_make(TYPE_I64, 0);
            }
            if (recv_ti.type_kind != TYPE_STRUCT) { return typeinfo_make(TYPE_I64, 0); }

            var name_info: *NameInfo = compiler_build_method_name(recv_ti.struct_name_ptr, recv_ti.struct_name_len, mc.method_ptr, mc.method_len);
            var resolved_ptr2: u64 = name_info.ptr;
            var resolved_len2: u64 = name_info.len;
            var resolved2: *NameInfo = resolve_name(name_info.ptr, name_info.len);
            if (resolved2 != 0) {
                resolved_ptr2 = resolved2.ptr;
                resolved_len2 = resolved2.len;
            }

            var num_funcs2: u64 = g_funcs_vec.len();
            for (var k2: u64 = 0; k2 < num_funcs2; k2++) {
                var fn2: *AstFunc = g_funcs_vec.get(k2);
                if (str_eq(fn2.name_ptr, fn2.name_len, resolved_ptr2, resolved_len2)) {
                    if (fn2.ret_type == TYPE_STRUCT) {
                        var struct_def2: *AstStructDef = get_struct_def(fn2.ret_struct_name_ptr, fn2.ret_struct_name_len);
                        var rs2: *TypeInfo = typeinfo_make_struct(fn2.ret_ptr_depth, fn2.ret_struct_name_ptr, fn2.ret_struct_name_len, struct_def2);
                        rs2.is_tagged = fn2.ret_is_tagged;
                        return rs2;
                    }
                    if (fn2.ret_type == TYPE_SLICE) {
                        var rsl2: *TypeInfo = typeinfo_make(fn2.ret_type, fn2.ret_ptr_depth);
                        rsl2.is_tagged = fn2.ret_is_tagged;
                        return rsl2;
                    }
                    var rb2: *TypeInfo = typeinfo_make(fn2.ret_type, fn2.ret_ptr_depth);
                    rb2.is_tagged = fn2.ret_is_tagged;
                    rb2.struct_name_ptr = fn2.ret_struct_name_ptr;
                    rb2.struct_name_len = fn2.ret_struct_name_len;
                    rb2.tag_layout_ptr = fn2.ret_tag_layout_ptr;
                    rb2.tag_layout_len = fn2.ret_tag_layout_len;
                    return rb2;
                }
            }
        }
        return typeinfo_make(TYPE_I64, 0);
    }

    if (kind == AST_SAFE_METHOD_CALL) {
        if (g_funcs_vec != 0) {
            var smc: *AstMethodCall = (*AstMethodCall)node;
            var sreceiver: u64 = smc.receiver;
            var srecv_ti: *TypeInfo = get_expr_type_with_symtab(sreceiver, symtab);
            if (srecv_ti == 0) { return typeinfo_make(TYPE_I64, 0); }
            if (srecv_ti.ptr_depth == 0) {
                emit_stderr("[ERROR] Safe method call requires pointer receiver\n", 59);
                return typeinfo_make(TYPE_I64, 0);
            }
            if (srecv_ti.type_kind == TYPE_TRAIT || compiler_is_trait_name(srecv_ti.struct_name_ptr, srecv_ti.struct_name_len) != 0) {
                var trait_def2: *TraitDef = compiler_get_trait_def(srecv_ti.struct_name_ptr, srecv_ti.struct_name_len);
                if (trait_def2 == 0) { return typeinfo_make(TYPE_I64, 0); }
                var mcount2: u64 = trait_def2.methods_vec.len();
                for (var mi2: u64 = 0; mi2 < mcount2; mi2++) {
                    var tm2: *TraitMethod = trait_def2.methods_vec.get(mi2);
                    if (str_eq(tm2.name_ptr, tm2.name_len, smc.method_ptr, smc.method_len)) {
                        var sig2: *AstFunc = tm2.sig;
                        if (sig2.ret_type == TYPE_STRUCT && sig2.ret_ptr_depth == 0) {
                            emit_stderr("[ERROR] Safe method call cannot return struct by value\n", 69);
                            return typeinfo_make(TYPE_I64, 0);
                        }
                        if (sig2.ret_type == TYPE_STRUCT) {
                            var struct_def_t2: *AstStructDef = get_struct_def(sig2.ret_struct_name_ptr, sig2.ret_struct_name_len);
                            var rs_t2: *TypeInfo = typeinfo_make_struct(sig2.ret_ptr_depth, sig2.ret_struct_name_ptr, sig2.ret_struct_name_len, struct_def_t2);
                            rs_t2.is_tagged = sig2.ret_is_tagged;
                            return rs_t2;
                        }
                        var rb_t2: *TypeInfo = typeinfo_make(sig2.ret_type, sig2.ret_ptr_depth);
                        rb_t2.is_tagged = sig2.ret_is_tagged;
                        rb_t2.struct_name_ptr = sig2.ret_struct_name_ptr;
                        rb_t2.struct_name_len = sig2.ret_struct_name_len;
                        rb_t2.tag_layout_ptr = sig2.ret_tag_layout_ptr;
                        rb_t2.tag_layout_len = sig2.ret_tag_layout_len;
                        return rb_t2;
                    }
                }
                return typeinfo_make(TYPE_I64, 0);
            }
            if (srecv_ti.type_kind != TYPE_STRUCT) { return typeinfo_make(TYPE_I64, 0); }

            var sname_info: *NameInfo = compiler_build_method_name(srecv_ti.struct_name_ptr, srecv_ti.struct_name_len, smc.method_ptr, smc.method_len);
            var sresolved_ptr2: u64 = sname_info.ptr;
            var sresolved_len2: u64 = sname_info.len;
            var sresolved2: *NameInfo = resolve_name(sname_info.ptr, sname_info.len);
            if (sresolved2 != 0) {
                sresolved_ptr2 = sresolved2.ptr;
                sresolved_len2 = sresolved2.len;
            }

            var snum_funcs2: u64 = g_funcs_vec.len();
            for (var sk2: u64 = 0; sk2 < snum_funcs2; sk2++) {
                var sfn2: *AstFunc = g_funcs_vec.get(sk2);
                if (str_eq(sfn2.name_ptr, sfn2.name_len, sresolved_ptr2, sresolved_len2)) {
                    if (sfn2.ret_type == TYPE_STRUCT) {
                        if (sfn2.ret_ptr_depth == 0) {
                            emit_stderr("[ERROR] Safe method call cannot return struct by value\n", 69);
                            return typeinfo_make(TYPE_I64, 0);
                        }
                        var sstruct_def2: *AstStructDef = get_struct_def(sfn2.ret_struct_name_ptr, sfn2.ret_struct_name_len);
                        var srs2: *TypeInfo = typeinfo_make_struct(sfn2.ret_ptr_depth, sfn2.ret_struct_name_ptr, sfn2.ret_struct_name_len, sstruct_def2);
                        srs2.is_tagged = sfn2.ret_is_tagged;
                        return srs2;
                    }
                    if (sfn2.ret_type == TYPE_SLICE) {
                        var srsl2: *TypeInfo = typeinfo_make(sfn2.ret_type, sfn2.ret_ptr_depth);
                        srsl2.is_tagged = sfn2.ret_is_tagged;
                        return srsl2;
                    }
                    var srb2: *TypeInfo = typeinfo_make(sfn2.ret_type, sfn2.ret_ptr_depth);
                    srb2.is_tagged = sfn2.ret_is_tagged;
                    srb2.struct_name_ptr = sfn2.ret_struct_name_ptr;
                    srb2.struct_name_len = sfn2.ret_struct_name_len;
                    srb2.tag_layout_ptr = sfn2.ret_tag_layout_ptr;
                    srb2.tag_layout_len = sfn2.ret_tag_layout_len;
                    return srb2;
                }
            }
        }
        return typeinfo_make(TYPE_I64, 0);
    }
    
    if (kind == AST_IDENT) {
        var ident: *AstIdent = (*AstIdent)node;
        var name_ptr: u64 = ident.name_ptr;
        var name_len: u64 = ident.name_len;
        // Need to call symtab_get_type - done by caller with symtab param
        var names: *Vec<*NameInfo> = symtab.names_vec;
        var types: *Vec<*TypeInfo> = symtab.types_vec;
        var count: u64 = symtab.count;

        if (count == 0) {
            var resolved_ptr0: u64 = name_ptr;
            var resolved_len0: u64 = name_len;
            var resolved0: *NameInfo = resolve_name(name_ptr, name_len);
            if (resolved0 != 0) {
                resolved_ptr0 = resolved0.ptr;
                resolved_len0 = resolved0.len;
            }
            var ginfo0: *GlobalInfo = compiler_find_global_info(resolved_ptr0, resolved_len0);
            if (ginfo0 == 0 && (resolved_ptr0 != name_ptr || resolved_len0 != name_len)) {
                ginfo0 = compiler_find_global_info(name_ptr, name_len);
            }
            if (ginfo0 != 0) {
                if (ginfo0.typeinfo_ptr != 0) { return ginfo0.typeinfo_ptr; }
            }
            return typeinfo_make(TYPE_I64, 0);
        }

        for (var idx: i64 = (i64)count - 1; idx >= 0; idx = idx - 1) {
            var i: u64 = (u64)idx;
            var name_info: *NameInfo = names.get(i);
            var n_ptr: u64 = name_info.ptr;
            var n_len: u64 = name_info.len;
            
            if (str_eq(n_ptr, n_len, name_ptr, name_len)) {
                return types.get(i);
            }

        }

        var resolved_ptr: u64 = name_ptr;
        var resolved_len: u64 = name_len;
        var resolved: *NameInfo = resolve_name(name_ptr, name_len);
        if (resolved != 0) {
            resolved_ptr = resolved.ptr;
            resolved_len = resolved.len;
        }

        var ginfo: *GlobalInfo = compiler_find_global_info(resolved_ptr, resolved_len);
        if (ginfo == 0 && (resolved_ptr != name_ptr || resolved_len != name_len)) {
            ginfo = compiler_find_global_info(name_ptr, name_len);
        }
        if (ginfo != 0) {
            if (ginfo.typeinfo_ptr != 0) { return ginfo.typeinfo_ptr; }
        }

        // Not found - return default type
        return typeinfo_make(TYPE_I64, 0);
    }
    
    if (kind == AST_STRING) {
        return typeinfo_make(TYPE_U8, 1);
    }
    
    if (kind == AST_CAST) {
        var cast_node: *AstCast = (*AstCast)node;
        if (cast_node.target_type == TYPE_TRAIT) {
            return typeinfo_make_trait(cast_node.target_ptr_depth, cast_node.struct_name_ptr, cast_node.struct_name_len);
        }
        if (cast_node.target_type == TYPE_STRUCT) {
            var struct_def: *AstStructDef = get_struct_def(cast_node.struct_name_ptr, cast_node.struct_name_len);
            var rs: *TypeInfo = typeinfo_make_struct(cast_node.target_ptr_depth, cast_node.struct_name_ptr, cast_node.struct_name_len, struct_def);
            rs.is_tagged = cast_node.target_is_tagged;
            return rs;
        }

        var rb: *TypeInfo = typeinfo_make(cast_node.target_type, cast_node.target_ptr_depth);
        rb.is_tagged = cast_node.target_is_tagged;
        rb.struct_name_ptr = cast_node.struct_name_ptr;
        rb.struct_name_len = cast_node.struct_name_len;
        rb.tag_layout_ptr = cast_node.tag_layout_ptr;
        rb.tag_layout_len = cast_node.tag_layout_len;
        return rb;
    }

    if (kind == AST_TRY) {
        var tr: *AstTry = (*AstTry)node;
        var opt_ti: *TypeInfo = get_expr_type_with_symtab(tr.operand, symtab);
        if (opt_ti == 0) { return 0; }
        if (opt_ti.type_kind != TYPE_STRUCT || opt_ti.ptr_depth != 0) { return 0; }

        var base_len: u64 = compiler_find_generic_suffix_index(opt_ti.struct_name_ptr, opt_ti.struct_name_len);
        var value_ptr: u64 = 0;
        var value_len: u64 = 0;
        if (str_eq(opt_ti.struct_name_ptr, base_len, "Option", 6)) {
            value_ptr = (u64)"value";
            value_len = 5;
        } else if (str_eq(opt_ti.struct_name_ptr, base_len, "Result", 6)) {
            value_ptr = (u64)"ok";
            value_len = 2;
        } else {
            return 0;
        }

        var struct_def: *AstStructDef = opt_ti.struct_def;
        if (struct_def == 0) {
            struct_def = get_struct_def(opt_ti.struct_name_ptr, opt_ti.struct_name_len);
        }
        if (struct_def == 0) { return 0; }

        var field: *FieldDesc = get_field_desc(struct_def, value_ptr, value_len);
        if (field == 0) { return 0; }

        if (field.type_kind == TYPE_STRUCT) {
            var field_struct_def: *AstStructDef = 0;
            if (field.struct_name_ptr != 0) {
                field_struct_def = get_struct_def(field.struct_name_ptr, field.struct_name_len);
            }
            var rs2: *TypeInfo = typeinfo_make_struct(field.ptr_depth, field.struct_name_ptr, field.struct_name_len, field_struct_def);
            rs2.is_tagged = field.is_tagged;
            rs2.tag_layout_ptr = field.tag_layout_ptr;
            rs2.tag_layout_len = field.tag_layout_len;
            return rs2;
        }
        if (field.type_kind == TYPE_ARRAY) {
            var elem_struct_def: *AstStructDef = 0;
            if (field.elem_type_kind == TYPE_STRUCT && field.struct_name_ptr != 0) {
                elem_struct_def = get_struct_def(field.struct_name_ptr, field.struct_name_len);
            }
            return typeinfo_make_array(field.ptr_depth, field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len, elem_struct_def, field.array_len);
        }
        if (field.type_kind == TYPE_SLICE) {
            var elem_struct_def2: *AstStructDef = 0;
            if (field.elem_type_kind == TYPE_STRUCT && field.struct_name_ptr != 0) {
                elem_struct_def2 = get_struct_def(field.struct_name_ptr, field.struct_name_len);
            }
            return typeinfo_make_slice(field.ptr_depth, field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len, elem_struct_def2);
        }
        var rf2: *TypeInfo = typeinfo_make(field.type_kind, field.ptr_depth);
        rf2.is_tagged = field.is_tagged;
        rf2.tag_layout_ptr = field.tag_layout_ptr;
        rf2.tag_layout_len = field.tag_layout_len;
        return rf2;
    }
    
    if (kind == AST_ADDR_OF) {
        var addr_of: *AstAddrOf = (*AstAddrOf)node;
        var operand: u64 = addr_of.operand;
        var op_ti: *TypeInfo = get_expr_type_with_symtab(operand, symtab);
        if (op_ti != 0) {
            var res_ti: *TypeInfo = new TypeInfo(op_ti.type_kind, op_ti.ptr_depth + 1);
            res_ti.struct_def = op_ti.struct_def;
            res_ti.struct_name_ptr = op_ti.struct_name_ptr;
            res_ti.struct_name_len = op_ti.struct_name_len;
            res_ti.elem_type_kind = op_ti.elem_type_kind;
            res_ti.elem_ptr_depth = op_ti.elem_ptr_depth;
            res_ti.array_len = op_ti.array_len;
            return res_ti;
        }
    }
    
    if (kind == AST_DEREF) {
        var deref: *AstDeref = (*AstDeref)node;
        var operand: u64 = deref.operand;
        var op_ti: *TypeInfo = get_expr_type_with_symtab(operand, symtab);
        if (op_ti != 0) {
            var depth: u64 = op_ti.ptr_depth;
            if (depth > 0) {
                var res_ti: *TypeInfo = new TypeInfo(op_ti.type_kind, depth - 1);
                res_ti.struct_def = op_ti.struct_def;
                res_ti.struct_name_ptr = op_ti.struct_name_ptr;
                res_ti.struct_name_len = op_ti.struct_name_len;
                res_ti.elem_type_kind = op_ti.elem_type_kind;
                res_ti.elem_ptr_depth = op_ti.elem_ptr_depth;
                res_ti.array_len = op_ti.array_len;
                return res_ti;
            }
        }
    }
    
    if (kind == AST_DEREF8) {
        return typeinfo_make(TYPE_U8, 0);
    }

    if (kind == AST_INDEX) {
        var index: *AstIndex = (*AstIndex)node;
        var base: u64 = index.base;
        var bt: *TypeInfo = get_expr_type_with_symtab(base, symtab);
        if (bt != 0) {
            if (bt.ptr_depth > 0) {
                if (bt.type_kind == TYPE_STRUCT) {
                    return typeinfo_make_struct(bt.ptr_depth - 1, bt.struct_name_ptr, bt.struct_name_len, bt.struct_def);
                }
                return typeinfo_make(bt.type_kind, bt.ptr_depth - 1);
            }
            if (bt.type_kind == TYPE_ARRAY || bt.type_kind == TYPE_SLICE) {
                if (bt.elem_type_kind == TYPE_STRUCT) {
                    return typeinfo_make_struct(bt.elem_ptr_depth, bt.struct_name_ptr, bt.struct_name_len, bt.struct_def);
                }
                return typeinfo_make(bt.elem_type_kind, bt.elem_ptr_depth);
            }
        }
        return typeinfo_make(TYPE_I64, 0);
    }

    if (kind == AST_SLICE) {
        var slice: *AstSlice = (*AstSlice)node;
        var ptr_expr: u64 = slice.ptr_expr;
        var pt: *TypeInfo = get_expr_type_with_symtab(ptr_expr, symtab);
        if (pt != 0) {
            if (pt.ptr_depth > 0) {
                if (pt.type_kind == TYPE_STRUCT) {
                    return typeinfo_make_slice(0, TYPE_STRUCT, pt.ptr_depth - 1, pt.struct_name_ptr, pt.struct_name_len, pt.struct_def);
                }
                return typeinfo_make_slice(0, pt.type_kind, pt.ptr_depth - 1, 0, 0, 0);
            }
        }
        return typeinfo_make_slice(0, TYPE_U8, 0, 0, 0, 0);
    }
    
    if (kind == AST_MEMBER_ACCESS) {
        var member_access: *AstMemberAccess = (*AstMemberAccess)node;
        var object: u64 = member_access.object;
        var member_ptr: u64 = member_access.member_ptr;
        var member_len: u64 = member_access.member_len;
        var parent_ptr: u64 = member_access.parent_ptr;
        var parent_len: u64 = member_access.parent_len;
        
        // Get the type of the object
        var obj_ti: *TypeInfo = get_expr_type_with_symtab(object, symtab);
        if (obj_ti == 0) { return 0; }
        var base_type: u64 = obj_ti.type_kind;
        var ptr_depth: u64 = obj_ti.ptr_depth;

        // Tagged layout bitfield access
        if (ptr_depth > 0 && obj_ti.is_tagged == 1 && obj_ti.tag_layout_ptr != 0) {
            return typeinfo_make(TYPE_U64, 0);
        }
        
        // Handle ptr.field (dereference pointer first)
        if (ptr_depth > 0) {
            ptr_depth = ptr_depth - 1;
        }
        
        if (base_type != TYPE_STRUCT) { return 0; }
        
        var struct_def: *AstStructDef = obj_ti.struct_def;
        if (struct_def == 0) { return 0; }
        
        var field: *FieldDesc = typeinfo_find_field_desc_scoped(struct_def, parent_ptr, parent_len, member_ptr, member_len);
        if (field == 0) { return 0; }
        var field_type: u64 = field.type_kind;
        var field_ptr_depth: u64 = field.ptr_depth;
        if (field_type == TYPE_STRUCT) {
            var field_struct_def: *AstStructDef = 0;
            if (g_structs_vec != 0) {
                var num_structs: u64 = g_structs_vec.len();
                for (var j: u64 = 0; j < num_structs; j++) {
                    var sd: *AstStructDef = g_structs_vec.get(j);
                    var sname_ptr: u64 = sd.name_ptr;
                    var sname_len: u64 = sd.name_len;
                    if (str_eq(sname_ptr, sname_len, field.struct_name_ptr, field.struct_name_len)) {
                        field_struct_def = sd;
                        break;
                    }
                }
            }
            var rs: *TypeInfo = typeinfo_make_struct(field_ptr_depth, field.struct_name_ptr, field.struct_name_len, field_struct_def);
            rs.is_tagged = field.is_tagged;
            rs.tag_layout_ptr = field.tag_layout_ptr;
            rs.tag_layout_len = field.tag_layout_len;
            return rs;
        }
        if (field_type == TYPE_ARRAY) {
            var elem_struct_def: *AstStructDef = 0;
            if (field.elem_type_kind == TYPE_STRUCT && field.struct_name_ptr != 0) {
                elem_struct_def = get_struct_def(field.struct_name_ptr, field.struct_name_len);
            }
            return typeinfo_make_array(field_ptr_depth, field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len, elem_struct_def, field.array_len);
        }
        if (field_type == TYPE_SLICE) {
            var elem_struct_def2: *AstStructDef = 0;
            if (field.elem_type_kind == TYPE_STRUCT && field.struct_name_ptr != 0) {
                elem_struct_def2 = get_struct_def(field.struct_name_ptr, field.struct_name_len);
            }
            return typeinfo_make_slice(field_ptr_depth, field.elem_type_kind, field.elem_ptr_depth, field.struct_name_ptr, field.struct_name_len, elem_struct_def2);
        }
        var rf: *TypeInfo = typeinfo_make(field_type, field_ptr_depth);
        rf.is_tagged = field.is_tagged;
        rf.tag_layout_ptr = field.tag_layout_ptr;
        rf.tag_layout_len = field.tag_layout_len;
        return rf;
        return 0;
    }

    if (kind == AST_SAFE_MEMBER_ACCESS) {
        var sm: *AstMemberAccess = (*AstMemberAccess)node;
        var sobj: u64 = sm.object;
        var sm_ptr: u64 = sm.member_ptr;
        var sm_len: u64 = sm.member_len;
        var sparent_ptr: u64 = sm.parent_ptr;
        var sparent_len: u64 = sm.parent_len;

        var sobj_ti: *TypeInfo = get_expr_type_with_symtab(sobj, symtab);
        if (sobj_ti == 0) { return 0; }
        if (sobj_ti.ptr_depth == 0) {
            emit_stderr("[ERROR] Safe member access requires pointer receiver\n", 59);
            return 0;
        }
        if (sobj_ti.type_kind != TYPE_STRUCT) { return 0; }

        var sstruct_def: *AstStructDef = sobj_ti.struct_def;
        if (sstruct_def == 0) { return 0; }

        var sfield: *FieldDesc = typeinfo_find_field_desc_scoped(sstruct_def, sparent_ptr, sparent_len, sm_ptr, sm_len);
        if (sfield == 0) { return 0; }
        var sfield_type: u64 = sfield.type_kind;
        var sfield_ptr_depth: u64 = sfield.ptr_depth;
        if (sfield_type == TYPE_STRUCT && sfield_ptr_depth == 0) {
            emit_stderr("[ERROR] Safe member access on struct value is not supported\n", 73);
            return 0;
        }
        if (sfield_type == TYPE_STRUCT) {
            var sfield_struct_def: *AstStructDef = 0;
            if (g_structs_vec != 0) {
                var sstructs_n: u64 = g_structs_vec.len();
                for (var sj: u64 = 0; sj < sstructs_n; sj++) {
                    var sd: *AstStructDef = g_structs_vec.get(sj);
                    var sname_ptr: u64 = sd.name_ptr;
                    var sname_len: u64 = sd.name_len;
                    if (str_eq(sname_ptr, sname_len, sfield.struct_name_ptr, sfield.struct_name_len)) {
                        sfield_struct_def = sd;
                        break;
                    }
                }
            }
            var srs: *TypeInfo = typeinfo_make_struct(sfield_ptr_depth, sfield.struct_name_ptr, sfield.struct_name_len, sfield_struct_def);
            srs.is_tagged = sfield.is_tagged;
            srs.tag_layout_ptr = sfield.tag_layout_ptr;
            srs.tag_layout_len = sfield.tag_layout_len;
            return srs;
        }
        if (sfield_type == TYPE_ARRAY) {
            var selem_struct_def: *AstStructDef = 0;
            if (sfield.elem_type_kind == TYPE_STRUCT && sfield.struct_name_ptr != 0) {
                selem_struct_def = get_struct_def(sfield.struct_name_ptr, sfield.struct_name_len);
            }
            return typeinfo_make_array(sfield_ptr_depth, sfield.elem_type_kind, sfield.elem_ptr_depth, sfield.struct_name_ptr, sfield.struct_name_len, selem_struct_def, sfield.array_len);
        }
        if (sfield_type == TYPE_SLICE) {
            var selem_struct_def2: *AstStructDef = 0;
            if (sfield.elem_type_kind == TYPE_STRUCT && sfield.struct_name_ptr != 0) {
                selem_struct_def2 = get_struct_def(sfield.struct_name_ptr, sfield.struct_name_len);
            }
            return typeinfo_make_slice(sfield_ptr_depth, sfield.elem_type_kind, sfield.elem_ptr_depth, sfield.struct_name_ptr, sfield.struct_name_len, selem_struct_def2);
        }
        var srf: *TypeInfo = typeinfo_make(sfield_type, sfield_ptr_depth);
        srf.is_tagged = sfield.is_tagged;
        srf.tag_layout_ptr = sfield.tag_layout_ptr;
        srf.tag_layout_len = sfield.tag_layout_len;
        return srf;
        return 0;
    }
    
    if (kind == AST_STRUCT_LITERAL) {
        var lit: *AstStructLiteral = (*AstStructLiteral)node;
        var struct_def: *AstStructDef = lit.struct_def;
        return typeinfo_make_struct(0, 0, 0, struct_def);
    }
    
    if (kind == AST_BINARY) {
        var binary: *AstBinary = (*AstBinary)node;
        var op: u64 = binary.op;

        var left_ti_f: *TypeInfo = get_expr_type_with_symtab(binary.left, symtab);
        var right_ti_f: *TypeInfo = get_expr_type_with_symtab(binary.right, symtab);
        if (left_ti_f != 0 && right_ti_f != 0) {
            if (left_ti_f.ptr_depth == 0 && right_ti_f.ptr_depth == 0 && left_ti_f.type_kind == TYPE_F64 && right_ti_f.type_kind == TYPE_F64) {
                if (op == TOKEN_PLUS || op == TOKEN_MINUS || op == TOKEN_STAR || op == TOKEN_SLASH) {
                    return typeinfo_make(TYPE_F64, 0);
                }
            }
        }

        // Logical/comparison operators return i64
        if (op == TOKEN_ANDAND || op == TOKEN_OROR ||
            op == TOKEN_LT || op == TOKEN_GT ||
            op == TOKEN_LTEQ || op == TOKEN_GTEQ ||
            op == TOKEN_EQEQ || op == TOKEN_BANGEQ) {
            return typeinfo_make(TYPE_I64, 0);
        }

        var left: u64 = binary.left;
        var right: u64 = binary.right;
        
        if (op == TOKEN_PLUS || op == TOKEN_MINUS) {
            var left_ti: *TypeInfo = get_expr_type_with_symtab(left, symtab);
            if (left_ti != 0) {
                var l_depth: u64 = left_ti.ptr_depth;
                if (l_depth > 0) {
                    var res_ti: *TypeInfo = new TypeInfo(left_ti.type_kind, l_depth);
                    res_ti.is_tagged = left_ti.is_tagged;
                    res_ti.struct_name_ptr = left_ti.struct_name_ptr;
                    res_ti.struct_name_len = left_ti.struct_name_len;
                    res_ti.tag_layout_ptr = left_ti.tag_layout_ptr;
                    res_ti.tag_layout_len = left_ti.tag_layout_len;
                    res_ti.struct_def = left_ti.struct_def;
                    res_ti.elem_type_kind = left_ti.elem_type_kind;
                    res_ti.elem_ptr_depth = left_ti.elem_ptr_depth;
                    res_ti.array_len = left_ti.array_len;
                    return res_ti;
                }
            }

            var right_ti: *TypeInfo = get_expr_type_with_symtab(right, symtab);
            if (right_ti != 0) {
                var r_depth: u64 = right_ti.ptr_depth;
                if (r_depth > 0) {
                    var res_ti: *TypeInfo = new TypeInfo(right_ti.type_kind, r_depth);
                    res_ti.is_tagged = right_ti.is_tagged;
                    res_ti.struct_name_ptr = right_ti.struct_name_ptr;
                    res_ti.struct_name_len = right_ti.struct_name_len;
                    res_ti.tag_layout_ptr = right_ti.tag_layout_ptr;
                    res_ti.tag_layout_len = right_ti.tag_layout_len;
                    res_ti.struct_def = right_ti.struct_def;
                    res_ti.elem_type_kind = right_ti.elem_type_kind;
                    res_ti.elem_ptr_depth = right_ti.elem_ptr_depth;
                    res_ti.array_len = right_ti.array_len;
                    return res_ti;
                }
            }
        }
    }
    
    if (kind == AST_LITERAL) {
        return typeinfo_make(TYPE_I64, 0);
    }

    if (kind == AST_FLOAT) {
        return typeinfo_make(TYPE_F64, 0);
    }
    
    // Default
    return typeinfo_make(TYPE_I64, 0);
}
