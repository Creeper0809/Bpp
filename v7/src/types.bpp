// types.b - Token and AST type constants for v3.8

// ============================================
// Token Types
// ============================================
const TOKEN_EOF = 0;
const TOKEN_IDENTIFIER = 10;
const TOKEN_NUMBER = 11;
const TOKEN_STRING = 12;
const TOKEN_FLOAT = 13;

// Keywords
const TOKEN_FUNC = 20;
const TOKEN_VAR = 21;
const TOKEN_CONST = 22;
const TOKEN_RETURN = 23;
const TOKEN_IF = 24;
const TOKEN_ELSE = 25;
const TOKEN_WHILE = 26;
const TOKEN_IMPORT = 27;
const TOKEN_FOR = 28;
const TOKEN_SWITCH = 29;
const TOKEN_CASE = 30;
const TOKEN_DEFAULT = 31;
const TOKEN_BREAK = 32;
const TOKEN_CONTINUE = 33;
const TOKEN_ASM = 34;
const TOKEN_TRUE = 35;
const TOKEN_FALSE = 36;
const TOKEN_STRUCT = 37;
const TOKEN_ENUM = 38;
const TOKEN_IMPL = 39;
const TOKEN_TRAIT = 91;
const TOKEN_ABST = 92;
const TOKEN_STATIC = 47;

// Compiler macros
const TOKEN_LINE_MACRO = 45;
const TOKEN_SIZEOF = 46;

// Type keywords
const TOKEN_U8 = 40;
const TOKEN_U16 = 41;
const TOKEN_U32 = 42;
const TOKEN_U64 = 43;
const TOKEN_I64 = 44;
const TOKEN_F64 = 90;
const TOKEN_CHAR = 48;
const TOKEN_TAGGED = 49;
const TOKEN_PACKED = 50;
const TOKEN_AS = 51;
const TOKEN_FROM = 52;
const TOKEN_NULL = 53;
const TOKEN_ALIAS = 54;
const TOKEN_DEFER = 55;
const TOKEN_NEW = 56;
const TOKEN_DELETE = 57;
const TOKEN_CONSTRUCTOR = 58;
const TOKEN_DESTRUCTOR = 59;

// Delimiters
const TOKEN_LPAREN = 100;
const TOKEN_RPAREN = 101;
const TOKEN_LBRACE = 102;
const TOKEN_RBRACE = 103;
const TOKEN_LBRACKET = 104;
const TOKEN_RBRACKET = 105;
const TOKEN_SEMICOLON = 106;
const TOKEN_COLON = 107;
const TOKEN_COMMA = 108;
const TOKEN_DOT = 109;
const TOKEN_ARROW = 110;
const TOKEN_DOT_Q = 111;
const TOKEN_QUESTION = 112;

// Operators
const TOKEN_PLUS = 60;
const TOKEN_MINUS = 61;
const TOKEN_STAR = 62;
const TOKEN_SLASH = 63;
const TOKEN_PERCENT = 64;
const TOKEN_CARET = 65;
const TOKEN_AMPERSAND = 66;
const TOKEN_BANG = 67;
const TOKEN_EQ = 68;
const TOKEN_EQEQ = 69;
const TOKEN_BANGEQ = 70;
const TOKEN_LT = 71;
const TOKEN_GT = 72;
const TOKEN_LTEQ = 73;
const TOKEN_GTEQ = 74;
const TOKEN_PIPE = 75;
const TOKEN_LSHIFT = 76;
const TOKEN_RSHIFT = 77;
const TOKEN_ANDAND = 78;
const TOKEN_OROR = 79;
const TOKEN_PLUSPLUS = 80;
const TOKEN_MINUSMINUS = 81;
const TOKEN_PLUS_EQ = 82;
const TOKEN_MINUS_EQ = 83;
const TOKEN_STAR_EQ = 84;
const TOKEN_SLASH_EQ = 85;
const TOKEN_PERCENT_EQ = 86;
const TOKEN_TILDE = 87;

// ============================================
// AST Node Types
// ============================================

// Expressions
const AST_LITERAL = 100;
const AST_IDENT = 101;
const AST_BINARY = 102;
const AST_UNARY = 103;
const AST_CALL = 104;
const AST_ADDR_OF = 105;
const AST_DEREF = 106;
const AST_DEREF8 = 107;
const AST_CAST = 108;
const AST_STRING = 109;
const AST_MEMBER_ACCESS = 110;
const AST_STRUCT_LITERAL = 111;
const AST_SIZEOF = 112;
const AST_METHOD_CALL = 113;
const AST_INDEX = 114;
const AST_SLICE = 115;
const AST_CALL_PTR = 116;
const AST_SIZEOF_EXPR = 117;
const AST_GENERIC_CALL = 118;
const AST_SAFE_MEMBER_ACCESS = 119;
const AST_SAFE_METHOD_CALL = 120;
const AST_TRY = 121;
const AST_FLOAT = 122;

// Statements
const AST_RETURN = 200;
const AST_VAR_DECL = 201;
const AST_CONST_DECL = 206;
const AST_ASSIGN = 202;
const AST_EXPR_STMT = 203;
const AST_IF = 204;
const AST_WHILE = 205;
const AST_FOR = 207;
const AST_SWITCH = 208;
const AST_CASE = 209;
const AST_BREAK = 211;
const AST_CONTINUE = 212;
const AST_BLOCK = 210;
const AST_ASM = 213;
const AST_ALIAS = 214;
const AST_DEFER = 215;
const AST_NEW = 216;
const AST_DELETE = 217;
const AST_STACK_CTOR = 218;

// Top-level
const AST_FUNC = 300;
const AST_PROGRAM = 301;
const AST_IMPORT = 302;
const AST_STRUCT_DEF = 303;

// ============================================
// Type Constants
// ============================================
const TYPE_VOID = 0;
const TYPE_U8 = 1;
const TYPE_U16 = 2;
const TYPE_U32 = 3;
const TYPE_U64 = 4;
const TYPE_I64 = 5;
const TYPE_F64 = 6;
const TYPE_PTR = 10;
const TYPE_STRUCT = 20;
const TYPE_ARRAY = 21;
const TYPE_SLICE = 22;
const TYPE_GENERIC = 23;
const TYPE_TRAIT = 24;

// Generic param kinds
const GENERIC_KIND_TYPE = 1;
const GENERIC_KIND_VALUE = 2;

// ============================================
// Parser Data Structures
// ============================================

// Parser state (16 bytes)
struct Parser {
    tokens_vec: *Vec<*Token>;
    cur: u64;
}

impl Parser {
    constructor() {
        self.tokens_vec = 0;
        self.cur = 0;
    }
}

// Type information (112 bytes)
struct TypeInfo {
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    struct_def: *AstStructDef;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
}

impl TypeInfo {
    constructor(base_type: u64, ptr_depth: u64) {
        self.type_kind = base_type;
        self.ptr_depth = ptr_depth;
        self.is_tagged = 0;
        self.struct_name_ptr = 0;
        self.struct_name_len = 0;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.struct_def = 0;
        self.elem_type_kind = 0;
        self.elem_ptr_depth = 0;
        self.array_len = 0;
        self.array_len_is_param = 0;
        self.array_len_param_ptr = 0;
        self.array_len_param_len = 0;
    }
}

// Struct field descriptor (112 bytes)
struct FieldDesc {
    name_ptr: u64;
    name_len: u64;
    type_kind: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    ptr_depth: u64;
    is_tagged: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    bit_width: u64;
    offset: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
}

// Struct parent descriptor (24 bytes)
struct ParentDesc {
    name_ptr: u64;
    name_len: u64;
    struct_def: *AstStructDef;
}

impl ParentDesc {
    constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.struct_def = 0;
    }
}

// Trait reference in struct inheritance list
struct TraitRef {
    name_ptr: u64;
    name_len: u64;
    trait_def: *TraitDef;
}

impl TraitRef {
    constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.trait_def = 0;
    }
}

impl FieldDesc {
    constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.type_kind = 0;
        self.struct_name_ptr = 0;
        self.struct_name_len = 0;
        self.ptr_depth = 0;
        self.is_tagged = 0;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.bit_width = 0;
        self.offset = 0;
        self.elem_type_kind = 0;
        self.elem_ptr_depth = 0;
        self.array_len = 0;
    }
}

const GLOBAL_INIT_NONE = 0;
const GLOBAL_INIT_VALUE = 1;
const GLOBAL_INIT_CONST = 2;
const GLOBAL_INIT_EXPR = 3;
const GLOBAL_INIT_RUNTIME = 4;

// Global variable info (64 bytes)
struct GlobalInfo {
    name_ptr: u64;
    name_len: u64;
    typeinfo_ptr: *TypeInfo;
    init_kind: u64;
    init_value: u64;
    init_name_ptr: u64;
    init_name_len: u64;
    init_expr: u64;
}

// ============================================
// Trait System Data Structures
// ============================================

// Trait method descriptor (32 bytes)
struct TraitMethod {
    name_ptr: u64;
    name_len: u64;
    sig: *AstFunc;
    index: u64;
}

// Trait definition (24 bytes)
struct TraitDef {
    name_ptr: u64;
    name_len: u64;
    methods_vec: *Vec<*TraitMethod>;
}

// Trait impl method descriptor (24 bytes)
struct TraitImplMethod {
    name_ptr: u64;
    name_len: u64;
    func_def: *AstFunc;
}

// Trait implementation (56 bytes)
struct TraitImpl {
    trait_ptr: u64;
    trait_len: u64;
    struct_ptr: u64;
    struct_len: u64;
    methods_vec: *Vec<*TraitImplMethod>;
    vtable_struct_def: *AstStructDef;
    vtable_global_ptr: u64;
    vtable_global_len: u64;
}

impl GlobalInfo {
    constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.typeinfo_ptr = 0;
        self.init_kind = 0;
        self.init_value = 0;
        self.init_name_ptr = 0;
        self.init_name_len = 0;
        self.init_expr = 0;
    }
}

// Name info (16 bytes)
struct NameInfo {
    ptr: u64;
    len: u64;
}

// Export entry (32 bytes)
struct ExportEntry {
    name_ptr: u64;
    name_len: u64;
    mangled_ptr: u64;
    mangled_len: u64;
}

// Constant info (24 bytes)
struct ConstInfo {
    name_ptr: u64;
    name_len: u64;
    value: u64;
}

// Constant lookup result (16 bytes)
struct ConstResult {
    found: u64;
    value: u64;
}

// String literal entry (24 bytes)
struct StringEntry {
    str_ptr: u64;
    str_len: u64;
    label_id: u64;
}

// Float literal entry (24 bytes)
struct FloatEntry {
    str_ptr: u64;
    str_len: u64;
    label_id: u64;
}

// Symbol table (40 bytes)
struct Symtab {
    names_vec: *Vec<*NameInfo>;
    offsets_vec: *Vec<u64>;
    types_vec: *Vec<*TypeInfo>;
    count: u64;
    stack_offset: u64;
}

impl Symtab {
    constructor() {
        self.names_vec = 0;
        self.offsets_vec = 0;
        self.types_vec = 0;
        self.count = 0;
        self.stack_offset = 0;
    }
}

// ============================================
// Lexer Data Structures
// ============================================

// Token structure (40 bytes)
struct Token {
    kind: u64;
    ptr: u64;
    len: u64;
    line: u64;
    col: u64;
}

impl Token {
    constructor() {
        self.kind = 0;
        self.ptr = 0;
        self.len = 0;
        self.line = 0;
        self.col = 0;
    }
}

// Lexer structure (40 bytes)
struct Lexer {
    src_ptr: u64;
    src_len: u64;
    pos: u64;
    line: u64;
    col: u64;
}

impl Lexer {
    constructor() {
        self.src_ptr = 0;
        self.src_len = 0;
        self.pos = 0;
        self.line = 0;
        self.col = 0;
    }
}

// ============================================
// Parser Data Structures
// ============================================

// Function parameter (120 bytes)
struct Param {
    name_ptr: u64;
    name_len: u64;
    type_kind: u64;
    ptr_depth: u64;
    is_tagged: u64;
    struct_name_ptr: u64;
    struct_name_len: u64;
    tag_layout_ptr: u64;
    tag_layout_len: u64;
    elem_type_kind: u64;
    elem_ptr_depth: u64;
    array_len: u64;
    array_len_is_param: u64;
    array_len_param_ptr: u64;
    array_len_param_len: u64;
}

impl Param {
    constructor() {
        self.name_ptr = 0;
        self.name_len = 0;
        self.type_kind = 0;
        self.ptr_depth = 0;
        self.is_tagged = 0;
        self.struct_name_ptr = 0;
        self.struct_name_len = 0;
        self.tag_layout_ptr = 0;
        self.tag_layout_len = 0;
        self.elem_type_kind = 0;
        self.elem_ptr_depth = 0;
        self.array_len = 0;
        self.array_len_is_param = 0;
        self.array_len_param_ptr = 0;
        self.array_len_param_len = 0;
    }
}

// Generic parameter descriptor (32 bytes)
struct GenericParam {
    kind: u64;
    name_ptr: u64;
    name_len: u64;
    value_type_kind: u64;
}

impl GenericParam {
    constructor() {
        self.kind = 0;
        self.name_ptr = 0;
        self.name_len = 0;
        self.value_type_kind = 0;
    }
}

// Generic argument descriptor (24 bytes)
struct GenericArg {
    kind: u64;
    type_ptr: *TypeInfo;
    value: u64;
}

impl GenericArg {
    constructor() {
        self.kind = 0;
        self.type_ptr = 0;
        self.value = 0;
    }
}
