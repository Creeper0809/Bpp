// Covers: struct members, nested struct, struct pointers, loops (stress)
// Expect exit code: 0

struct Inner {
    a: i64;
    b: i64;
}

struct Outer {
    inner: Inner;
    c: i64;
}

struct Point {
    x: i64;
    y: i64;
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var outer: Outer;
    outer.inner.a = 10;
    outer.inner.b = 15;
    outer.c = 17;

    var p: Point;
    var p_ptr: *Point = &p;
    var sum_points: i64 = 0;
    var copy_sum: i64 = 0;

    // Execution
    if (outer.inner.a + outer.inner.b + outer.c != 42) { return 1; }

    p_ptr->x = 20;
    p_ptr->y = 22;
    if (p_ptr->x + p_ptr->y != 42) { return 2; }

    // Edge: struct copy/assignment by value
    var p_copy: Point = p;
    if (p_copy.x + p_copy.y != 42) { return 3; }
    p_copy.x = 7;
    if (p.x != 20) { return 4; }
    copy_sum = p_copy.x + p_copy.y;
    if (copy_sum != 29) { return 5; }

    var total: i64 = 0;
    for (var i: i64 = 0; i < 6; i = i + 1) {
        total = total + i;
    }
    if (total != 15) { return 6; }

    // Stress: struct array accumulation
    var points: [10]Point;
    for (var j: i64 = 0; j < 10; j = j + 1) {
        points[j].x = j;
        points[j].y = 10 - j;
    }
    for (var k: i64 = 0; k < 10; k = k + 1) {
        sum_points = sum_points + points[k].x + points[k].y;
    }
    if (sum_points != 100) { return 7; }

    // Assertion
    return 0;
}
