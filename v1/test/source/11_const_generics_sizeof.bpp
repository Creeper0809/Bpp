// Covers: const generics, sizeof, array size (stress)
// Expect exit code: 0

func size_of_buf<const N: u64>() -> u64 {
    return sizeof([N]u64);
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var size_bytes: u64 = size_of_buf<4>();
    var size_one: u64 = size_of_buf<1>();
    var size_eight: u64 = size_of_buf<8>();
    var size_large: u64 = size_of_buf<128>();

    // Execution
    if (size_bytes != 32) { return 1; }
    if (size_one != 8) { return 2; }
    if (size_eight != 64) { return 3; }
    if (size_large != 1024) { return 4; }

    // Complex: size aggregation with conditional logic
    var sizes: [4]u64;
    sizes[0] = size_of_buf<2>();
    sizes[1] = size_of_buf<3>();
    sizes[2] = size_of_buf<5>();
    sizes[3] = size_of_buf<7>();

    var complex_size: i64 = 0;
    for (var i: i64 = 0; i < 4; i = i + 1) {
        if ((i & 1) == 0) {
            complex_size = complex_size + (i64)sizes[i];
        } else {
            complex_size = complex_size - (i64)sizes[i];
        }
    }
    if (complex_size != -24) { return 5; }

    var scale: i64 = 0;
    for (var j: i64 = 0; j < 4; j = j + 1) {
        var v: i64 = (i64)sizes[j];
        if (v > 20) {
            scale = scale + v;
        } else {
            scale = scale - v;
        }
    }
    if (scale != 104) { return 6; }

    // Assertion
    return 0;
}
