// Covers: arithmetic, bitwise, shift, comparisons, precedence (stress + edge)
// Expect exit code: 0

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var a: i64 = 10;
    var b: i64 = 5;
    var c: i64 = 3;
    var neg: i64 = -5;

    // Execution
    if (a + b != 15) { return 1; }
    if (a - b != 5) { return 2; }
    if (a * b != 50) { return 3; }
    if (a / b != 2) { return 4; }
    if (a % b != 0) { return 5; }

    var bit_and: i64 = 42 & 15;
    var bit_or: i64 = 42 | 15;
    var bit_xor: i64 = 42 ^ 15;
    if (bit_and != 10) { return 6; }
    if (bit_or != 47) { return 7; }
    if (bit_xor != 37) { return 8; }

    var shift_left: i64 = 1 << 4;
    var shift_right: i64 = 128 >> 3;
    if (shift_left != 16) { return 9; }
    if (shift_right != 16) { return 10; }

    if (!(10 > 5)) { return 11; }
    if (!(10 >= 10)) { return 12; }
    if (!(5 < 10)) { return 13; }
    if (!(5 <= 5)) { return 14; }
    if (!(5 != 10)) { return 15; }
    if (!(7 == 7)) { return 16; }
    if (!(neg < 0)) { return 17; }
    var neg_div: i64 = neg / 5;
    if (neg_div != -1) { return 18; }

    var prec1: i64 = 1 + 2 << 1;
    var prec2: i64 = 1 << 2 + 1;
    if (prec1 != 6) { return 19; }
    if (prec2 != 8) { return 20; }

    // Stress: repeated bitwise accumulation
    var stress_sum: i64 = 0;
    for (var i: i64 = 0; i < 1000; i = i + 1) {
        stress_sum = stress_sum + (i & 7);
    }
    if (stress_sum != 3500) { return 21; }

    // Stress: repeated multiplication (power of two)
    var mul_acc: i64 = 1;
    for (var j: i64 = 0; j < 10; j = j + 1) {
        mul_acc = mul_acc * 2;
    }
    if (mul_acc != 1024) { return 22; }

    // Assertion
    var result: i64 = (a + b) * c;
    if (result != 45) { return 23; }
    return 0;
}
