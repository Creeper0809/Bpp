// Covers: struct return, nested return, conditional return, large struct (stress)
// Expect exit code: 0

struct Pair {
    first: i64;
    second: i64;
}

struct Big {
    a: i64;
    b: i64;
    c: i64;
    d: i64;
    e: i64;
    f: i64;
    g: i64;
    h: i64;
    i: i64;
    j: i64;
    k: i64;
    l: i64;
}

func make_pair(a: i64, b: i64) -> Pair {
    var p: Pair;
    p.first = a;
    p.second = b;
    return p;
}

func choose_pair(flag: i64) -> Pair {
    if (flag != 0) { return make_pair(10, 32); }
    return make_pair(20, 22);
}

func swap_pair(p: Pair) -> Pair {
    var out: Pair;
    out.first = p.second;
    out.second = p.first;
    return out;
}

func accum_pairs(n: i64) -> Pair {
    var acc: Pair = make_pair(0, 0);
    for (var i: i64 = 0; i < n; i = i + 1) {
        var pick: Pair = choose_pair(i & 1);
        acc.first = acc.first + pick.first;
        acc.second = acc.second + pick.second;
    }
    return acc;
}

func make_big(seed: i64) -> Big {
    var b: Big;
    b.a = seed + 0;
    b.b = seed + 1;
    b.c = seed + 2;
    b.d = seed + 3;
    b.e = seed + 4;
    b.f = seed + 5;
    b.g = seed + 6;
    b.h = seed + 7;
    b.i = seed + 8;
    b.j = seed + 9;
    b.k = seed + 10;
    b.l = seed + 11;
    return b;
}

func update_big(b: Big, delta: i64) -> Big {
    b.a = b.a + delta;
    b.d = b.d - delta;
    b.f = b.f + (delta * 2);
    b.l = b.l - (delta * 3);
    return b;
}

func sum_big(b: Big) -> i64 {
    return b.a + b.b + b.c + b.d + b.e + b.f + b.g + b.h + b.i + b.j + b.k + b.l;
}

func choose_big(flag: i64) -> Big {
    if (flag != 0) { return make_big(5); }
    return update_big(make_big(5), 2);
}

func main(argc, argv) -> i64 {
    // Import

    // Setup
    var p0: Pair = make_pair(40, 2);
    var p1: Pair = choose_pair(1);
    var sum: i64 = 0;

    // Execution
    if (p0.first + p0.second != 42) { return 1; }
    if (p1.first + p1.second != 42) { return 2; }

    // Stress: 반복 선택 반환 누적
    for (var i: i64 = 0; i < 100; i = i + 1) {
        var pick: Pair = choose_pair(i & 1);
        sum = sum + pick.first + pick.second;
    }
    if (sum != 4200) { return 3; }

    // Complex: struct return + nested accumulation
    var swapped: Pair = swap_pair(p0);
    if (swapped.first != 2) { return 4; }
    if (swapped.second != 40) { return 5; }

    var acc: Pair = accum_pairs(10);
    if (acc.first + acc.second != 420) { return 6; }

    // Complex: large struct return + nested updates
    var big0: Big = make_big(10);
    if (sum_big(big0) != 186) { return 7; }

    var big1: Big = update_big(big0, 3);
    if (sum_big(big1) != 183) { return 8; }

    var pick0: Big = choose_big(0);
    if (sum_big(pick0) != 124) { return 9; }
    var pick1: Big = choose_big(1);
    if (sum_big(pick1) != 126) { return 10; }

    var big_acc: i64 = 0;
    for (var k: i64 = 0; k < 10; k = k + 1) {
        var pick: Big = choose_big(k & 1);
        big_acc = big_acc + sum_big(pick);
    }
    if (big_acc != 1250) { return 11; }

    // Assertion
    return 0;
}
